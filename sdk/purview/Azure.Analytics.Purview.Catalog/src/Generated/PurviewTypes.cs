// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Analytics.Purview.Catalog
{
    /// <summary> The PurviewTypes service client. </summary>
    public partial class PurviewTypes
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://purview.azure.net/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of PurviewTypes for mocking. </summary>
        protected PurviewTypes()
        {
        }

        /// <summary> Initializes a new instance of PurviewTypes. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint"> The catalog endpoint of your Purview account. Example: https://{accountName}.purview.azure.com. </param>
        /// <param name="apiVersion"> Api Version. </param>
        internal PurviewTypes(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary> Get the businessMetadata definition for the given guid. </summary>
        /// <param name="guid"> businessMetadata guid. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetBusinessMetadataDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetBusinessMetadataDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the businessMetadata definition for the given guid. </summary>
        /// <param name="guid"> businessMetadata guid. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetBusinessMetadataDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetBusinessMetadataDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the businessMetadata definition by it&apos;s name (unique). </summary>
        /// <param name="name"> businessMetadata name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetBusinessMetadataDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetBusinessMetadataDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the businessMetadata definition by it&apos;s name (unique). </summary>
        /// <param name="name"> businessMetadata name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetBusinessMetadataDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetBusinessMetadataDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBusinessMetadataDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the classification definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetClassificationDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetClassificationDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the classification definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetClassificationDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetClassificationDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the classification definition by its name (unique). </summary>
        /// <param name="name"> The name of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetClassificationDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetClassificationDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the classification definition by its name (unique). </summary>
        /// <param name="name"> The name of the classification. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetClassificationDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetClassificationDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetClassificationDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the Entity definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetEntityDefinitionByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEntityDefinitionByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityDefinitionByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the Entity definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetEntityDefinitionByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEntityDefinitionByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityDefinitionByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the entity definition by its name (unique). </summary>
        /// <param name="name"> The name of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetEntityDefinitionByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEntityDefinitionByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityDefinitionByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the entity definition by its name (unique). </summary>
        /// <param name="name"> The name of the entity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetEntityDefinitionByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEntityDefinitionByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEntityDefinitionByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the enum definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the enum. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEnumDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetEnumDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEnumDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnumDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the enum definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the enum. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEnumDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetEnumDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEnumDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnumDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the enum definition by its name (unique). </summary>
        /// <param name="name"> The name of the enum. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEnumDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetEnumDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEnumDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnumDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the enum definition by its name (unique). </summary>
        /// <param name="name"> The name of the enum. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasEnumDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetEnumDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetEnumDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetEnumDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the relationship definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the relationship. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetRelationshipDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetRelationshipDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelationshipDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the relationship definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the relationship. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetRelationshipDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetRelationshipDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelationshipDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the relationship definition by its name (unique). </summary>
        /// <param name="name"> The name of the relationship. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetRelationshipDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetRelationshipDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelationshipDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the relationship definition by its name (unique). </summary>
        /// <param name="name"> The name of the relationship. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetRelationshipDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetRelationshipDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRelationshipDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the struct definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the struct. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetStructDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetStructDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStructDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the struct definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the struct. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetStructDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetStructDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStructDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the struct definition by its name (unique). </summary>
        /// <param name="name"> The name of the struct. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetStructDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetStructDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStructDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the struct definition by its name (unique). </summary>
        /// <param name="name"> The name of the struct. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
        /// <details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        /// }
        /// </code>
        /// </details>
        /// <details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// </details>
        /// </details>
        /// 
        /// </remarks>
        public virtual Response GetStructDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetStructDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetStructDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the type definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypeDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTypeDefinitionByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the type definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypeDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTypeDefinitionByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the type definition by its name (unique). </summary>
        /// <param name="name"> The name of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypeDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTypeDefinitionByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the type definition by its name (unique). </summary>
        /// <param name="name"> The name of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypeDef</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///   entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///   subTypes: [string], # Optional. An array of sub types.
        ///   superTypes: [string], # Optional. An array of super types.
        ///   relationshipAttributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///       isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///       relationshipTypeName: string, # Optional. The name of the relationship type.
        ///     }
        ///   ], # Optional. An array of relationship attributes.
        ///   defaultValue: string, # Optional. The default value.
        ///   elementDefs: [
        ///     {
        ///       description: string, # Optional. The description of the enum element definition.
        ///       ordinal: number, # Optional. The ordinal of the enum element definition.
        ///       value: string, # Optional. The value of the enum element definition.
        ///     }
        ///   ], # Optional. An array of enum element definitions.
        ///   endDef1: {
        ///     cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///     description: string, # Optional. The description of the relationship end definition.
        ///     isContainer: boolean, # Optional. Determines if it is container.
        ///     isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///     name: string, # Optional. The name of the relationship end definition.
        ///     type: string, # Optional. The type of the relationship end.
        ///   }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///   relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///   relationshipLabel: string, # Optional. The label of the relationship.
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTypeDefinitionByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete API for type identified by its name. </summary>
        /// <param name="name"> The name of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteTypeByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.DeleteTypeByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTypeByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete API for type identified by its name. </summary>
        /// <param name="name"> The name of the type. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteTypeByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.DeleteTypeByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTypeByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all type definitions in Atlas in bulk. </summary>
        /// <param name="includeTermTemplate">
        /// Whether include termtemplatedef when return all typedefs.
        /// This is always true when search filter type=term_template
        /// </param>
        /// <param name="type"> Typedef name as search filter when get typedefs. Allowed values: &quot;enum&quot; | &quot;entity&quot; | &quot;classification&quot; | &quot;relationship&quot; | &quot;struct&quot; | &quot;term_template&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetAllTypeDefinitionsAsync(bool? includeTermTemplate = null, string type = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetAllTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllTypeDefinitionsRequest(includeTermTemplate, type, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get all type definitions in Atlas in bulk. </summary>
        /// <param name="includeTermTemplate">
        /// Whether include termtemplatedef when return all typedefs.
        /// This is always true when search filter type=term_template
        /// </param>
        /// <param name="type"> Typedef name as search filter when get typedefs. Allowed values: &quot;enum&quot; | &quot;entity&quot; | &quot;classification&quot; | &quot;relationship&quot; | &quot;struct&quot; | &quot;term_template&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetAllTypeDefinitions(bool? includeTermTemplate = null, string type = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetAllTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllTypeDefinitionsRequest(includeTermTemplate, type, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create all atlas type definitions in bulk, only new definitions will be created.
        /// Any changes to the existing definitions will be discarded.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateTypeDefinitionsAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.CreateTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTypeDefinitionsRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create all atlas type definitions in bulk, only new definitions will be created.
        /// Any changes to the existing definitions will be discarded.
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateTypeDefinitions(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.CreateTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTypeDefinitionsRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update all types in bulk, changes detected in the type definitions would be persisted. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateAtlasTypeDefinitionsAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.UpdateAtlasTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateAtlasTypeDefinitionsRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update all types in bulk, changes detected in the type definitions would be persisted. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UpdateAtlasTypeDefinitions(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.UpdateAtlasTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateAtlasTypeDefinitionsRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete API for all types in bulk. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteTypeDefinitionsAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.DeleteTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTypeDefinitionsRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete API for all types in bulk. </summary>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request payload.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>AtlasTypesDef</c>:
        /// <code>{
        ///   businessMetadataDefs: [
        ///     {
        ///       attributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [
        ///             {
        ///               params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///               type: string, # Optional. The type of the constraint.
        ///             }
        ///           ], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///         }
        ///       ], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: {
        ///         availableLocales: [string], # Optional. An array of available locales.
        ///         calendar: number, # Optional.
        ///         dateInstance: DateFormat, # Optional. The date format.
        ///         dateTimeInstance: DateFormat, # Optional. The date format.
        ///         instance: DateFormat, # Optional. The date format.
        ///         lenient: boolean, # Optional. Determines the leniency of the date format.
        ///         numberFormat: {
        ///           availableLocales: [string], # Optional. The number format.
        ///           currency: string, # Optional. The currency.
        ///           currencyInstance: NumberFormat, # Optional. The number format.
        ///           groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///           instance: NumberFormat, # Optional. The number format.
        ///           integerInstance: NumberFormat, # Optional. The number format.
        ///           maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///           maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///           minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///           minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///           numberInstance: NumberFormat, # Optional. The number format.
        ///           parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///           percentInstance: NumberFormat, # Optional. The number format.
        ///           roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///         }, # Optional. The number format.
        ///         timeInstance: DateFormat, # Optional. The date format.
        ///         timeZone: {
        ///           dstSavings: number, # Optional. The value of the daylight saving time.
        ///           id: string, # Optional. The ID of the timezone.
        ///           availableIds: [string], # Optional. An array of available IDs.
        ///           default: TimeZone, # Optional. The timezone information.
        ///           displayName: string, # Optional. The display name of the timezone.
        ///           rawOffset: number, # Optional. The raw offset of the timezone.
        ///         }, # Optional. The timezone information.
        ///       }, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. businessMetadataDefs
        ///   classificationDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
        /// only be applied to those entityTypes.
        /// &lt;ul&gt;
        /// &lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
        /// &lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
        /// &lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
        /// &lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
        /// &lt;/ul&gt;
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///     }
        ///   ], # Optional. An array of classification definitions.
        ///   entityDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       subTypes: [string], # Optional. An array of sub types.
        ///       superTypes: [string], # Optional. An array of super types.
        ///       relationshipAttributeDefs: [
        ///         {
        ///           cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///           constraints: [AtlasConstraintDef], # Optional. An array of constraints.
        ///           defaultValue: string, # Optional. The default value of the attribute.
        ///           description: string, # Optional. The description of the attribute.
        ///           includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///           isIndexable: boolean, # Optional. Determines if it is indexable.
        ///           isOptional: boolean, # Optional. Determines if it is optional.
        ///           isUnique: boolean, # Optional. Determines if it unique.
        ///           name: string, # Optional. The name of the attribute.
        ///           options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///           typeName: string, # Optional. The name of the type.
        ///           valuesMaxCount: number, # Optional. The maximum count of the values.
        ///           valuesMinCount: number, # Optional. The minimum count of the values.
        ///           isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///           relationshipTypeName: string, # Optional. The name of the relationship type.
        ///         }
        ///       ], # Optional. An array of relationship attributes.
        ///     }
        ///   ], # Optional. An array of entity definitions.
        ///   enumDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       defaultValue: string, # Optional. The default value.
        ///       elementDefs: [
        ///         {
        ///           description: string, # Optional. The description of the enum element definition.
        ///           ordinal: number, # Optional. The ordinal of the enum element definition.
        ///           value: string, # Optional. The value of the enum element definition.
        ///         }
        ///       ], # Optional. An array of enum element definitions.
        ///     }
        ///   ], # Optional. An array of enum definitions.
        ///   relationshipDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       endDef1: {
        ///         cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///         description: string, # Optional. The description of the relationship end definition.
        ///         isContainer: boolean, # Optional. Determines if it is container.
        ///         isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        ///         name: string, # Optional. The name of the relationship end definition.
        ///         type: string, # Optional. The type of the relationship end.
        ///       }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
        /// attribute name, cardinality and whether it  is the container end of the relationship.
        ///       relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
        /// UML terminology is used for the values.
        /// &lt;p&gt;
        /// ASSOCIATION is a relationship with no containment. &lt;br&gt;
        /// COMPOSITION and AGGREGATION are containment relationships.
        /// &lt;p&gt;
        /// The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
        /// the children cannot exist without the container. For AGGREGATION, the life cycles
        /// of the container and children are totally independent.
        ///       relationshipLabel: string, # Optional. The label of the relationship.
        ///     }
        ///   ], # Optional. An array of relationship definitions.
        ///   structDefs: [
        ///     {
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///     }
        ///   ], # Optional. An array of struct definitions.
        ///   termTemplateDefs: [
        ///     {
        ///       attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
        ///       category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///       createTime: number, # Optional. The created time of the record.
        ///       createdBy: string, # Optional. The user who created the record.
        ///       dateFormatter: DateFormat, # Optional. The date format.
        ///       description: string, # Optional. The description of the type definition.
        ///       guid: string, # Optional. The GUID of the type definition.
        ///       name: string, # Optional. The name of the type definition.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///       serviceType: string, # Optional. The service type.
        ///       typeVersion: string, # Optional. The version of the type.
        ///       updateTime: number, # Optional. The update time of the record.
        ///       updatedBy: string, # Optional. The user who updated the record.
        ///       version: number, # Optional. The version of the record.
        ///       lastModifiedTS: string, # Optional. ETag for concurrency control.
        ///     }
        ///   ], # Optional. An array of term template definitions.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteTypeDefinitions(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.DeleteTypeDefinitions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTypeDefinitionsRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all type definitions returned as a list of minimal information header. </summary>
        /// <param name="includeTermTemplate">
        /// Whether include termtemplatedef when return all typedefs.
        /// This is always true when search filter type=term_template
        /// </param>
        /// <param name="type"> Typedef name as search filter when get typedefs. Allowed values: &quot;enum&quot; | &quot;entity&quot; | &quot;classification&quot; | &quot;relationship&quot; | &quot;struct&quot; | &quot;term_template&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfAtlasTypeDefHeader</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTypeDefinitionHeadersAsync(bool? includeTermTemplate = null, string type = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionHeaders");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionHeadersRequest(includeTermTemplate, type, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all type definitions returned as a list of minimal information header. </summary>
        /// <param name="includeTermTemplate">
        /// Whether include termtemplatedef when return all typedefs.
        /// This is always true when search filter type=term_template
        /// </param>
        /// <param name="type"> Typedef name as search filter when get typedefs. Allowed values: &quot;enum&quot; | &quot;entity&quot; | &quot;classification&quot; | &quot;relationship&quot; | &quot;struct&quot; | &quot;term_template&quot;. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>ArrayOfAtlasTypeDefHeader</c>:
        /// <code>{
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTypeDefinitionHeaders(bool? includeTermTemplate = null, string type = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTypeDefinitionHeaders");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTypeDefinitionHeadersRequest(includeTermTemplate, type, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the term template definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the term template. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTermTemplateDefByGuidAsync(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTermTemplateDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermTemplateDefByGuidRequest(guid, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the term template definition for the given GUID. </summary>
        /// <param name="guid"> The globally unique identifier of the term template. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="guid"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="guid"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTermTemplateDefByGuid(string guid, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(guid, nameof(guid));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTermTemplateDefByGuid");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermTemplateDefByGuidRequest(guid, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the term template definition by its name (unique). </summary>
        /// <param name="name"> The name of the term template. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetTermTemplateDefByNameAsync(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTermTemplateDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermTemplateDefByNameRequest(name, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the term template definition by its name (unique). </summary>
        /// <param name="name"> The name of the term template. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="name"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>TermTemplateDef</c>:
        /// <code>{
        ///   attributeDefs: [
        ///     {
        ///       cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        ///       constraints: [
        ///         {
        ///           params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
        ///           type: string, # Optional. The type of the constraint.
        ///         }
        ///       ], # Optional. An array of constraints.
        ///       defaultValue: string, # Optional. The default value of the attribute.
        ///       description: string, # Optional. The description of the attribute.
        ///       includeInNotification: boolean, # Optional. Determines if it is included in notification.
        ///       isIndexable: boolean, # Optional. Determines if it is indexable.
        ///       isOptional: boolean, # Optional. Determines if it is optional.
        ///       isUnique: boolean, # Optional. Determines if it unique.
        ///       name: string, # Optional. The name of the attribute.
        ///       options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
        ///       typeName: string, # Optional. The name of the type.
        ///       valuesMaxCount: number, # Optional. The maximum count of the values.
        ///       valuesMinCount: number, # Optional. The minimum count of the values.
        ///     }
        ///   ], # Optional. An array of attribute definitions.
        ///   category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
        ///   createTime: number, # Optional. The created time of the record.
        ///   createdBy: string, # Optional. The user who created the record.
        ///   dateFormatter: {
        ///     availableLocales: [string], # Optional. An array of available locales.
        ///     calendar: number, # Optional.
        ///     dateInstance: DateFormat, # Optional. The date format.
        ///     dateTimeInstance: DateFormat, # Optional. The date format.
        ///     instance: DateFormat, # Optional. The date format.
        ///     lenient: boolean, # Optional. Determines the leniency of the date format.
        ///     numberFormat: {
        ///       availableLocales: [string], # Optional. The number format.
        ///       currency: string, # Optional. The currency.
        ///       currencyInstance: NumberFormat, # Optional. The number format.
        ///       groupingUsed: boolean, # Optional. Determines if grouping is used.
        ///       instance: NumberFormat, # Optional. The number format.
        ///       integerInstance: NumberFormat, # Optional. The number format.
        ///       maximumFractionDigits: number, # Optional. The maximum of fraction digits.
        ///       maximumIntegerDigits: number, # Optional. The maximum of integer digits.
        ///       minimumFractionDigits: number, # Optional. The minimum of fraction digits.
        ///       minimumIntegerDigits: number, # Optional. The minimum of integer digits.
        ///       numberInstance: NumberFormat, # Optional. The number format.
        ///       parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
        ///       percentInstance: NumberFormat, # Optional. The number format.
        ///       roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        ///     }, # Optional. The number format.
        ///     timeInstance: DateFormat, # Optional. The date format.
        ///     timeZone: {
        ///       dstSavings: number, # Optional. The value of the daylight saving time.
        ///       id: string, # Optional. The ID of the timezone.
        ///       availableIds: [string], # Optional. An array of available IDs.
        ///       default: TimeZone, # Optional. The timezone information.
        ///       displayName: string, # Optional. The display name of the timezone.
        ///       rawOffset: number, # Optional. The raw offset of the timezone.
        ///     }, # Optional. The timezone information.
        ///   }, # Optional. The date format.
        ///   description: string, # Optional. The description of the type definition.
        ///   guid: string, # Optional. The GUID of the type definition.
        ///   name: string, # Optional. The name of the type definition.
        ///   options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
        ///   serviceType: string, # Optional. The service type.
        ///   typeVersion: string, # Optional. The version of the type.
        ///   updateTime: number, # Optional. The update time of the record.
        ///   updatedBy: string, # Optional. The user who updated the record.
        ///   version: number, # Optional. The version of the record.
        ///   lastModifiedTS: string, # Optional. ETag for concurrency control.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetTermTemplateDefByName(string name, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(name, nameof(name));

            using var scope = ClientDiagnostics.CreateScope("PurviewTypes.GetTermTemplateDefByName");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTermTemplateDefByNameRequest(name, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetBusinessMetadataDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/businessmetadatadef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBusinessMetadataDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/businessmetadatadef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetClassificationDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/classificationdef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetClassificationDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/classificationdef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEntityDefinitionByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/entitydef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEntityDefinitionByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/entitydef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnumDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/enumdef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnumDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/enumdef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetRelationshipDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/relationshipdef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetRelationshipDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/relationshipdef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetStructDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/structdef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetStructDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/structdef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTypeDefinitionByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedef/guid/", false);
            uri.AppendPath(guid, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTypeDefinitionByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteTypeByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedef/name/", false);
            uri.AppendPath(name, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllTypeDefinitionsRequest(bool? includeTermTemplate, string type, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs", false);
            if (includeTermTemplate != null)
            {
                uri.AppendQuery("includeTermTemplate", includeTermTemplate.Value, true);
            }
            if (type != null)
            {
                uri.AppendQuery("type", type, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateTypeDefinitionsRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateAtlasTypeDefinitionsRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteTypeDefinitionsRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTypeDefinitionHeadersRequest(bool? includeTermTemplate, string type, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/atlas/v2/types/typedefs/headers", false);
            if (includeTermTemplate != null)
            {
                uri.AppendQuery("includeTermTemplate", includeTermTemplate.Value, true);
            }
            if (type != null)
            {
                uri.AppendQuery("type", type, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTermTemplateDefByGuidRequest(string guid, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/types/termtemplatedef/guid/", false);
            uri.AppendPath(guid, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetTermTemplateDefByNameRequest(string name, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/catalog/api", false);
            uri.AppendPath("/types/termtemplatedef/name/", false);
            uri.AppendPath(name, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
