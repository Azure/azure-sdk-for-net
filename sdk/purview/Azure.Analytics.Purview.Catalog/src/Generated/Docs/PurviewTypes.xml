<?xml version="1.0" encoding="utf-8"?>
<doc>
  <members>
    <member name="GetBusinessMetadataDefByGuidAsync(String,RequestContext)">
<example>
This sample shows how to call GetBusinessMetadataDefByGuidAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetBusinessMetadataDefByGuidAsync("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasBusinessMetadataDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetBusinessMetadataDefByGuid(String,RequestContext)">
<example>
This sample shows how to call GetBusinessMetadataDefByGuid with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetBusinessMetadataDefByGuid("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasBusinessMetadataDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetBusinessMetadataDefByNameAsync(String,RequestContext)">
<example>
This sample shows how to call GetBusinessMetadataDefByNameAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetBusinessMetadataDefByNameAsync("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasBusinessMetadataDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetBusinessMetadataDefByName(String,RequestContext)">
<example>
This sample shows how to call GetBusinessMetadataDefByName with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetBusinessMetadataDefByName("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasBusinessMetadataDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetClassificationDefByGuidAsync(String,RequestContext)">
<example>
This sample shows how to call GetClassificationDefByGuidAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetClassificationDefByGuidAsync("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasClassificationDef</c>:
<code>{
  entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetClassificationDefByGuid(String,RequestContext)">
<example>
This sample shows how to call GetClassificationDefByGuid with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetClassificationDefByGuid("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasClassificationDef</c>:
<code>{
  entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetClassificationDefByNameAsync(String,RequestContext)">
<example>
This sample shows how to call GetClassificationDefByNameAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetClassificationDefByNameAsync("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasClassificationDef</c>:
<code>{
  entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetClassificationDefByName(String,RequestContext)">
<example>
This sample shows how to call GetClassificationDefByName with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetClassificationDefByName("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasClassificationDef</c>:
<code>{
  entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetEntityDefinitionByGuidAsync(String,RequestContext)">
<example>
This sample shows how to call GetEntityDefinitionByGuidAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetEntityDefinitionByGuidAsync("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasEntityDef</c>:
<code>{
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  relationshipAttributeDefs: [
    {
      isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
      relationshipTypeName: string, # Optional. The name of the relationship type.
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of relationship attributes.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [AtlasConstraintDef], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetEntityDefinitionByGuid(String,RequestContext)">
<example>
This sample shows how to call GetEntityDefinitionByGuid with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetEntityDefinitionByGuid("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasEntityDef</c>:
<code>{
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  relationshipAttributeDefs: [
    {
      isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
      relationshipTypeName: string, # Optional. The name of the relationship type.
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of relationship attributes.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [AtlasConstraintDef], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetEntityDefinitionByNameAsync(String,RequestContext)">
<example>
This sample shows how to call GetEntityDefinitionByNameAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetEntityDefinitionByNameAsync("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasEntityDef</c>:
<code>{
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  relationshipAttributeDefs: [
    {
      isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
      relationshipTypeName: string, # Optional. The name of the relationship type.
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of relationship attributes.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [AtlasConstraintDef], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetEntityDefinitionByName(String,RequestContext)">
<example>
This sample shows how to call GetEntityDefinitionByName with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetEntityDefinitionByName("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasEntityDef</c>:
<code>{
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  relationshipAttributeDefs: [
    {
      isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
      relationshipTypeName: string, # Optional. The name of the relationship type.
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of relationship attributes.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [AtlasConstraintDef], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetEnumDefByGuidAsync(String,RequestContext)">
<example>
This sample shows how to call GetEnumDefByGuidAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetEnumDefByGuidAsync("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasEnumDef</c>:
<code>{
  defaultValue: string, # Optional. The default value.
  elementDefs: [
    {
      description: string, # Optional. The description of the enum element definition.
      ordinal: number, # Optional. The ordinal of the enum element definition.
      value: string, # Optional. The value of the enum element definition.
    }
  ], # Optional. An array of enum element definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetEnumDefByGuid(String,RequestContext)">
<example>
This sample shows how to call GetEnumDefByGuid with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetEnumDefByGuid("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasEnumDef</c>:
<code>{
  defaultValue: string, # Optional. The default value.
  elementDefs: [
    {
      description: string, # Optional. The description of the enum element definition.
      ordinal: number, # Optional. The ordinal of the enum element definition.
      value: string, # Optional. The value of the enum element definition.
    }
  ], # Optional. An array of enum element definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetEnumDefByNameAsync(String,RequestContext)">
<example>
This sample shows how to call GetEnumDefByNameAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetEnumDefByNameAsync("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasEnumDef</c>:
<code>{
  defaultValue: string, # Optional. The default value.
  elementDefs: [
    {
      description: string, # Optional. The description of the enum element definition.
      ordinal: number, # Optional. The ordinal of the enum element definition.
      value: string, # Optional. The value of the enum element definition.
    }
  ], # Optional. An array of enum element definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetEnumDefByName(String,RequestContext)">
<example>
This sample shows how to call GetEnumDefByName with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetEnumDefByName("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasEnumDef</c>:
<code>{
  defaultValue: string, # Optional. The default value.
  elementDefs: [
    {
      description: string, # Optional. The description of the enum element definition.
      ordinal: number, # Optional. The ordinal of the enum element definition.
      value: string, # Optional. The value of the enum element definition.
    }
  ], # Optional. An array of enum element definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetRelationshipDefByGuidAsync(String,RequestContext)">
<example>
This sample shows how to call GetRelationshipDefByGuidAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetRelationshipDefByGuidAsync("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasRelationshipDef</c>:
<code>{
  endDef1: {
    cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
    description: string, # Optional. The description of the relationship end definition.
    isContainer: boolean, # Optional. Determines if it is container.
    isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
    name: string, # Optional. The name of the relationship end definition.
    type: string, # Optional. The type of the relationship end.
  }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
  relationshipLabel: string, # Optional. The label of the relationship.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetRelationshipDefByGuid(String,RequestContext)">
<example>
This sample shows how to call GetRelationshipDefByGuid with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetRelationshipDefByGuid("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasRelationshipDef</c>:
<code>{
  endDef1: {
    cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
    description: string, # Optional. The description of the relationship end definition.
    isContainer: boolean, # Optional. Determines if it is container.
    isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
    name: string, # Optional. The name of the relationship end definition.
    type: string, # Optional. The type of the relationship end.
  }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
  relationshipLabel: string, # Optional. The label of the relationship.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetRelationshipDefByNameAsync(String,RequestContext)">
<example>
This sample shows how to call GetRelationshipDefByNameAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetRelationshipDefByNameAsync("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasRelationshipDef</c>:
<code>{
  endDef1: {
    cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
    description: string, # Optional. The description of the relationship end definition.
    isContainer: boolean, # Optional. Determines if it is container.
    isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
    name: string, # Optional. The name of the relationship end definition.
    type: string, # Optional. The type of the relationship end.
  }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
  relationshipLabel: string, # Optional. The label of the relationship.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetRelationshipDefByName(String,RequestContext)">
<example>
This sample shows how to call GetRelationshipDefByName with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetRelationshipDefByName("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasRelationshipDef</c>:
<code>{
  endDef1: {
    cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
    description: string, # Optional. The description of the relationship end definition.
    isContainer: boolean, # Optional. Determines if it is container.
    isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
    name: string, # Optional. The name of the relationship end definition.
    type: string, # Optional. The type of the relationship end.
  }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
  relationshipLabel: string, # Optional. The label of the relationship.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetStructDefByGuidAsync(String,RequestContext)">
<example>
This sample shows how to call GetStructDefByGuidAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetStructDefByGuidAsync("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
<details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
<code>{
  entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
<code>{
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  relationshipAttributeDefs: [
    {
      isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
      relationshipTypeName: string, # Optional. The name of the relationship type.
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of relationship attributes.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [AtlasConstraintDef], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
<code>{
  endDef1: {
    cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
    description: string, # Optional. The description of the relationship end definition.
    isContainer: boolean, # Optional. Determines if it is container.
    isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
    name: string, # Optional. The name of the relationship end definition.
    type: string, # Optional. The type of the relationship end.
  }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
  relationshipLabel: string, # Optional. The label of the relationship.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
</details>

</remarks>
    </member>
    <member name="GetStructDefByGuid(String,RequestContext)">
<example>
This sample shows how to call GetStructDefByGuid with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetStructDefByGuid("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
<details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
<code>{
  entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
<code>{
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  relationshipAttributeDefs: [
    {
      isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
      relationshipTypeName: string, # Optional. The name of the relationship type.
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of relationship attributes.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [AtlasConstraintDef], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
<code>{
  endDef1: {
    cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
    description: string, # Optional. The description of the relationship end definition.
    isContainer: boolean, # Optional. Determines if it is container.
    isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
    name: string, # Optional. The name of the relationship end definition.
    type: string, # Optional. The type of the relationship end.
  }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
  relationshipLabel: string, # Optional. The label of the relationship.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
</details>

</remarks>
    </member>
    <member name="GetStructDefByNameAsync(String,RequestContext)">
<example>
This sample shows how to call GetStructDefByNameAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetStructDefByNameAsync("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
<details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
<code>{
  entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
<code>{
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  relationshipAttributeDefs: [
    {
      isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
      relationshipTypeName: string, # Optional. The name of the relationship type.
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of relationship attributes.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [AtlasConstraintDef], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
<code>{
  endDef1: {
    cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
    description: string, # Optional. The description of the relationship end definition.
    isContainer: boolean, # Optional. Determines if it is container.
    isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
    name: string, # Optional. The name of the relationship end definition.
    type: string, # Optional. The type of the relationship end.
  }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
  relationshipLabel: string, # Optional. The label of the relationship.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
</details>

</remarks>
    </member>
    <member name="GetStructDefByName(String,RequestContext)">
<example>
This sample shows how to call GetStructDefByName with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetStructDefByName("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

This method takes one of the JSON objects below as a payload. Please select a JSON object to view the schema for this.
<details><summary>AtlasBusinessMetadataDef</summary>Schema for <c>AtlasBusinessMetadataDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>~+ 4 more JSON objects</summary><details><summary>AtlasClassificationDef</summary>Schema for <c>AtlasClassificationDef</c>:
<code>{
  entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>AtlasEntityDef</summary>Schema for <c>AtlasEntityDef</c>:
<code>{
  subTypes: [string], # Optional. An array of sub types.
  superTypes: [string], # Optional. An array of super types.
  relationshipAttributeDefs: [
    {
      isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
      relationshipTypeName: string, # Optional. The name of the relationship type.
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of relationship attributes.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [AtlasConstraintDef], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>AtlasRelationshipDef</summary>Schema for <c>AtlasRelationshipDef</c>:
<code>{
  endDef1: {
    cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
    description: string, # Optional. The description of the relationship end definition.
    isContainer: boolean, # Optional. Determines if it is container.
    isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
    name: string, # Optional. The name of the relationship end definition.
    type: string, # Optional. The type of the relationship end.
  }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
  relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
  relationshipLabel: string, # Optional. The label of the relationship.
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
<details><summary>TermTemplateDef</summary>Schema for <c>TermTemplateDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>
</details>
</details>

</remarks>
    </member>
    <member name="GetTypeDefinitionByGuidAsync(String,RequestContext)">
<example>
This sample shows how to call GetTypeDefinitionByGuidAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetTypeDefinitionByGuidAsync("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasTypeDef</c>:
<code>{
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetTypeDefinitionByGuid(String,RequestContext)">
<example>
This sample shows how to call GetTypeDefinitionByGuid with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetTypeDefinitionByGuid("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasTypeDef</c>:
<code>{
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetTypeDefinitionByNameAsync(String,RequestContext)">
<example>
This sample shows how to call GetTypeDefinitionByNameAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetTypeDefinitionByNameAsync("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasTypeDef</c>:
<code>{
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetTypeDefinitionByName(String,RequestContext)">
<example>
This sample shows how to call GetTypeDefinitionByName with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetTypeDefinitionByName("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasTypeDef</c>:
<code>{
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="DeleteTypeByNameAsync(String,RequestContext)">
<example>
This sample shows how to call DeleteTypeByNameAsync with required parameters.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.DeleteTypeByNameAsync("<name>");
Console.WriteLine(response.Status);
]]></code>
</example>
    </member>
    <member name="DeleteTypeByName(String,RequestContext)">
<example>
This sample shows how to call DeleteTypeByName with required parameters.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.DeleteTypeByName("<name>");
Console.WriteLine(response.Status);
]]></code>
</example>
    </member>
    <member name="GetAllTypeDefinitionsAsync(Boolean,String,RequestContext)">
<example>
This sample shows how to call GetAllTypeDefinitionsAsync and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetAllTypeDefinitionsAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetAllTypeDefinitionsAsync with all parameters, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetAllTypeDefinitionsAsync(true, "<type>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

</remarks>
    </member>
    <member name="GetAllTypeDefinitions(Boolean,String,RequestContext)">
<example>
This sample shows how to call GetAllTypeDefinitions and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetAllTypeDefinitions();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call GetAllTypeDefinitions with all parameters, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetAllTypeDefinitions(true, "<type>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

</remarks>
    </member>
    <member name="CreateTypeDefinitionsAsync(RequestContent,RequestContext)">
<example>
This sample shows how to call CreateTypeDefinitionsAsync and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {};

Response response = await client.CreateTypeDefinitionsAsync(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateTypeDefinitionsAsync with all request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {
    businessMetadataDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    classificationDefs = new[] {
        new {
            entityTypes = new[] {
                "<String>"
            },
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    entityDefs = new[] {
        new {
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            relationshipAttributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    enumDefs = new[] {
        new {
            defaultValue = "<defaultValue>",
            elementDefs = new[] {
                new {
                    description = "<description>",
                    ordinal = 123.45f,
                    value = "<value>",
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    relationshipDefs = new[] {
        new {
            endDef1 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            endDef2 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            relationshipCategory = "ASSOCIATION",
            relationshipLabel = "<relationshipLabel>",
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    structDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    termTemplateDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
};

Response response = await client.CreateTypeDefinitionsAsync(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

Response Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

</remarks>
    </member>
    <member name="CreateTypeDefinitions(RequestContent,RequestContext)">
<example>
This sample shows how to call CreateTypeDefinitions and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {};

Response response = client.CreateTypeDefinitions(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call CreateTypeDefinitions with all request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {
    businessMetadataDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    classificationDefs = new[] {
        new {
            entityTypes = new[] {
                "<String>"
            },
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    entityDefs = new[] {
        new {
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            relationshipAttributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    enumDefs = new[] {
        new {
            defaultValue = "<defaultValue>",
            elementDefs = new[] {
                new {
                    description = "<description>",
                    ordinal = 123.45f,
                    value = "<value>",
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    relationshipDefs = new[] {
        new {
            endDef1 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            endDef2 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            relationshipCategory = "ASSOCIATION",
            relationshipLabel = "<relationshipLabel>",
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    structDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    termTemplateDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
};

Response response = client.CreateTypeDefinitions(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

Response Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

</remarks>
    </member>
    <member name="UpdateAtlasTypeDefinitionsAsync(RequestContent,RequestContext)">
<example>
This sample shows how to call UpdateAtlasTypeDefinitionsAsync and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {};

Response response = await client.UpdateAtlasTypeDefinitionsAsync(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateAtlasTypeDefinitionsAsync with all request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {
    businessMetadataDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    classificationDefs = new[] {
        new {
            entityTypes = new[] {
                "<String>"
            },
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    entityDefs = new[] {
        new {
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            relationshipAttributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    enumDefs = new[] {
        new {
            defaultValue = "<defaultValue>",
            elementDefs = new[] {
                new {
                    description = "<description>",
                    ordinal = 123.45f,
                    value = "<value>",
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    relationshipDefs = new[] {
        new {
            endDef1 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            endDef2 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            relationshipCategory = "ASSOCIATION",
            relationshipLabel = "<relationshipLabel>",
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    structDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    termTemplateDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
};

Response response = await client.UpdateAtlasTypeDefinitionsAsync(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

Response Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

</remarks>
    </member>
    <member name="UpdateAtlasTypeDefinitions(RequestContent,RequestContext)">
<example>
This sample shows how to call UpdateAtlasTypeDefinitions and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {};

Response response = client.UpdateAtlasTypeDefinitions(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.ToString());
]]></code>
This sample shows how to call UpdateAtlasTypeDefinitions with all request content, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {
    businessMetadataDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    classificationDefs = new[] {
        new {
            entityTypes = new[] {
                "<String>"
            },
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    entityDefs = new[] {
        new {
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            relationshipAttributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    enumDefs = new[] {
        new {
            defaultValue = "<defaultValue>",
            elementDefs = new[] {
                new {
                    description = "<description>",
                    ordinal = 123.45f,
                    value = "<value>",
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    relationshipDefs = new[] {
        new {
            endDef1 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            endDef2 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            relationshipCategory = "ASSOCIATION",
            relationshipLabel = "<relationshipLabel>",
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    structDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    termTemplateDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
};

Response response = client.UpdateAtlasTypeDefinitions(RequestContent.Create(data));

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("businessMetadataDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("entityTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("classificationDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("subTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("superTypes")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("relationshipTypeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("relationshipAttributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("entityDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("ordinal").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("elementDefs")[0].GetProperty("value").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("enumDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef1").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isContainer").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("isLegacyAttribute").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("endDef2").GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipCategory").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("relationshipLabel").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("relationshipDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("structDefs")[0].GetProperty("lastModifiedTS").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("termTemplateDefs")[0].GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the request and response payloads.

Request Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

Response Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

</remarks>
    </member>
    <member name="DeleteTypeDefinitionsAsync(RequestContent,RequestContext)">
<example>
This sample shows how to call DeleteTypeDefinitionsAsync.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {};

Response response = await client.DeleteTypeDefinitionsAsync(RequestContent.Create(data));
Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTypeDefinitionsAsync with all request content.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {
    businessMetadataDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    classificationDefs = new[] {
        new {
            entityTypes = new[] {
                "<String>"
            },
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    entityDefs = new[] {
        new {
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            relationshipAttributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    enumDefs = new[] {
        new {
            defaultValue = "<defaultValue>",
            elementDefs = new[] {
                new {
                    description = "<description>",
                    ordinal = 123.45f,
                    value = "<value>",
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    relationshipDefs = new[] {
        new {
            endDef1 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            endDef2 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            relationshipCategory = "ASSOCIATION",
            relationshipLabel = "<relationshipLabel>",
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    structDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    termTemplateDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
};

Response response = await client.DeleteTypeDefinitionsAsync(RequestContent.Create(data));
Console.WriteLine(response.Status);
]]></code>
</example>
<remarks>
Below is the JSON schema for the request payload.

Request Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

</remarks>
    </member>
    <member name="DeleteTypeDefinitions(RequestContent,RequestContext)">
<example>
This sample shows how to call DeleteTypeDefinitions.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {};

Response response = client.DeleteTypeDefinitions(RequestContent.Create(data));
Console.WriteLine(response.Status);
]]></code>
This sample shows how to call DeleteTypeDefinitions with all request content.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

var data = new {
    businessMetadataDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    classificationDefs = new[] {
        new {
            entityTypes = new[] {
                "<String>"
            },
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    entityDefs = new[] {
        new {
            subTypes = new[] {
                "<String>"
            },
            superTypes = new[] {
                "<String>"
            },
            relationshipAttributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    enumDefs = new[] {
        new {
            defaultValue = "<defaultValue>",
            elementDefs = new[] {
                new {
                    description = "<description>",
                    ordinal = 123.45f,
                    value = "<value>",
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    relationshipDefs = new[] {
        new {
            endDef1 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            endDef2 = new {
                cardinality = "SINGLE",
                description = "<description>",
                isContainer = true,
                isLegacyAttribute = true,
                name = "<name>",
                type = "<type>",
            },
            relationshipCategory = "ASSOCIATION",
            relationshipLabel = "<relationshipLabel>",
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    structDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
    termTemplateDefs = new[] {
        new {
            attributeDefs = new[] {
                new {
                    isLegacyAttribute = true,
                    relationshipTypeName = "<relationshipTypeName>",
                    cardinality = "SINGLE",
                    constraints = new[] {
                        new {
                            params = new {
                                key = new {},
                            },
                            type = "<type>",
                        }
                    },
                    defaultValue = "<defaultValue>",
                    description = "<description>",
                    includeInNotification = true,
                    isIndexable = true,
                    isOptional = true,
                    isUnique = true,
                    name = "<name>",
                    options = new {
                        key = "<String>",
                    },
                    typeName = "<typeName>",
                    valuesMaxCount = 1234,
                    valuesMinCount = 1234,
                }
            },
            category = "PRIMITIVE",
            createTime = 123.45f,
            createdBy = "<createdBy>",
            dateFormatter = new {
                availableLocales = new[] {
                    "<String>"
                },
                calendar = 123.45f,
                lenient = true,
                numberFormat = new {
                    availableLocales = new[] {
                        "<String>"
                    },
                    currency = "<currency>",
                    groupingUsed = true,
                    maximumFractionDigits = 1234,
                    maximumIntegerDigits = 1234,
                    minimumFractionDigits = 1234,
                    minimumIntegerDigits = 1234,
                    parseIntegerOnly = true,
                    roundingMode = "UP",
                },
                timeZone = new {
                    dstSavings = 1234,
                    id = "<id>",
                    availableIds = new[] {
                        "<String>"
                    },
                    displayName = "<displayName>",
                    rawOffset = 1234,
                },
            },
            description = "<description>",
            guid = "<guid>",
            name = "<name>",
            options = new {
                key = "<String>",
            },
            serviceType = "<serviceType>",
            typeVersion = "<typeVersion>",
            updateTime = 123.45f,
            updatedBy = "<updatedBy>",
            version = 123.45f,
            lastModifiedTS = "<lastModifiedTS>",
        }
    },
};

Response response = client.DeleteTypeDefinitions(RequestContent.Create(data));
Console.WriteLine(response.Status);
]]></code>
</example>
<remarks>
Below is the JSON schema for the request payload.

Request Body:

Schema for <c>AtlasTypesDef</c>:
<code>{
  businessMetadataDefs: [
    {
      attributeDefs: [
        {
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [
            {
              params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
              type: string, # Optional. The type of the constraint.
            }
          ], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: {
        availableLocales: [string], # Optional. An array of available locales.
        calendar: number, # Optional.
        dateInstance: DateFormat, # Optional. The date format.
        dateTimeInstance: DateFormat, # Optional. The date format.
        instance: DateFormat, # Optional. The date format.
        lenient: boolean, # Optional. Determines the leniency of the date format.
        numberFormat: {
          availableLocales: [string], # Optional. The number format.
          currency: string, # Optional. The currency.
          currencyInstance: NumberFormat, # Optional. The number format.
          groupingUsed: boolean, # Optional. Determines if grouping is used.
          instance: NumberFormat, # Optional. The number format.
          integerInstance: NumberFormat, # Optional. The number format.
          maximumFractionDigits: number, # Optional. The maximum of fraction digits.
          maximumIntegerDigits: number, # Optional. The maximum of integer digits.
          minimumFractionDigits: number, # Optional. The minimum of fraction digits.
          minimumIntegerDigits: number, # Optional. The minimum of integer digits.
          numberInstance: NumberFormat, # Optional. The number format.
          parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
          percentInstance: NumberFormat, # Optional. The number format.
          roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
        }, # Optional. The number format.
        timeInstance: DateFormat, # Optional. The date format.
        timeZone: {
          dstSavings: number, # Optional. The value of the daylight saving time.
          id: string, # Optional. The ID of the timezone.
          availableIds: [string], # Optional. An array of available IDs.
          default: TimeZone, # Optional. The timezone information.
          displayName: string, # Optional. The display name of the timezone.
          rawOffset: number, # Optional. The raw offset of the timezone.
        }, # Optional. The timezone information.
      }, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. businessMetadataDefs
  classificationDefs: [
    {
      entityTypes: [string], # Optional. Specifying a list of entityType names in the classificationDef, ensures that classifications can
only be applied to those entityTypes.
&lt;ul&gt;
&lt;li&gt;Any subtypes of the entity types inherit the restriction&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes inherit the parents entityTypes restrictions&lt;/li&gt;
&lt;li&gt;Any classificationDef subtypes can further restrict the parents entityTypes restrictions by specifying a subset of the entityTypes&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are no parent restrictions means there are no restrictions&lt;/li&gt;
&lt;li&gt;An empty entityTypes list when there are parent restrictions means that the subtype picks up the parents restrictions&lt;/li&gt;
&lt;li&gt;If a list of entityTypes are supplied, where one inherits from another, this will be rejected. This should encourage cleaner classificationsDefs&lt;/li&gt;
&lt;/ul&gt;
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of classification definitions.
  entityDefs: [
    {
      subTypes: [string], # Optional. An array of sub types.
      superTypes: [string], # Optional. An array of super types.
      relationshipAttributeDefs: [
        {
          isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
          relationshipTypeName: string, # Optional. The name of the relationship type.
          cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
          constraints: [AtlasConstraintDef], # Optional. An array of constraints.
          defaultValue: string, # Optional. The default value of the attribute.
          description: string, # Optional. The description of the attribute.
          includeInNotification: boolean, # Optional. Determines if it is included in notification.
          isIndexable: boolean, # Optional. Determines if it is indexable.
          isOptional: boolean, # Optional. Determines if it is optional.
          isUnique: boolean, # Optional. Determines if it unique.
          name: string, # Optional. The name of the attribute.
          options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
          typeName: string, # Optional. The name of the type.
          valuesMaxCount: number, # Optional. The maximum count of the values.
          valuesMinCount: number, # Optional. The minimum count of the values.
        }
      ], # Optional. An array of relationship attributes.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of entity definitions.
  enumDefs: [
    {
      defaultValue: string, # Optional. The default value.
      elementDefs: [
        {
          description: string, # Optional. The description of the enum element definition.
          ordinal: number, # Optional. The ordinal of the enum element definition.
          value: string, # Optional. The value of the enum element definition.
        }
      ], # Optional. An array of enum element definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of enum definitions.
  relationshipDefs: [
    {
      endDef1: {
        cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
        description: string, # Optional. The description of the relationship end definition.
        isContainer: boolean, # Optional. Determines if it is container.
        isLegacyAttribute: boolean, # Optional. Determines if it is a legacy attribute.
        name: string, # Optional. The name of the relationship end definition.
        type: string, # Optional. The type of the relationship end.
      }, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      endDef2: AtlasRelationshipEndDef, # Optional. The relationshipEndDef represents an end of the relationship. The end of the relationship is defined by a type, an
attribute name, cardinality and whether it  is the container end of the relationship.
      relationshipCategory: &quot;ASSOCIATION&quot; | &quot;AGGREGATION&quot; | &quot;COMPOSITION&quot;, # Optional. The Relationship category determines the style of relationship around containment and lifecycle.
UML terminology is used for the values.
&lt;p&gt;
ASSOCIATION is a relationship with no containment. &lt;br&gt;
COMPOSITION and AGGREGATION are containment relationships.
&lt;p&gt;
The difference being in the lifecycles of the container and its children. In the COMPOSITION case,
the children cannot exist without the container. For AGGREGATION, the life cycles
of the container and children are totally independent.
      relationshipLabel: string, # Optional. The label of the relationship.
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of relationship definitions.
  structDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of struct definitions.
  termTemplateDefs: [
    {
      attributeDefs: [AtlasAttributeDef], # Optional. An array of attribute definitions.
      category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
      createTime: number, # Optional. The created time of the record.
      createdBy: string, # Optional. The user who created the record.
      dateFormatter: DateFormat, # Optional. The date format.
      description: string, # Optional. The description of the type definition.
      guid: string, # Optional. The GUID of the type definition.
      name: string, # Optional. The name of the type definition.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
      serviceType: string, # Optional. The service type.
      typeVersion: string, # Optional. The version of the type.
      updateTime: number, # Optional. The update time of the record.
      updatedBy: string, # Optional. The user who updated the record.
      version: number, # Optional. The version of the record.
      lastModifiedTS: string, # Optional. ETag for concurrency control.
    }
  ], # Optional. An array of term template definitions.
}
</code>

</remarks>
    </member>
    <member name="GetTypeDefinitionHeadersAsync(Boolean,String,RequestContext)">
<example>
This sample shows how to call GetTypeDefinitionHeadersAsync and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetTypeDefinitionHeadersAsync();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code>
This sample shows how to call GetTypeDefinitionHeadersAsync with all parameters, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetTypeDefinitionHeadersAsync(true, "<type>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].GetProperty("category").ToString());
Console.WriteLine(result[0].GetProperty("guid").ToString());
Console.WriteLine(result[0].GetProperty("name").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasTypeDefHeader</c>:
<code>{
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
}
</code>

</remarks>
    </member>
    <member name="GetTypeDefinitionHeaders(Boolean,String,RequestContext)">
<example>
This sample shows how to call GetTypeDefinitionHeaders and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetTypeDefinitionHeaders();

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].ToString());
]]></code>
This sample shows how to call GetTypeDefinitionHeaders with all parameters, and how to parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetTypeDefinitionHeaders(true, "<type>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result[0].GetProperty("category").ToString());
Console.WriteLine(result[0].GetProperty("guid").ToString());
Console.WriteLine(result[0].GetProperty("name").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>AtlasTypeDefHeader</c>:
<code>{
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
}
</code>

</remarks>
    </member>
    <member name="GetTermTemplateDefByGuidAsync(String,RequestContext)">
<example>
This sample shows how to call GetTermTemplateDefByGuidAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetTermTemplateDefByGuidAsync("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TermTemplateDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetTermTemplateDefByGuid(String,RequestContext)">
<example>
This sample shows how to call GetTermTemplateDefByGuid with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetTermTemplateDefByGuid("<guid>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TermTemplateDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetTermTemplateDefByNameAsync(String,RequestContext)">
<example>
This sample shows how to call GetTermTemplateDefByNameAsync with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = await client.GetTermTemplateDefByNameAsync("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TermTemplateDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
    <member name="GetTermTemplateDefByName(String,RequestContext)">
<example>
This sample shows how to call GetTermTemplateDefByName with required parameters and parse the result.
<code><![CDATA[
var credential = new DefaultAzureCredential();
var endpoint = new Uri("<https://my-service.azure.com>");
var client = new PurviewCatalogClient(endpoint, credential).GetPurviewTypesClient();

Response response = client.GetTermTemplateDefByName("<name>");

JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("cardinality").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("params").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("constraints")[0].GetProperty("type").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("defaultValue").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("includeInNotification").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isIndexable").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isOptional").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("isUnique").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("typeName").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMaxCount").ToString());
Console.WriteLine(result.GetProperty("attributeDefs")[0].GetProperty("valuesMinCount").ToString());
Console.WriteLine(result.GetProperty("category").ToString());
Console.WriteLine(result.GetProperty("createTime").ToString());
Console.WriteLine(result.GetProperty("createdBy").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("calendar").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("lenient").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("availableLocales")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("currency").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("groupingUsed").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("maximumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumFractionDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("minimumIntegerDigits").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("parseIntegerOnly").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("numberFormat").GetProperty("roundingMode").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("dstSavings").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("id").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("availableIds")[0].ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("displayName").ToString());
Console.WriteLine(result.GetProperty("dateFormatter").GetProperty("timeZone").GetProperty("rawOffset").ToString());
Console.WriteLine(result.GetProperty("description").ToString());
Console.WriteLine(result.GetProperty("guid").ToString());
Console.WriteLine(result.GetProperty("name").ToString());
Console.WriteLine(result.GetProperty("options").GetProperty("<test>").ToString());
Console.WriteLine(result.GetProperty("serviceType").ToString());
Console.WriteLine(result.GetProperty("typeVersion").ToString());
Console.WriteLine(result.GetProperty("updateTime").ToString());
Console.WriteLine(result.GetProperty("updatedBy").ToString());
Console.WriteLine(result.GetProperty("version").ToString());
Console.WriteLine(result.GetProperty("lastModifiedTS").ToString());
]]></code>
</example>
<remarks>
Below is the JSON schema for the response payload.

Response Body:

Schema for <c>TermTemplateDef</c>:
<code>{
  attributeDefs: [
    {
      cardinality: &quot;SINGLE&quot; | &quot;LIST&quot; | &quot;SET&quot;, # Optional. single-valued attribute or multi-valued attribute.
      constraints: [
        {
          params: Dictionary&lt;string, AnyObject&gt;, # Optional. The parameters of the constraint definition.
          type: string, # Optional. The type of the constraint.
        }
      ], # Optional. An array of constraints.
      defaultValue: string, # Optional. The default value of the attribute.
      description: string, # Optional. The description of the attribute.
      includeInNotification: boolean, # Optional. Determines if it is included in notification.
      isIndexable: boolean, # Optional. Determines if it is indexable.
      isOptional: boolean, # Optional. Determines if it is optional.
      isUnique: boolean, # Optional. Determines if it unique.
      name: string, # Optional. The name of the attribute.
      options: Dictionary&lt;string, string&gt;, # Optional. The options for the attribute.
      typeName: string, # Optional. The name of the type.
      valuesMaxCount: number, # Optional. The maximum count of the values.
      valuesMinCount: number, # Optional. The minimum count of the values.
    }
  ], # Optional. An array of attribute definitions.
  category: &quot;PRIMITIVE&quot; | &quot;OBJECT_ID_TYPE&quot; | &quot;ENUM&quot; | &quot;STRUCT&quot; | &quot;CLASSIFICATION&quot; | &quot;ENTITY&quot; | &quot;ARRAY&quot; | &quot;MAP&quot; | &quot;RELATIONSHIP&quot; | &quot;TERM_TEMPLATE&quot;, # Optional. The enum of type category.
  createTime: number, # Optional. The created time of the record.
  createdBy: string, # Optional. The user who created the record.
  dateFormatter: {
    availableLocales: [string], # Optional. An array of available locales.
    calendar: number, # Optional.
    dateInstance: DateFormat, # Optional. The date format.
    dateTimeInstance: DateFormat, # Optional. The date format.
    instance: DateFormat, # Optional. The date format.
    lenient: boolean, # Optional. Determines the leniency of the date format.
    numberFormat: {
      availableLocales: [string], # Optional. The number format.
      currency: string, # Optional. The currency.
      currencyInstance: NumberFormat, # Optional. The number format.
      groupingUsed: boolean, # Optional. Determines if grouping is used.
      instance: NumberFormat, # Optional. The number format.
      integerInstance: NumberFormat, # Optional. The number format.
      maximumFractionDigits: number, # Optional. The maximum of fraction digits.
      maximumIntegerDigits: number, # Optional. The maximum of integer digits.
      minimumFractionDigits: number, # Optional. The minimum of fraction digits.
      minimumIntegerDigits: number, # Optional. The minimum of integer digits.
      numberInstance: NumberFormat, # Optional. The number format.
      parseIntegerOnly: boolean, # Optional. Determines if only integer is parsed.
      percentInstance: NumberFormat, # Optional. The number format.
      roundingMode: &quot;UP&quot; | &quot;DOWN&quot; | &quot;CEILING&quot; | &quot;FLOOR&quot; | &quot;HALF_UP&quot; | &quot;HALF_DOWN&quot; | &quot;HALF_EVEN&quot; | &quot;UNNECESSARY&quot;, # Optional. The enum of rounding mode.
    }, # Optional. The number format.
    timeInstance: DateFormat, # Optional. The date format.
    timeZone: {
      dstSavings: number, # Optional. The value of the daylight saving time.
      id: string, # Optional. The ID of the timezone.
      availableIds: [string], # Optional. An array of available IDs.
      default: TimeZone, # Optional. The timezone information.
      displayName: string, # Optional. The display name of the timezone.
      rawOffset: number, # Optional. The raw offset of the timezone.
    }, # Optional. The timezone information.
  }, # Optional. The date format.
  description: string, # Optional. The description of the type definition.
  guid: string, # Optional. The GUID of the type definition.
  name: string, # Optional. The name of the type definition.
  options: Dictionary&lt;string, string&gt;, # Optional. The options for the type definition.
  serviceType: string, # Optional. The service type.
  typeVersion: string, # Optional. The version of the type.
  updateTime: number, # Optional. The update time of the record.
  updatedBy: string, # Optional. The user who updated the record.
  version: number, # Optional. The version of the record.
  lastModifiedTS: string, # Optional. ETag for concurrency control.
}
</code>

</remarks>
    </member>
  </members>
</doc>