// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using Azure;
using Azure.Core;
using Azure.ResourceManager.ContainerRegistry;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.ContainerRegistry.Models
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class ArmContainerRegistryModelFactory
    {

        /// <summary> An object that represents a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The properties of the container registry. </param>
        /// <param name="sku"> The SKU of the container registry. </param>
        /// <param name="identity"> The identity of the container registry. </param>
        /// <returns> A new <see cref="ContainerRegistry.RegistryData"/> instance for mocking. </returns>
        public static RegistryData RegistryData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, RegistryProperties properties = default, ContainerRegistrySku sku = default, IdentityProperties identity = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new RegistryData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties,
                sku,
                identity);
        }

        /// <summary> The properties of a container registry. </summary>
        /// <param name="loginServer"> The URL that can be used to log into the container registry. </param>
        /// <param name="createdOn"> The creation date of the container registry in ISO8601 format. </param>
        /// <param name="provisioningState"> The provisioning state of the container registry at the time the operation was called. </param>
        /// <param name="status"> The status of the container registry at the time the operation was called. </param>
        /// <param name="adminUserEnabled"> The value that indicates whether the admin user is enabled. </param>
        /// <param name="networkRuleSet"> The network rule set for a container registry. </param>
        /// <param name="policies"> The policies for a container registry. </param>
        /// <param name="encryption"> The encryption settings of container registry. </param>
        /// <param name="dataEndpointEnabled"> Enable a single data endpoint per region for serving data. </param>
        /// <param name="dataEndpointHostNames"> List of host names that will serve data when dataEndpointEnabled is true. </param>
        /// <param name="privateEndpointConnections"> List of private endpoint connections for a container registry. </param>
        /// <param name="publicNetworkAccess"> Whether or not public network access is allowed for the container registry. </param>
        /// <param name="networkRuleBypassOptions"> Whether to allow trusted Azure services to access a network restricted registry. </param>
        /// <param name="networkRuleBypassAllowedForTasks"> Whether or not Tasks allowed to bypass the network rules for this container registry. </param>
        /// <param name="zoneRedundancy"> Whether or not zone redundancy is enabled for this container registry. </param>
        /// <param name="anonymousPullEnabled"> Enables registry-wide pull from unauthenticated clients. </param>
        /// <param name="roleAssignmentMode"> Determines registry role assignment mode. </param>
        /// <returns> A new <see cref="Models.RegistryProperties"/> instance for mocking. </returns>
        public static RegistryProperties RegistryProperties(string loginServer = default, DateTimeOffset? createdOn = default, ProvisioningState? provisioningState = default, Status status = default, bool? adminUserEnabled = default, NetworkRuleSet networkRuleSet = default, Policies policies = default, EncryptionProperty encryption = default, bool? dataEndpointEnabled = default, IEnumerable<string> dataEndpointHostNames = default, IEnumerable<ContainerRegistryPrivateEndpointConnectionData> privateEndpointConnections = default, PublicNetworkAccess? publicNetworkAccess = default, NetworkRuleBypassOptions? networkRuleBypassOptions = default, bool? networkRuleBypassAllowedForTasks = default, ZoneRedundancy? zoneRedundancy = default, bool? anonymousPullEnabled = default, RoleAssignmentMode? roleAssignmentMode = default)
        {
            dataEndpointHostNames ??= new ChangeTrackingList<string>();
            privateEndpointConnections ??= new ChangeTrackingList<ContainerRegistryPrivateEndpointConnectionData>();

            return new RegistryProperties(
                loginServer,
                createdOn,
                provisioningState,
                status,
                adminUserEnabled,
                networkRuleSet,
                policies,
                encryption,
                dataEndpointEnabled,
                dataEndpointHostNames.ToList(),
                privateEndpointConnections.ToList(),
                publicNetworkAccess,
                networkRuleBypassOptions,
                networkRuleBypassAllowedForTasks,
                zoneRedundancy,
                anonymousPullEnabled,
                roleAssignmentMode,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The status of an Azure resource at the time the operation was called. </summary>
        /// <param name="displayStatus"> The short label for the status. </param>
        /// <param name="message"> The detailed message for the status, including alerts and error messages. </param>
        /// <param name="timestamp"> The timestamp when the status was changed to the current value. </param>
        /// <returns> A new <see cref="Models.Status"/> instance for mocking. </returns>
        public static Status Status(string displayStatus = default, string message = default, DateTimeOffset? timestamp = default)
        {
            return new Status(displayStatus, message, timestamp, additionalBinaryDataProperties: null);
        }

        /// <summary> The network rule set for a container registry. </summary>
        /// <param name="defaultAction"> The default action of allow or deny when no other rules match. </param>
        /// <param name="ipRules"> The IP ACL rules. </param>
        /// <returns> A new <see cref="Models.NetworkRuleSet"/> instance for mocking. </returns>
        public static NetworkRuleSet NetworkRuleSet(DefaultAction defaultAction = default, IEnumerable<IPRule> ipRules = default)
        {
            ipRules ??= new ChangeTrackingList<IPRule>();

            return new NetworkRuleSet(defaultAction, ipRules.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The retention policy for a container registry. </summary>
        /// <param name="days"> The number of days to retain an untagged manifest after which it gets purged. </param>
        /// <param name="lastUpdatedOn"> The timestamp when the policy was last updated. </param>
        /// <param name="status"> The value that indicates whether the policy is enabled or not. </param>
        /// <returns> A new <see cref="Models.RetentionPolicy"/> instance for mocking. </returns>
        public static RetentionPolicy RetentionPolicy(int? days = default, DateTimeOffset? lastUpdatedOn = default, PolicyStatus? status = default)
        {
            return new RetentionPolicy(days, lastUpdatedOn, status, additionalBinaryDataProperties: null);
        }

        /// <summary> The KeyVaultProperties. </summary>
        /// <param name="keyIdentifier"> Key vault uri to access the encryption key. </param>
        /// <param name="versionedKeyIdentifier"> The fully qualified key identifier that includes the version of the key that is actually used for encryption. </param>
        /// <param name="identity"> The client id of the identity which will be used to access key vault. </param>
        /// <param name="keyRotationEnabled"> Auto key rotation status for a CMK enabled registry. </param>
        /// <param name="lastKeyRotationTimestamp"> Timestamp of the last successful key rotation. </param>
        /// <returns> A new <see cref="Models.KeyVaultProperties"/> instance for mocking. </returns>
        public static KeyVaultProperties KeyVaultProperties(string keyIdentifier = default, string versionedKeyIdentifier = default, string identity = default, bool? keyRotationEnabled = default, DateTimeOffset? lastKeyRotationTimestamp = default)
        {
            return new KeyVaultProperties(
                keyIdentifier,
                versionedKeyIdentifier,
                identity,
                keyRotationEnabled,
                lastKeyRotationTimestamp,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a private endpoint connection for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of a private endpoint connection. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryPrivateEndpointConnectionData"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateEndpointConnectionData ContainerRegistryPrivateEndpointConnectionData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, PrivateEndpointConnectionProperties properties = default)
        {
            return new ContainerRegistryPrivateEndpointConnectionData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <param name="privateEndpointId"> This is private endpoint resource created with Microsoft.Network resource provider. </param>
        /// <param name="privateLinkServiceConnectionState"> A collection of information about the state of the connection between service consumer and provider. </param>
        /// <param name="provisioningState"> The provisioning state of private endpoint connection resource. </param>
        /// <returns> A new <see cref="Models.PrivateEndpointConnectionProperties"/> instance for mocking. </returns>
        public static PrivateEndpointConnectionProperties PrivateEndpointConnectionProperties(string privateEndpointId = default, ContainerRegistryPrivateLinkServiceConnectionState privateLinkServiceConnectionState = default, ProvisioningState? provisioningState = default)
        {
            return new PrivateEndpointConnectionProperties(privateEndpointId is null ? default : new PrivateEndpoint(privateEndpointId, null), privateLinkServiceConnectionState, provisioningState, additionalBinaryDataProperties: null);
        }

        /// <summary> The SKU of a container registry. </summary>
        /// <param name="name"> The SKU name of the container registry. Required for registry creation. </param>
        /// <param name="tier"> The SKU tier based on the SKU name. </param>
        /// <returns> A new <see cref="Models.ContainerRegistrySku"/> instance for mocking. </returns>
        public static ContainerRegistrySku ContainerRegistrySku(ContainerRegistrySkuName name = default, ContainerRegistrySkuTier? tier = default)
        {
            return new ContainerRegistrySku(name, tier, additionalBinaryDataProperties: null);
        }

        /// <summary> Managed identity for the resource. </summary>
        /// <param name="principalId"> The principal ID of resource identity. </param>
        /// <param name="tenantId"> The tenant ID of resource. </param>
        /// <param name="type"> The identity type. </param>
        /// <param name="userAssignedIdentities">
        /// The list of user identities associated with the resource. The user identity
        /// dictionary key references will be ARM resource ids in the form:
        /// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
        /// providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        /// </param>
        /// <returns> A new <see cref="Models.IdentityProperties"/> instance for mocking. </returns>
        public static IdentityProperties IdentityProperties(string principalId = default, string tenantId = default, ResourceIdentityType? @type = default, IDictionary<string, UserIdentityProperties> userAssignedIdentities = default)
        {
            userAssignedIdentities ??= new ChangeTrackingDictionary<string, UserIdentityProperties>();

            return new IdentityProperties(principalId, tenantId, @type, userAssignedIdentities, additionalBinaryDataProperties: null);
        }

        /// <summary> The UserIdentityProperties. </summary>
        /// <param name="principalId"> The principal id of user assigned identity. </param>
        /// <param name="clientId"> The client id of user assigned identity. </param>
        /// <returns> A new <see cref="Models.UserIdentityProperties"/> instance for mocking. </returns>
        public static UserIdentityProperties UserIdentityProperties(string principalId = default, string clientId = default)
        {
            return new UserIdentityProperties(principalId, clientId, additionalBinaryDataProperties: null);
        }

        /// <param name="identity"> The identity of the container registry. </param>
        /// <param name="tags"> The tags for the container registry. </param>
        /// <param name="sku"> The SKU of the container registry. </param>
        /// <param name="adminUserEnabled"> The value that indicates whether the admin user is enabled. </param>
        /// <param name="networkRuleSet"> The network rule set for a container registry. </param>
        /// <param name="policies"> The policies for a container registry. </param>
        /// <param name="encryption"> The encryption settings of container registry. </param>
        /// <param name="dataEndpointEnabled"> Enable a single data endpoint per region for serving data. </param>
        /// <param name="publicNetworkAccess"> Whether or not public network access is allowed for the container registry. </param>
        /// <param name="networkRuleBypassOptions"> Whether to allow trusted Azure services to access a network restricted registry. </param>
        /// <param name="networkRuleBypassAllowedForTasks"> Whether to allow ACR Tasks service to access a network restricted registry. </param>
        /// <param name="anonymousPullEnabled"> Enables registry-wide pull from unauthenticated clients. </param>
        /// <param name="roleAssignmentMode"> Determines registry role assignment mode. </param>
        /// <returns> A new <see cref="Models.RegistryPatch"/> instance for mocking. </returns>
        public static RegistryPatch RegistryPatch(IdentityProperties identity = default, IDictionary<string, string> tags = default, ContainerRegistrySku sku = default, bool? adminUserEnabled = default, NetworkRuleSet networkRuleSet = default, Policies policies = default, EncryptionProperty encryption = default, bool? dataEndpointEnabled = default, PublicNetworkAccess? publicNetworkAccess = default, NetworkRuleBypassOptions? networkRuleBypassOptions = default, bool? networkRuleBypassAllowedForTasks = default, bool? anonymousPullEnabled = default, RoleAssignmentMode? roleAssignmentMode = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new RegistryPatch(identity, tags, sku, adminUserEnabled is null && networkRuleSet is null && policies is null && encryption is null && dataEndpointEnabled is null && publicNetworkAccess is null && networkRuleBypassOptions is null && networkRuleBypassAllowedForTasks is null && anonymousPullEnabled is null && roleAssignmentMode is null ? default : new RegistryPropertiesUpdateParameters(
                adminUserEnabled,
                networkRuleSet,
                policies,
                encryption,
                dataEndpointEnabled,
                publicNetworkAccess,
                networkRuleBypassOptions,
                networkRuleBypassAllowedForTasks,
                anonymousPullEnabled,
                roleAssignmentMode,
                null), additionalBinaryDataProperties: null);
        }

        /// <summary> The ImportImageParameters. </summary>
        /// <param name="source"> The source of the image. </param>
        /// <param name="targetTags"> List of strings of the form repo[:tag]. When tag is omitted the source will be used (or 'latest' if source tag is also omitted). </param>
        /// <param name="untaggedTargetRepositories"> List of strings of repository names to do a manifest only copy. No tag will be created. </param>
        /// <param name="mode"> When Force, any existing target tags will be overwritten. When NoForce, any existing target tags will fail the operation before any copying begins. </param>
        /// <returns> A new <see cref="Models.ImportImageParameters"/> instance for mocking. </returns>
        public static ImportImageParameters ImportImageParameters(ImportSource source = default, IEnumerable<string> targetTags = default, IEnumerable<string> untaggedTargetRepositories = default, ImportMode? mode = default)
        {
            targetTags ??= new ChangeTrackingList<string>();
            untaggedTargetRepositories ??= new ChangeTrackingList<string>();

            return new ImportImageParameters(source, targetTags.ToList(), untaggedTargetRepositories.ToList(), mode, additionalBinaryDataProperties: null);
        }

        /// <summary> The ImportSource. </summary>
        /// <param name="resourceId"> The resource identifier of the source Azure Container Registry. </param>
        /// <param name="registryUri"> The address of the source registry (e.g. 'mcr.microsoft.com'). </param>
        /// <param name="credentials"> Credentials used when importing from a registry uri. </param>
        /// <param name="sourceImage">
        /// Repository name of the source image.
        /// Specify an image by repository ('hello-world'). This will use the 'latest' tag.
        /// Specify an image by tag ('hello-world:latest').
        /// Specify an image by sha256-based manifest digest ('hello-world@sha256:abc123').
        /// </param>
        /// <returns> A new <see cref="Models.ImportSource"/> instance for mocking. </returns>
        public static ImportSource ImportSource(string resourceId = default, string registryUri = default, ImportSourceCredentials credentials = default, string sourceImage = default)
        {
            return new ImportSource(resourceId, registryUri, credentials, sourceImage, additionalBinaryDataProperties: null);
        }

        /// <summary> The ImportSourceCredentials. </summary>
        /// <param name="username"> The username to authenticate with the source registry. </param>
        /// <param name="password"> The password used to authenticate with the source registry. </param>
        /// <returns> A new <see cref="Models.ImportSourceCredentials"/> instance for mocking. </returns>
        public static ImportSourceCredentials ImportSourceCredentials(string username = default, string password = default)
        {
            return new ImportSourceCredentials(username, password, additionalBinaryDataProperties: null);
        }

        /// <summary> The result of a request to get container registry quota usages. </summary>
        /// <param name="value"> The list of container registry quota usages. </param>
        /// <returns> A new <see cref="Models.RegistryUsageListResult"/> instance for mocking. </returns>
        public static RegistryUsageListResult RegistryUsageListResult(IEnumerable<RegistryUsage> value = default)
        {
            value ??= new ChangeTrackingList<RegistryUsage>();

            return new RegistryUsageListResult(value.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The quota usage for a container registry. </summary>
        /// <param name="name"> The name of the usage. </param>
        /// <param name="limit"> The limit of the usage. </param>
        /// <param name="currentValue"> The current value of the usage. </param>
        /// <param name="unit"> The unit of measurement. </param>
        /// <returns> A new <see cref="Models.RegistryUsage"/> instance for mocking. </returns>
        public static RegistryUsage RegistryUsage(string name = default, long? limit = default, long? currentValue = default, RegistryUsageUnit? unit = default)
        {
            return new RegistryUsage(name, limit, currentValue, unit, additionalBinaryDataProperties: null);
        }

        /// <summary> The response from the ListCredentials operation. </summary>
        /// <param name="username"> The username for a container registry. </param>
        /// <param name="passwords"> The list of passwords for a container registry. </param>
        /// <returns> A new <see cref="Models.RegistryListCredentialsResult"/> instance for mocking. </returns>
        public static RegistryListCredentialsResult RegistryListCredentialsResult(string username = default, IEnumerable<RegistryPassword> passwords = default)
        {
            passwords ??= new ChangeTrackingList<RegistryPassword>();

            return new RegistryListCredentialsResult(username, passwords.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The login password for the container registry. </summary>
        /// <param name="name"> The password name. </param>
        /// <param name="value"> The password value. </param>
        /// <returns> A new <see cref="Models.RegistryPassword"/> instance for mocking. </returns>
        public static RegistryPassword RegistryPassword(PasswordName? name = default, string value = default)
        {
            return new RegistryPassword(name, value, additionalBinaryDataProperties: null);
        }

        /// <summary> The parameters used to regenerate the login credential. </summary>
        /// <param name="name"> Specifies name of the password which should be regenerated -- password or password2. </param>
        /// <returns> A new <see cref="Models.RegenerateCredentialParameters"/> instance for mocking. </returns>
        public static RegenerateCredentialParameters RegenerateCredentialParameters(PasswordName name = default)
        {
            return new RegenerateCredentialParameters(name, additionalBinaryDataProperties: null);
        }

        /// <summary> The response from the GenerateCredentials operation. </summary>
        /// <param name="username"> The username for a container registry. </param>
        /// <param name="passwords"> The list of passwords for a container registry. </param>
        /// <returns> A new <see cref="Models.GenerateCredentialsResult"/> instance for mocking. </returns>
        public static GenerateCredentialsResult GenerateCredentialsResult(string username = default, IEnumerable<TokenPassword> passwords = default)
        {
            passwords ??= new ChangeTrackingList<TokenPassword>();

            return new GenerateCredentialsResult(username, passwords.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The password that will be used for authenticating the token of a container registry. </summary>
        /// <param name="createdOn"> The creation datetime of the password. </param>
        /// <param name="expiry"> The expiry datetime of the password. </param>
        /// <param name="name"> The password name "password1" or "password2". </param>
        /// <param name="value"> The password value. </param>
        /// <returns> A new <see cref="Models.TokenPassword"/> instance for mocking. </returns>
        public static TokenPassword TokenPassword(DateTimeOffset? createdOn = default, DateTimeOffset? expiry = default, TokenPasswordName? name = default, string value = default)
        {
            return new TokenPassword(createdOn, expiry, name, value, additionalBinaryDataProperties: null);
        }

        /// <summary> A request to check whether a container registry name is available. </summary>
        /// <param name="name"> The name of the container registry. </param>
        /// <param name="type"> The resource type of the container registry. This field must be set to 'Microsoft.ContainerRegistry/registries'. </param>
        /// <returns> A new <see cref="Models.RegistryNameCheckRequest"/> instance for mocking. </returns>
        public static RegistryNameCheckRequest RegistryNameCheckRequest(string name = default, ContainerRegistryResourceType @type = default)
        {
            return new RegistryNameCheckRequest(name, @type, additionalBinaryDataProperties: null);
        }

        /// <summary> The result of a request to check the availability of a container registry name. </summary>
        /// <param name="nameAvailable"> The value that indicates whether the name is available. </param>
        /// <param name="reason"> If any, the reason that the name is not available. </param>
        /// <param name="message"> If any, the error message that provides more detail for the reason that the name is not available. </param>
        /// <returns> A new <see cref="Models.RegistryNameStatus"/> instance for mocking. </returns>
        public static RegistryNameStatus RegistryNameStatus(bool? nameAvailable = default, string reason = default, string message = default)
        {
            return new RegistryNameStatus(nameAvailable, reason, message, additionalBinaryDataProperties: null);
        }

        /// <summary> A private link resource. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> A resource that supports private link capabilities. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPrivateLinkResource"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateLinkResource ContainerRegistryPrivateLinkResource(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ContainerRegistryPrivateLinkResourceProperties properties = default)
        {
            return new ContainerRegistryPrivateLinkResource(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> Properties of a private link resource. </summary>
        /// <param name="groupId"> The private link resource group id. </param>
        /// <param name="requiredMembers"> The private link resource required member names. </param>
        /// <param name="requiredZoneNames"> The private link resource private link DNS zone name. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPrivateLinkResourceProperties"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateLinkResourceProperties ContainerRegistryPrivateLinkResourceProperties(string groupId = default, IEnumerable<string> requiredMembers = default, IEnumerable<string> requiredZoneNames = default)
        {
            requiredMembers ??= new ChangeTrackingList<string>();
            requiredZoneNames ??= new ChangeTrackingList<string>();

            return new ContainerRegistryPrivateLinkResourceProperties(groupId, requiredMembers.ToList(), requiredZoneNames.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a cache rule for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the cache rule. </param>
        /// <returns> A new <see cref="ContainerRegistry.CacheRuleData"/> instance for mocking. </returns>
        public static CacheRuleData CacheRuleData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, CacheRuleProperties properties = default)
        {
            return new CacheRuleData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> The properties of a cache rule. </summary>
        /// <param name="credentialSetResourceId"> The ARM resource ID of the credential store which is associated with the cache rule. </param>
        /// <param name="sourceRepository"> Source repository pulled from upstream. </param>
        /// <param name="targetRepository">
        /// Target repository specified in docker pull command.
        /// Eg: docker pull myregistry.azurecr.io/{targetRepository}:{tag}
        /// </param>
        /// <param name="createdOn"> The creation date of the cache rule. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <returns> A new <see cref="Models.CacheRuleProperties"/> instance for mocking. </returns>
        public static CacheRuleProperties CacheRuleProperties(string credentialSetResourceId = default, string sourceRepository = default, string targetRepository = default, DateTimeOffset? createdOn = default, ProvisioningState? provisioningState = default)
        {
            return new CacheRuleProperties(
                credentialSetResourceId,
                sourceRepository,
                targetRepository,
                createdOn,
                provisioningState,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a credential set resource for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the credential set. </param>
        /// <param name="identity"> Identities associated with the resource. This is used to access the KeyVault secrets. </param>
        /// <returns> A new <see cref="ContainerRegistry.CredentialSetData"/> instance for mocking. </returns>
        public static CredentialSetData CredentialSetData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, CredentialSetProperties properties = default, IdentityProperties identity = default)
        {
            return new CredentialSetData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties,
                identity);
        }

        /// <summary> The properties of a credential set resource. </summary>
        /// <param name="loginServer"> The credentials are stored for this upstream or login server. </param>
        /// <param name="authCredentials">
        /// List of authentication credentials stored for an upstream.
        /// Usually consists of a primary and an optional secondary credential.
        /// </param>
        /// <param name="createdOn"> The creation date of credential store resource. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <returns> A new <see cref="Models.CredentialSetProperties"/> instance for mocking. </returns>
        public static CredentialSetProperties CredentialSetProperties(string loginServer = default, IEnumerable<AuthCredential> authCredentials = default, DateTimeOffset? createdOn = default, ProvisioningState? provisioningState = default)
        {
            authCredentials ??= new ChangeTrackingList<AuthCredential>();

            return new CredentialSetProperties(loginServer, authCredentials.ToList(), createdOn, provisioningState, additionalBinaryDataProperties: null);
        }

        /// <summary> Authentication credential stored for an upstream. </summary>
        /// <param name="name"> The name of the credential. </param>
        /// <param name="usernameSecretIdentifier"> KeyVault Secret URI for accessing the username. </param>
        /// <param name="passwordSecretIdentifier"> KeyVault Secret URI for accessing the password. </param>
        /// <param name="credentialHealth"> This provides data pertaining to the health of the auth credential. </param>
        /// <returns> A new <see cref="Models.AuthCredential"/> instance for mocking. </returns>
        public static AuthCredential AuthCredential(CredentialName? name = default, string usernameSecretIdentifier = default, string passwordSecretIdentifier = default, CredentialHealth credentialHealth = default)
        {
            return new AuthCredential(name, usernameSecretIdentifier, passwordSecretIdentifier, credentialHealth, additionalBinaryDataProperties: null);
        }

        /// <summary> The health of the auth credential. </summary>
        /// <param name="status"> The health status of credential. </param>
        /// <param name="errorCode"> Error code representing the health check error. </param>
        /// <param name="errorMessage"> Descriptive message representing the health check error. </param>
        /// <returns> A new <see cref="Models.CredentialHealth"/> instance for mocking. </returns>
        public static CredentialHealth CredentialHealth(CredentialHealthStatus? status = default, string errorCode = default, string errorMessage = default)
        {
            return new CredentialHealth(status, errorCode, errorMessage, additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a connected registry for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the connected registry. </param>
        /// <returns> A new <see cref="ContainerRegistry.ConnectedRegistryData"/> instance for mocking. </returns>
        public static ConnectedRegistryData ConnectedRegistryData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ConnectedRegistryProperties properties = default)
        {
            return new ConnectedRegistryData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="mode"> The mode of the connected registry resource that indicates the permissions of the registry. </param>
        /// <param name="version"> The current version of ACR runtime on the connected registry. </param>
        /// <param name="connectionState"> The current connection state of the connected registry. </param>
        /// <param name="lastActivityOn"> The last activity time of the connected registry. </param>
        /// <param name="activationStatus"> The activation status of the connected registry. </param>
        /// <param name="parent"> The parent of the connected registry. </param>
        /// <param name="clientTokenIds"> The list of the ACR token resource IDs used to authenticate clients to the connected registry. </param>
        /// <param name="loginServer"> The login server properties of the connected registry. </param>
        /// <param name="logging"> The logging properties of the connected registry. </param>
        /// <param name="statusDetails"> The list of current statuses of the connected registry. </param>
        /// <param name="notificationsList"> The list of notifications subscription information for the connected registry. </param>
        /// <param name="garbageCollection"> The garbage collection properties of the connected registry. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistryProperties"/> instance for mocking. </returns>
        public static ConnectedRegistryProperties ConnectedRegistryProperties(ProvisioningState? provisioningState = default, ConnectedRegistryMode mode = default, string version = default, ConnectionState? connectionState = default, DateTimeOffset? lastActivityOn = default, ActivationStatus? activationStatus = default, ParentProperties parent = default, IEnumerable<string> clientTokenIds = default, LoginServerProperties loginServer = default, LoggingProperties logging = default, IEnumerable<StatusDetailProperties> statusDetails = default, IEnumerable<string> notificationsList = default, GarbageCollectionProperties garbageCollection = default)
        {
            clientTokenIds ??= new ChangeTrackingList<string>();
            statusDetails ??= new ChangeTrackingList<StatusDetailProperties>();
            notificationsList ??= new ChangeTrackingList<string>();

            return new ConnectedRegistryProperties(
                provisioningState,
                mode,
                version,
                connectionState,
                lastActivityOn,
                activationStatus is null ? default : new ActivationProperties(activationStatus, null),
                parent,
                clientTokenIds.ToList(),
                loginServer,
                logging,
                statusDetails.ToList(),
                notificationsList.ToList(),
                garbageCollection,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The sync properties of the connected registry with its parent. </summary>
        /// <param name="tokenId"> The resource ID of the ACR token used to authenticate the connected registry to its parent during sync. </param>
        /// <param name="schedule"> The cron expression indicating the schedule that the connected registry will sync with its parent. </param>
        /// <param name="syncWindow"> The time window during which sync is enabled for each schedule occurrence. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601. </param>
        /// <param name="messageTtl"> The period of time for which a message is available to sync before it is expired. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601. </param>
        /// <param name="lastSyncOn"> The last time a sync occurred between the connected registry and its parent. </param>
        /// <param name="gatewayEndpoint"> The gateway endpoint used by the connected registry to communicate with its parent. </param>
        /// <returns> A new <see cref="Models.SyncProperties"/> instance for mocking. </returns>
        public static SyncProperties SyncProperties(string tokenId = default, string schedule = default, TimeSpan? syncWindow = default, TimeSpan messageTtl = default, DateTimeOffset? lastSyncOn = default, string gatewayEndpoint = default)
        {
            return new SyncProperties(
                tokenId,
                schedule,
                syncWindow,
                messageTtl,
                lastSyncOn,
                gatewayEndpoint,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The login server properties of the connected registry. </summary>
        /// <param name="host"> The host of the connected registry. Can be FQDN or IP. </param>
        /// <param name="tls"> The TLS properties of the connected registry login server. </param>
        /// <returns> A new <see cref="Models.LoginServerProperties"/> instance for mocking. </returns>
        public static LoginServerProperties LoginServerProperties(string host = default, TlsProperties tls = default)
        {
            return new LoginServerProperties(host, tls, additionalBinaryDataProperties: null);
        }

        /// <summary> The TLS properties of the connected registry login server. </summary>
        /// <param name="status"> Indicates whether HTTPS is enabled for the login server. </param>
        /// <param name="certificate"> The certificate used to configure HTTPS for the login server. </param>
        /// <returns> A new <see cref="Models.TlsProperties"/> instance for mocking. </returns>
        public static TlsProperties TlsProperties(TlsStatus? status = default, TlsCertificateProperties certificate = default)
        {
            return new TlsProperties(status, certificate, additionalBinaryDataProperties: null);
        }

        /// <summary> The TLS certificate properties of the connected registry login server. </summary>
        /// <param name="type"> The type of certificate location. </param>
        /// <param name="location"> Indicates the location of the certificates. </param>
        /// <returns> A new <see cref="Models.TlsCertificateProperties"/> instance for mocking. </returns>
        public static TlsCertificateProperties TlsCertificateProperties(CertificateType? @type = default, string location = default)
        {
            return new TlsCertificateProperties(@type, location, additionalBinaryDataProperties: null);
        }

        /// <summary> The status detail properties of the connected registry. </summary>
        /// <param name="type"> The component of the connected registry corresponding to the status. </param>
        /// <param name="code"> The HTTP status code. </param>
        /// <param name="description"> The description of the status. </param>
        /// <param name="timestamp"> The timestamp of the status. </param>
        /// <param name="correlationId"> The correlation ID of the status. </param>
        /// <returns> A new <see cref="Models.StatusDetailProperties"/> instance for mocking. </returns>
        public static StatusDetailProperties StatusDetailProperties(string @type = default, string code = default, string description = default, DateTimeOffset? timestamp = default, string correlationId = default)
        {
            return new StatusDetailProperties(
                @type,
                code,
                description,
                timestamp,
                correlationId,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a replication for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The properties of the replication. </param>
        /// <returns> A new <see cref="ContainerRegistry.ReplicationData"/> instance for mocking. </returns>
        public static ReplicationData ReplicationData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, ReplicationProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ReplicationData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties);
        }

        /// <summary> The properties of a replication. </summary>
        /// <param name="provisioningState"> The provisioning state of the replication at the time the operation was called. </param>
        /// <param name="status"> The status of the replication at the time the operation was called. </param>
        /// <param name="regionEndpointEnabled"> Specifies whether the replication's regional endpoint is enabled. Requests will not be routed to a replication whose regional endpoint is disabled, however its data will continue to be synced with other replications. </param>
        /// <param name="zoneRedundancy"> Whether or not zone redundancy is enabled for this container registry replication. </param>
        /// <returns> A new <see cref="Models.ReplicationProperties"/> instance for mocking. </returns>
        public static ReplicationProperties ReplicationProperties(ProvisioningState? provisioningState = default, Status status = default, bool? regionEndpointEnabled = default, ZoneRedundancy? zoneRedundancy = default)
        {
            return new ReplicationProperties(provisioningState, status, regionEndpointEnabled, zoneRedundancy, additionalBinaryDataProperties: null);
        }

        /// <param name="tags"> The tags for the replication. </param>
        /// <param name="regionEndpointEnabled"> Specifies whether the replication's regional endpoint is enabled. Requests will not be routed to a replication whose regional endpoint is disabled, however its data will continue to be synced with other replications. </param>
        /// <returns> A new <see cref="Models.ReplicationPatch"/> instance for mocking. </returns>
        public static ReplicationPatch ReplicationPatch(IDictionary<string, string> tags = default, bool? regionEndpointEnabled = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ReplicationPatch(tags, regionEndpointEnabled is null ? default : new ReplicationUpdateParametersProperties(regionEndpointEnabled, null), additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a scope map for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the scope map. </param>
        /// <returns> A new <see cref="ContainerRegistry.ScopeMapData"/> instance for mocking. </returns>
        public static ScopeMapData ScopeMapData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ScopeMapProperties properties = default)
        {
            return new ScopeMapData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> The properties of a scope map. </summary>
        /// <param name="description"> The user friendly description of the scope map. </param>
        /// <param name="type"> The type of the scope map. E.g. BuildIn scope map. </param>
        /// <param name="createdOn"> The creation date of scope map. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="actions">
        /// The list of scoped permissions for registry artifacts.
        /// E.g. repositories/repository-name/content/read,
        /// repositories/repository-name/metadata/write
        /// </param>
        /// <returns> A new <see cref="Models.ScopeMapProperties"/> instance for mocking. </returns>
        public static ScopeMapProperties ScopeMapProperties(string description = default, string @type = default, DateTimeOffset? createdOn = default, ProvisioningState? provisioningState = default, IEnumerable<string> actions = default)
        {
            actions ??= new ChangeTrackingList<string>();

            return new ScopeMapProperties(
                description,
                @type,
                createdOn,
                provisioningState,
                actions.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a token for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the token. </param>
        /// <returns> A new <see cref="ContainerRegistry.TokenData"/> instance for mocking. </returns>
        public static TokenData TokenData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, TokenProperties properties = default)
        {
            return new TokenData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> The properties of a token. </summary>
        /// <param name="createdOn"> The creation date of scope map. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="scopeMapId"> The resource ID of the scope map to which the token will be associated with. </param>
        /// <param name="credentials"> The credentials that can be used for authenticating the token. </param>
        /// <param name="status"> The status of the token example enabled or disabled. </param>
        /// <returns> A new <see cref="Models.TokenProperties"/> instance for mocking. </returns>
        public static TokenProperties TokenProperties(DateTimeOffset? createdOn = default, ProvisioningState? provisioningState = default, string scopeMapId = default, TokenCredentialsProperties credentials = default, TokenStatus? status = default)
        {
            return new TokenProperties(
                createdOn,
                provisioningState,
                scopeMapId,
                credentials,
                status,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The properties of the credentials that can be used for authenticating the token. </summary>
        /// <param name="certificates"></param>
        /// <param name="passwords"></param>
        /// <returns> A new <see cref="Models.TokenCredentialsProperties"/> instance for mocking. </returns>
        public static TokenCredentialsProperties TokenCredentialsProperties(IEnumerable<TokenCertificate> certificates = default, IEnumerable<TokenPassword> passwords = default)
        {
            certificates ??= new ChangeTrackingList<TokenCertificate>();
            passwords ??= new ChangeTrackingList<TokenPassword>();

            return new TokenCredentialsProperties(certificates.ToList(), passwords.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a webhook for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The properties of the webhook. </param>
        /// <returns> A new <see cref="ContainerRegistry.WebhookData"/> instance for mocking. </returns>
        public static WebhookData WebhookData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, WebhookProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new WebhookData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties);
        }

        /// <summary> The properties of a webhook. </summary>
        /// <param name="status"> The status of the webhook at the time the operation was called. </param>
        /// <param name="scope"> The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is equivalent to 'foo:latest'. Empty means all events. </param>
        /// <param name="actions"> The list of actions that trigger the webhook to post notifications. </param>
        /// <param name="provisioningState"> The provisioning state of the webhook at the time the operation was called. </param>
        /// <returns> A new <see cref="Models.WebhookProperties"/> instance for mocking. </returns>
        public static WebhookProperties WebhookProperties(WebhookStatus? status = default, string scope = default, IEnumerable<WebhookAction> actions = default, ProvisioningState? provisioningState = default)
        {
            actions ??= new ChangeTrackingList<WebhookAction>();

            return new WebhookProperties(status, scope, actions.ToList(), provisioningState, additionalBinaryDataProperties: null);
        }

        /// <param name="tags"> The tags for the webhook. </param>
        /// <param name="location"> The location of the webhook. This cannot be changed after the resource is created. </param>
        /// <param name="serviceUri"> The service URI for the webhook to post notifications. </param>
        /// <param name="customHeaders"> Custom headers that will be added to the webhook notifications. </param>
        /// <param name="status"> The status of the webhook at the time the operation was called. </param>
        /// <param name="scope"> The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is equivalent to 'foo:latest'. Empty means all events. </param>
        /// <param name="actions"> The list of actions that trigger the webhook to post notifications. </param>
        /// <returns> A new <see cref="Models.WebhookCreateParameters"/> instance for mocking. </returns>
        public static WebhookCreateParameters WebhookCreateParameters(IDictionary<string, string> tags = default, string location = default, string serviceUri = default, IDictionary<string, string> customHeaders = default, WebhookStatus? status = default, string scope = default, IEnumerable<WebhookAction> actions = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new WebhookCreateParameters(tags, location, serviceUri is null && customHeaders is null && status is null && scope is null && actions is null ? default : new WebhookPropertiesCreateParameters(
                serviceUri,
                customHeaders,
                status,
                scope,
                (actions ?? new ChangeTrackingList<WebhookAction>()).ToList(),
                null), additionalBinaryDataProperties: null);
        }

        /// <param name="tags"> The tags for the webhook. </param>
        /// <param name="serviceUri"> The service URI for the webhook to post notifications. </param>
        /// <param name="customHeaders"> Custom headers that will be added to the webhook notifications. </param>
        /// <param name="status"> The status of the webhook at the time the operation was called. </param>
        /// <param name="scope"> The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is equivalent to 'foo:latest'. Empty means all events. </param>
        /// <param name="actions"> The list of actions that trigger the webhook to post notifications. </param>
        /// <returns> A new <see cref="Models.WebhookPatch"/> instance for mocking. </returns>
        public static WebhookPatch WebhookPatch(IDictionary<string, string> tags = default, string serviceUri = default, IDictionary<string, string> customHeaders = default, WebhookStatus? status = default, string scope = default, IEnumerable<WebhookAction> actions = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new WebhookPatch(tags, serviceUri is null && customHeaders is null && status is null && scope is null && actions is null ? default : new WebhookPropertiesUpdateParameters(
                serviceUri,
                customHeaders,
                status,
                scope,
                (actions ?? new ChangeTrackingList<WebhookAction>()).ToList(),
                null), additionalBinaryDataProperties: null);
        }

        /// <summary> The basic information of an event. </summary>
        /// <param name="id"> The event ID. </param>
        /// <returns> A new <see cref="Models.EventInfo"/> instance for mocking. </returns>
        public static EventInfo EventInfo(string id = default)
        {
            return new EventInfo(id, additionalBinaryDataProperties: null);
        }

        /// <summary> The event for a webhook. </summary>
        /// <param name="id"> The event ID. </param>
        /// <param name="eventRequestMessage"> The event request message sent to the service URI. </param>
        /// <param name="eventResponseMessage"> The event response message received from the service URI. </param>
        /// <returns> A new <see cref="Models.Event"/> instance for mocking. </returns>
        public static Event Event(string id = default, EventRequestMessage eventRequestMessage = default, EventResponseMessage eventResponseMessage = default)
        {
            return new Event(id, additionalBinaryDataProperties: null, eventRequestMessage, eventResponseMessage);
        }

        /// <summary> The event request message sent to the service URI. </summary>
        /// <param name="content"> The content of the event request message. </param>
        /// <param name="headers"> The headers of the event request message. </param>
        /// <param name="method"> The HTTP method used to send the event request message. </param>
        /// <param name="requestUri"> The URI used to send the event request message. </param>
        /// <param name="version"> The HTTP message version. </param>
        /// <returns> A new <see cref="Models.EventRequestMessage"/> instance for mocking. </returns>
        public static EventRequestMessage EventRequestMessage(EventContent content = default, IDictionary<string, string> headers = default, string @method = default, string requestUri = default, string version = default)
        {
            headers ??= new ChangeTrackingDictionary<string, string>();

            return new EventRequestMessage(
                content,
                headers,
                @method,
                requestUri,
                version,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> The event ID. </param>
        /// <param name="timestamp"> The time at which the event occurred. </param>
        /// <param name="action"> The action that encompasses the provided event. </param>
        /// <param name="target"> The target of the event. </param>
        /// <param name="request"> The request that generated the event. </param>
        /// <param name="actorName"> The subject or username associated with the request context that generated the event. </param>
        /// <param name="source"> The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it. </param>
        /// <returns> A new <see cref="Models.EventContent"/> instance for mocking. </returns>
        public static EventContent EventContent(string id = default, DateTimeOffset? timestamp = default, string action = default, Target target = default, Request request = default, string actorName = default, Source source = default)
        {
            return new EventContent(
                id,
                timestamp,
                action,
                target,
                request,
                actorName is null ? default : new Actor(actorName, null),
                source,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The target of the event. </summary>
        /// <param name="mediaType"> The MIME type of the referenced object. </param>
        /// <param name="size"> The number of bytes of the content. Same as Length field. </param>
        /// <param name="digest"> The digest of the content, as defined by the Registry V2 HTTP API Specification. </param>
        /// <param name="length"> The number of bytes of the content. Same as Size field. </param>
        /// <param name="repository"> The repository name. </param>
        /// <param name="uri"> The direct URL to the content. </param>
        /// <param name="tag"> The tag name. </param>
        /// <param name="name"> The name of the artifact. </param>
        /// <param name="version"> The version of the artifact. </param>
        /// <returns> A new <see cref="Models.Target"/> instance for mocking. </returns>
        public static Target Target(string mediaType = default, long? size = default, string digest = default, long? length = default, string repository = default, string uri = default, string tag = default, string name = default, string version = default)
        {
            return new Target(
                mediaType,
                size,
                digest,
                length,
                repository,
                uri,
                tag,
                name,
                version,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The request that generated the event. </summary>
        /// <param name="id"> The ID of the request that initiated the event. </param>
        /// <param name="addr"> The IP or hostname and possibly port of the client connection that initiated the event. This is the RemoteAddr from the standard http request. </param>
        /// <param name="host"> The externally accessible hostname of the registry instance, as specified by the http host header on incoming requests. </param>
        /// <param name="method"> The request method that generated the event. </param>
        /// <param name="useragent"> The user agent header of the request. </param>
        /// <returns> A new <see cref="Models.Request"/> instance for mocking. </returns>
        public static Request Request(string id = default, string addr = default, string host = default, string @method = default, string useragent = default)
        {
            return new Request(
                id,
                addr,
                host,
                @method,
                useragent,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it. </summary>
        /// <param name="addr"> The IP or hostname and the port of the registry node that generated the event. Generally, this will be resolved by os.Hostname() along with the running port. </param>
        /// <param name="instanceID"> The running instance of an application. Changes after each restart. </param>
        /// <returns> A new <see cref="Models.Source"/> instance for mocking. </returns>
        public static Source Source(string addr = default, string instanceID = default)
        {
            return new Source(addr, instanceID, additionalBinaryDataProperties: null);
        }

        /// <summary> The event response message received from the service URI. </summary>
        /// <param name="content"> The content of the event response message. </param>
        /// <param name="headers"> The headers of the event response message. </param>
        /// <param name="reasonPhrase"> The reason phrase of the event response message. </param>
        /// <param name="statusCode"> The status code of the event response message. </param>
        /// <param name="version"> The HTTP message version. </param>
        /// <returns> A new <see cref="Models.EventResponseMessage"/> instance for mocking. </returns>
        public static EventResponseMessage EventResponseMessage(string content = default, IDictionary<string, string> headers = default, string reasonPhrase = default, string statusCode = default, string version = default)
        {
            headers ??= new ChangeTrackingDictionary<string, string>();

            return new EventResponseMessage(
                content,
                headers,
                reasonPhrase,
                statusCode,
                version,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The configuration of service URI and custom headers for the webhook. </summary>
        /// <param name="serviceUri"> The service URI for the webhook to post notifications. </param>
        /// <param name="customHeaders"> Custom headers that will be added to the webhook notifications. </param>
        /// <returns> A new <see cref="Models.CallbackConfig"/> instance for mocking. </returns>
        public static CallbackConfig CallbackConfig(string serviceUri = default, IDictionary<string, string> customHeaders = default)
        {
            customHeaders ??= new ChangeTrackingDictionary<string, string>();

            return new CallbackConfig(serviceUri, customHeaders, additionalBinaryDataProperties: null);
        }

        /// <summary> Initializes a new instance of <see cref="ContainerRegistry.ContainerRegistryPrivateEndpointConnectionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="privateEndpointId"> The resource of private endpoint. </param>
        /// <param name="connectionState"> A collection of information about the state of the connection between service consumer and provider. </param>
        /// <param name="provisioningState"> The provisioning state of private endpoint connection resource. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryPrivateEndpointConnectionData"/> instance for mocking. </returns>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static ContainerRegistryPrivateEndpointConnectionData ContainerRegistryPrivateEndpointConnectionData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, ResourceIdentifier privateEndpointId, ContainerRegistryPrivateLinkServiceConnectionState connectionState, Models.ContainerRegistryProvisioningState? provisioningState)
        {
            return new ContainerRegistryPrivateEndpointConnectionData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                default);
        }

        /// <summary> Initializes a new instance of <see cref="ContainerRegistry.ConnectedRegistryData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="mode"> The mode of the connected registry resource that indicates the permissions of the registry. </param>
        /// <param name="version"> The current version of ACR runtime on the connected registry. </param>
        /// <param name="connectionState"> The current connection state of the connected registry. </param>
        /// <param name="lastActivityOn"> The last activity time of the connected registry. </param>
        /// <param name="activationStatus"> The activation properties of the connected registry. </param>
        /// <param name="parent"> The parent of the connected registry. </param>
        /// <param name="clientTokenIds"> The list of the ACR token resource IDs used to authenticate clients to the connected registry. </param>
        /// <param name="loginServer"> The login server properties of the connected registry. </param>
        /// <param name="logging"> The logging properties of the connected registry. </param>
        /// <param name="statusDetails"> The list of current statuses of the connected registry. </param>
        /// <param name="notificationsList"> The list of notifications subscription information for the connected registry. </param>
        /// <param name="garbageCollection"> The garbage collection properties of the connected registry. </param>
        /// <returns> A new <see cref="ContainerRegistry.ConnectedRegistryData"/> instance for mocking. </returns>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static ConnectedRegistryData ConnectedRegistryData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, Models.ContainerRegistryProvisioningState? provisioningState, ConnectedRegistryMode? mode, string version, Models.ConnectedRegistryConnectionState? connectionState, DateTimeOffset? lastActivityOn, Models.ConnectedRegistryActivationStatus? activationStatus, Models.ConnectedRegistryParent parent, IEnumerable<ResourceIdentifier> clientTokenIds, Models.ConnectedRegistryLoginServer loginServer, Models.ConnectedRegistryLogging logging, IEnumerable<Models.ConnectedRegistryStatusDetail> statusDetails, IEnumerable<string> notificationsList, GarbageCollectionProperties garbageCollection)
        {
            clientTokenIds ??= new ChangeTrackingList<ResourceIdentifier>();
            statusDetails ??= new ChangeTrackingList<Models.ConnectedRegistryStatusDetail>();
            notificationsList ??= new ChangeTrackingList<string>();

            return new ConnectedRegistryData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                default);
        }

        /// <summary> Initializes a new instance of <see cref="ContainerRegistry.ScopeMapData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="description"> The user friendly description of the scope map. </param>
        /// <param name="scopeMapType"> The type of the scope map. E.g. BuildIn scope map. </param>
        /// <param name="createdOn"> The creation date of scope map. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="actions">
        /// The list of scoped permissions for registry artifacts.
        ///             E.g. repositories/repository-name/content/read,
        ///             repositories/repository-name/metadata/write
        /// </param>
        /// <returns> A new <see cref="ContainerRegistry.ScopeMapData"/> instance for mocking. </returns>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static ScopeMapData ScopeMapData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, string description, string scopeMapType, DateTimeOffset? createdOn, Models.ContainerRegistryProvisioningState? provisioningState, IEnumerable<string> actions)
        {
            actions ??= new ChangeTrackingList<string>();

            return new ScopeMapData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                default);
        }
    }
}
