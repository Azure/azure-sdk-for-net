// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Core;
using Azure.ResourceManager.ContainerRegistry;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.ContainerRegistry.Models
{
    /// <summary> Model factory for models. </summary>
    public static partial class ArmContainerRegistryModelFactory
    {
        /// <summary> Initializes a new instance of ConnectedRegistryData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="mode"> The mode of the connected registry resource that indicates the permissions of the registry. </param>
        /// <param name="version"> The current version of ACR runtime on the connected registry. </param>
        /// <param name="connectionState"> The current connection state of the connected registry. </param>
        /// <param name="lastActivityOn"> The last activity time of the connected registry. </param>
        /// <param name="activationStatus"> The activation properties of the connected registry. </param>
        /// <param name="parent"> The parent of the connected registry. </param>
        /// <param name="clientTokenIds"> The list of the ACR token resource IDs used to authenticate clients to the connected registry. </param>
        /// <param name="loginServer"> The login server properties of the connected registry. </param>
        /// <param name="logging"> The logging properties of the connected registry. </param>
        /// <param name="statusDetails"> The list of current statuses of the connected registry. </param>
        /// <param name="notificationsList"> The list of notifications subscription information for the connected registry. </param>
        /// <returns> A new <see cref="ContainerRegistry.ConnectedRegistryData"/> instance for mocking. </returns>
        public static ConnectedRegistryData ConnectedRegistryData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ContainerRegistryProvisioningState? provisioningState = null, ConnectedRegistryMode? mode = null, string version = null, ConnectedRegistryConnectionState? connectionState = null, DateTimeOffset? lastActivityOn = null, ConnectedRegistryActivationStatus? activationStatus = null, ConnectedRegistryParent parent = null, IEnumerable<ResourceIdentifier> clientTokenIds = null, ConnectedRegistryLoginServer loginServer = null, ConnectedRegistryLogging logging = null, IEnumerable<ConnectedRegistryStatusDetail> statusDetails = null, IEnumerable<string> notificationsList = null)
        {
            clientTokenIds ??= new List<ResourceIdentifier>();
            statusDetails ??= new List<ConnectedRegistryStatusDetail>();
            notificationsList ??= new List<string>();

            return new ConnectedRegistryData(id, name, resourceType, systemData, provisioningState, mode, version, connectionState, lastActivityOn, activationStatus != null ? new ConnectedRegistryActivation(activationStatus) : null, parent, clientTokenIds?.ToList(), loginServer, logging, statusDetails?.ToList(), notificationsList?.ToList());
        }

        /// <summary> Initializes a new instance of ConnectedRegistrySyncProperties. </summary>
        /// <param name="tokenId"> The resource ID of the ACR token used to authenticate the connected registry to its parent during sync. </param>
        /// <param name="schedule"> The cron expression indicating the schedule that the connected registry will sync with its parent. </param>
        /// <param name="syncWindow"> The time window during which sync is enabled for each schedule occurrence. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601. </param>
        /// <param name="messageTtl"> The period of time for which a message is available to sync before it is expired. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601. </param>
        /// <param name="lastSyncOn"> The last time a sync occurred between the connected registry and its parent. </param>
        /// <param name="gatewayEndpoint"> The gateway endpoint used by the connected registry to communicate with its parent. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistrySyncProperties"/> instance for mocking. </returns>
        public static ConnectedRegistrySyncProperties ConnectedRegistrySyncProperties(ResourceIdentifier tokenId = null, string schedule = null, TimeSpan? syncWindow = null, TimeSpan messageTtl = default, DateTimeOffset? lastSyncOn = null, string gatewayEndpoint = null)
        {
            return new ConnectedRegistrySyncProperties(tokenId, schedule, syncWindow, messageTtl, lastSyncOn, gatewayEndpoint);
        }

        /// <summary> Initializes a new instance of ConnectedRegistryLoginServer. </summary>
        /// <param name="host"> The host of the connected registry. Can be FQDN or IP. </param>
        /// <param name="tls"> The TLS properties of the connected registry login server. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistryLoginServer"/> instance for mocking. </returns>
        public static ConnectedRegistryLoginServer ConnectedRegistryLoginServer(string host = null, TlsProperties tls = null)
        {
            return new ConnectedRegistryLoginServer(host, tls);
        }

        /// <summary> Initializes a new instance of TlsProperties. </summary>
        /// <param name="status"> Indicates whether HTTPS is enabled for the login server. </param>
        /// <param name="certificate"> The certificate used to configure HTTPS for the login server. </param>
        /// <returns> A new <see cref="Models.TlsProperties"/> instance for mocking. </returns>
        public static TlsProperties TlsProperties(TlsStatus? status = null, TlsCertificateProperties certificate = null)
        {
            return new TlsProperties(status, certificate);
        }

        /// <summary> Initializes a new instance of TlsCertificateProperties. </summary>
        /// <param name="locationType"> The type of certificate location. </param>
        /// <param name="certificateLocation"> Indicates the location of the certificates. </param>
        /// <returns> A new <see cref="Models.TlsCertificateProperties"/> instance for mocking. </returns>
        public static TlsCertificateProperties TlsCertificateProperties(TlsCertificateLocationType? locationType = null, string certificateLocation = null)
        {
            return new TlsCertificateProperties(locationType, certificateLocation);
        }

        /// <summary> Initializes a new instance of ConnectedRegistryStatusDetail. </summary>
        /// <param name="statusDetailType"> The component of the connected registry corresponding to the status. </param>
        /// <param name="code"> The code of the status. </param>
        /// <param name="description"> The description of the status. </param>
        /// <param name="timestamp"> The timestamp of the status. </param>
        /// <param name="correlationId"> The correlation ID of the status. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistryStatusDetail"/> instance for mocking. </returns>
        public static ConnectedRegistryStatusDetail ConnectedRegistryStatusDetail(string statusDetailType = null, string code = null, string description = null, DateTimeOffset? timestamp = null, string correlationId = null)
        {
            return new ConnectedRegistryStatusDetail(statusDetailType, code, description, timestamp, correlationId);
        }

        /// <summary> Initializes a new instance of ExportPipelineData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="location"> The location of the export pipeline. </param>
        /// <param name="identity"> The identity of the export pipeline. </param>
        /// <param name="target"> The target properties of the export pipeline. </param>
        /// <param name="options"> The list of all options configured for the pipeline. </param>
        /// <param name="provisioningState"> The provisioning state of the pipeline at the time the operation was called. </param>
        /// <returns> A new <see cref="ContainerRegistry.ExportPipelineData"/> instance for mocking. </returns>
        public static ExportPipelineData ExportPipelineData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, AzureLocation? location = null, ManagedServiceIdentity identity = null, ExportPipelineTargetProperties target = null, IEnumerable<PipelineOption> options = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            options ??= new List<PipelineOption>();

            return new ExportPipelineData(id, name, resourceType, systemData, location, identity, target, options?.ToList(), provisioningState);
        }

        /// <summary> Initializes a new instance of ImportPipelineData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="location"> The location of the import pipeline. </param>
        /// <param name="identity"> The identity of the import pipeline. </param>
        /// <param name="source"> The source properties of the import pipeline. </param>
        /// <param name="sourceTriggerStatus"> The properties that describe the trigger of the import pipeline. </param>
        /// <param name="options"> The list of all options configured for the pipeline. </param>
        /// <param name="provisioningState"> The provisioning state of the pipeline at the time the operation was called. </param>
        /// <returns> A new <see cref="ContainerRegistry.ImportPipelineData"/> instance for mocking. </returns>
        public static ImportPipelineData ImportPipelineData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, AzureLocation? location = null, ManagedServiceIdentity identity = null, ImportPipelineSourceProperties source = null, ContainerRegistryTriggerStatus? sourceTriggerStatus = null, IEnumerable<PipelineOption> options = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            options ??= new List<PipelineOption>();

            return new ImportPipelineData(id, name, resourceType, systemData, location, identity, source, sourceTriggerStatus.HasValue ? new PipelineTriggerProperties(new PipelineSourceTriggerProperties(sourceTriggerStatus.Value)) : null, options?.ToList(), provisioningState);
        }

        /// <summary> Initializes a new instance of ContainerRegistryNameAvailableResult. </summary>
        /// <param name="isNameAvailable"> The value that indicates whether the name is available. </param>
        /// <param name="reason"> If any, the reason that the name is not available. </param>
        /// <param name="message"> If any, the error message that provides more detail for the reason that the name is not available. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryNameAvailableResult"/> instance for mocking. </returns>
        public static ContainerRegistryNameAvailableResult ContainerRegistryNameAvailableResult(bool? isNameAvailable = null, string reason = null, string message = null)
        {
            return new ContainerRegistryNameAvailableResult(isNameAvailable, reason, message);
        }

        /// <summary> Initializes a new instance of ContainerRegistryPipelineRunData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="provisioningState"> The provisioning state of a pipeline run. </param>
        /// <param name="request"> The request parameters for a pipeline run. </param>
        /// <param name="response"> The response of a pipeline run. </param>
        /// <param name="forceUpdateTag"> How the pipeline run should be forced to recreate even if the pipeline run configuration has not changed. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryPipelineRunData"/> instance for mocking. </returns>
        public static ContainerRegistryPipelineRunData ContainerRegistryPipelineRunData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ContainerRegistryProvisioningState? provisioningState = null, PipelineRunContent request = null, PipelineRunResult response = null, string forceUpdateTag = null)
        {
            return new ContainerRegistryPipelineRunData(id, name, resourceType, systemData, provisioningState, request, response, forceUpdateTag);
        }

        /// <summary> Initializes a new instance of PipelineRunResult. </summary>
        /// <param name="status"> The current status of the pipeline run. </param>
        /// <param name="importedArtifacts"> The artifacts imported in the pipeline run. </param>
        /// <param name="progressPercentage"> The current progress of the copy operation. </param>
        /// <param name="startOn"> The time the pipeline run started. </param>
        /// <param name="finishOn"> The time the pipeline run finished. </param>
        /// <param name="source"> The source of the pipeline run. </param>
        /// <param name="target"> The target of the pipeline run. </param>
        /// <param name="catalogDigest"> The digest of the tar used to transfer the artifacts. </param>
        /// <param name="sourceTriggerTimestamp"> The trigger that caused the pipeline run. </param>
        /// <param name="pipelineRunErrorMessage"> The detailed error message for the pipeline run in the case of failure. </param>
        /// <returns> A new <see cref="Models.PipelineRunResult"/> instance for mocking. </returns>
        public static PipelineRunResult PipelineRunResult(string status = null, IEnumerable<string> importedArtifacts = null, string progressPercentage = null, DateTimeOffset? startOn = null, DateTimeOffset? finishOn = null, ImportPipelineSourceProperties source = null, ExportPipelineTargetProperties target = null, string catalogDigest = null, DateTimeOffset? sourceTriggerTimestamp = null, string pipelineRunErrorMessage = null)
        {
            importedArtifacts ??= new List<string>();

            return new PipelineRunResult(status, importedArtifacts?.ToList(), progressPercentage != null ? new PipelineProgress(progressPercentage) : null, startOn, finishOn, source, target, catalogDigest, sourceTriggerTimestamp != null ? new PipelineTriggerDescriptor(new PipelineSourceTriggerDescriptor(sourceTriggerTimestamp)) : null, pipelineRunErrorMessage);
        }

        /// <summary> Initializes a new instance of ContainerRegistryPrivateEndpointConnectionData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="privateEndpointId"> The resource of private endpoint. </param>
        /// <param name="connectionState"> A collection of information about the state of the connection between service consumer and provider. </param>
        /// <param name="provisioningState"> The provisioning state of private endpoint connection resource. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryPrivateEndpointConnectionData"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateEndpointConnectionData ContainerRegistryPrivateEndpointConnectionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ResourceIdentifier privateEndpointId = null, ContainerRegistryPrivateLinkServiceConnectionState connectionState = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            return new ContainerRegistryPrivateEndpointConnectionData(id, name, resourceType, systemData, privateEndpointId != null ? ResourceManagerModelFactory.WritableSubResource(privateEndpointId) : null, connectionState, provisioningState);
        }

        /// <summary> Initializes a new instance of ContainerRegistryData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="sku"> The SKU of the container registry. </param>
        /// <param name="identity"> The identity of the container registry. </param>
        /// <param name="loginServer"> The URL that can be used to log into the container registry. </param>
        /// <param name="createdOn"> The creation date of the container registry in ISO8601 format. </param>
        /// <param name="provisioningState"> The provisioning state of the container registry at the time the operation was called. </param>
        /// <param name="status"> The status of the container registry at the time the operation was called. </param>
        /// <param name="isAdminUserEnabled"> The value that indicates whether the admin user is enabled. </param>
        /// <param name="networkRuleSet"> The network rule set for a container registry. </param>
        /// <param name="policies"> The policies for a container registry. </param>
        /// <param name="encryption"> The encryption settings of container registry. </param>
        /// <param name="isDataEndpointEnabled"> Enable a single data endpoint per region for serving data. </param>
        /// <param name="dataEndpointHostNames"> List of host names that will serve data when dataEndpointEnabled is true. </param>
        /// <param name="privateEndpointConnections"> List of private endpoint connections for a container registry. </param>
        /// <param name="publicNetworkAccess"> Whether or not public network access is allowed for the container registry. </param>
        /// <param name="networkRuleBypassOptions"> Whether to allow trusted Azure services to access a network restricted registry. </param>
        /// <param name="zoneRedundancy"> Whether or not zone redundancy is enabled for this container registry. </param>
        /// <param name="isAnonymousPullEnabled"> Enables registry-wide pull from unauthenticated clients. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryData"/> instance for mocking. </returns>
        public static ContainerRegistryData ContainerRegistryData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ContainerRegistrySku sku = null, ManagedServiceIdentity identity = null, string loginServer = null, DateTimeOffset? createdOn = null, ContainerRegistryProvisioningState? provisioningState = null, ContainerRegistryResourceStatus status = null, bool? isAdminUserEnabled = null, ContainerRegistryNetworkRuleSet networkRuleSet = null, ContainerRegistryPolicies policies = null, ContainerRegistryEncryption encryption = null, bool? isDataEndpointEnabled = null, IEnumerable<string> dataEndpointHostNames = null, IEnumerable<ContainerRegistryPrivateEndpointConnectionData> privateEndpointConnections = null, ContainerRegistryPublicNetworkAccess? publicNetworkAccess = null, ContainerRegistryNetworkRuleBypassOption? networkRuleBypassOptions = null, ContainerRegistryZoneRedundancy? zoneRedundancy = null, bool? isAnonymousPullEnabled = null)
        {
            tags ??= new Dictionary<string, string>();
            dataEndpointHostNames ??= new List<string>();
            privateEndpointConnections ??= new List<ContainerRegistryPrivateEndpointConnectionData>();

            return new ContainerRegistryData(id, name, resourceType, systemData, tags, location, sku, identity, loginServer, createdOn, provisioningState, status, isAdminUserEnabled, networkRuleSet, policies, encryption, isDataEndpointEnabled, dataEndpointHostNames?.ToList(), privateEndpointConnections?.ToList(), publicNetworkAccess, networkRuleBypassOptions, zoneRedundancy, isAnonymousPullEnabled);
        }

        /// <summary> Initializes a new instance of ContainerRegistrySku. </summary>
        /// <param name="name"> The SKU name of the container registry. Required for registry creation. </param>
        /// <param name="tier"> The SKU tier based on the SKU name. </param>
        /// <returns> A new <see cref="Models.ContainerRegistrySku"/> instance for mocking. </returns>
        public static ContainerRegistrySku ContainerRegistrySku(ContainerRegistrySkuName name = default, ContainerRegistrySkuTier? tier = null)
        {
            return new ContainerRegistrySku(name, tier);
        }

        /// <summary> Initializes a new instance of ContainerRegistryResourceStatus. </summary>
        /// <param name="displayStatus"> The short label for the status. </param>
        /// <param name="message"> The detailed message for the status, including alerts and error messages. </param>
        /// <param name="timestamp"> The timestamp when the status was changed to the current value. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryResourceStatus"/> instance for mocking. </returns>
        public static ContainerRegistryResourceStatus ContainerRegistryResourceStatus(string displayStatus = null, string message = null, DateTimeOffset? timestamp = null)
        {
            return new ContainerRegistryResourceStatus(displayStatus, message, timestamp);
        }

        /// <summary> Initializes a new instance of ContainerRegistryRetentionPolicy. </summary>
        /// <param name="days"> The number of days to retain an untagged manifest after which it gets purged. </param>
        /// <param name="lastUpdatedOn"> The timestamp when the policy was last updated. </param>
        /// <param name="status"> The value that indicates whether the policy is enabled or not. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryRetentionPolicy"/> instance for mocking. </returns>
        public static ContainerRegistryRetentionPolicy ContainerRegistryRetentionPolicy(int? days = null, DateTimeOffset? lastUpdatedOn = null, ContainerRegistryPolicyStatus? status = null)
        {
            return new ContainerRegistryRetentionPolicy(days, lastUpdatedOn, status);
        }

        /// <summary> Initializes a new instance of ContainerRegistrySoftDeletePolicy. </summary>
        /// <param name="retentionDays"> The number of days after which a soft-deleted item is permanently deleted. </param>
        /// <param name="lastUpdatedOn"> The timestamp when the policy was last updated. </param>
        /// <param name="status"> The value that indicates whether the policy is enabled or not. </param>
        /// <returns> A new <see cref="Models.ContainerRegistrySoftDeletePolicy"/> instance for mocking. </returns>
        public static ContainerRegistrySoftDeletePolicy ContainerRegistrySoftDeletePolicy(int? retentionDays = null, DateTimeOffset? lastUpdatedOn = null, ContainerRegistryPolicyStatus? status = null)
        {
            return new ContainerRegistrySoftDeletePolicy(retentionDays, lastUpdatedOn, status);
        }

        /// <summary> Initializes a new instance of ContainerRegistryKeyVaultProperties. </summary>
        /// <param name="keyIdentifier"> Key vault uri to access the encryption key. </param>
        /// <param name="versionedKeyIdentifier"> The fully qualified key identifier that includes the version of the key that is actually used for encryption. </param>
        /// <param name="identity"> The client id of the identity which will be used to access key vault. </param>
        /// <param name="isKeyRotationEnabled"> Auto key rotation status for a CMK enabled registry. </param>
        /// <param name="lastKeyRotationTimestamp"> Timestamp of the last successful key rotation. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryKeyVaultProperties"/> instance for mocking. </returns>
        public static ContainerRegistryKeyVaultProperties ContainerRegistryKeyVaultProperties(string keyIdentifier = null, string versionedKeyIdentifier = null, string identity = null, bool? isKeyRotationEnabled = null, DateTimeOffset? lastKeyRotationTimestamp = null)
        {
            return new ContainerRegistryKeyVaultProperties(keyIdentifier, versionedKeyIdentifier, identity, isKeyRotationEnabled, lastKeyRotationTimestamp);
        }

        /// <summary> Initializes a new instance of ContainerRegistryUsage. </summary>
        /// <param name="name"> The name of the usage. </param>
        /// <param name="limit"> The limit of the usage. </param>
        /// <param name="currentValue"> The current value of the usage. </param>
        /// <param name="unit"> The unit of measurement. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryUsage"/> instance for mocking. </returns>
        public static ContainerRegistryUsage ContainerRegistryUsage(string name = null, long? limit = null, long? currentValue = null, ContainerRegistryUsageUnit? unit = null)
        {
            return new ContainerRegistryUsage(name, limit, currentValue, unit);
        }

        /// <summary> Initializes a new instance of ContainerRegistryPrivateLinkResourceData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="groupId"> The private link resource group id. </param>
        /// <param name="requiredMembers"> The private link resource required member names. </param>
        /// <param name="requiredZoneNames"> The private link resource Private link DNS zone name. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryPrivateLinkResourceData"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateLinkResourceData ContainerRegistryPrivateLinkResourceData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string groupId = null, IEnumerable<string> requiredMembers = null, IEnumerable<string> requiredZoneNames = null)
        {
            requiredMembers ??= new List<string>();
            requiredZoneNames ??= new List<string>();

            return new ContainerRegistryPrivateLinkResourceData(id, name, resourceType, systemData, groupId, requiredMembers?.ToList(), requiredZoneNames?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryListCredentialsResult. </summary>
        /// <param name="username"> The username for a container registry. </param>
        /// <param name="passwords"> The list of passwords for a container registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryListCredentialsResult"/> instance for mocking. </returns>
        public static ContainerRegistryListCredentialsResult ContainerRegistryListCredentialsResult(string username = null, IEnumerable<ContainerRegistryPassword> passwords = null)
        {
            passwords ??= new List<ContainerRegistryPassword>();

            return new ContainerRegistryListCredentialsResult(username, passwords?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryPassword. </summary>
        /// <param name="name"> The password name. </param>
        /// <param name="value"> The password value. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPassword"/> instance for mocking. </returns>
        public static ContainerRegistryPassword ContainerRegistryPassword(ContainerRegistryPasswordName? name = null, string value = null)
        {
            return new ContainerRegistryPassword(name, value);
        }

        /// <summary> Initializes a new instance of ContainerRegistryReplicationData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="provisioningState"> The provisioning state of the replication at the time the operation was called. </param>
        /// <param name="status"> The status of the replication at the time the operation was called. </param>
        /// <param name="isRegionEndpointEnabled"> Specifies whether the replication&apos;s regional endpoint is enabled. Requests will not be routed to a replication whose regional endpoint is disabled, however its data will continue to be synced with other replications. </param>
        /// <param name="zoneRedundancy"> Whether or not zone redundancy is enabled for this container registry replication. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryReplicationData"/> instance for mocking. </returns>
        public static ContainerRegistryReplicationData ContainerRegistryReplicationData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ContainerRegistryProvisioningState? provisioningState = null, ContainerRegistryResourceStatus status = null, bool? isRegionEndpointEnabled = null, ContainerRegistryZoneRedundancy? zoneRedundancy = null)
        {
            tags ??= new Dictionary<string, string>();

            return new ContainerRegistryReplicationData(id, name, resourceType, systemData, tags, location, provisioningState, status, isRegionEndpointEnabled, zoneRedundancy);
        }

        /// <summary> Initializes a new instance of ScopeMapData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="description"> The user friendly description of the scope map. </param>
        /// <param name="scopeMapType"> The type of the scope map. E.g. BuildIn scope map. </param>
        /// <param name="createdOn"> The creation date of scope map. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="actions">
        /// The list of scoped permissions for registry artifacts.
        /// E.g. repositories/repository-name/content/read,
        /// repositories/repository-name/metadata/write
        /// </param>
        /// <returns> A new <see cref="ContainerRegistry.ScopeMapData"/> instance for mocking. </returns>
        public static ScopeMapData ScopeMapData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string description = null, string scopeMapType = null, DateTimeOffset? createdOn = null, ContainerRegistryProvisioningState? provisioningState = null, IEnumerable<string> actions = null)
        {
            actions ??= new List<string>();

            return new ScopeMapData(id, name, resourceType, systemData, description, scopeMapType, createdOn, provisioningState, actions?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryTokenData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="createdOn"> The creation date of scope map. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="scopeMapId"> The resource ID of the scope map to which the token will be associated with. </param>
        /// <param name="credentials"> The credentials that can be used for authenticating the token. </param>
        /// <param name="status"> The status of the token example enabled or disabled. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryTokenData"/> instance for mocking. </returns>
        public static ContainerRegistryTokenData ContainerRegistryTokenData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, DateTimeOffset? createdOn = null, ContainerRegistryProvisioningState? provisioningState = null, ResourceIdentifier scopeMapId = null, ContainerRegistryTokenCredentials credentials = null, ContainerRegistryTokenStatus? status = null)
        {
            return new ContainerRegistryTokenData(id, name, resourceType, systemData, createdOn, provisioningState, scopeMapId, credentials, status);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTokenPassword. </summary>
        /// <param name="createdOn"> The creation datetime of the password. </param>
        /// <param name="expireOn"> The expiry datetime of the password. </param>
        /// <param name="name"> The password name &quot;password1&quot; or &quot;password2&quot;. </param>
        /// <param name="value"> The password value. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTokenPassword"/> instance for mocking. </returns>
        public static ContainerRegistryTokenPassword ContainerRegistryTokenPassword(DateTimeOffset? createdOn = null, DateTimeOffset? expireOn = null, ContainerRegistryTokenPasswordName? name = null, string value = null)
        {
            return new ContainerRegistryTokenPassword(createdOn, expireOn, name, value);
        }

        /// <summary> Initializes a new instance of ContainerRegistryGenerateCredentialsResult. </summary>
        /// <param name="username"> The username for a container registry. </param>
        /// <param name="passwords"> The list of passwords for a container registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryGenerateCredentialsResult"/> instance for mocking. </returns>
        public static ContainerRegistryGenerateCredentialsResult ContainerRegistryGenerateCredentialsResult(string username = null, IEnumerable<ContainerRegistryTokenPassword> passwords = null)
        {
            passwords ??= new List<ContainerRegistryTokenPassword>();

            return new ContainerRegistryGenerateCredentialsResult(username, passwords?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="status"> The status of the webhook at the time the operation was called. </param>
        /// <param name="scope"> The scope of repositories where the event can be triggered. For example, &apos;foo:*&apos; means events for all tags under repository &apos;foo&apos;. &apos;foo:bar&apos; means events for &apos;foo:bar&apos; only. &apos;foo&apos; is equivalent to &apos;foo:latest&apos;. Empty means all events. </param>
        /// <param name="actions"> The list of actions that trigger the webhook to post notifications. </param>
        /// <param name="provisioningState"> The provisioning state of the webhook at the time the operation was called. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryWebhookData"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookData ContainerRegistryWebhookData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ContainerRegistryWebhookStatus? status = null, string scope = null, IEnumerable<ContainerRegistryWebhookAction> actions = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            tags ??= new Dictionary<string, string>();
            actions ??= new List<ContainerRegistryWebhookAction>();

            return new ContainerRegistryWebhookData(id, name, resourceType, systemData, tags, location, status, scope, actions?.ToList(), provisioningState);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventInfo. </summary>
        /// <param name="id"> The event ID. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventInfo"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventInfo ContainerRegistryWebhookEventInfo(Guid? id = null)
        {
            return new ContainerRegistryWebhookEventInfo(id);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEvent. </summary>
        /// <param name="id"> The event ID. </param>
        /// <param name="eventRequestMessage"> The event request message sent to the service URI. </param>
        /// <param name="eventResponseMessage"> The event response message received from the service URI. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEvent"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEvent ContainerRegistryWebhookEvent(Guid? id = null, ContainerRegistryWebhookEventRequestMessage eventRequestMessage = null, ContainerRegistryWebhookEventResponseMessage eventResponseMessage = null)
        {
            return new ContainerRegistryWebhookEvent(id, eventRequestMessage, eventResponseMessage);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventRequestMessage. </summary>
        /// <param name="content"> The content of the event request message. </param>
        /// <param name="headers"> The headers of the event request message. </param>
        /// <param name="method"> The HTTP method used to send the event request message. </param>
        /// <param name="requestUri"> The URI used to send the event request message. </param>
        /// <param name="version"> The HTTP message version. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventRequestMessage"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventRequestMessage ContainerRegistryWebhookEventRequestMessage(ContainerRegistryWebhookEventContent content = null, IReadOnlyDictionary<string, string> headers = null, string method = null, Uri requestUri = null, string version = null)
        {
            headers ??= new Dictionary<string, string>();

            return new ContainerRegistryWebhookEventRequestMessage(content, headers, method, requestUri, version);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventContent. </summary>
        /// <param name="id"> The event ID. </param>
        /// <param name="timestamp"> The time at which the event occurred. </param>
        /// <param name="action"> The action that encompasses the provided event. </param>
        /// <param name="target"> The target of the event. </param>
        /// <param name="request"> The request that generated the event. </param>
        /// <param name="actorName"> The agent that initiated the event. For most situations, this could be from the authorization context of the request. </param>
        /// <param name="source"> The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventContent"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventContent ContainerRegistryWebhookEventContent(Guid? id = null, DateTimeOffset? timestamp = null, string action = null, ContainerRegistryWebhookEventTarget target = null, ContainerRegistryWebhookEventRequestContent request = null, string actorName = null, ContainerRegistryWebhookEventSource source = null)
        {
            return new ContainerRegistryWebhookEventContent(id, timestamp, action, target, request, actorName != null ? new ContainerRegistryWebhookEventActor(actorName) : null, source);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventTarget. </summary>
        /// <param name="mediaType"> The MIME type of the referenced object. </param>
        /// <param name="size"> The number of bytes of the content. Same as Length field. </param>
        /// <param name="digest"> The digest of the content, as defined by the Registry V2 HTTP API Specification. </param>
        /// <param name="length"> The number of bytes of the content. Same as Size field. </param>
        /// <param name="repository"> The repository name. </param>
        /// <param name="uri"> The direct URL to the content. </param>
        /// <param name="tag"> The tag name. </param>
        /// <param name="name"> The name of the artifact. </param>
        /// <param name="version"> The version of the artifact. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventTarget"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventTarget ContainerRegistryWebhookEventTarget(string mediaType = null, long? size = null, string digest = null, long? length = null, string repository = null, Uri uri = null, string tag = null, string name = null, string version = null)
        {
            return new ContainerRegistryWebhookEventTarget(mediaType, size, digest, length, repository, uri, tag, name, version);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventRequestContent. </summary>
        /// <param name="id"> The ID of the request that initiated the event. </param>
        /// <param name="addr"> The IP or hostname and possibly port of the client connection that initiated the event. This is the RemoteAddr from the standard http request. </param>
        /// <param name="host"> The externally accessible hostname of the registry instance, as specified by the http host header on incoming requests. </param>
        /// <param name="method"> The request method that generated the event. </param>
        /// <param name="userAgent"> The user agent header of the request. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventRequestContent"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventRequestContent ContainerRegistryWebhookEventRequestContent(Guid? id = null, string addr = null, string host = null, string method = null, string userAgent = null)
        {
            return new ContainerRegistryWebhookEventRequestContent(id, addr, host, method, userAgent);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventSource. </summary>
        /// <param name="addr"> The IP or hostname and the port of the registry node that generated the event. Generally, this will be resolved by os.Hostname() along with the running port. </param>
        /// <param name="instanceId"> The running instance of an application. Changes after each restart. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventSource"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventSource ContainerRegistryWebhookEventSource(string addr = null, string instanceId = null)
        {
            return new ContainerRegistryWebhookEventSource(addr, instanceId);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventResponseMessage. </summary>
        /// <param name="content"> The content of the event response message. </param>
        /// <param name="headers"> The headers of the event response message. </param>
        /// <param name="reasonPhrase"> The reason phrase of the event response message. </param>
        /// <param name="statusCode"> The status code of the event response message. </param>
        /// <param name="version"> The HTTP message version. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventResponseMessage"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventResponseMessage ContainerRegistryWebhookEventResponseMessage(string content = null, IReadOnlyDictionary<string, string> headers = null, string reasonPhrase = null, string statusCode = null, string version = null)
        {
            headers ??= new Dictionary<string, string>();

            return new ContainerRegistryWebhookEventResponseMessage(content, headers, reasonPhrase, statusCode, version);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookCallbackConfig. </summary>
        /// <param name="serviceUri"> The service URI for the webhook to post notifications. </param>
        /// <param name="customHeaders"> Custom headers that will be added to the webhook notifications. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookCallbackConfig"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookCallbackConfig ContainerRegistryWebhookCallbackConfig(Uri serviceUri = null, IReadOnlyDictionary<string, string> customHeaders = null)
        {
            customHeaders ??= new Dictionary<string, string>();

            return new ContainerRegistryWebhookCallbackConfig(serviceUri, customHeaders);
        }

        /// <summary> Initializes a new instance of ContainerRegistryAgentPoolData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="count"> The count of agent machine. </param>
        /// <param name="tier"> The Tier of agent machine. </param>
        /// <param name="os"> The OS of agent machine. </param>
        /// <param name="virtualNetworkSubnetResourceId"> The Virtual Network Subnet Resource Id of the agent machine. </param>
        /// <param name="provisioningState"> The provisioning state of this agent pool. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryAgentPoolData"/> instance for mocking. </returns>
        public static ContainerRegistryAgentPoolData ContainerRegistryAgentPoolData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, int? count = null, string tier = null, ContainerRegistryOS? os = null, ResourceIdentifier virtualNetworkSubnetResourceId = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            tags ??= new Dictionary<string, string>();

            return new ContainerRegistryAgentPoolData(id, name, resourceType, systemData, tags, location, count, tier, os, virtualNetworkSubnetResourceId, provisioningState);
        }

        /// <summary> Initializes a new instance of ContainerRegistryAgentPoolQueueStatus. </summary>
        /// <param name="count"> The number of pending runs in the queue. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryAgentPoolQueueStatus"/> instance for mocking. </returns>
        public static ContainerRegistryAgentPoolQueueStatus ContainerRegistryAgentPoolQueueStatus(int? count = null)
        {
            return new ContainerRegistryAgentPoolQueueStatus(count);
        }

        /// <summary> Initializes a new instance of ContainerRegistryRunData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="runId"> The unique identifier for the run. </param>
        /// <param name="status"> The current status of the run. </param>
        /// <param name="lastUpdatedOn"> The last updated time for the run. </param>
        /// <param name="runType"> The type of run. </param>
        /// <param name="agentPoolName"> The dedicated agent pool for the run. </param>
        /// <param name="createdOn"> The time the run was scheduled. </param>
        /// <param name="startOn"> The time the run started. </param>
        /// <param name="finishOn"> The time the run finished. </param>
        /// <param name="outputImages"> The list of all images that were generated from the run. This is applicable if the run generates base image dependencies. </param>
        /// <param name="task"> The task against which run was scheduled. </param>
        /// <param name="imageUpdateTrigger"> The image update trigger that caused the run. This is applicable if the task has base image trigger configured. </param>
        /// <param name="sourceTrigger"> The source trigger that caused the run. </param>
        /// <param name="timerTrigger"> The timer trigger that caused the run. </param>
        /// <param name="platform"> The platform properties against which the run will happen. </param>
        /// <param name="agentCpu"> The machine configuration of the run agent. </param>
        /// <param name="sourceRegistryAuth"> The scope of the credentials that were used to login to the source registry during this run. </param>
        /// <param name="customRegistries"> The list of custom registries that were logged in during this run. </param>
        /// <param name="runErrorMessage"> The error message received from backend systems after the run is scheduled. </param>
        /// <param name="updateTriggerToken"> The update trigger token passed for the Run. </param>
        /// <param name="logArtifact"> The image description for the log artifact. </param>
        /// <param name="provisioningState"> The provisioning state of a run. </param>
        /// <param name="isArchiveEnabled"> The value that indicates whether archiving is enabled or not. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryRunData"/> instance for mocking. </returns>
        public static ContainerRegistryRunData ContainerRegistryRunData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string runId = null, ContainerRegistryRunStatus? status = null, DateTimeOffset? lastUpdatedOn = null, ContainerRegistryRunType? runType = null, string agentPoolName = null, DateTimeOffset? createdOn = null, DateTimeOffset? startOn = null, DateTimeOffset? finishOn = null, IEnumerable<ContainerRegistryImageDescriptor> outputImages = null, string task = null, ContainerRegistryImageUpdateTrigger imageUpdateTrigger = null, ContainerRegistrySourceTriggerDescriptor sourceTrigger = null, ContainerRegistryTimerTriggerDescriptor timerTrigger = null, ContainerRegistryPlatformProperties platform = null, int? agentCpu = null, string sourceRegistryAuth = null, IEnumerable<string> customRegistries = null, string runErrorMessage = null, string updateTriggerToken = null, ContainerRegistryImageDescriptor logArtifact = null, ContainerRegistryProvisioningState? provisioningState = null, bool? isArchiveEnabled = null)
        {
            outputImages ??= new List<ContainerRegistryImageDescriptor>();
            customRegistries ??= new List<string>();

            return new ContainerRegistryRunData(id, name, resourceType, systemData, runId, status, lastUpdatedOn, runType, agentPoolName, createdOn, startOn, finishOn, outputImages?.ToList(), task, imageUpdateTrigger, sourceTrigger, timerTrigger, platform, agentCpu != null ? new ContainerRegistryAgentProperties(agentCpu) : null, sourceRegistryAuth, customRegistries?.ToList(), runErrorMessage, updateTriggerToken, logArtifact, provisioningState, isArchiveEnabled);
        }

        /// <summary> Initializes a new instance of SourceUploadDefinition. </summary>
        /// <param name="uploadUri"> The URL where the client can upload the source. </param>
        /// <param name="relativePath"> The relative path to the source. This is used to submit the subsequent queue build request. </param>
        /// <returns> A new <see cref="Models.SourceUploadDefinition"/> instance for mocking. </returns>
        public static SourceUploadDefinition SourceUploadDefinition(Uri uploadUri = null, string relativePath = null)
        {
            return new SourceUploadDefinition(uploadUri, relativePath);
        }

        /// <summary> Initializes a new instance of ContainerRegistryRunGetLogResult. </summary>
        /// <param name="logLink"> The link to logs for a run on a azure container registry. </param>
        /// <param name="logArtifactLink"> The link to logs in registry for a run on a azure container registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryRunGetLogResult"/> instance for mocking. </returns>
        public static ContainerRegistryRunGetLogResult ContainerRegistryRunGetLogResult(string logLink = null, string logArtifactLink = null)
        {
            return new ContainerRegistryRunGetLogResult(logLink, logArtifactLink);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTaskRunData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="identity"> Identity for the resource. </param>
        /// <param name="location"> The location of the resource. </param>
        /// <param name="provisioningState"> The provisioning state of this task run. </param>
        /// <param name="runRequest">
        /// The request (parameters) for the run
        /// Please note <see cref="ContainerRegistryRunContent"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ContainerRegistryDockerBuildContent"/>, <see cref="ContainerRegistryEncodedTaskRunContent"/>, <see cref="ContainerRegistryFileTaskRunContent"/> and <see cref="ContainerRegistryTaskRunContent"/>.
        /// </param>
        /// <param name="runResult"> The result of this task run. </param>
        /// <param name="forceUpdateTag"> How the run should be forced to rerun even if the run request configuration has not changed. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryTaskRunData"/> instance for mocking. </returns>
        public static ContainerRegistryTaskRunData ContainerRegistryTaskRunData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ManagedServiceIdentity identity = null, AzureLocation? location = null, ContainerRegistryProvisioningState? provisioningState = null, ContainerRegistryRunContent runRequest = null, ContainerRegistryRunData runResult = null, string forceUpdateTag = null)
        {
            return new ContainerRegistryTaskRunData(id, name, resourceType, systemData, identity, location, provisioningState, runRequest, runResult, forceUpdateTag);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTaskData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="identity"> Identity for the resource. </param>
        /// <param name="provisioningState"> The provisioning state of the task. </param>
        /// <param name="createdOn"> The creation date of task. </param>
        /// <param name="status"> The current status of task. </param>
        /// <param name="platform"> The platform properties against which the run has to happen. </param>
        /// <param name="agentCpu"> The machine configuration of the run agent. </param>
        /// <param name="agentPoolName"> The dedicated agent pool for the task. </param>
        /// <param name="timeoutInSeconds"> Run timeout in seconds. </param>
        /// <param name="step">
        /// The properties of a task step.
        /// Please note <see cref="ContainerRegistryTaskStepProperties"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ContainerRegistryDockerBuildStep"/>, <see cref="ContainerRegistryEncodedTaskStep"/> and <see cref="ContainerRegistryFileTaskStep"/>.
        /// </param>
        /// <param name="trigger"> The properties that describe all triggers for the task. </param>
        /// <param name="credentials"> The properties that describes a set of credentials that will be used when this run is invoked. </param>
        /// <param name="logTemplate"> The template that describes the repository and tag information for run log artifact. </param>
        /// <param name="isSystemTask"> The value of this property indicates whether the task resource is system task or not. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryTaskData"/> instance for mocking. </returns>
        public static ContainerRegistryTaskData ContainerRegistryTaskData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ManagedServiceIdentity identity = null, ContainerRegistryProvisioningState? provisioningState = null, DateTimeOffset? createdOn = null, ContainerRegistryTaskStatus? status = null, ContainerRegistryPlatformProperties platform = null, int? agentCpu = null, string agentPoolName = null, int? timeoutInSeconds = null, ContainerRegistryTaskStepProperties step = null, ContainerRegistryTriggerProperties trigger = null, ContainerRegistryCredentials credentials = null, string logTemplate = null, bool? isSystemTask = null)
        {
            tags ??= new Dictionary<string, string>();

            return new ContainerRegistryTaskData(id, name, resourceType, systemData, tags, location, identity, provisioningState, createdOn, status, platform, agentCpu != null ? new ContainerRegistryAgentProperties(agentCpu) : null, agentPoolName, timeoutInSeconds, step, trigger, credentials, logTemplate, isSystemTask);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTaskStepProperties. </summary>
        /// <param name="containerRegistryTaskStepType"> The type of the step. </param>
        /// <param name="baseImageDependencies"> List of base image dependencies for a step. </param>
        /// <param name="contextPath"> The URL(absolute or relative) of the source context for the task step. </param>
        /// <param name="contextAccessToken"> The token (git PAT or SAS token of storage account blob) associated with the context for a step. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTaskStepProperties"/> instance for mocking. </returns>
        public static ContainerRegistryTaskStepProperties ContainerRegistryTaskStepProperties(string containerRegistryTaskStepType = "Unknown", IEnumerable<ContainerRegistryBaseImageDependency> baseImageDependencies = null, string contextPath = null, string contextAccessToken = null)
        {
            baseImageDependencies ??= new List<ContainerRegistryBaseImageDependency>();

            return new UnknownTaskStepProperties(containerRegistryTaskStepType, baseImageDependencies?.ToList(), contextPath, contextAccessToken);
        }

        /// <summary> Initializes a new instance of ContainerRegistryBaseImageDependency. </summary>
        /// <param name="dependencyType"> The type of the base image dependency. </param>
        /// <param name="registry"> The registry login server. </param>
        /// <param name="repository"> The repository name. </param>
        /// <param name="tag"> The tag name. </param>
        /// <param name="digest"> The sha256-based digest of the image manifest. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryBaseImageDependency"/> instance for mocking. </returns>
        public static ContainerRegistryBaseImageDependency ContainerRegistryBaseImageDependency(ContainerRegistryBaseImageDependencyType? dependencyType = null, string registry = null, string repository = null, string tag = null, string digest = null)
        {
            return new ContainerRegistryBaseImageDependency(dependencyType, registry, repository, tag, digest);
        }

        /// <summary> Initializes a new instance of ContainerRegistryDockerBuildStep. </summary>
        /// <param name="baseImageDependencies"> List of base image dependencies for a step. </param>
        /// <param name="contextPath"> The URL(absolute or relative) of the source context for the task step. </param>
        /// <param name="contextAccessToken"> The token (git PAT or SAS token of storage account blob) associated with the context for a step. </param>
        /// <param name="imageNames"> The fully qualified image names including the repository and tag. </param>
        /// <param name="isPushEnabled"> The value of this property indicates whether the image built should be pushed to the registry or not. </param>
        /// <param name="noCache"> The value of this property indicates whether the image cache is enabled or not. </param>
        /// <param name="dockerFilePath"> The Docker file path relative to the source context. </param>
        /// <param name="target"> The name of the target build stage for the docker build. </param>
        /// <param name="arguments"> The collection of override arguments to be used when executing this build step. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryDockerBuildStep"/> instance for mocking. </returns>
        public static ContainerRegistryDockerBuildStep ContainerRegistryDockerBuildStep(IEnumerable<ContainerRegistryBaseImageDependency> baseImageDependencies = null, string contextPath = null, string contextAccessToken = null, IEnumerable<string> imageNames = null, bool? isPushEnabled = null, bool? noCache = null, string dockerFilePath = null, string target = null, IEnumerable<ContainerRegistryRunArgument> arguments = null)
        {
            baseImageDependencies ??= new List<ContainerRegistryBaseImageDependency>();
            imageNames ??= new List<string>();
            arguments ??= new List<ContainerRegistryRunArgument>();

            return new ContainerRegistryDockerBuildStep(ContainerRegistryTaskStepType.Docker, baseImageDependencies?.ToList(), contextPath, contextAccessToken, imageNames?.ToList(), isPushEnabled, noCache, dockerFilePath, target, arguments?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryFileTaskStep. </summary>
        /// <param name="baseImageDependencies"> List of base image dependencies for a step. </param>
        /// <param name="contextPath"> The URL(absolute or relative) of the source context for the task step. </param>
        /// <param name="contextAccessToken"> The token (git PAT or SAS token of storage account blob) associated with the context for a step. </param>
        /// <param name="taskFilePath"> The task template/definition file path relative to the source context. </param>
        /// <param name="valuesFilePath"> The task values/parameters file path relative to the source context. </param>
        /// <param name="values"> The collection of overridable values that can be passed when running a task. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryFileTaskStep"/> instance for mocking. </returns>
        public static ContainerRegistryFileTaskStep ContainerRegistryFileTaskStep(IEnumerable<ContainerRegistryBaseImageDependency> baseImageDependencies = null, string contextPath = null, string contextAccessToken = null, string taskFilePath = null, string valuesFilePath = null, IEnumerable<ContainerRegistryTaskOverridableValue> values = null)
        {
            baseImageDependencies ??= new List<ContainerRegistryBaseImageDependency>();
            values ??= new List<ContainerRegistryTaskOverridableValue>();

            return new ContainerRegistryFileTaskStep(ContainerRegistryTaskStepType.FileTask, baseImageDependencies?.ToList(), contextPath, contextAccessToken, taskFilePath, valuesFilePath, values?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryEncodedTaskStep. </summary>
        /// <param name="baseImageDependencies"> List of base image dependencies for a step. </param>
        /// <param name="contextPath"> The URL(absolute or relative) of the source context for the task step. </param>
        /// <param name="contextAccessToken"> The token (git PAT or SAS token of storage account blob) associated with the context for a step. </param>
        /// <param name="encodedTaskContent"> Base64 encoded value of the template/definition file content. </param>
        /// <param name="encodedValuesContent"> Base64 encoded value of the parameters/values file content. </param>
        /// <param name="values"> The collection of overridable values that can be passed when running a task. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryEncodedTaskStep"/> instance for mocking. </returns>
        public static ContainerRegistryEncodedTaskStep ContainerRegistryEncodedTaskStep(IEnumerable<ContainerRegistryBaseImageDependency> baseImageDependencies = null, string contextPath = null, string contextAccessToken = null, string encodedTaskContent = null, string encodedValuesContent = null, IEnumerable<ContainerRegistryTaskOverridableValue> values = null)
        {
            baseImageDependencies ??= new List<ContainerRegistryBaseImageDependency>();
            values ??= new List<ContainerRegistryTaskOverridableValue>();

            return new ContainerRegistryEncodedTaskStep(ContainerRegistryTaskStepType.EncodedTask, baseImageDependencies?.ToList(), contextPath, contextAccessToken, encodedTaskContent, encodedValuesContent, values?.ToList());
        }
    }
}
