// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure;
using Azure.Core;
using Azure.ResourceManager.ContainerRegistry;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.ContainerRegistry.Models
{
    /// <summary> A factory class for creating instances of the models for mocking. </summary>
    public static partial class ArmContainerRegistryModelFactory
    {

        /// <param name="origin"> The origin information of the container registry operation. </param>
        /// <param name="name"> Operation name: {provider}/{resource}/{operation}. </param>
        /// <param name="display"> The display information for the container registry operation. </param>
        /// <param name="serviceSpecification"> The definition of Azure Monitoring service. </param>
        /// <param name="isDataAction">
        /// This property indicates if the operation is an action or a data action
        /// ref: https://docs.microsoft.com/en-us/azure/role-based-access-control/role-definitions#management-and-data-operations
        /// </param>
        /// <returns> A new <see cref="Models.OperationDefinition"/> instance for mocking. </returns>
        public static OperationDefinition OperationDefinition(string origin = default, string name = default, OperationDisplayDefinition display = default, OperationServiceSpecificationDefinition serviceSpecification = default, bool? isDataAction = default)
        {
            return new OperationDefinition(
                origin,
                name,
                display,
                serviceSpecification is null ? default : new OperationPropertiesDefinition(serviceSpecification, null),
                isDataAction,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The display information for a container registry operation. </summary>
        /// <param name="provider"> The resource provider name: Microsoft.ContainerRegistry. </param>
        /// <param name="resource"> The resource on which the operation is performed. </param>
        /// <param name="operation"> The operation that users can perform. </param>
        /// <param name="description"> The description for the operation. </param>
        /// <returns> A new <see cref="Models.OperationDisplayDefinition"/> instance for mocking. </returns>
        public static OperationDisplayDefinition OperationDisplayDefinition(string provider = default, string resource = default, string operation = default, string description = default)
        {
            return new OperationDisplayDefinition(provider, resource, operation, description, additionalBinaryDataProperties: null);
        }

        /// <summary> The definition of Azure Monitoring list. </summary>
        /// <param name="metricSpecifications"> A list of Azure Monitoring metrics definition. </param>
        /// <param name="logSpecifications"> A list of Azure Monitoring log definitions. </param>
        /// <returns> A new <see cref="Models.OperationServiceSpecificationDefinition"/> instance for mocking. </returns>
        public static OperationServiceSpecificationDefinition OperationServiceSpecificationDefinition(IEnumerable<OperationMetricSpecificationDefinition> metricSpecifications = default, IEnumerable<OperationLogSpecificationDefinition> logSpecifications = default)
        {
            metricSpecifications ??= new ChangeTrackingList<OperationMetricSpecificationDefinition>();
            logSpecifications ??= new ChangeTrackingList<OperationLogSpecificationDefinition>();

            return new OperationServiceSpecificationDefinition(metricSpecifications.ToList(), logSpecifications.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The definition of Azure Monitoring metric. </summary>
        /// <param name="name"> Metric name. </param>
        /// <param name="displayName"> Metric display name. </param>
        /// <param name="displayDescription"> Metric description. </param>
        /// <param name="unit"> Metric unit. </param>
        /// <param name="aggregationType"> Metric aggregation type. </param>
        /// <param name="internalMetricName"> Internal metric name. </param>
        /// <returns> A new <see cref="Models.OperationMetricSpecificationDefinition"/> instance for mocking. </returns>
        public static OperationMetricSpecificationDefinition OperationMetricSpecificationDefinition(string name = default, string displayName = default, string displayDescription = default, string unit = default, string aggregationType = default, string internalMetricName = default)
        {
            return new OperationMetricSpecificationDefinition(
                name,
                displayName,
                displayDescription,
                unit,
                aggregationType,
                internalMetricName,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The definition of Azure Monitoring log. </summary>
        /// <param name="name"> Log name. </param>
        /// <param name="displayName"> Log display name. </param>
        /// <param name="blobDuration"> Log blob duration. </param>
        /// <returns> A new <see cref="Models.OperationLogSpecificationDefinition"/> instance for mocking. </returns>
        public static OperationLogSpecificationDefinition OperationLogSpecificationDefinition(string name = default, string displayName = default, string blobDuration = default)
        {
            return new OperationLogSpecificationDefinition(name, displayName, blobDuration, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="loginServer"> The URL that can be used to log into the container registry. </param>
        /// <param name="createdOn"> The creation date of the container registry in ISO8601 format. </param>
        /// <param name="provisioningState"> The provisioning state of the container registry at the time the operation was called. </param>
        /// <param name="status"> The status of the container registry at the time the operation was called. </param>
        /// <param name="adminUserEnabled"> The value that indicates whether the admin user is enabled. </param>
        /// <param name="networkRuleSet"> The network rule set for a container registry. </param>
        /// <param name="policies"> The policies for a container registry. </param>
        /// <param name="encryption"> The encryption settings of container registry. </param>
        /// <param name="dataEndpointEnabled"> Enable a single data endpoint per region for serving data. </param>
        /// <param name="dataEndpointHostNames"> List of host names that will serve data when dataEndpointEnabled is true. </param>
        /// <param name="privateEndpointConnections"> List of private endpoint connections for a container registry. </param>
        /// <param name="publicNetworkAccess"> Whether or not public network access is allowed for the container registry. </param>
        /// <param name="networkRuleBypassOptions"> Whether to allow trusted Azure services to access a network restricted registry. </param>
        /// <param name="networkRuleBypassAllowedForTasks"> Whether or not Tasks allowed to bypass the network rules for this container registry. </param>
        /// <param name="zoneRedundancy"> Whether or not zone redundancy is enabled for this container registry. </param>
        /// <param name="anonymousPullEnabled"> Enables registry-wide pull from unauthenticated clients. </param>
        /// <param name="metadataSearch"> Determines whether registry artifacts are indexed for metadata search. </param>
        /// <param name="autoGeneratedDomainNameLabelScope"> Determines the domain name label reuse scope. </param>
        /// <param name="roleAssignmentMode"> Determines registry role assignment mode. </param>
        /// <param name="sku"> The SKU of the container registry. </param>
        /// <param name="identity"> The identity of the container registry. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryData"/> instance for mocking. </returns>
        public static ContainerRegistryData ContainerRegistryData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, string loginServer = default, DateTimeOffset? createdOn = default, ContainerRegistryProvisioningState? provisioningState = default, ContainerRegistryResourceStatus status = default, bool? adminUserEnabled = default, ContainerRegistryNetworkRuleSet networkRuleSet = default, ContainerRegistryPolicies policies = default, ContainerRegistryEncryption encryption = default, bool? dataEndpointEnabled = default, IEnumerable<string> dataEndpointHostNames = default, IEnumerable<ContainerRegistryPrivateEndpointConnectionDataData> privateEndpointConnections = default, ContainerRegistryPublicNetworkAccess? publicNetworkAccess = default, ContainerRegistryNetworkRuleBypassOption? networkRuleBypassOptions = default, bool? networkRuleBypassAllowedForTasks = default, ContainerRegistryZoneRedundancy? zoneRedundancy = default, bool? anonymousPullEnabled = default, MetadataSearch? metadataSearch = default, AutoGeneratedDomainNameLabelScope? autoGeneratedDomainNameLabelScope = default, ContainerRegistryRoleAssignmentMode? roleAssignmentMode = default, ContainerRegistrySku sku = default, ManagedServiceIdentity identity = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ContainerRegistryData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                loginServer is null && createdOn is null && provisioningState is null && status is null && adminUserEnabled is null && networkRuleSet is null && policies is null && encryption is null && dataEndpointEnabled is null && dataEndpointHostNames is null && privateEndpointConnections is null && publicNetworkAccess is null && networkRuleBypassOptions is null && networkRuleBypassAllowedForTasks is null && zoneRedundancy is null && anonymousPullEnabled is null && metadataSearch is null && autoGeneratedDomainNameLabelScope is null && roleAssignmentMode is null ? default : new RegistryProperties(
                    loginServer,
                    createdOn,
                    provisioningState,
                    status,
                    adminUserEnabled,
                    networkRuleSet,
                    policies,
                    encryption,
                    dataEndpointEnabled,
                    (dataEndpointHostNames ?? new ChangeTrackingList<string>()).ToList(),
                    (privateEndpointConnections ?? new ChangeTrackingList<ContainerRegistryPrivateEndpointConnectionDataData>()).ToList(),
                    publicNetworkAccess,
                    networkRuleBypassOptions,
                    networkRuleBypassAllowedForTasks,
                    zoneRedundancy,
                    anonymousPullEnabled,
                    metadataSearch,
                    autoGeneratedDomainNameLabelScope,
                    roleAssignmentMode,
                    null),
                sku,
                identity);
        }

        /// <summary> The status of an Azure resource at the time the operation was called. </summary>
        /// <param name="displayStatus"> The short label for the status. </param>
        /// <param name="message"> The detailed message for the status, including alerts and error messages. </param>
        /// <param name="timestamp"> The timestamp when the status was changed to the current value. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryResourceStatus"/> instance for mocking. </returns>
        public static ContainerRegistryResourceStatus ContainerRegistryResourceStatus(string displayStatus = default, string message = default, DateTimeOffset? timestamp = default)
        {
            return new ContainerRegistryResourceStatus(displayStatus, message, timestamp, additionalBinaryDataProperties: null);
        }

        /// <summary> The network rule set for a container registry. </summary>
        /// <param name="defaultAction"> The default action of allow or deny when no other rules match. </param>
        /// <param name="ipRules"> The IP ACL rules. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryNetworkRuleSet"/> instance for mocking. </returns>
        public static ContainerRegistryNetworkRuleSet ContainerRegistryNetworkRuleSet(ContainerRegistryNetworkRuleDefaultAction defaultAction = default, IEnumerable<ContainerRegistryIPRule> ipRules = default)
        {
            ipRules ??= new ChangeTrackingList<ContainerRegistryIPRule>();

            return new ContainerRegistryNetworkRuleSet(defaultAction, ipRules.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The retention policy for a container registry. </summary>
        /// <param name="days"> The number of days to retain an untagged manifest after which it gets purged. </param>
        /// <param name="lastUpdatedOn"> The timestamp when the policy was last updated. </param>
        /// <param name="status"> The value that indicates whether the policy is enabled or not. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryRetentionPolicy"/> instance for mocking. </returns>
        public static ContainerRegistryRetentionPolicy ContainerRegistryRetentionPolicy(int? days = default, DateTimeOffset? lastUpdatedOn = default, ContainerRegistryPolicyStatus? status = default)
        {
            return new ContainerRegistryRetentionPolicy(days, lastUpdatedOn, status, additionalBinaryDataProperties: null);
        }

        /// <summary> The soft delete policy for a container registry. </summary>
        /// <param name="retentionDays"> The number of days after which a soft-deleted item is permanently deleted. </param>
        /// <param name="lastUpdatedOn"> The timestamp when the policy was last updated. </param>
        /// <param name="status"> The value that indicates whether the policy is enabled or not. </param>
        /// <returns> A new <see cref="Models.SoftDeletePolicy"/> instance for mocking. </returns>
        public static SoftDeletePolicy SoftDeletePolicy(int? retentionDays = default, DateTimeOffset? lastUpdatedOn = default, ContainerRegistryPolicyStatus? status = default)
        {
            return new SoftDeletePolicy(retentionDays, lastUpdatedOn, status, additionalBinaryDataProperties: null);
        }

        /// <summary> The ContainerRegistryKeyVaultProperties. </summary>
        /// <param name="keyIdentifier"> Key vault uri to access the encryption key. </param>
        /// <param name="versionedKeyIdentifier"> The fully qualified key identifier that includes the version of the key that is actually used for encryption. </param>
        /// <param name="identity"> The client id of the identity which will be used to access key vault. </param>
        /// <param name="isKeyRotationEnabled"> Auto key rotation status for a CMK enabled registry. </param>
        /// <param name="lastKeyRotationTimestamp"> Timestamp of the last successful key rotation. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryKeyVaultProperties"/> instance for mocking. </returns>
        public static ContainerRegistryKeyVaultProperties ContainerRegistryKeyVaultProperties(string keyIdentifier = default, string versionedKeyIdentifier = default, string identity = default, bool? isKeyRotationEnabled = default, DateTimeOffset? lastKeyRotationTimestamp = default)
        {
            return new ContainerRegistryKeyVaultProperties(
                keyIdentifier,
                versionedKeyIdentifier,
                identity,
                isKeyRotationEnabled,
                lastKeyRotationTimestamp,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a private endpoint connection for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of a private endpoint connection. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryPrivateEndpointConnectionDataData"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateEndpointConnectionDataData ContainerRegistryPrivateEndpointConnectionDataData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, PrivateEndpointConnectionProperties properties = default)
        {
            return new ContainerRegistryPrivateEndpointConnectionDataData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <param name="privateEndpointId"> This is private endpoint resource created with Microsoft.Network resource provider. </param>
        /// <param name="privateLinkServiceConnectionState"> A collection of information about the state of the connection between service consumer and provider. </param>
        /// <param name="provisioningState"> The provisioning state of private endpoint connection resource. </param>
        /// <returns> A new <see cref="Models.PrivateEndpointConnectionProperties"/> instance for mocking. </returns>
        public static PrivateEndpointConnectionProperties PrivateEndpointConnectionProperties(string privateEndpointId = default, ContainerRegistryPrivateLinkServiceConnectionState privateLinkServiceConnectionState = default, ContainerRegistryProvisioningState? provisioningState = default)
        {
            return new PrivateEndpointConnectionProperties(privateEndpointId is null ? default : new PrivateEndpoint(privateEndpointId, null), privateLinkServiceConnectionState, provisioningState, additionalBinaryDataProperties: null);
        }

        /// <summary> The SKU of a container registry. </summary>
        /// <param name="name"> The SKU name of the container registry. Required for registry creation. </param>
        /// <param name="tier"> The SKU tier based on the SKU name. </param>
        /// <returns> A new <see cref="Models.ContainerRegistrySku"/> instance for mocking. </returns>
        public static ContainerRegistrySku ContainerRegistrySku(ContainerRegistrySkuName name = default, ContainerRegistrySkuTier? tier = default)
        {
            return new ContainerRegistrySku(name, tier, additionalBinaryDataProperties: null);
        }

        /// <param name="identity"> The identity of the container registry. </param>
        /// <param name="tags"> The tags for the container registry. </param>
        /// <param name="sku"> The SKU of the container registry. </param>
        /// <param name="adminUserEnabled"> The value that indicates whether the admin user is enabled. </param>
        /// <param name="networkRuleSet"> The network rule set for a container registry. </param>
        /// <param name="policies"> The policies for a container registry. </param>
        /// <param name="encryption"> The encryption settings of container registry. </param>
        /// <param name="dataEndpointEnabled"> Enable a single data endpoint per region for serving data. </param>
        /// <param name="publicNetworkAccess"> Whether or not public network access is allowed for the container registry. </param>
        /// <param name="networkRuleBypassOptions"> Whether to allow trusted Azure services to access a network restricted registry. </param>
        /// <param name="networkRuleBypassAllowedForTasks"> Whether to allow ACR Tasks service to access a network restricted registry. </param>
        /// <param name="anonymousPullEnabled"> Enables registry-wide pull from unauthenticated clients. </param>
        /// <param name="metadataSearch"> Determines whether registry artifacts are indexed for metadata search. </param>
        /// <param name="roleAssignmentMode"> Determines registry role assignment mode. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPatch"/> instance for mocking. </returns>
        public static ContainerRegistryPatch ContainerRegistryPatch(IdentityProperties identity = default, IDictionary<string, string> tags = default, ContainerRegistrySku sku = default, bool? adminUserEnabled = default, ContainerRegistryNetworkRuleSet networkRuleSet = default, ContainerRegistryPolicies policies = default, ContainerRegistryEncryption encryption = default, bool? dataEndpointEnabled = default, ContainerRegistryPublicNetworkAccess? publicNetworkAccess = default, ContainerRegistryNetworkRuleBypassOption? networkRuleBypassOptions = default, bool? networkRuleBypassAllowedForTasks = default, bool? anonymousPullEnabled = default, MetadataSearch? metadataSearch = default, ContainerRegistryRoleAssignmentMode? roleAssignmentMode = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ContainerRegistryPatch(identity, tags, sku, adminUserEnabled is null && networkRuleSet is null && policies is null && encryption is null && dataEndpointEnabled is null && publicNetworkAccess is null && networkRuleBypassOptions is null && networkRuleBypassAllowedForTasks is null && anonymousPullEnabled is null && metadataSearch is null && roleAssignmentMode is null ? default : new RegistryPropertiesUpdateParameters(
                adminUserEnabled,
                networkRuleSet,
                policies,
                encryption,
                dataEndpointEnabled,
                publicNetworkAccess,
                networkRuleBypassOptions,
                networkRuleBypassAllowedForTasks,
                anonymousPullEnabled,
                metadataSearch,
                roleAssignmentMode,
                null), additionalBinaryDataProperties: null);
        }

        /// <summary> Managed identity for the resource. </summary>
        /// <param name="principalId"> The principal ID of resource identity. </param>
        /// <param name="tenantId"> The tenant ID of resource. </param>
        /// <param name="type"> The identity type. </param>
        /// <param name="userAssignedIdentities">
        /// The list of user identities associated with the resource. The user identity
        /// dictionary key references will be ARM resource ids in the form:
        /// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/
        /// providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
        /// </param>
        /// <returns> A new <see cref="Models.IdentityProperties"/> instance for mocking. </returns>
        public static IdentityProperties IdentityProperties(string principalId = default, string tenantId = default, ResourceIdentityType? @type = default, IDictionary<string, UserIdentityProperties> userAssignedIdentities = default)
        {
            userAssignedIdentities ??= new ChangeTrackingDictionary<string, UserIdentityProperties>();

            return new IdentityProperties(principalId, tenantId, @type, userAssignedIdentities, additionalBinaryDataProperties: null);
        }

        /// <summary> The UserIdentityProperties. </summary>
        /// <param name="principalId"> The principal id of user assigned identity. </param>
        /// <param name="clientId"> The client id of user assigned identity. </param>
        /// <returns> A new <see cref="Models.UserIdentityProperties"/> instance for mocking. </returns>
        public static UserIdentityProperties UserIdentityProperties(string principalId = default, string clientId = default)
        {
            return new UserIdentityProperties(principalId, clientId, additionalBinaryDataProperties: null);
        }

        /// <summary> The ContainerRegistryImportImageParameters. </summary>
        /// <param name="source"> The source of the image. </param>
        /// <param name="targetTags"> List of strings of the form repo[:tag]. When tag is omitted the source will be used (or 'latest' if source tag is also omitted). </param>
        /// <param name="untaggedTargetRepositories"> List of strings of repository names to do a manifest only copy. No tag will be created. </param>
        /// <param name="mode"> When Force, any existing target tags will be overwritten. When NoForce, any existing target tags will fail the operation before any copying begins. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryImportImageParameters"/> instance for mocking. </returns>
        public static ContainerRegistryImportImageParameters ContainerRegistryImportImageParameters(ContainerRegistryImportSource source = default, IEnumerable<string> targetTags = default, IEnumerable<string> untaggedTargetRepositories = default, ContainerRegistryImportMode? mode = default)
        {
            targetTags ??= new ChangeTrackingList<string>();
            untaggedTargetRepositories ??= new ChangeTrackingList<string>();

            return new ContainerRegistryImportImageParameters(source, targetTags.ToList(), untaggedTargetRepositories.ToList(), mode, additionalBinaryDataProperties: null);
        }

        /// <summary> The ContainerRegistryImportSource. </summary>
        /// <param name="resourceId"> The resource identifier of the source Azure Container Registry. </param>
        /// <param name="registryAddress"> The address of the source registry (e.g. 'mcr.microsoft.com'). </param>
        /// <param name="credentials"> Credentials used when importing from a registry uri. </param>
        /// <param name="sourceImage">
        /// Repository name of the source image.
        /// Specify an image by repository ('hello-world'). This will use the 'latest' tag.
        /// Specify an image by tag ('hello-world:latest').
        /// Specify an image by sha256-based manifest digest ('hello-world@sha256:abc123').
        /// </param>
        /// <returns> A new <see cref="Models.ContainerRegistryImportSource"/> instance for mocking. </returns>
        public static ContainerRegistryImportSource ContainerRegistryImportSource(string resourceId = default, string registryAddress = default, ContainerRegistryImportSourceCredentials credentials = default, string sourceImage = default)
        {
            return new ContainerRegistryImportSource(resourceId, registryAddress, credentials, sourceImage, additionalBinaryDataProperties: null);
        }

        /// <summary> The ContainerRegistryImportSourceCredentials. </summary>
        /// <param name="username"> The username to authenticate with the source registry. </param>
        /// <param name="password"> The password used to authenticate with the source registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryImportSourceCredentials"/> instance for mocking. </returns>
        public static ContainerRegistryImportSourceCredentials ContainerRegistryImportSourceCredentials(string username = default, string password = default)
        {
            return new ContainerRegistryImportSourceCredentials(username, password, additionalBinaryDataProperties: null);
        }

        /// <summary> The result of a request to get container registry quota usages. </summary>
        /// <param name="value"> The list of container registry quota usages. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryUsageListResult"/> instance for mocking. </returns>
        public static ContainerRegistryUsageListResult ContainerRegistryUsageListResult(IEnumerable<ContainerRegistryUsage> value = default)
        {
            value ??= new ChangeTrackingList<ContainerRegistryUsage>();

            return new ContainerRegistryUsageListResult(value.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The quota usage for a container registry. </summary>
        /// <param name="name"> The name of the usage. </param>
        /// <param name="limit"> The limit of the usage. </param>
        /// <param name="currentValue"> The current value of the usage. </param>
        /// <param name="unit"> The unit of measurement. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryUsage"/> instance for mocking. </returns>
        public static ContainerRegistryUsage ContainerRegistryUsage(string name = default, long? limit = default, long? currentValue = default, ContainerRegistryUsageUnit? unit = default)
        {
            return new ContainerRegistryUsage(name, limit, currentValue, unit, additionalBinaryDataProperties: null);
        }

        /// <summary> The response from the ListCredentials operation. </summary>
        /// <param name="username"> The username for a container registry. </param>
        /// <param name="passwords"> The list of passwords for a container registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryListCredentialsResult"/> instance for mocking. </returns>
        public static ContainerRegistryListCredentialsResult ContainerRegistryListCredentialsResult(string username = default, IEnumerable<ContainerRegistryPassword> passwords = default)
        {
            passwords ??= new ChangeTrackingList<ContainerRegistryPassword>();

            return new ContainerRegistryListCredentialsResult(username, passwords.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The login password for the container registry. </summary>
        /// <param name="name"> The password name. </param>
        /// <param name="value"> The password value. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPassword"/> instance for mocking. </returns>
        public static ContainerRegistryPassword ContainerRegistryPassword(ContainerRegistryPasswordName? name = default, string value = default)
        {
            return new ContainerRegistryPassword(name, value, additionalBinaryDataProperties: null);
        }

        /// <summary> The parameters used to regenerate the login credential. </summary>
        /// <param name="name"> Specifies name of the password which should be regenerated -- password or password2. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryCredentialRegenerateContent"/> instance for mocking. </returns>
        public static ContainerRegistryCredentialRegenerateContent ContainerRegistryCredentialRegenerateContent(ContainerRegistryPasswordName name = default)
        {
            return new ContainerRegistryCredentialRegenerateContent(name, additionalBinaryDataProperties: null);
        }

        /// <summary> The response from the GenerateCredentials operation. </summary>
        /// <param name="username"> The username for a container registry. </param>
        /// <param name="passwords"> The list of passwords for a container registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryGenerateCredentialsResult"/> instance for mocking. </returns>
        public static ContainerRegistryGenerateCredentialsResult ContainerRegistryGenerateCredentialsResult(string username = default, IEnumerable<ContainerRegistryTokenPassword> passwords = default)
        {
            passwords ??= new ChangeTrackingList<ContainerRegistryTokenPassword>();

            return new ContainerRegistryGenerateCredentialsResult(username, passwords.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> The password that will be used for authenticating the token of a container registry. </summary>
        /// <param name="createdOn"> The creation datetime of the password. </param>
        /// <param name="expiry"> The expiry datetime of the password. </param>
        /// <param name="name"> The password name "password1" or "password2". </param>
        /// <param name="value"> The password value. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTokenPassword"/> instance for mocking. </returns>
        public static ContainerRegistryTokenPassword ContainerRegistryTokenPassword(DateTimeOffset? createdOn = default, DateTimeOffset? expiry = default, ContainerRegistryTokenPasswordName? name = default, string value = default)
        {
            return new ContainerRegistryTokenPassword(createdOn, expiry, name, value, additionalBinaryDataProperties: null);
        }

        /// <summary> A request to check whether a container registry name is available. </summary>
        /// <param name="name"> The name of the container registry. </param>
        /// <param name="type"> The resource type of the container registry. This field must be set to 'Microsoft.ContainerRegistry/registries'. </param>
        /// <param name="resourceGroupName"> The resource group name of the container registry. </param>
        /// <param name="autoGeneratedDomainNameLabelScope"> The auto generated domain name label of the container registry. This value defaults to "Unsecure". </param>
        /// <returns> A new <see cref="Models.ContainerRegistryNameAvailabilityContent"/> instance for mocking. </returns>
        public static ContainerRegistryNameAvailabilityContent ContainerRegistryNameAvailabilityContent(string name = default, ContainerRegistryResourceType @type = default, string resourceGroupName = default, AutoGeneratedDomainNameLabelScope? autoGeneratedDomainNameLabelScope = default)
        {
            return new ContainerRegistryNameAvailabilityContent(name, @type, resourceGroupName, autoGeneratedDomainNameLabelScope, additionalBinaryDataProperties: null);
        }

        /// <summary> The result of a request to check the availability of a container registry name. </summary>
        /// <param name="availableLoginServerName"> The complete login server name with domain name label (DNL) hash, if available. </param>
        /// <param name="isNameAvailable"> The value that indicates whether the name is available. </param>
        /// <param name="reason"> If any, the reason that the name is not available. </param>
        /// <param name="message"> If any, the error message that provides more detail for the reason that the name is not available. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryNameAvailableResult"/> instance for mocking. </returns>
        public static ContainerRegistryNameAvailableResult ContainerRegistryNameAvailableResult(string availableLoginServerName = default, bool? isNameAvailable = default, string reason = default, string message = default)
        {
            return new ContainerRegistryNameAvailableResult(availableLoginServerName, isNameAvailable, reason, message, additionalBinaryDataProperties: null);
        }

        /// <summary> A private link resource. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> A resource that supports private link capabilities. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPrivateLinkResource"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateLinkResource ContainerRegistryPrivateLinkResource(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ContainerRegistryPrivateLinkResourceProperties properties = default)
        {
            return new ContainerRegistryPrivateLinkResource(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> Properties of a private link resource. </summary>
        /// <param name="groupId"> The private link resource group id. </param>
        /// <param name="requiredMembers"> The private link resource required member names. </param>
        /// <param name="requiredZoneNames"> The private link resource private link DNS zone name. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPrivateLinkResourceProperties"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateLinkResourceProperties ContainerRegistryPrivateLinkResourceProperties(string groupId = default, IEnumerable<string> requiredMembers = default, IEnumerable<string> requiredZoneNames = default)
        {
            requiredMembers ??= new ChangeTrackingList<string>();
            requiredZoneNames ??= new ChangeTrackingList<string>();

            return new ContainerRegistryPrivateLinkResourceProperties(groupId, requiredMembers.ToList(), requiredZoneNames.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a archive for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the archive. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryArchiveData"/> instance for mocking. </returns>
        public static ContainerRegistryArchiveData ContainerRegistryArchiveData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ArchiveProperties properties = default)
        {
            return new ContainerRegistryArchiveData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> The properties of a archive. </summary>
        /// <param name="packageSource"> The package source of the archive. </param>
        /// <param name="publishedVersion"> The published version of the archive. </param>
        /// <param name="repositoryEndpointPrefix"></param>
        /// <param name="repositoryEndpoint"></param>
        /// <param name="provisioningState"> The provisioning state of the archive at the time the operation was called. </param>
        /// <returns> A new <see cref="Models.ArchiveProperties"/> instance for mocking. </returns>
        public static ArchiveProperties ArchiveProperties(ArchivePackageSourceProperties packageSource = default, string publishedVersion = default, string repositoryEndpointPrefix = default, string repositoryEndpoint = default, ContainerRegistryProvisioningState? provisioningState = default)
        {
            return new ArchiveProperties(
                packageSource,
                publishedVersion,
                repositoryEndpointPrefix,
                repositoryEndpoint,
                provisioningState,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents an export pipeline for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the archive. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryArchiveVersionData"/> instance for mocking. </returns>
        public static ContainerRegistryArchiveVersionData ContainerRegistryArchiveVersionData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ArchiveVersionProperties properties = default)
        {
            return new ContainerRegistryArchiveVersionData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> The properties of an archive version. </summary>
        /// <param name="provisioningState"> The provisioning state of the archive at the time the operation was called. </param>
        /// <param name="archiveVersionErrorMessage"> The detailed error message for the archive version in the case of failure. </param>
        /// <returns> A new <see cref="Models.ArchiveVersionProperties"/> instance for mocking. </returns>
        public static ArchiveVersionProperties ArchiveVersionProperties(ContainerRegistryProvisioningState? provisioningState = default, string archiveVersionErrorMessage = default)
        {
            return new ArchiveVersionProperties(provisioningState, archiveVersionErrorMessage, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="credentialSetResourceId"> The ARM resource ID of the credential store which is associated with the cache rule. </param>
        /// <param name="sourceRepository"> Source repository pulled from upstream. </param>
        /// <param name="targetRepository">
        /// Target repository specified in docker pull command.
        /// Eg: docker pull myregistry.azurecr.io/{targetRepository}:{tag}
        /// </param>
        /// <param name="createdOn"> The creation date of the cache rule. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryCacheRuleData"/> instance for mocking. </returns>
        public static ContainerRegistryCacheRuleData ContainerRegistryCacheRuleData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, string credentialSetResourceId = default, string sourceRepository = default, string targetRepository = default, DateTimeOffset? createdOn = default, ContainerRegistryProvisioningState? provisioningState = default)
        {
            return new ContainerRegistryCacheRuleData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                credentialSetResourceId is null && sourceRepository is null && targetRepository is null && createdOn is null && provisioningState is null ? default : new CacheRuleProperties(
                    credentialSetResourceId,
                    sourceRepository,
                    targetRepository,
                    createdOn,
                    provisioningState,
                    null));
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="loginServer"> The credentials are stored for this upstream or login server. </param>
        /// <param name="authCredentials">
        /// List of authentication credentials stored for an upstream.
        /// Usually consists of a primary and an optional secondary credential.
        /// </param>
        /// <param name="createdOn"> The creation date of credential store resource. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="identity"> Identities associated with the resource. This is used to access the KeyVault secrets. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryCredentialSetData"/> instance for mocking. </returns>
        public static ContainerRegistryCredentialSetData ContainerRegistryCredentialSetData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, string loginServer = default, IEnumerable<ContainerRegistryAuthCredential> authCredentials = default, DateTimeOffset? createdOn = default, ContainerRegistryProvisioningState? provisioningState = default, ManagedServiceIdentity identity = default)
        {
            return new ContainerRegistryCredentialSetData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                loginServer is null && authCredentials is null && createdOn is null && provisioningState is null ? default : new CredentialSetProperties(loginServer, (authCredentials ?? new ChangeTrackingList<ContainerRegistryAuthCredential>()).ToList(), createdOn, provisioningState, null),
                identity);
        }

        /// <summary> Authentication credential stored for an upstream. </summary>
        /// <param name="name"> The name of the credential. </param>
        /// <param name="usernameSecretIdentifier"> KeyVault Secret URI for accessing the username. </param>
        /// <param name="passwordSecretIdentifier"> KeyVault Secret URI for accessing the password. </param>
        /// <param name="credentialHealth"> This provides data pertaining to the health of the auth credential. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryAuthCredential"/> instance for mocking. </returns>
        public static ContainerRegistryAuthCredential ContainerRegistryAuthCredential(ContainerRegistryCredentialName? name = default, string usernameSecretIdentifier = default, string passwordSecretIdentifier = default, ContainerRegistryCredentialHealth credentialHealth = default)
        {
            return new ContainerRegistryAuthCredential(name, usernameSecretIdentifier, passwordSecretIdentifier, credentialHealth, additionalBinaryDataProperties: null);
        }

        /// <summary> The health of the auth credential. </summary>
        /// <param name="status"> The health status of credential. </param>
        /// <param name="errorCode"> Error code representing the health check error. </param>
        /// <param name="errorMessage"> Descriptive message representing the health check error. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryCredentialHealth"/> instance for mocking. </returns>
        public static ContainerRegistryCredentialHealth ContainerRegistryCredentialHealth(ContainerRegistryCredentialHealthStatus? status = default, string errorCode = default, string errorMessage = default)
        {
            return new ContainerRegistryCredentialHealth(status, errorCode, errorMessage, additionalBinaryDataProperties: null);
        }

        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="mode"> The mode of the connected registry resource that indicates the permissions of the registry. </param>
        /// <param name="version"> The current version of ACR runtime on the connected registry. </param>
        /// <param name="connectionState"> The current connection state of the connected registry. </param>
        /// <param name="lastActivityOn"> The last activity time of the connected registry. </param>
        /// <param name="parent"> The parent of the connected registry. </param>
        /// <param name="clientTokenIds"> The list of the ACR token resource IDs used to authenticate clients to the connected registry. </param>
        /// <param name="loginServer"> The login server properties of the connected registry. </param>
        /// <param name="logging"> The logging properties of the connected registry. </param>
        /// <param name="statusDetails"> The list of current statuses of the connected registry. </param>
        /// <param name="notificationsList"> The list of notifications subscription information for the connected registry. </param>
        /// <param name="garbageCollection"> The garbage collection properties of the connected registry. </param>
        /// <param name="activationStatus"> The activation status of the connected registry. </param>
        /// <returns> A new <see cref="ContainerRegistry.ConnectedRegistryData"/> instance for mocking. </returns>
        public static ConnectedRegistryData ConnectedRegistryData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ContainerRegistryProvisioningState? provisioningState = default, ConnectedRegistryMode? mode = default, string version = default, ConnectedRegistryConnectionState? connectionState = default, DateTimeOffset? lastActivityOn = default, ConnectedRegistryParent parent = default, IEnumerable<ResourceIdentifier> clientTokenIds = default, ConnectedRegistryLoginServer loginServer = default, ConnectedRegistryLogging logging = default, IEnumerable<ConnectedRegistryStatusDetail> statusDetails = default, IEnumerable<string> notificationsList = default, GarbageCollectionProperties garbageCollection = default, ConnectedRegistryActivationStatus? activationStatus = default)
        {
            return new ConnectedRegistryData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                provisioningState is null && mode is null && version is null && connectionState is null && lastActivityOn is null && parent is null && clientTokenIds is null && loginServer is null && logging is null && statusDetails is null && notificationsList is null && garbageCollection is null && activationStatus is null ? default : new ConnectedRegistryProperties(
                    provisioningState,
                    mode.Value,
                    version,
                    connectionState,
                    lastActivityOn,
                    new ConnectedRegistryActivation(activationStatus, null),
                    parent,
                    (clientTokenIds ?? new ChangeTrackingList<ResourceIdentifier>()).ToList(),
                    loginServer,
                    logging,
                    (statusDetails ?? new ChangeTrackingList<ConnectedRegistryStatusDetail>()).ToList(),
                    (notificationsList ?? new ChangeTrackingList<string>()).ToList(),
                    garbageCollection,
                    null));
        }

        /// <summary> The sync properties of the connected registry with its parent. </summary>
        /// <param name="tokenId"> The resource ID of the ACR token used to authenticate the connected registry to its parent during sync. </param>
        /// <param name="schedule"> The cron expression indicating the schedule that the connected registry will sync with its parent. </param>
        /// <param name="syncWindow"> The time window during which sync is enabled for each schedule occurrence. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601. </param>
        /// <param name="messageTtl"> The period of time for which a message is available to sync before it is expired. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601. </param>
        /// <param name="lastSyncOn"> The last time a sync occurred between the connected registry and its parent. </param>
        /// <param name="gatewayEndpoint"> The gateway endpoint used by the connected registry to communicate with its parent. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistrySyncProperties"/> instance for mocking. </returns>
        public static ConnectedRegistrySyncProperties ConnectedRegistrySyncProperties(string tokenId = default, string schedule = default, TimeSpan? syncWindow = default, TimeSpan messageTtl = default, DateTimeOffset? lastSyncOn = default, string gatewayEndpoint = default)
        {
            return new ConnectedRegistrySyncProperties(
                tokenId,
                schedule,
                syncWindow,
                messageTtl,
                lastSyncOn,
                gatewayEndpoint,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The login server properties of the connected registry. </summary>
        /// <param name="host"> The host of the connected registry. Can be FQDN or IP. </param>
        /// <param name="tls"> The TLS properties of the connected registry login server. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistryLoginServer"/> instance for mocking. </returns>
        public static ConnectedRegistryLoginServer ConnectedRegistryLoginServer(string host = default, ContainerRegistryTlsProperties tls = default)
        {
            return new ConnectedRegistryLoginServer(host, tls, additionalBinaryDataProperties: null);
        }

        /// <summary> The TLS properties of the connected registry login server. </summary>
        /// <param name="status"> Indicates whether HTTPS is enabled for the login server. </param>
        /// <param name="certificate"> The certificate used to configure HTTPS for the login server. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTlsProperties"/> instance for mocking. </returns>
        public static ContainerRegistryTlsProperties ContainerRegistryTlsProperties(ContainerRegistryTlsStatus? status = default, ContainerRegistryTlsCertificateProperties certificate = default)
        {
            return new ContainerRegistryTlsProperties(status, certificate, additionalBinaryDataProperties: null);
        }

        /// <summary> The TLS certificate properties of the connected registry login server. </summary>
        /// <param name="type"> The type of certificate location. </param>
        /// <param name="certificateLocation"> Indicates the location of the certificates. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTlsCertificateProperties"/> instance for mocking. </returns>
        public static ContainerRegistryTlsCertificateProperties ContainerRegistryTlsCertificateProperties(ContainerRegistryCertificateType? @type = default, string certificateLocation = default)
        {
            return new ContainerRegistryTlsCertificateProperties(@type, certificateLocation, additionalBinaryDataProperties: null);
        }

        /// <summary> The status detail properties of the connected registry. </summary>
        /// <param name="statusDetailType"> The component of the connected registry corresponding to the status. </param>
        /// <param name="code"> The HTTP status code. </param>
        /// <param name="description"> The description of the status. </param>
        /// <param name="timestamp"> The timestamp of the status. </param>
        /// <param name="correlationId"> The correlation ID of the status. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistryStatusDetail"/> instance for mocking. </returns>
        public static ConnectedRegistryStatusDetail ConnectedRegistryStatusDetail(string statusDetailType = default, string code = default, string description = default, DateTimeOffset? timestamp = default, string correlationId = default)
        {
            return new ConnectedRegistryStatusDetail(
                statusDetailType,
                code,
                description,
                timestamp,
                correlationId,
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a replication for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The properties of the replication. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryReplicationData"/> instance for mocking. </returns>
        public static ContainerRegistryReplicationData ContainerRegistryReplicationData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, ReplicationProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ContainerRegistryReplicationData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties);
        }

        /// <summary> The properties of a replication. </summary>
        /// <param name="provisioningState"> The provisioning state of the replication at the time the operation was called. </param>
        /// <param name="status"> The status of the replication at the time the operation was called. </param>
        /// <param name="regionEndpointEnabled"> Specifies whether the replication's regional endpoint is enabled. Requests will not be routed to a replication whose regional endpoint is disabled, however its data will continue to be synced with other replications. </param>
        /// <param name="zoneRedundancy"> Whether or not zone redundancy is enabled for this container registry replication. </param>
        /// <returns> A new <see cref="Models.ReplicationProperties"/> instance for mocking. </returns>
        public static ReplicationProperties ReplicationProperties(ContainerRegistryProvisioningState? provisioningState = default, ContainerRegistryResourceStatus status = default, bool? regionEndpointEnabled = default, ContainerRegistryZoneRedundancy? zoneRedundancy = default)
        {
            return new ReplicationProperties(provisioningState, status, regionEndpointEnabled, zoneRedundancy, additionalBinaryDataProperties: null);
        }

        /// <param name="tags"> The tags for the replication. </param>
        /// <param name="regionEndpointEnabled"> Specifies whether the replication's regional endpoint is enabled. Requests will not be routed to a replication whose regional endpoint is disabled, however its data will continue to be synced with other replications. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryReplicationPatch"/> instance for mocking. </returns>
        public static ContainerRegistryReplicationPatch ContainerRegistryReplicationPatch(IDictionary<string, string> tags = default, bool? regionEndpointEnabled = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ContainerRegistryReplicationPatch(tags, regionEndpointEnabled is null ? default : new ReplicationUpdateParametersProperties(regionEndpointEnabled, null), additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a scope map for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the scope map. </param>
        /// <returns> A new <see cref="ContainerRegistry.ScopeMapData"/> instance for mocking. </returns>
        public static ScopeMapData ScopeMapData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ScopeMapProperties properties = default)
        {
            return new ScopeMapData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> The properties of a scope map. </summary>
        /// <param name="description"> The user friendly description of the scope map. </param>
        /// <param name="type"> The type of the scope map. E.g. BuildIn scope map. </param>
        /// <param name="createdOn"> The creation date of scope map. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="actions">
        /// The list of scoped permissions for registry artifacts.
        /// E.g. repositories/repository-name/content/read,
        /// repositories/repository-name/metadata/write
        /// </param>
        /// <returns> A new <see cref="Models.ScopeMapProperties"/> instance for mocking. </returns>
        public static ScopeMapProperties ScopeMapProperties(string description = default, string @type = default, DateTimeOffset? createdOn = default, ContainerRegistryProvisioningState? provisioningState = default, IEnumerable<string> actions = default)
        {
            actions ??= new ChangeTrackingList<string>();

            return new ScopeMapProperties(
                description,
                @type,
                createdOn,
                provisioningState,
                actions.ToList(),
                additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a token for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the token. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryTokenData"/> instance for mocking. </returns>
        public static ContainerRegistryTokenData ContainerRegistryTokenData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, TokenProperties properties = default)
        {
            return new ContainerRegistryTokenData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> The properties of a token. </summary>
        /// <param name="createdOn"> The creation date of scope map. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="scopeMapId"> The resource ID of the scope map to which the token will be associated with. </param>
        /// <param name="credentials"> The credentials that can be used for authenticating the token. </param>
        /// <param name="status"> The status of the token example enabled or disabled. </param>
        /// <returns> A new <see cref="Models.TokenProperties"/> instance for mocking. </returns>
        public static TokenProperties TokenProperties(DateTimeOffset? createdOn = default, ContainerRegistryProvisioningState? provisioningState = default, string scopeMapId = default, ContainerRegistryTokenCredentials credentials = default, ContainerRegistryTokenStatus? status = default)
        {
            return new TokenProperties(
                createdOn,
                provisioningState,
                scopeMapId,
                credentials,
                status,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The properties of the credentials that can be used for authenticating the token. </summary>
        /// <param name="certificates"></param>
        /// <param name="passwords"></param>
        /// <returns> A new <see cref="Models.ContainerRegistryTokenCredentials"/> instance for mocking. </returns>
        public static ContainerRegistryTokenCredentials ContainerRegistryTokenCredentials(IEnumerable<ContainerRegistryTokenCertificate> certificates = default, IEnumerable<ContainerRegistryTokenPassword> passwords = default)
        {
            certificates ??= new ChangeTrackingList<ContainerRegistryTokenCertificate>();
            passwords ??= new ChangeTrackingList<ContainerRegistryTokenPassword>();

            return new ContainerRegistryTokenCredentials(certificates.ToList(), passwords.ToList(), additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents an export pipeline for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the export pipeline. </param>
        /// <param name="location"> The location of the export pipeline. </param>
        /// <param name="identity"> The identity of the export pipeline. </param>
        /// <returns> A new <see cref="ContainerRegistry.ExportPipelineData"/> instance for mocking. </returns>
        public static ExportPipelineData ExportPipelineData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ExportPipelineProperties properties = default, string location = default, IdentityProperties identity = default)
        {
            return new ExportPipelineData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties,
                location,
                identity);
        }

        /// <summary> The properties of an export pipeline. </summary>
        /// <param name="target"> The target properties of the export pipeline. </param>
        /// <param name="options"> The list of all options configured for the pipeline. </param>
        /// <param name="provisioningState"> The provisioning state of the pipeline at the time the operation was called. </param>
        /// <returns> A new <see cref="Models.ExportPipelineProperties"/> instance for mocking. </returns>
        public static ExportPipelineProperties ExportPipelineProperties(ExportPipelineTargetProperties target = default, IEnumerable<PipelineOptions> options = default, ContainerRegistryProvisioningState? provisioningState = default)
        {
            options ??= new ChangeTrackingList<PipelineOptions>();

            return new ExportPipelineProperties(target, options.ToList(), provisioningState, additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents an import pipeline for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of the import pipeline. </param>
        /// <param name="location"> The location of the import pipeline. </param>
        /// <param name="identity"> The identity of the import pipeline. </param>
        /// <returns> A new <see cref="ContainerRegistry.ImportPipelineData"/> instance for mocking. </returns>
        public static ImportPipelineData ImportPipelineData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, ImportPipelineProperties properties = default, string location = default, IdentityProperties identity = default)
        {
            return new ImportPipelineData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties,
                location,
                identity);
        }

        /// <summary> The properties of an import pipeline. </summary>
        /// <param name="source"> The source properties of the import pipeline. </param>
        /// <param name="trigger"> The properties that describe the trigger of the import pipeline. </param>
        /// <param name="options"> The list of all options configured for the pipeline. </param>
        /// <param name="provisioningState"> The provisioning state of the pipeline at the time the operation was called. </param>
        /// <returns> A new <see cref="Models.ImportPipelineProperties"/> instance for mocking. </returns>
        public static ImportPipelineProperties ImportPipelineProperties(ImportPipelineSourceProperties source = default, PipelineTriggerProperties trigger = default, IEnumerable<PipelineOptions> options = default, ContainerRegistryProvisioningState? provisioningState = default)
        {
            options ??= new ChangeTrackingList<PipelineOptions>();

            return new ImportPipelineProperties(source, trigger, options.ToList(), provisioningState, additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a pipeline run for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="properties"> The properties of a pipeline run. </param>
        /// <returns> A new <see cref="ContainerRegistry.PipelineRunData"/> instance for mocking. </returns>
        public static PipelineRunData PipelineRunData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, PipelineRunProperties properties = default)
        {
            return new PipelineRunData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                properties);
        }

        /// <summary> The properties of a pipeline run. </summary>
        /// <param name="provisioningState"> The provisioning state of a pipeline run. </param>
        /// <param name="request"> The request parameters for a pipeline run. </param>
        /// <param name="response"> The response of a pipeline run. </param>
        /// <param name="forceUpdateTag"> How the pipeline run should be forced to recreate even if the pipeline run configuration has not changed. </param>
        /// <returns> A new <see cref="Models.PipelineRunProperties"/> instance for mocking. </returns>
        public static PipelineRunProperties PipelineRunProperties(ContainerRegistryProvisioningState? provisioningState = default, PipelineRunRequest request = default, PipelineRunResponse response = default, string forceUpdateTag = default)
        {
            return new PipelineRunProperties(provisioningState, request, response, forceUpdateTag, additionalBinaryDataProperties: null);
        }

        /// <summary> The request properties provided for a pipeline run. </summary>
        /// <param name="pipelineResourceId"> The resource ID of the pipeline to run. </param>
        /// <param name="artifacts">
        /// List of source artifacts to be transferred by the pipeline. 
        /// Specify an image by repository ('hello-world'). This will use the 'latest' tag.
        /// Specify an image by tag ('hello-world:latest').
        /// Specify an image by sha256-based manifest digest ('hello-world@sha256:abc123').
        /// </param>
        /// <param name="source"> The source properties of the pipeline run. </param>
        /// <param name="target"> The target properties of the pipeline run. </param>
        /// <param name="catalogDigest"> The digest of the tar used to transfer the artifacts. </param>
        /// <returns> A new <see cref="Models.PipelineRunRequest"/> instance for mocking. </returns>
        public static PipelineRunRequest PipelineRunRequest(string pipelineResourceId = default, IEnumerable<string> artifacts = default, PipelineRunSourceProperties source = default, PipelineRunTargetProperties target = default, string catalogDigest = default)
        {
            artifacts ??= new ChangeTrackingList<string>();

            return new PipelineRunRequest(
                pipelineResourceId,
                artifacts.ToList(),
                source,
                target,
                catalogDigest,
                additionalBinaryDataProperties: null);
        }

        /// <param name="status"> The current status of the pipeline run. </param>
        /// <param name="importedArtifacts"> The artifacts imported in the pipeline run. </param>
        /// <param name="progressPercentage"> The percentage complete of the copy operation. </param>
        /// <param name="startOn"> The time the pipeline run started. </param>
        /// <param name="finishOn"> The time the pipeline run finished. </param>
        /// <param name="source"> The source of the pipeline run. </param>
        /// <param name="target"> The target of the pipeline run. </param>
        /// <param name="catalogDigest"> The digest of the tar used to transfer the artifacts. </param>
        /// <param name="trigger"> The trigger that caused the pipeline run. </param>
        /// <param name="pipelineRunErrorMessage"> The detailed error message for the pipeline run in the case of failure. </param>
        /// <returns> A new <see cref="Models.PipelineRunResponse"/> instance for mocking. </returns>
        public static PipelineRunResponse PipelineRunResponse(string status = default, IEnumerable<string> importedArtifacts = default, string progressPercentage = default, DateTimeOffset? startOn = default, DateTimeOffset? finishOn = default, ImportPipelineSourceProperties source = default, ExportPipelineTargetProperties target = default, string catalogDigest = default, PipelineTriggerDescriptor trigger = default, string pipelineRunErrorMessage = default)
        {
            importedArtifacts ??= new ChangeTrackingList<string>();

            return new PipelineRunResponse(
                status,
                importedArtifacts.ToList(),
                progressPercentage is null ? default : new ProgressProperties(progressPercentage, null),
                startOn,
                finishOn,
                source,
                target,
                catalogDigest,
                trigger,
                pipelineRunErrorMessage,
                additionalBinaryDataProperties: null);
        }

        /// <param name="sourceTriggerTimestamp"> The timestamp when the source update happened. </param>
        /// <returns> A new <see cref="Models.PipelineTriggerDescriptor"/> instance for mocking. </returns>
        public static PipelineTriggerDescriptor PipelineTriggerDescriptor(DateTimeOffset? sourceTriggerTimestamp = default)
        {
            return new PipelineTriggerDescriptor(sourceTriggerTimestamp is null ? default : new PipelineSourceTriggerDescriptor(sourceTriggerTimestamp, null), additionalBinaryDataProperties: null);
        }

        /// <summary> An object that represents a webhook for a container registry. </summary>
        /// <param name="id"> Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}. </param>
        /// <param name="name"> The name of the private link resource. </param>
        /// <param name="resourceType"> The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts". </param>
        /// <param name="systemData"> Azure Resource Manager metadata containing createdBy and modifiedBy information. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="location"> The geo-location where the resource lives. </param>
        /// <param name="properties"> The properties of the webhook. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryWebhookData"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookData ContainerRegistryWebhookData(ResourceIdentifier id = default, string name = default, ResourceType resourceType = default, SystemData systemData = default, IDictionary<string, string> tags = default, AzureLocation location = default, WebhookProperties properties = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ContainerRegistryWebhookData(
                id,
                name,
                resourceType,
                systemData,
                additionalBinaryDataProperties: null,
                tags,
                location,
                properties);
        }

        /// <summary> The properties of a webhook. </summary>
        /// <param name="status"> The status of the webhook at the time the operation was called. </param>
        /// <param name="scope"> The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is equivalent to 'foo:latest'. Empty means all events. </param>
        /// <param name="actions"> The list of actions that trigger the webhook to post notifications. </param>
        /// <param name="provisioningState"> The provisioning state of the webhook at the time the operation was called. </param>
        /// <returns> A new <see cref="Models.WebhookProperties"/> instance for mocking. </returns>
        public static WebhookProperties WebhookProperties(ContainerRegistryWebhookStatus? status = default, string scope = default, IEnumerable<ContainerRegistryWebhookAction> actions = default, ContainerRegistryProvisioningState? provisioningState = default)
        {
            actions ??= new ChangeTrackingList<ContainerRegistryWebhookAction>();

            return new WebhookProperties(status, scope, actions.ToList(), provisioningState, additionalBinaryDataProperties: null);
        }

        /// <param name="tags"> The tags for the webhook. </param>
        /// <param name="location"> The location of the webhook. This cannot be changed after the resource is created. </param>
        /// <param name="serviceUri"> The service URI for the webhook to post notifications. </param>
        /// <param name="customHeaders"> Custom headers that will be added to the webhook notifications. </param>
        /// <param name="status"> The status of the webhook at the time the operation was called. </param>
        /// <param name="scope"> The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is equivalent to 'foo:latest'. Empty means all events. </param>
        /// <param name="actions"> The list of actions that trigger the webhook to post notifications. </param>
        /// <returns> A new <see cref="Models.WebhookCreateParameters"/> instance for mocking. </returns>
        public static WebhookCreateParameters WebhookCreateParameters(IDictionary<string, string> tags = default, string location = default, string serviceUri = default, IDictionary<string, string> customHeaders = default, ContainerRegistryWebhookStatus? status = default, string scope = default, IEnumerable<ContainerRegistryWebhookAction> actions = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new WebhookCreateParameters(tags, location, serviceUri is null && customHeaders is null && status is null && scope is null && actions is null ? default : new WebhookPropertiesCreateParameters(
                serviceUri,
                customHeaders,
                status,
                scope,
                (actions ?? new ChangeTrackingList<ContainerRegistryWebhookAction>()).ToList(),
                null), additionalBinaryDataProperties: null);
        }

        /// <param name="tags"> The tags for the webhook. </param>
        /// <param name="serviceUri"> The service URI for the webhook to post notifications. </param>
        /// <param name="customHeaders"> Custom headers that will be added to the webhook notifications. </param>
        /// <param name="status"> The status of the webhook at the time the operation was called. </param>
        /// <param name="scope"> The scope of repositories where the event can be triggered. For example, 'foo:*' means events for all tags under repository 'foo'. 'foo:bar' means events for 'foo:bar' only. 'foo' is equivalent to 'foo:latest'. Empty means all events. </param>
        /// <param name="actions"> The list of actions that trigger the webhook to post notifications. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookPatch"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookPatch ContainerRegistryWebhookPatch(IDictionary<string, string> tags = default, string serviceUri = default, IDictionary<string, string> customHeaders = default, ContainerRegistryWebhookStatus? status = default, string scope = default, IEnumerable<ContainerRegistryWebhookAction> actions = default)
        {
            tags ??= new ChangeTrackingDictionary<string, string>();

            return new ContainerRegistryWebhookPatch(tags, serviceUri is null && customHeaders is null && status is null && scope is null && actions is null ? default : new WebhookPropertiesUpdateParameters(
                serviceUri,
                customHeaders,
                status,
                scope,
                (actions ?? new ChangeTrackingList<ContainerRegistryWebhookAction>()).ToList(),
                null), additionalBinaryDataProperties: null);
        }

        /// <summary> The basic information of an event. </summary>
        /// <param name="id"> The event ID. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventInfo"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventInfo ContainerRegistryWebhookEventInfo(string id = default)
        {
            return new ContainerRegistryWebhookEventInfo(id, additionalBinaryDataProperties: null);
        }

        /// <summary> The event for a webhook. </summary>
        /// <param name="id"> The event ID. </param>
        /// <param name="eventRequestMessage"> The event request message sent to the service URI. </param>
        /// <param name="eventResponseMessage"> The event response message received from the service URI. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEvent"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEvent ContainerRegistryWebhookEvent(string id = default, ContainerRegistryWebhookEventRequestMessage eventRequestMessage = default, ContainerRegistryWebhookEventResponseMessage eventResponseMessage = default)
        {
            return new ContainerRegistryWebhookEvent(id, additionalBinaryDataProperties: null, eventRequestMessage, eventResponseMessage);
        }

        /// <summary> The event request message sent to the service URI. </summary>
        /// <param name="content"> The content of the event request message. </param>
        /// <param name="headers"> The headers of the event request message. </param>
        /// <param name="method"> The HTTP method used to send the event request message. </param>
        /// <param name="requestUri"> The URI used to send the event request message. </param>
        /// <param name="version"> The HTTP message version. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventRequestMessage"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventRequestMessage ContainerRegistryWebhookEventRequestMessage(ContainerRegistryWebhookEventContent content = default, IReadOnlyDictionary<string, string> headers = default, string @method = default, string requestUri = default, string version = default)
        {
            headers ??= new ChangeTrackingDictionary<string, string>();

            return new ContainerRegistryWebhookEventRequestMessage(
                content,
                headers,
                @method,
                requestUri,
                version,
                additionalBinaryDataProperties: null);
        }

        /// <param name="id"> The event ID. </param>
        /// <param name="timestamp"> The time at which the event occurred. </param>
        /// <param name="action"> The action that encompasses the provided event. </param>
        /// <param name="target"> The target of the event. </param>
        /// <param name="request"> The request that generated the event. </param>
        /// <param name="actorName"> The subject or username associated with the request context that generated the event. </param>
        /// <param name="source"> The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventContent"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventContent ContainerRegistryWebhookEventContent(string id = default, DateTimeOffset? timestamp = default, string action = default, ContainerRegistryWebhookEventTarget target = default, ContainerRegistryWebhookEventRequestContent request = default, string actorName = default, ContainerRegistryWebhookEventSource source = default)
        {
            return new ContainerRegistryWebhookEventContent(
                id,
                timestamp,
                action,
                target,
                request,
                actorName is null ? default : new ContainerRegistryWebhookEventActor(actorName, null),
                source,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The target of the event. </summary>
        /// <param name="mediaType"> The MIME type of the referenced object. </param>
        /// <param name="size"> The number of bytes of the content. Same as Length field. </param>
        /// <param name="digest"> The digest of the content, as defined by the Registry V2 HTTP API Specification. </param>
        /// <param name="length"> The number of bytes of the content. Same as Size field. </param>
        /// <param name="repository"> The repository name. </param>
        /// <param name="uri"> The direct URL to the content. </param>
        /// <param name="tag"> The tag name. </param>
        /// <param name="name"> The name of the artifact. </param>
        /// <param name="version"> The version of the artifact. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventTarget"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventTarget ContainerRegistryWebhookEventTarget(string mediaType = default, long? size = default, string digest = default, long? length = default, string repository = default, string uri = default, string tag = default, string name = default, string version = default)
        {
            return new ContainerRegistryWebhookEventTarget(
                mediaType,
                size,
                digest,
                length,
                repository,
                uri,
                tag,
                name,
                version,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The request that generated the event. </summary>
        /// <param name="id"> The ID of the request that initiated the event. </param>
        /// <param name="addr"> The IP or hostname and possibly port of the client connection that initiated the event. This is the RemoteAddr from the standard http request. </param>
        /// <param name="host"> The externally accessible hostname of the registry instance, as specified by the http host header on incoming requests. </param>
        /// <param name="method"> The request method that generated the event. </param>
        /// <param name="useragent"> The user agent header of the request. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventRequestContent"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventRequestContent ContainerRegistryWebhookEventRequestContent(string id = default, string addr = default, string host = default, string @method = default, string useragent = default)
        {
            return new ContainerRegistryWebhookEventRequestContent(
                id,
                addr,
                host,
                @method,
                useragent,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it. </summary>
        /// <param name="addr"> The IP or hostname and the port of the registry node that generated the event. Generally, this will be resolved by os.Hostname() along with the running port. </param>
        /// <param name="instanceID"> The running instance of an application. Changes after each restart. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventSource"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventSource ContainerRegistryWebhookEventSource(string addr = default, string instanceID = default)
        {
            return new ContainerRegistryWebhookEventSource(addr, instanceID, additionalBinaryDataProperties: null);
        }

        /// <summary> The event response message received from the service URI. </summary>
        /// <param name="content"> The content of the event response message. </param>
        /// <param name="headers"> The headers of the event response message. </param>
        /// <param name="reasonPhrase"> The reason phrase of the event response message. </param>
        /// <param name="statusCode"> The status code of the event response message. </param>
        /// <param name="version"> The HTTP message version. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventResponseMessage"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventResponseMessage ContainerRegistryWebhookEventResponseMessage(string content = default, IReadOnlyDictionary<string, string> headers = default, string reasonPhrase = default, string statusCode = default, string version = default)
        {
            headers ??= new ChangeTrackingDictionary<string, string>();

            return new ContainerRegistryWebhookEventResponseMessage(
                content,
                headers,
                reasonPhrase,
                statusCode,
                version,
                additionalBinaryDataProperties: null);
        }

        /// <summary> The configuration of service URI and custom headers for the webhook. </summary>
        /// <param name="serviceUri"> The service URI for the webhook to post notifications. </param>
        /// <param name="customHeaders"> Custom headers that will be added to the webhook notifications. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookCallbackConfig"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookCallbackConfig ContainerRegistryWebhookCallbackConfig(string serviceUri = default, IReadOnlyDictionary<string, string> customHeaders = default)
        {
            customHeaders ??= new ChangeTrackingDictionary<string, string>();

            return new ContainerRegistryWebhookCallbackConfig(serviceUri, customHeaders, additionalBinaryDataProperties: null);
        }
    }
}
