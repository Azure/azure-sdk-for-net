// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Core;
using Azure.ResourceManager.ContainerRegistry;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.ContainerRegistry.Models
{
    /// <summary> Model factory for generated models. </summary>
    public static partial class ContainerRegistryModelFactory
    {
        /// <summary> Initializes a new instance of ConnectedRegistryData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="mode"> The mode of the connected registry resource that indicates the permissions of the registry. </param>
        /// <param name="version"> The current version of ACR runtime on the connected registry. </param>
        /// <param name="connectionState"> The current connection state of the connected registry. </param>
        /// <param name="lastActivityOn"> The last activity time of the connected registry. </param>
        /// <param name="activationStatus"> The activation properties of the connected registry. </param>
        /// <param name="parent"> The parent of the connected registry. </param>
        /// <param name="clientTokenIds"> The list of the ACR token resource IDs used to authenticate clients to the connected registry. </param>
        /// <param name="loginServer"> The login server properties of the connected registry. </param>
        /// <param name="logging"> The logging properties of the connected registry. </param>
        /// <param name="statusDetails"> The list of current statuses of the connected registry. </param>
        /// <param name="notificationsList"> The list of notifications subscription information for the connected registry. </param>
        /// <returns> A new <see cref="ContainerRegistry.ConnectedRegistryData"/> instance for mocking. </returns>
        public static ConnectedRegistryData ConnectedRegistryData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ContainerRegistryProvisioningState? provisioningState = null, ConnectedRegistryMode? mode = null, string version = null, ConnectedRegistryConnectionState? connectionState = null, DateTimeOffset? lastActivityOn = null, ConnectedRegistryActivationStatus? activationStatus = null, ConnectedRegistryParent parent = null, IEnumerable<ResourceIdentifier> clientTokenIds = null, ConnectedRegistryLoginServer loginServer = null, ConnectedRegistryLogging logging = null, IEnumerable<ConnectedRegistryStatusDetail> statusDetails = null, IEnumerable<string> notificationsList = null)
        {
            clientTokenIds ??= new List<ResourceIdentifier>();
            statusDetails ??= new List<ConnectedRegistryStatusDetail>();
            notificationsList ??= new List<string>();

            return new ConnectedRegistryData(id, name, resourceType, systemData, provisioningState, mode, version, connectionState, lastActivityOn, activationStatus != null ? new ConnectedRegistryActivation(activationStatus) : null, parent, clientTokenIds?.ToList(), loginServer, logging, statusDetails?.ToList(), notificationsList?.ToList());
        }

        /// <summary> Initializes a new instance of ConnectedRegistryParent. </summary>
        /// <param name="id"> The resource ID of the parent to which the connected registry will be associated. </param>
        /// <param name="syncProperties"> The sync properties of the connected registry with its parent. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistryParent"/> instance for mocking. </returns>
        public static ConnectedRegistryParent ConnectedRegistryParent(ResourceIdentifier id = null, ConnectedRegistrySyncProperties syncProperties = null)
        {
            return new ConnectedRegistryParent(id, syncProperties);
        }

        /// <summary> Initializes a new instance of ConnectedRegistrySyncProperties. </summary>
        /// <param name="tokenId"> The resource ID of the ACR token used to authenticate the connected registry to its parent during sync. </param>
        /// <param name="schedule"> The cron expression indicating the schedule that the connected registry will sync with its parent. </param>
        /// <param name="syncWindow"> The time window during which sync is enabled for each schedule occurrence. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601. </param>
        /// <param name="messageTtl"> The period of time for which a message is available to sync before it is expired. Specify the duration using the format P[n]Y[n]M[n]DT[n]H[n]M[n]S as per ISO8601. </param>
        /// <param name="lastSyncOn"> The last time a sync occurred between the connected registry and its parent. </param>
        /// <param name="gatewayEndpoint"> The gateway endpoint used by the connected registry to communicate with its parent. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistrySyncProperties"/> instance for mocking. </returns>
        public static ConnectedRegistrySyncProperties ConnectedRegistrySyncProperties(ResourceIdentifier tokenId = null, string schedule = null, TimeSpan? syncWindow = null, TimeSpan messageTtl = default, DateTimeOffset? lastSyncOn = null, string gatewayEndpoint = null)
        {
            return new ConnectedRegistrySyncProperties(tokenId, schedule, syncWindow, messageTtl, lastSyncOn, gatewayEndpoint);
        }

        /// <summary> Initializes a new instance of ConnectedRegistryLoginServer. </summary>
        /// <param name="host"> The host of the connected registry. Can be FQDN or IP. </param>
        /// <param name="tls"> The TLS properties of the connected registry login server. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistryLoginServer"/> instance for mocking. </returns>
        public static ConnectedRegistryLoginServer ConnectedRegistryLoginServer(string host = null, TlsProperties tls = null)
        {
            return new ConnectedRegistryLoginServer(host, tls);
        }

        /// <summary> Initializes a new instance of TlsProperties. </summary>
        /// <param name="status"> Indicates whether HTTPS is enabled for the login server. </param>
        /// <param name="certificate"> The certificate used to configure HTTPS for the login server. </param>
        /// <returns> A new <see cref="Models.TlsProperties"/> instance for mocking. </returns>
        public static TlsProperties TlsProperties(TlsStatus? status = null, TlsCertificateProperties certificate = null)
        {
            return new TlsProperties(status, certificate);
        }

        /// <summary> Initializes a new instance of TlsCertificateProperties. </summary>
        /// <param name="locationType"> The type of certificate location. </param>
        /// <param name="certificateLocation"> Indicates the location of the certificates. </param>
        /// <returns> A new <see cref="Models.TlsCertificateProperties"/> instance for mocking. </returns>
        public static TlsCertificateProperties TlsCertificateProperties(TlsCertificateLocationType? locationType = null, string certificateLocation = null)
        {
            return new TlsCertificateProperties(locationType, certificateLocation);
        }

        /// <summary> Initializes a new instance of ConnectedRegistryLogging. </summary>
        /// <param name="logLevel"> The verbosity of logs persisted on the connected registry. </param>
        /// <param name="auditLogStatus"> Indicates whether audit logs are enabled on the connected registry. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistryLogging"/> instance for mocking. </returns>
        public static ConnectedRegistryLogging ConnectedRegistryLogging(ConnectedRegistryLogLevel? logLevel = null, ConnectedRegistryAuditLogStatus? auditLogStatus = null)
        {
            return new ConnectedRegistryLogging(logLevel, auditLogStatus);
        }

        /// <summary> Initializes a new instance of ConnectedRegistryStatusDetail. </summary>
        /// <param name="statusDetailType"> The component of the connected registry corresponding to the status. </param>
        /// <param name="code"> The code of the status. </param>
        /// <param name="description"> The description of the status. </param>
        /// <param name="timestamp"> The timestamp of the status. </param>
        /// <param name="correlationId"> The correlation ID of the status. </param>
        /// <returns> A new <see cref="Models.ConnectedRegistryStatusDetail"/> instance for mocking. </returns>
        public static ConnectedRegistryStatusDetail ConnectedRegistryStatusDetail(string statusDetailType = null, string code = null, string description = null, DateTimeOffset? timestamp = null, string correlationId = null)
        {
            return new ConnectedRegistryStatusDetail(statusDetailType, code, description, timestamp, correlationId);
        }

        /// <summary> Initializes a new instance of ExportPipelineData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="location"> The location of the export pipeline. </param>
        /// <param name="identity"> The identity of the export pipeline. </param>
        /// <param name="target"> The target properties of the export pipeline. </param>
        /// <param name="options"> The list of all options configured for the pipeline. </param>
        /// <param name="provisioningState"> The provisioning state of the pipeline at the time the operation was called. </param>
        /// <returns> A new <see cref="ContainerRegistry.ExportPipelineData"/> instance for mocking. </returns>
        public static ExportPipelineData ExportPipelineData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, AzureLocation? location = null, ManagedServiceIdentity identity = null, ExportPipelineTargetProperties target = null, IEnumerable<PipelineOption> options = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            options ??= new List<PipelineOption>();

            return new ExportPipelineData(id, name, resourceType, systemData, location, identity, target, options?.ToList(), provisioningState);
        }

        /// <summary> Initializes a new instance of ExportPipelineTargetProperties. </summary>
        /// <param name="pipelineTargetType"> The type of target for the export pipeline. </param>
        /// <param name="uri">
        /// The target uri of the export pipeline.
        /// When &apos;AzureStorageBlob&apos;: &quot;https://accountName.blob.core.windows.net/containerName/blobName&quot;
        /// When &apos;AzureStorageBlobContainer&apos;:  &quot;https://accountName.blob.core.windows.net/containerName&quot;
        /// </param>
        /// <param name="keyVaultUri"> They key vault secret uri to obtain the target storage SAS token. </param>
        /// <returns> A new <see cref="Models.ExportPipelineTargetProperties"/> instance for mocking. </returns>
        public static ExportPipelineTargetProperties ExportPipelineTargetProperties(string pipelineTargetType = null, Uri uri = null, Uri keyVaultUri = null)
        {
            return new ExportPipelineTargetProperties(pipelineTargetType, uri, keyVaultUri);
        }

        /// <summary> Initializes a new instance of ImportPipelineData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="location"> The location of the import pipeline. </param>
        /// <param name="identity"> The identity of the import pipeline. </param>
        /// <param name="source"> The source properties of the import pipeline. </param>
        /// <param name="sourceTriggerStatus"> The properties that describe the trigger of the import pipeline. </param>
        /// <param name="options"> The list of all options configured for the pipeline. </param>
        /// <param name="provisioningState"> The provisioning state of the pipeline at the time the operation was called. </param>
        /// <returns> A new <see cref="ContainerRegistry.ImportPipelineData"/> instance for mocking. </returns>
        public static ImportPipelineData ImportPipelineData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, AzureLocation? location = null, ManagedServiceIdentity identity = null, ImportPipelineSourceProperties source = null, ContainerRegistryTriggerStatus? sourceTriggerStatus = null, IEnumerable<PipelineOption> options = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            options ??= new List<PipelineOption>();

            return new ImportPipelineData(id, name, resourceType, systemData, location, identity, source, sourceTriggerStatus.HasValue ? new PipelineTriggerProperties(new PipelineSourceTriggerProperties(sourceTriggerStatus.Value)) : null, options?.ToList(), provisioningState);
        }

        /// <summary> Initializes a new instance of ImportPipelineSourceProperties. </summary>
        /// <param name="pipelineSourceType"> The type of source for the import pipeline. </param>
        /// <param name="uri">
        /// The source uri of the import pipeline.
        /// When &apos;AzureStorageBlob&apos;: &quot;https://accountName.blob.core.windows.net/containerName/blobName&quot;
        /// When &apos;AzureStorageBlobContainer&apos;: &quot;https://accountName.blob.core.windows.net/containerName&quot;
        /// </param>
        /// <param name="keyVaultUri"> They key vault secret uri to obtain the source storage SAS token. </param>
        /// <returns> A new <see cref="Models.ImportPipelineSourceProperties"/> instance for mocking. </returns>
        public static ImportPipelineSourceProperties ImportPipelineSourceProperties(PipelineSourceType? pipelineSourceType = null, Uri uri = null, Uri keyVaultUri = null)
        {
            return new ImportPipelineSourceProperties(pipelineSourceType, uri, keyVaultUri);
        }

        /// <summary> Initializes a new instance of ContainerRegistryNameAvailableResult. </summary>
        /// <param name="isNameAvailable"> The value that indicates whether the name is available. </param>
        /// <param name="reason"> If any, the reason that the name is not available. </param>
        /// <param name="message"> If any, the error message that provides more detail for the reason that the name is not available. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryNameAvailableResult"/> instance for mocking. </returns>
        public static ContainerRegistryNameAvailableResult ContainerRegistryNameAvailableResult(bool? isNameAvailable = null, string reason = null, string message = null)
        {
            return new ContainerRegistryNameAvailableResult(isNameAvailable, reason, message);
        }

        /// <summary> Initializes a new instance of ContainerRegistryPipelineRunData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="provisioningState"> The provisioning state of a pipeline run. </param>
        /// <param name="request"> The request parameters for a pipeline run. </param>
        /// <param name="response"> The response of a pipeline run. </param>
        /// <param name="forceUpdateTag"> How the pipeline run should be forced to recreate even if the pipeline run configuration has not changed. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryPipelineRunData"/> instance for mocking. </returns>
        public static ContainerRegistryPipelineRunData ContainerRegistryPipelineRunData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ContainerRegistryProvisioningState? provisioningState = null, PipelineRunContent request = null, PipelineRunResult response = null, string forceUpdateTag = null)
        {
            return new ContainerRegistryPipelineRunData(id, name, resourceType, systemData, provisioningState, request, response, forceUpdateTag);
        }

        /// <summary> Initializes a new instance of PipelineRunContent. </summary>
        /// <param name="pipelineResourceId"> The resource ID of the pipeline to run. </param>
        /// <param name="artifacts">
        /// List of source artifacts to be transferred by the pipeline. 
        /// Specify an image by repository (&apos;hello-world&apos;). This will use the &apos;latest&apos; tag.
        /// Specify an image by tag (&apos;hello-world:latest&apos;).
        /// Specify an image by sha256-based manifest digest (&apos;hello-world@sha256:abc123&apos;).
        /// </param>
        /// <param name="source"> The source properties of the pipeline run. </param>
        /// <param name="target"> The target properties of the pipeline run. </param>
        /// <param name="catalogDigest"> The digest of the tar used to transfer the artifacts. </param>
        /// <returns> A new <see cref="Models.PipelineRunContent"/> instance for mocking. </returns>
        public static PipelineRunContent PipelineRunContent(ResourceIdentifier pipelineResourceId = null, IEnumerable<string> artifacts = null, PipelineRunSourceProperties source = null, PipelineRunTargetProperties target = null, string catalogDigest = null)
        {
            artifacts ??= new List<string>();

            return new PipelineRunContent(pipelineResourceId, artifacts?.ToList(), source, target, catalogDigest);
        }

        /// <summary> Initializes a new instance of PipelineRunSourceProperties. </summary>
        /// <param name="sourceType"> The type of the source. </param>
        /// <param name="name"> The name of the source. </param>
        /// <returns> A new <see cref="Models.PipelineRunSourceProperties"/> instance for mocking. </returns>
        public static PipelineRunSourceProperties PipelineRunSourceProperties(PipelineRunSourceType? sourceType = null, string name = null)
        {
            return new PipelineRunSourceProperties(sourceType, name);
        }

        /// <summary> Initializes a new instance of PipelineRunTargetProperties. </summary>
        /// <param name="targetType"> The type of the target. </param>
        /// <param name="name"> The name of the target. </param>
        /// <returns> A new <see cref="Models.PipelineRunTargetProperties"/> instance for mocking. </returns>
        public static PipelineRunTargetProperties PipelineRunTargetProperties(PipelineRunTargetType? targetType = null, string name = null)
        {
            return new PipelineRunTargetProperties(targetType, name);
        }

        /// <summary> Initializes a new instance of PipelineRunResult. </summary>
        /// <param name="status"> The current status of the pipeline run. </param>
        /// <param name="importedArtifacts"> The artifacts imported in the pipeline run. </param>
        /// <param name="progressPercentage"> The current progress of the copy operation. </param>
        /// <param name="startOn"> The time the pipeline run started. </param>
        /// <param name="finishOn"> The time the pipeline run finished. </param>
        /// <param name="source"> The source of the pipeline run. </param>
        /// <param name="target"> The target of the pipeline run. </param>
        /// <param name="catalogDigest"> The digest of the tar used to transfer the artifacts. </param>
        /// <param name="sourceTriggerTimestamp"> The trigger that caused the pipeline run. </param>
        /// <param name="pipelineRunErrorMessage"> The detailed error message for the pipeline run in the case of failure. </param>
        /// <returns> A new <see cref="Models.PipelineRunResult"/> instance for mocking. </returns>
        public static PipelineRunResult PipelineRunResult(string status = null, IEnumerable<string> importedArtifacts = null, string progressPercentage = null, DateTimeOffset? startOn = null, DateTimeOffset? finishOn = null, ImportPipelineSourceProperties source = null, ExportPipelineTargetProperties target = null, string catalogDigest = null, DateTimeOffset? sourceTriggerTimestamp = null, string pipelineRunErrorMessage = null)
        {
            importedArtifacts ??= new List<string>();

            return new PipelineRunResult(status, importedArtifacts?.ToList(), progressPercentage != null ? new PipelineProgress(progressPercentage) : null, startOn, finishOn, source, target, catalogDigest, sourceTriggerTimestamp != null ? new PipelineTriggerDescriptor(new PipelineSourceTriggerDescriptor(sourceTriggerTimestamp)) : null, pipelineRunErrorMessage);
        }

        /// <summary> Initializes a new instance of ContainerRegistryPrivateEndpointConnectionData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="privateEndpointId"> The resource of private endpoint. </param>
        /// <param name="connectionState"> A collection of information about the state of the connection between service consumer and provider. </param>
        /// <param name="provisioningState"> The provisioning state of private endpoint connection resource. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryPrivateEndpointConnectionData"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateEndpointConnectionData ContainerRegistryPrivateEndpointConnectionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ResourceIdentifier privateEndpointId = null, ContainerRegistryPrivateLinkServiceConnectionState connectionState = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            return new ContainerRegistryPrivateEndpointConnectionData(id, name, resourceType, systemData, privateEndpointId != null ? ResourceManagerModelFactory.WritableSubResource(privateEndpointId) : null, connectionState, provisioningState);
        }

        /// <summary> Initializes a new instance of ContainerRegistryPrivateLinkServiceConnectionState. </summary>
        /// <param name="status"> The private link service connection status. </param>
        /// <param name="description"> The description for connection status. For example if connection is rejected it can indicate reason for rejection. </param>
        /// <param name="actionsRequired"> A message indicating if changes on the service provider require any updates on the consumer. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPrivateLinkServiceConnectionState"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateLinkServiceConnectionState ContainerRegistryPrivateLinkServiceConnectionState(ContainerRegistryPrivateLinkServiceConnectionStatus? status = null, string description = null, ActionsRequiredForPrivateLinkServiceConsumer? actionsRequired = null)
        {
            return new ContainerRegistryPrivateLinkServiceConnectionState(status, description, actionsRequired);
        }

        /// <summary> Initializes a new instance of ContainerRegistryData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="sku"> The SKU of the container registry. </param>
        /// <param name="identity"> The identity of the container registry. </param>
        /// <param name="loginServer"> The URL that can be used to log into the container registry. </param>
        /// <param name="createdOn"> The creation date of the container registry in ISO8601 format. </param>
        /// <param name="provisioningState"> The provisioning state of the container registry at the time the operation was called. </param>
        /// <param name="status"> The status of the container registry at the time the operation was called. </param>
        /// <param name="isAdminUserEnabled"> The value that indicates whether the admin user is enabled. </param>
        /// <param name="networkRuleSet"> The network rule set for a container registry. </param>
        /// <param name="policies"> The policies for a container registry. </param>
        /// <param name="encryption"> The encryption settings of container registry. </param>
        /// <param name="isDataEndpointEnabled"> Enable a single data endpoint per region for serving data. </param>
        /// <param name="dataEndpointHostNames"> List of host names that will serve data when dataEndpointEnabled is true. </param>
        /// <param name="privateEndpointConnections"> List of private endpoint connections for a container registry. </param>
        /// <param name="publicNetworkAccess"> Whether or not public network access is allowed for the container registry. </param>
        /// <param name="networkRuleBypassOptions"> Whether to allow trusted Azure services to access a network restricted registry. </param>
        /// <param name="zoneRedundancy"> Whether or not zone redundancy is enabled for this container registry. </param>
        /// <param name="isAnonymousPullEnabled"> Enables registry-wide pull from unauthenticated clients. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryData"/> instance for mocking. </returns>
        public static ContainerRegistryData ContainerRegistryData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ContainerRegistrySku sku = null, ManagedServiceIdentity identity = null, string loginServer = null, DateTimeOffset? createdOn = null, ContainerRegistryProvisioningState? provisioningState = null, ContainerRegistryResourceStatus status = null, bool? isAdminUserEnabled = null, ContainerRegistryNetworkRuleSet networkRuleSet = null, ContainerRegistryPolicies policies = null, ContainerRegistryEncryption encryption = null, bool? isDataEndpointEnabled = null, IEnumerable<string> dataEndpointHostNames = null, IEnumerable<ContainerRegistryPrivateEndpointConnectionData> privateEndpointConnections = null, ContainerRegistryPublicNetworkAccess? publicNetworkAccess = null, ContainerRegistryNetworkRuleBypassOption? networkRuleBypassOptions = null, ContainerRegistryZoneRedundancy? zoneRedundancy = null, bool? isAnonymousPullEnabled = null)
        {
            tags ??= new Dictionary<string, string>();
            dataEndpointHostNames ??= new List<string>();
            privateEndpointConnections ??= new List<ContainerRegistryPrivateEndpointConnectionData>();

            return new ContainerRegistryData(id, name, resourceType, systemData, tags, location, sku, identity, loginServer, createdOn, provisioningState, status, isAdminUserEnabled, networkRuleSet, policies, encryption, isDataEndpointEnabled, dataEndpointHostNames?.ToList(), privateEndpointConnections?.ToList(), publicNetworkAccess, networkRuleBypassOptions, zoneRedundancy, isAnonymousPullEnabled);
        }

        /// <summary> Initializes a new instance of ContainerRegistrySku. </summary>
        /// <param name="name"> The SKU name of the container registry. Required for registry creation. </param>
        /// <param name="tier"> The SKU tier based on the SKU name. </param>
        /// <returns> A new <see cref="Models.ContainerRegistrySku"/> instance for mocking. </returns>
        public static ContainerRegistrySku ContainerRegistrySku(ContainerRegistrySkuName name = default, ContainerRegistrySkuTier? tier = null)
        {
            return new ContainerRegistrySku(name, tier);
        }

        /// <summary> Initializes a new instance of ContainerRegistryResourceStatus. </summary>
        /// <param name="displayStatus"> The short label for the status. </param>
        /// <param name="message"> The detailed message for the status, including alerts and error messages. </param>
        /// <param name="timestamp"> The timestamp when the status was changed to the current value. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryResourceStatus"/> instance for mocking. </returns>
        public static ContainerRegistryResourceStatus ContainerRegistryResourceStatus(string displayStatus = null, string message = null, DateTimeOffset? timestamp = null)
        {
            return new ContainerRegistryResourceStatus(displayStatus, message, timestamp);
        }

        /// <summary> Initializes a new instance of ContainerRegistryNetworkRuleSet. </summary>
        /// <param name="defaultAction"> The default action of allow or deny when no other rules match. </param>
        /// <param name="ipRules"> The IP ACL rules. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryNetworkRuleSet"/> instance for mocking. </returns>
        public static ContainerRegistryNetworkRuleSet ContainerRegistryNetworkRuleSet(ContainerRegistryNetworkRuleDefaultAction defaultAction = default, IEnumerable<ContainerRegistryIPRule> ipRules = null)
        {
            ipRules ??= new List<ContainerRegistryIPRule>();

            return new ContainerRegistryNetworkRuleSet(defaultAction, ipRules?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryIPRule. </summary>
        /// <param name="action"> The action of IP ACL rule. </param>
        /// <param name="ipAddressOrRange"> Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryIPRule"/> instance for mocking. </returns>
        public static ContainerRegistryIPRule ContainerRegistryIPRule(ContainerRegistryIPRuleAction? action = null, string ipAddressOrRange = null)
        {
            return new ContainerRegistryIPRule(action, ipAddressOrRange);
        }

        /// <summary> Initializes a new instance of ContainerRegistryPolicies. </summary>
        /// <param name="quarantineStatus"> The quarantine policy for a container registry. </param>
        /// <param name="trustPolicy"> The content trust policy for a container registry. </param>
        /// <param name="retentionPolicy"> The retention policy for a container registry. </param>
        /// <param name="exportStatus"> The export policy for a container registry. </param>
        /// <param name="azureADAuthenticationAsArmStatus"> The policy for using ARM audience token for a container registry. </param>
        /// <param name="softDeletePolicy"> The soft delete policy for a container registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPolicies"/> instance for mocking. </returns>
        public static ContainerRegistryPolicies ContainerRegistryPolicies(ContainerRegistryPolicyStatus? quarantineStatus = null, ContainerRegistryTrustPolicy trustPolicy = null, ContainerRegistryRetentionPolicy retentionPolicy = null, ContainerRegistryExportPolicyStatus? exportStatus = null, AzureADAuthenticationAsArmPolicyStatus? azureADAuthenticationAsArmStatus = null, ContainerRegistrySoftDeletePolicy softDeletePolicy = null)
        {
            return new ContainerRegistryPolicies(quarantineStatus != null ? new ContainerRegistryQuarantinePolicy(quarantineStatus) : null, trustPolicy, retentionPolicy, exportStatus != null ? new ContainerRegistryExportPolicy(exportStatus) : null, azureADAuthenticationAsArmStatus != null ? new AzureADAuthenticationAsArmPolicy(azureADAuthenticationAsArmStatus) : null, softDeletePolicy);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTrustPolicy. </summary>
        /// <param name="policyType"> The type of trust policy. </param>
        /// <param name="status"> The value that indicates whether the policy is enabled or not. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTrustPolicy"/> instance for mocking. </returns>
        public static ContainerRegistryTrustPolicy ContainerRegistryTrustPolicy(ContainerRegistryTrustPolicyType? policyType = null, ContainerRegistryPolicyStatus? status = null)
        {
            return new ContainerRegistryTrustPolicy(policyType, status);
        }

        /// <summary> Initializes a new instance of ContainerRegistryRetentionPolicy. </summary>
        /// <param name="days"> The number of days to retain an untagged manifest after which it gets purged. </param>
        /// <param name="lastUpdatedOn"> The timestamp when the policy was last updated. </param>
        /// <param name="status"> The value that indicates whether the policy is enabled or not. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryRetentionPolicy"/> instance for mocking. </returns>
        public static ContainerRegistryRetentionPolicy ContainerRegistryRetentionPolicy(int? days = null, DateTimeOffset? lastUpdatedOn = null, ContainerRegistryPolicyStatus? status = null)
        {
            return new ContainerRegistryRetentionPolicy(days, lastUpdatedOn, status);
        }

        /// <summary> Initializes a new instance of ContainerRegistrySoftDeletePolicy. </summary>
        /// <param name="retentionDays"> The number of days after which a soft-deleted item is permanently deleted. </param>
        /// <param name="lastUpdatedOn"> The timestamp when the policy was last updated. </param>
        /// <param name="status"> The value that indicates whether the policy is enabled or not. </param>
        /// <returns> A new <see cref="Models.ContainerRegistrySoftDeletePolicy"/> instance for mocking. </returns>
        public static ContainerRegistrySoftDeletePolicy ContainerRegistrySoftDeletePolicy(int? retentionDays = null, DateTimeOffset? lastUpdatedOn = null, ContainerRegistryPolicyStatus? status = null)
        {
            return new ContainerRegistrySoftDeletePolicy(retentionDays, lastUpdatedOn, status);
        }

        /// <summary> Initializes a new instance of ContainerRegistryEncryption. </summary>
        /// <param name="status"> Indicates whether or not the encryption is enabled for container registry. </param>
        /// <param name="keyVaultProperties"> Key vault properties. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryEncryption"/> instance for mocking. </returns>
        public static ContainerRegistryEncryption ContainerRegistryEncryption(ContainerRegistryEncryptionStatus? status = null, ContainerRegistryKeyVaultProperties keyVaultProperties = null)
        {
            return new ContainerRegistryEncryption(status, keyVaultProperties);
        }

        /// <summary> Initializes a new instance of ContainerRegistryKeyVaultProperties. </summary>
        /// <param name="keyIdentifier"> Key vault uri to access the encryption key. </param>
        /// <param name="versionedKeyIdentifier"> The fully qualified key identifier that includes the version of the key that is actually used for encryption. </param>
        /// <param name="identity"> The client id of the identity which will be used to access key vault. </param>
        /// <param name="isKeyRotationEnabled"> Auto key rotation status for a CMK enabled registry. </param>
        /// <param name="lastKeyRotationTimestamp"> Timestamp of the last successful key rotation. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryKeyVaultProperties"/> instance for mocking. </returns>
        public static ContainerRegistryKeyVaultProperties ContainerRegistryKeyVaultProperties(string keyIdentifier = null, string versionedKeyIdentifier = null, string identity = null, bool? isKeyRotationEnabled = null, DateTimeOffset? lastKeyRotationTimestamp = null)
        {
            return new ContainerRegistryKeyVaultProperties(keyIdentifier, versionedKeyIdentifier, identity, isKeyRotationEnabled, lastKeyRotationTimestamp);
        }

        /// <summary> Initializes a new instance of ContainerRegistryUsage. </summary>
        /// <param name="name"> The name of the usage. </param>
        /// <param name="limit"> The limit of the usage. </param>
        /// <param name="currentValue"> The current value of the usage. </param>
        /// <param name="unit"> The unit of measurement. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryUsage"/> instance for mocking. </returns>
        public static ContainerRegistryUsage ContainerRegistryUsage(string name = null, long? limit = null, long? currentValue = null, ContainerRegistryUsageUnit? unit = null)
        {
            return new ContainerRegistryUsage(name, limit, currentValue, unit);
        }

        /// <summary> Initializes a new instance of ContainerRegistryPrivateLinkResourceData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="groupId"> The private link resource group id. </param>
        /// <param name="requiredMembers"> The private link resource required member names. </param>
        /// <param name="requiredZoneNames"> The private link resource Private link DNS zone name. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryPrivateLinkResourceData"/> instance for mocking. </returns>
        public static ContainerRegistryPrivateLinkResourceData ContainerRegistryPrivateLinkResourceData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string groupId = null, IEnumerable<string> requiredMembers = null, IEnumerable<string> requiredZoneNames = null)
        {
            requiredMembers ??= new List<string>();
            requiredZoneNames ??= new List<string>();

            return new ContainerRegistryPrivateLinkResourceData(id, name, resourceType, systemData, groupId, requiredMembers?.ToList(), requiredZoneNames?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryListCredentialsResult. </summary>
        /// <param name="username"> The username for a container registry. </param>
        /// <param name="passwords"> The list of passwords for a container registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryListCredentialsResult"/> instance for mocking. </returns>
        public static ContainerRegistryListCredentialsResult ContainerRegistryListCredentialsResult(string username = null, IEnumerable<ContainerRegistryPassword> passwords = null)
        {
            passwords ??= new List<ContainerRegistryPassword>();

            return new ContainerRegistryListCredentialsResult(username, passwords?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryPassword. </summary>
        /// <param name="name"> The password name. </param>
        /// <param name="value"> The password value. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPassword"/> instance for mocking. </returns>
        public static ContainerRegistryPassword ContainerRegistryPassword(ContainerRegistryPasswordName? name = null, string value = null)
        {
            return new ContainerRegistryPassword(name, value);
        }

        /// <summary> Initializes a new instance of ContainerRegistryReplicationData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="provisioningState"> The provisioning state of the replication at the time the operation was called. </param>
        /// <param name="status"> The status of the replication at the time the operation was called. </param>
        /// <param name="isRegionEndpointEnabled"> Specifies whether the replication&apos;s regional endpoint is enabled. Requests will not be routed to a replication whose regional endpoint is disabled, however its data will continue to be synced with other replications. </param>
        /// <param name="zoneRedundancy"> Whether or not zone redundancy is enabled for this container registry replication. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryReplicationData"/> instance for mocking. </returns>
        public static ContainerRegistryReplicationData ContainerRegistryReplicationData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ContainerRegistryProvisioningState? provisioningState = null, ContainerRegistryResourceStatus status = null, bool? isRegionEndpointEnabled = null, ContainerRegistryZoneRedundancy? zoneRedundancy = null)
        {
            tags ??= new Dictionary<string, string>();

            return new ContainerRegistryReplicationData(id, name, resourceType, systemData, tags, location, provisioningState, status, isRegionEndpointEnabled, zoneRedundancy);
        }

        /// <summary> Initializes a new instance of ScopeMapData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="description"> The user friendly description of the scope map. </param>
        /// <param name="scopeMapType"> The type of the scope map. E.g. BuildIn scope map. </param>
        /// <param name="createdOn"> The creation date of scope map. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="actions">
        /// The list of scoped permissions for registry artifacts.
        /// E.g. repositories/repository-name/content/read,
        /// repositories/repository-name/metadata/write
        /// </param>
        /// <returns> A new <see cref="ContainerRegistry.ScopeMapData"/> instance for mocking. </returns>
        public static ScopeMapData ScopeMapData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string description = null, string scopeMapType = null, DateTimeOffset? createdOn = null, ContainerRegistryProvisioningState? provisioningState = null, IEnumerable<string> actions = null)
        {
            actions ??= new List<string>();

            return new ScopeMapData(id, name, resourceType, systemData, description, scopeMapType, createdOn, provisioningState, actions?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryTokenData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="createdOn"> The creation date of scope map. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="scopeMapId"> The resource ID of the scope map to which the token will be associated with. </param>
        /// <param name="credentials"> The credentials that can be used for authenticating the token. </param>
        /// <param name="status"> The status of the token example enabled or disabled. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryTokenData"/> instance for mocking. </returns>
        public static ContainerRegistryTokenData ContainerRegistryTokenData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, DateTimeOffset? createdOn = null, ContainerRegistryProvisioningState? provisioningState = null, ResourceIdentifier scopeMapId = null, ContainerRegistryTokenCredentials credentials = null, ContainerRegistryTokenStatus? status = null)
        {
            return new ContainerRegistryTokenData(id, name, resourceType, systemData, createdOn, provisioningState, scopeMapId, credentials, status);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTokenCredentials. </summary>
        /// <param name="certificates"></param>
        /// <param name="passwords"></param>
        /// <returns> A new <see cref="Models.ContainerRegistryTokenCredentials"/> instance for mocking. </returns>
        public static ContainerRegistryTokenCredentials ContainerRegistryTokenCredentials(IEnumerable<ContainerRegistryTokenCertificate> certificates = null, IEnumerable<ContainerRegistryTokenPassword> passwords = null)
        {
            certificates ??= new List<ContainerRegistryTokenCertificate>();
            passwords ??= new List<ContainerRegistryTokenPassword>();

            return new ContainerRegistryTokenCredentials(certificates?.ToList(), passwords?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryTokenCertificate. </summary>
        /// <param name="name"></param>
        /// <param name="expireOn"> The expiry datetime of the certificate. </param>
        /// <param name="thumbprint"> The thumbprint of the certificate. </param>
        /// <param name="encodedPemCertificate"> Base 64 encoded string of the public certificate1 in PEM format that will be used for authenticating the token. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTokenCertificate"/> instance for mocking. </returns>
        public static ContainerRegistryTokenCertificate ContainerRegistryTokenCertificate(ContainerRegistryTokenCertificateName? name = null, DateTimeOffset? expireOn = null, string thumbprint = null, string encodedPemCertificate = null)
        {
            return new ContainerRegistryTokenCertificate(name, expireOn, thumbprint, encodedPemCertificate);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTokenPassword. </summary>
        /// <param name="createdOn"> The creation datetime of the password. </param>
        /// <param name="expireOn"> The expiry datetime of the password. </param>
        /// <param name="name"> The password name &quot;password1&quot; or &quot;password2&quot;. </param>
        /// <param name="value"> The password value. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTokenPassword"/> instance for mocking. </returns>
        public static ContainerRegistryTokenPassword ContainerRegistryTokenPassword(DateTimeOffset? createdOn = null, DateTimeOffset? expireOn = null, ContainerRegistryTokenPasswordName? name = null, string value = null)
        {
            return new ContainerRegistryTokenPassword(createdOn, expireOn, name, value);
        }

        /// <summary> Initializes a new instance of ContainerRegistryGenerateCredentialsResult. </summary>
        /// <param name="username"> The username for a container registry. </param>
        /// <param name="passwords"> The list of passwords for a container registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryGenerateCredentialsResult"/> instance for mocking. </returns>
        public static ContainerRegistryGenerateCredentialsResult ContainerRegistryGenerateCredentialsResult(string username = null, IEnumerable<ContainerRegistryTokenPassword> passwords = null)
        {
            passwords ??= new List<ContainerRegistryTokenPassword>();

            return new ContainerRegistryGenerateCredentialsResult(username, passwords?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="status"> The status of the webhook at the time the operation was called. </param>
        /// <param name="scope"> The scope of repositories where the event can be triggered. For example, &apos;foo:*&apos; means events for all tags under repository &apos;foo&apos;. &apos;foo:bar&apos; means events for &apos;foo:bar&apos; only. &apos;foo&apos; is equivalent to &apos;foo:latest&apos;. Empty means all events. </param>
        /// <param name="actions"> The list of actions that trigger the webhook to post notifications. </param>
        /// <param name="provisioningState"> The provisioning state of the webhook at the time the operation was called. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryWebhookData"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookData ContainerRegistryWebhookData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ContainerRegistryWebhookStatus? status = null, string scope = null, IEnumerable<ContainerRegistryWebhookAction> actions = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            tags ??= new Dictionary<string, string>();
            actions ??= new List<ContainerRegistryWebhookAction>();

            return new ContainerRegistryWebhookData(id, name, resourceType, systemData, tags, location, status, scope, actions?.ToList(), provisioningState);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventInfo. </summary>
        /// <param name="id"> The event ID. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventInfo"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventInfo ContainerRegistryWebhookEventInfo(Guid? id = null)
        {
            return new ContainerRegistryWebhookEventInfo(id);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEvent. </summary>
        /// <param name="id"> The event ID. </param>
        /// <param name="eventRequestMessage"> The event request message sent to the service URI. </param>
        /// <param name="eventResponseMessage"> The event response message received from the service URI. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEvent"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEvent ContainerRegistryWebhookEvent(Guid? id = null, ContainerRegistryWebhookEventRequestMessage eventRequestMessage = null, ContainerRegistryWebhookEventResponseMessage eventResponseMessage = null)
        {
            return new ContainerRegistryWebhookEvent(id, eventRequestMessage, eventResponseMessage);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventRequestMessage. </summary>
        /// <param name="content"> The content of the event request message. </param>
        /// <param name="headers"> The headers of the event request message. </param>
        /// <param name="method"> The HTTP method used to send the event request message. </param>
        /// <param name="requestUri"> The URI used to send the event request message. </param>
        /// <param name="version"> The HTTP message version. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventRequestMessage"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventRequestMessage ContainerRegistryWebhookEventRequestMessage(ContainerRegistryWebhookEventContent content = null, IReadOnlyDictionary<string, string> headers = null, string method = null, Uri requestUri = null, string version = null)
        {
            headers ??= new Dictionary<string, string>();

            return new ContainerRegistryWebhookEventRequestMessage(content, headers, method, requestUri, version);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventContent. </summary>
        /// <param name="id"> The event ID. </param>
        /// <param name="timestamp"> The time at which the event occurred. </param>
        /// <param name="action"> The action that encompasses the provided event. </param>
        /// <param name="target"> The target of the event. </param>
        /// <param name="request"> The request that generated the event. </param>
        /// <param name="actorName"> The agent that initiated the event. For most situations, this could be from the authorization context of the request. </param>
        /// <param name="source"> The registry node that generated the event. Put differently, while the actor initiates the event, the source generates it. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventContent"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventContent ContainerRegistryWebhookEventContent(Guid? id = null, DateTimeOffset? timestamp = null, string action = null, ContainerRegistryWebhookEventTarget target = null, ContainerRegistryWebhookEventRequestContent request = null, string actorName = null, ContainerRegistryWebhookEventSource source = null)
        {
            return new ContainerRegistryWebhookEventContent(id, timestamp, action, target, request, actorName != null ? new ContainerRegistryWebhookEventActor(actorName) : null, source);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventTarget. </summary>
        /// <param name="mediaType"> The MIME type of the referenced object. </param>
        /// <param name="size"> The number of bytes of the content. Same as Length field. </param>
        /// <param name="digest"> The digest of the content, as defined by the Registry V2 HTTP API Specification. </param>
        /// <param name="length"> The number of bytes of the content. Same as Size field. </param>
        /// <param name="repository"> The repository name. </param>
        /// <param name="uri"> The direct URL to the content. </param>
        /// <param name="tag"> The tag name. </param>
        /// <param name="name"> The name of the artifact. </param>
        /// <param name="version"> The version of the artifact. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventTarget"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventTarget ContainerRegistryWebhookEventTarget(string mediaType = null, long? size = null, string digest = null, long? length = null, string repository = null, Uri uri = null, string tag = null, string name = null, string version = null)
        {
            return new ContainerRegistryWebhookEventTarget(mediaType, size, digest, length, repository, uri, tag, name, version);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventRequestContent. </summary>
        /// <param name="id"> The ID of the request that initiated the event. </param>
        /// <param name="addr"> The IP or hostname and possibly port of the client connection that initiated the event. This is the RemoteAddr from the standard http request. </param>
        /// <param name="host"> The externally accessible hostname of the registry instance, as specified by the http host header on incoming requests. </param>
        /// <param name="method"> The request method that generated the event. </param>
        /// <param name="userAgent"> The user agent header of the request. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventRequestContent"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventRequestContent ContainerRegistryWebhookEventRequestContent(Guid? id = null, string addr = null, string host = null, string method = null, string userAgent = null)
        {
            return new ContainerRegistryWebhookEventRequestContent(id, addr, host, method, userAgent);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventSource. </summary>
        /// <param name="addr"> The IP or hostname and the port of the registry node that generated the event. Generally, this will be resolved by os.Hostname() along with the running port. </param>
        /// <param name="instanceId"> The running instance of an application. Changes after each restart. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventSource"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventSource ContainerRegistryWebhookEventSource(string addr = null, string instanceId = null)
        {
            return new ContainerRegistryWebhookEventSource(addr, instanceId);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookEventResponseMessage. </summary>
        /// <param name="content"> The content of the event response message. </param>
        /// <param name="headers"> The headers of the event response message. </param>
        /// <param name="reasonPhrase"> The reason phrase of the event response message. </param>
        /// <param name="statusCode"> The status code of the event response message. </param>
        /// <param name="version"> The HTTP message version. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookEventResponseMessage"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookEventResponseMessage ContainerRegistryWebhookEventResponseMessage(string content = null, IReadOnlyDictionary<string, string> headers = null, string reasonPhrase = null, string statusCode = null, string version = null)
        {
            headers ??= new Dictionary<string, string>();

            return new ContainerRegistryWebhookEventResponseMessage(content, headers, reasonPhrase, statusCode, version);
        }

        /// <summary> Initializes a new instance of ContainerRegistryWebhookCallbackConfig. </summary>
        /// <param name="serviceUri"> The service URI for the webhook to post notifications. </param>
        /// <param name="customHeaders"> Custom headers that will be added to the webhook notifications. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryWebhookCallbackConfig"/> instance for mocking. </returns>
        public static ContainerRegistryWebhookCallbackConfig ContainerRegistryWebhookCallbackConfig(Uri serviceUri = null, IReadOnlyDictionary<string, string> customHeaders = null)
        {
            customHeaders ??= new Dictionary<string, string>();

            return new ContainerRegistryWebhookCallbackConfig(serviceUri, customHeaders);
        }

        /// <summary> Initializes a new instance of ContainerRegistryAgentPoolData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="count"> The count of agent machine. </param>
        /// <param name="tier"> The Tier of agent machine. </param>
        /// <param name="os"> The OS of agent machine. </param>
        /// <param name="virtualNetworkSubnetResourceId"> The Virtual Network Subnet Resource Id of the agent machine. </param>
        /// <param name="provisioningState"> The provisioning state of this agent pool. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryAgentPoolData"/> instance for mocking. </returns>
        public static ContainerRegistryAgentPoolData ContainerRegistryAgentPoolData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, int? count = null, string tier = null, ContainerRegistryOS? os = null, ResourceIdentifier virtualNetworkSubnetResourceId = null, ContainerRegistryProvisioningState? provisioningState = null)
        {
            tags ??= new Dictionary<string, string>();

            return new ContainerRegistryAgentPoolData(id, name, resourceType, systemData, tags, location, count, tier, os, virtualNetworkSubnetResourceId, provisioningState);
        }

        /// <summary> Initializes a new instance of ContainerRegistryAgentPoolQueueStatus. </summary>
        /// <param name="count"> The number of pending runs in the queue. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryAgentPoolQueueStatus"/> instance for mocking. </returns>
        public static ContainerRegistryAgentPoolQueueStatus ContainerRegistryAgentPoolQueueStatus(int? count = null)
        {
            return new ContainerRegistryAgentPoolQueueStatus(count);
        }

        /// <summary> Initializes a new instance of ContainerRegistryRunContent. </summary>
        /// <param name="runRequestType"> The type of the run request. </param>
        /// <param name="isArchiveEnabled"> The value that indicates whether archiving is enabled for the run or not. </param>
        /// <param name="agentPoolName"> The dedicated agent pool for the run. </param>
        /// <param name="logTemplate"> The template that describes the repository and tag information for run log artifact. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryRunContent"/> instance for mocking. </returns>
        public static ContainerRegistryRunContent ContainerRegistryRunContent(string runRequestType = null, bool? isArchiveEnabled = null, string agentPoolName = null, string logTemplate = null)
        {
            return new UnknownRunRequest(runRequestType, isArchiveEnabled, agentPoolName, logTemplate);
        }

        /// <summary> Initializes a new instance of ContainerRegistryRunData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="runId"> The unique identifier for the run. </param>
        /// <param name="status"> The current status of the run. </param>
        /// <param name="lastUpdatedOn"> The last updated time for the run. </param>
        /// <param name="runType"> The type of run. </param>
        /// <param name="agentPoolName"> The dedicated agent pool for the run. </param>
        /// <param name="createdOn"> The time the run was scheduled. </param>
        /// <param name="startOn"> The time the run started. </param>
        /// <param name="finishOn"> The time the run finished. </param>
        /// <param name="outputImages"> The list of all images that were generated from the run. This is applicable if the run generates base image dependencies. </param>
        /// <param name="task"> The task against which run was scheduled. </param>
        /// <param name="imageUpdateTrigger"> The image update trigger that caused the run. This is applicable if the task has base image trigger configured. </param>
        /// <param name="sourceTrigger"> The source trigger that caused the run. </param>
        /// <param name="timerTrigger"> The timer trigger that caused the run. </param>
        /// <param name="platform"> The platform properties against which the run will happen. </param>
        /// <param name="agentCpu"> The machine configuration of the run agent. </param>
        /// <param name="sourceRegistryAuth"> The scope of the credentials that were used to login to the source registry during this run. </param>
        /// <param name="customRegistries"> The list of custom registries that were logged in during this run. </param>
        /// <param name="runErrorMessage"> The error message received from backend systems after the run is scheduled. </param>
        /// <param name="updateTriggerToken"> The update trigger token passed for the Run. </param>
        /// <param name="logArtifact"> The image description for the log artifact. </param>
        /// <param name="provisioningState"> The provisioning state of a run. </param>
        /// <param name="isArchiveEnabled"> The value that indicates whether archiving is enabled or not. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryRunData"/> instance for mocking. </returns>
        public static ContainerRegistryRunData ContainerRegistryRunData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string runId = null, ContainerRegistryRunStatus? status = null, DateTimeOffset? lastUpdatedOn = null, ContainerRegistryRunType? runType = null, string agentPoolName = null, DateTimeOffset? createdOn = null, DateTimeOffset? startOn = null, DateTimeOffset? finishOn = null, IEnumerable<ContainerRegistryImageDescriptor> outputImages = null, string task = null, ContainerRegistryImageUpdateTrigger imageUpdateTrigger = null, ContainerRegistrySourceTriggerDescriptor sourceTrigger = null, ContainerRegistryTimerTriggerDescriptor timerTrigger = null, ContainerRegistryPlatformProperties platform = null, int? agentCpu = null, string sourceRegistryAuth = null, IEnumerable<string> customRegistries = null, string runErrorMessage = null, string updateTriggerToken = null, ContainerRegistryImageDescriptor logArtifact = null, ContainerRegistryProvisioningState? provisioningState = null, bool? isArchiveEnabled = null)
        {
            outputImages ??= new List<ContainerRegistryImageDescriptor>();
            customRegistries ??= new List<string>();

            return new ContainerRegistryRunData(id, name, resourceType, systemData, runId, status, lastUpdatedOn, runType, agentPoolName, createdOn, startOn, finishOn, outputImages?.ToList(), task, imageUpdateTrigger, sourceTrigger, timerTrigger, platform, agentCpu != null ? new ContainerRegistryAgentProperties(agentCpu) : null, sourceRegistryAuth, customRegistries?.ToList(), runErrorMessage, updateTriggerToken, logArtifact, provisioningState, isArchiveEnabled);
        }

        /// <summary> Initializes a new instance of ContainerRegistryImageDescriptor. </summary>
        /// <param name="registry"> The registry login server. </param>
        /// <param name="repository"> The repository name. </param>
        /// <param name="tag"> The tag name. </param>
        /// <param name="digest"> The sha256-based digest of the image manifest. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryImageDescriptor"/> instance for mocking. </returns>
        public static ContainerRegistryImageDescriptor ContainerRegistryImageDescriptor(string registry = null, string repository = null, string tag = null, string digest = null)
        {
            return new ContainerRegistryImageDescriptor(registry, repository, tag, digest);
        }

        /// <summary> Initializes a new instance of ContainerRegistryImageUpdateTrigger. </summary>
        /// <param name="id"> The unique ID of the trigger. </param>
        /// <param name="timestamp"> The timestamp when the image update happened. </param>
        /// <param name="images"> The list of image updates that caused the build. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryImageUpdateTrigger"/> instance for mocking. </returns>
        public static ContainerRegistryImageUpdateTrigger ContainerRegistryImageUpdateTrigger(Guid? id = null, DateTimeOffset? timestamp = null, IEnumerable<ContainerRegistryImageDescriptor> images = null)
        {
            images ??= new List<ContainerRegistryImageDescriptor>();

            return new ContainerRegistryImageUpdateTrigger(id, timestamp, images?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistrySourceTriggerDescriptor. </summary>
        /// <param name="id"> The unique ID of the trigger. </param>
        /// <param name="eventType"> The event type of the trigger. </param>
        /// <param name="commitId"> The unique ID that identifies a commit. </param>
        /// <param name="pullRequestId"> The unique ID that identifies pull request. </param>
        /// <param name="repositoryUri"> The repository URL. </param>
        /// <param name="branchName"> The branch name in the repository. </param>
        /// <param name="providerType"> The source control provider type. </param>
        /// <returns> A new <see cref="Models.ContainerRegistrySourceTriggerDescriptor"/> instance for mocking. </returns>
        public static ContainerRegistrySourceTriggerDescriptor ContainerRegistrySourceTriggerDescriptor(Guid? id = null, string eventType = null, string commitId = null, string pullRequestId = null, Uri repositoryUri = null, string branchName = null, string providerType = null)
        {
            return new ContainerRegistrySourceTriggerDescriptor(id, eventType, commitId, pullRequestId, repositoryUri, branchName, providerType);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTimerTriggerDescriptor. </summary>
        /// <param name="timerTriggerName"> The timer trigger name that caused the run. </param>
        /// <param name="scheduleOccurrence"> The occurrence that triggered the run. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTimerTriggerDescriptor"/> instance for mocking. </returns>
        public static ContainerRegistryTimerTriggerDescriptor ContainerRegistryTimerTriggerDescriptor(string timerTriggerName = null, string scheduleOccurrence = null)
        {
            return new ContainerRegistryTimerTriggerDescriptor(timerTriggerName, scheduleOccurrence);
        }

        /// <summary> Initializes a new instance of ContainerRegistryPlatformProperties. </summary>
        /// <param name="os"> The operating system type required for the run. </param>
        /// <param name="architecture"> The OS architecture. </param>
        /// <param name="variant"> Variant of the CPU. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryPlatformProperties"/> instance for mocking. </returns>
        public static ContainerRegistryPlatformProperties ContainerRegistryPlatformProperties(ContainerRegistryOS os = default, ContainerRegistryOSArchitecture? architecture = null, ContainerRegistryCpuVariant? variant = null)
        {
            return new ContainerRegistryPlatformProperties(os, architecture, variant);
        }

        /// <summary> Initializes a new instance of SourceUploadDefinition. </summary>
        /// <param name="uploadUri"> The URL where the client can upload the source. </param>
        /// <param name="relativePath"> The relative path to the source. This is used to submit the subsequent queue build request. </param>
        /// <returns> A new <see cref="Models.SourceUploadDefinition"/> instance for mocking. </returns>
        public static SourceUploadDefinition SourceUploadDefinition(Uri uploadUri = null, string relativePath = null)
        {
            return new SourceUploadDefinition(uploadUri, relativePath);
        }

        /// <summary> Initializes a new instance of ContainerRegistryRunGetLogResult. </summary>
        /// <param name="logLink"> The link to logs for a run on a azure container registry. </param>
        /// <param name="logArtifactLink"> The link to logs in registry for a run on a azure container registry. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryRunGetLogResult"/> instance for mocking. </returns>
        public static ContainerRegistryRunGetLogResult ContainerRegistryRunGetLogResult(string logLink = null, string logArtifactLink = null)
        {
            return new ContainerRegistryRunGetLogResult(logLink, logArtifactLink);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTaskRunData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="identity"> Identity for the resource. </param>
        /// <param name="location"> The location of the resource. </param>
        /// <param name="provisioningState"> The provisioning state of this task run. </param>
        /// <param name="runRequest">
        /// The request (parameters) for the run
        /// Please note <see cref="ContainerRegistryRunContent"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ContainerRegistryDockerBuildContent"/>, <see cref="ContainerRegistryEncodedTaskRunContent"/>, <see cref="ContainerRegistryFileTaskRunContent"/> and <see cref="ContainerRegistryTaskRunContent"/>.
        /// </param>
        /// <param name="runResult"> The result of this task run. </param>
        /// <param name="forceUpdateTag"> How the run should be forced to rerun even if the run request configuration has not changed. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryTaskRunData"/> instance for mocking. </returns>
        public static ContainerRegistryTaskRunData ContainerRegistryTaskRunData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ManagedServiceIdentity identity = null, AzureLocation? location = null, ContainerRegistryProvisioningState? provisioningState = null, ContainerRegistryRunContent runRequest = null, ContainerRegistryRunData runResult = null, string forceUpdateTag = null)
        {
            return new ContainerRegistryTaskRunData(id, name, resourceType, systemData, identity, location, provisioningState, runRequest, runResult, forceUpdateTag);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTaskData. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="identity"> Identity for the resource. </param>
        /// <param name="provisioningState"> The provisioning state of the task. </param>
        /// <param name="createdOn"> The creation date of task. </param>
        /// <param name="status"> The current status of task. </param>
        /// <param name="platform"> The platform properties against which the run has to happen. </param>
        /// <param name="agentCpu"> The machine configuration of the run agent. </param>
        /// <param name="agentPoolName"> The dedicated agent pool for the task. </param>
        /// <param name="timeoutInSeconds"> Run timeout in seconds. </param>
        /// <param name="step">
        /// The properties of a task step.
        /// Please note <see cref="ContainerRegistryTaskStepProperties"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ContainerRegistryDockerBuildStep"/>, <see cref="ContainerRegistryEncodedTaskStep"/> and <see cref="ContainerRegistryFileTaskStep"/>.
        /// </param>
        /// <param name="trigger"> The properties that describe all triggers for the task. </param>
        /// <param name="credentials"> The properties that describes a set of credentials that will be used when this run is invoked. </param>
        /// <param name="logTemplate"> The template that describes the repository and tag information for run log artifact. </param>
        /// <param name="isSystemTask"> The value of this property indicates whether the task resource is system task or not. </param>
        /// <returns> A new <see cref="ContainerRegistry.ContainerRegistryTaskData"/> instance for mocking. </returns>
        public static ContainerRegistryTaskData ContainerRegistryTaskData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ManagedServiceIdentity identity = null, ContainerRegistryProvisioningState? provisioningState = null, DateTimeOffset? createdOn = null, ContainerRegistryTaskStatus? status = null, ContainerRegistryPlatformProperties platform = null, int? agentCpu = null, string agentPoolName = null, int? timeoutInSeconds = null, ContainerRegistryTaskStepProperties step = null, ContainerRegistryTriggerProperties trigger = null, ContainerRegistryCredentials credentials = null, string logTemplate = null, bool? isSystemTask = null)
        {
            tags ??= new Dictionary<string, string>();

            return new ContainerRegistryTaskData(id, name, resourceType, systemData, tags, location, identity, provisioningState, createdOn, status, platform, agentCpu != null ? new ContainerRegistryAgentProperties(agentCpu) : null, agentPoolName, timeoutInSeconds, step, trigger, credentials, logTemplate, isSystemTask);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTaskStepProperties. </summary>
        /// <param name="containerRegistryTaskStepType"> The type of the step. </param>
        /// <param name="baseImageDependencies"> List of base image dependencies for a step. </param>
        /// <param name="contextPath"> The URL(absolute or relative) of the source context for the task step. </param>
        /// <param name="contextAccessToken"> The token (git PAT or SAS token of storage account blob) associated with the context for a step. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTaskStepProperties"/> instance for mocking. </returns>
        public static ContainerRegistryTaskStepProperties ContainerRegistryTaskStepProperties(string containerRegistryTaskStepType = null, IEnumerable<ContainerRegistryBaseImageDependency> baseImageDependencies = null, string contextPath = null, string contextAccessToken = null)
        {
            baseImageDependencies ??= new List<ContainerRegistryBaseImageDependency>();

            return new UnknownTaskStepProperties(containerRegistryTaskStepType, baseImageDependencies?.ToList(), contextPath, contextAccessToken);
        }

        /// <summary> Initializes a new instance of ContainerRegistryBaseImageDependency. </summary>
        /// <param name="dependencyType"> The type of the base image dependency. </param>
        /// <param name="registry"> The registry login server. </param>
        /// <param name="repository"> The repository name. </param>
        /// <param name="tag"> The tag name. </param>
        /// <param name="digest"> The sha256-based digest of the image manifest. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryBaseImageDependency"/> instance for mocking. </returns>
        public static ContainerRegistryBaseImageDependency ContainerRegistryBaseImageDependency(ContainerRegistryBaseImageDependencyType? dependencyType = null, string registry = null, string repository = null, string tag = null, string digest = null)
        {
            return new ContainerRegistryBaseImageDependency(dependencyType, registry, repository, tag, digest);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTriggerProperties. </summary>
        /// <param name="timerTriggers"> The collection of timer triggers. </param>
        /// <param name="sourceTriggers"> The collection of triggers based on source code repository. </param>
        /// <param name="baseImageTrigger"> The trigger based on base image dependencies. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTriggerProperties"/> instance for mocking. </returns>
        public static ContainerRegistryTriggerProperties ContainerRegistryTriggerProperties(IEnumerable<ContainerRegistryTimerTrigger> timerTriggers = null, IEnumerable<ContainerRegistrySourceTrigger> sourceTriggers = null, ContainerRegistryBaseImageTrigger baseImageTrigger = null)
        {
            timerTriggers ??= new List<ContainerRegistryTimerTrigger>();
            sourceTriggers ??= new List<ContainerRegistrySourceTrigger>();

            return new ContainerRegistryTriggerProperties(timerTriggers?.ToList(), sourceTriggers?.ToList(), baseImageTrigger);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTimerTrigger. </summary>
        /// <param name="schedule"> The CRON expression for the task schedule. </param>
        /// <param name="status"> The current status of trigger. </param>
        /// <param name="name"> The name of the trigger. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTimerTrigger"/> instance for mocking. </returns>
        public static ContainerRegistryTimerTrigger ContainerRegistryTimerTrigger(string schedule = null, ContainerRegistryTriggerStatus? status = null, string name = null)
        {
            return new ContainerRegistryTimerTrigger(schedule, status, name);
        }

        /// <summary> Initializes a new instance of ContainerRegistrySourceTrigger. </summary>
        /// <param name="sourceRepository"> The properties that describes the source(code) for the task. </param>
        /// <param name="sourceTriggerEvents"> The source event corresponding to the trigger. </param>
        /// <param name="status"> The current status of trigger. </param>
        /// <param name="name"> The name of the trigger. </param>
        /// <returns> A new <see cref="Models.ContainerRegistrySourceTrigger"/> instance for mocking. </returns>
        public static ContainerRegistrySourceTrigger ContainerRegistrySourceTrigger(SourceCodeRepoProperties sourceRepository = null, IEnumerable<ContainerRegistrySourceTriggerEvent> sourceTriggerEvents = null, ContainerRegistryTriggerStatus? status = null, string name = null)
        {
            sourceTriggerEvents ??= new List<ContainerRegistrySourceTriggerEvent>();

            return new ContainerRegistrySourceTrigger(sourceRepository, sourceTriggerEvents?.ToList(), status, name);
        }

        /// <summary> Initializes a new instance of SourceCodeRepoProperties. </summary>
        /// <param name="sourceControlType"> The type of source control service. </param>
        /// <param name="repositoryUri"> The full URL to the source code repository. </param>
        /// <param name="branch"> The branch name of the source code. </param>
        /// <param name="sourceControlAuthProperties">
        /// The authorization properties for accessing the source code repository and to set up
        /// webhooks for notifications.
        /// </param>
        /// <returns> A new <see cref="Models.SourceCodeRepoProperties"/> instance for mocking. </returns>
        public static SourceCodeRepoProperties SourceCodeRepoProperties(SourceControlType sourceControlType = default, Uri repositoryUri = null, string branch = null, SourceCodeRepoAuthInfo sourceControlAuthProperties = null)
        {
            return new SourceCodeRepoProperties(sourceControlType, repositoryUri, branch, sourceControlAuthProperties);
        }

        /// <summary> Initializes a new instance of SourceCodeRepoAuthInfo. </summary>
        /// <param name="tokenType"> The type of Auth token. </param>
        /// <param name="token"> The access token used to access the source control provider. </param>
        /// <param name="refreshToken"> The refresh token used to refresh the access token. </param>
        /// <param name="scope"> The scope of the access token. </param>
        /// <param name="expireInSeconds"> Time in seconds that the token remains valid. </param>
        /// <returns> A new <see cref="Models.SourceCodeRepoAuthInfo"/> instance for mocking. </returns>
        public static SourceCodeRepoAuthInfo SourceCodeRepoAuthInfo(SourceCodeRepoAuthTokenType tokenType = default, string token = null, string refreshToken = null, string scope = null, int? expireInSeconds = null)
        {
            return new SourceCodeRepoAuthInfo(tokenType, token, refreshToken, scope, expireInSeconds);
        }

        /// <summary> Initializes a new instance of ContainerRegistryBaseImageTrigger. </summary>
        /// <param name="baseImageTriggerType"> The type of the auto trigger for base image dependency updates. </param>
        /// <param name="updateTriggerEndpoint"> The endpoint URL for receiving update triggers. </param>
        /// <param name="updateTriggerPayloadType"> Type of Payload body for Base image update triggers. </param>
        /// <param name="status"> The current status of trigger. </param>
        /// <param name="name"> The name of the trigger. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryBaseImageTrigger"/> instance for mocking. </returns>
        public static ContainerRegistryBaseImageTrigger ContainerRegistryBaseImageTrigger(ContainerRegistryBaseImageTriggerType baseImageTriggerType = default, string updateTriggerEndpoint = null, ContainerRegistryUpdateTriggerPayloadType? updateTriggerPayloadType = null, ContainerRegistryTriggerStatus? status = null, string name = null)
        {
            return new ContainerRegistryBaseImageTrigger(baseImageTriggerType, updateTriggerEndpoint, updateTriggerPayloadType, status, name);
        }

        /// <summary> Initializes a new instance of ContainerRegistryCredentials. </summary>
        /// <param name="sourceRegistryLoginMode"> Describes the credential parameters for accessing the source registry. </param>
        /// <param name="customRegistries">
        /// Describes the credential parameters for accessing other custom registries. The key
        /// for the dictionary item will be the registry login server (myregistry.azurecr.io) and
        /// the value of the item will be the registry credentials for accessing the registry.
        /// </param>
        /// <returns> A new <see cref="Models.ContainerRegistryCredentials"/> instance for mocking. </returns>
        public static ContainerRegistryCredentials ContainerRegistryCredentials(SourceRegistryLoginMode? sourceRegistryLoginMode = null, IDictionary<string, CustomRegistryCredentials> customRegistries = null)
        {
            customRegistries ??= new Dictionary<string, CustomRegistryCredentials>();

            return new ContainerRegistryCredentials(sourceRegistryLoginMode != null ? new SourceRegistryCredentials(sourceRegistryLoginMode) : null, customRegistries);
        }

        /// <summary> Initializes a new instance of CustomRegistryCredentials. </summary>
        /// <param name="userName"> The username for logging into the custom registry. </param>
        /// <param name="password">
        /// The password for logging into the custom registry. The password is a secret 
        /// object that allows multiple ways of providing the value for it.
        /// </param>
        /// <param name="identity">
        /// Indicates the managed identity assigned to the custom credential. If a user-assigned identity
        /// this value is the Client ID. If a system-assigned identity, the value will be `system`. In
        /// the case of a system-assigned identity, the Client ID will be determined by the runner. This
        /// identity may be used to authenticate to key vault to retrieve credentials or it may be the only 
        /// source of authentication used for accessing the registry.
        /// </param>
        /// <returns> A new <see cref="Models.CustomRegistryCredentials"/> instance for mocking. </returns>
        public static CustomRegistryCredentials CustomRegistryCredentials(ContainerRegistrySecretObject userName = null, ContainerRegistrySecretObject password = null, string identity = null)
        {
            return new CustomRegistryCredentials(userName, password, identity);
        }

        /// <summary> Initializes a new instance of ContainerRegistrySecretObject. </summary>
        /// <param name="value">
        /// The value of the secret. The format of this value will be determined
        /// based on the type of the secret object. If the type is Opaque, the value will be
        /// used as is without any modification.
        /// </param>
        /// <param name="objectType">
        /// The type of the secret object which determines how the value of the secret object has to be
        /// interpreted.
        /// </param>
        /// <returns> A new <see cref="Models.ContainerRegistrySecretObject"/> instance for mocking. </returns>
        public static ContainerRegistrySecretObject ContainerRegistrySecretObject(string value = null, ContainerRegistrySecretObjectType? objectType = null)
        {
            return new ContainerRegistrySecretObject(value, objectType);
        }

        /// <summary> Initializes a new instance of ContainerRegistryDockerBuildContent. </summary>
        /// <param name="isArchiveEnabled"> The value that indicates whether archiving is enabled for the run or not. </param>
        /// <param name="agentPoolName"> The dedicated agent pool for the run. </param>
        /// <param name="logTemplate"> The template that describes the repository and tag information for run log artifact. </param>
        /// <param name="imageNames"> The fully qualified image names including the repository and tag. </param>
        /// <param name="isPushEnabled"> The value of this property indicates whether the image built should be pushed to the registry or not. </param>
        /// <param name="noCache"> The value of this property indicates whether the image cache is enabled or not. </param>
        /// <param name="dockerFilePath"> The Docker file path relative to the source location. </param>
        /// <param name="target"> The name of the target build stage for the docker build. </param>
        /// <param name="arguments"> The collection of override arguments to be used when executing the run. </param>
        /// <param name="timeoutInSeconds"> Run timeout in seconds. </param>
        /// <param name="platform"> The platform properties against which the run has to happen. </param>
        /// <param name="agentCpu"> The machine configuration of the run agent. </param>
        /// <param name="sourceLocation">
        /// The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository.
        /// If it is relative URL, the relative path should be obtained from calling listBuildSourceUploadUrl API.
        /// </param>
        /// <param name="credentials"> The properties that describes a set of credentials that will be used when this run is invoked. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryDockerBuildContent"/> instance for mocking. </returns>
        public static ContainerRegistryDockerBuildContent ContainerRegistryDockerBuildContent(bool? isArchiveEnabled = null, string agentPoolName = null, string logTemplate = null, IEnumerable<string> imageNames = null, bool? isPushEnabled = null, bool? noCache = null, string dockerFilePath = null, string target = null, IEnumerable<ContainerRegistryRunArgument> arguments = null, int? timeoutInSeconds = null, ContainerRegistryPlatformProperties platform = null, int? agentCpu = null, string sourceLocation = null, ContainerRegistryCredentials credentials = null)
        {
            imageNames ??= new List<string>();
            arguments ??= new List<ContainerRegistryRunArgument>();

            return new ContainerRegistryDockerBuildContent("DockerBuildRequest", isArchiveEnabled, agentPoolName, logTemplate, imageNames?.ToList(), isPushEnabled, noCache, dockerFilePath, target, arguments?.ToList(), timeoutInSeconds, platform, agentCpu != null ? new ContainerRegistryAgentProperties(agentCpu) : null, sourceLocation, credentials);
        }

        /// <summary> Initializes a new instance of ContainerRegistryRunArgument. </summary>
        /// <param name="name"> The name of the argument. </param>
        /// <param name="value"> The value of the argument. </param>
        /// <param name="isSecret"> Flag to indicate whether the argument represents a secret and want to be removed from build logs. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryRunArgument"/> instance for mocking. </returns>
        public static ContainerRegistryRunArgument ContainerRegistryRunArgument(string name = null, string value = null, bool? isSecret = null)
        {
            return new ContainerRegistryRunArgument(name, value, isSecret);
        }

        /// <summary> Initializes a new instance of ContainerRegistryFileTaskRunContent. </summary>
        /// <param name="isArchiveEnabled"> The value that indicates whether archiving is enabled for the run or not. </param>
        /// <param name="agentPoolName"> The dedicated agent pool for the run. </param>
        /// <param name="logTemplate"> The template that describes the repository and tag information for run log artifact. </param>
        /// <param name="taskFilePath"> The template/definition file path relative to the source. </param>
        /// <param name="valuesFilePath"> The values/parameters file path relative to the source. </param>
        /// <param name="values"> The collection of overridable values that can be passed when running a task. </param>
        /// <param name="timeoutInSeconds"> Run timeout in seconds. </param>
        /// <param name="platform"> The platform properties against which the run has to happen. </param>
        /// <param name="agentCpu"> The machine configuration of the run agent. </param>
        /// <param name="sourceLocation">
        /// The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository.
        /// If it is relative URL, the relative path should be obtained from calling listBuildSourceUploadUrl API.
        /// </param>
        /// <param name="credentials"> The properties that describes a set of credentials that will be used when this run is invoked. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryFileTaskRunContent"/> instance for mocking. </returns>
        public static ContainerRegistryFileTaskRunContent ContainerRegistryFileTaskRunContent(bool? isArchiveEnabled = null, string agentPoolName = null, string logTemplate = null, string taskFilePath = null, string valuesFilePath = null, IEnumerable<ContainerRegistryTaskOverridableValue> values = null, int? timeoutInSeconds = null, ContainerRegistryPlatformProperties platform = null, int? agentCpu = null, string sourceLocation = null, ContainerRegistryCredentials credentials = null)
        {
            values ??= new List<ContainerRegistryTaskOverridableValue>();

            return new ContainerRegistryFileTaskRunContent("FileTaskRunRequest", isArchiveEnabled, agentPoolName, logTemplate, taskFilePath, valuesFilePath, values?.ToList(), timeoutInSeconds, platform, agentCpu != null ? new ContainerRegistryAgentProperties(agentCpu) : null, sourceLocation, credentials);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTaskOverridableValue. </summary>
        /// <param name="name"> The name of the overridable value. </param>
        /// <param name="value"> The overridable value. </param>
        /// <param name="isSecret"> Flag to indicate whether the value represents a secret or not. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTaskOverridableValue"/> instance for mocking. </returns>
        public static ContainerRegistryTaskOverridableValue ContainerRegistryTaskOverridableValue(string name = null, string value = null, bool? isSecret = null)
        {
            return new ContainerRegistryTaskOverridableValue(name, value, isSecret);
        }

        /// <summary> Initializes a new instance of ContainerRegistryTaskRunContent. </summary>
        /// <param name="isArchiveEnabled"> The value that indicates whether archiving is enabled for the run or not. </param>
        /// <param name="agentPoolName"> The dedicated agent pool for the run. </param>
        /// <param name="logTemplate"> The template that describes the repository and tag information for run log artifact. </param>
        /// <param name="taskId"> The resource ID of task against which run has to be queued. </param>
        /// <param name="overrideTaskStepProperties"> Set of overridable parameters that can be passed when running a Task. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryTaskRunContent"/> instance for mocking. </returns>
        public static ContainerRegistryTaskRunContent ContainerRegistryTaskRunContent(bool? isArchiveEnabled = null, string agentPoolName = null, string logTemplate = null, ResourceIdentifier taskId = null, ContainerRegistryOverrideTaskStepProperties overrideTaskStepProperties = null)
        {
            return new ContainerRegistryTaskRunContent("TaskRunRequest", isArchiveEnabled, agentPoolName, logTemplate, taskId, overrideTaskStepProperties);
        }

        /// <summary> Initializes a new instance of ContainerRegistryOverrideTaskStepProperties. </summary>
        /// <param name="contextPath"> The source context against which run has to be queued. </param>
        /// <param name="file"> The file against which run has to be queued. </param>
        /// <param name="arguments">
        /// Gets or sets the collection of override arguments to be used when
        /// executing a build step.
        /// </param>
        /// <param name="target"> The name of the target build stage for the docker build. </param>
        /// <param name="values"> The collection of overridable values that can be passed when running a Task. </param>
        /// <param name="updateTriggerToken"> Base64 encoded update trigger token that will be attached with the base image trigger webhook. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryOverrideTaskStepProperties"/> instance for mocking. </returns>
        public static ContainerRegistryOverrideTaskStepProperties ContainerRegistryOverrideTaskStepProperties(string contextPath = null, string file = null, IEnumerable<ContainerRegistryRunArgument> arguments = null, string target = null, IEnumerable<ContainerRegistryTaskOverridableValue> values = null, string updateTriggerToken = null)
        {
            arguments ??= new List<ContainerRegistryRunArgument>();
            values ??= new List<ContainerRegistryTaskOverridableValue>();

            return new ContainerRegistryOverrideTaskStepProperties(contextPath, file, arguments?.ToList(), target, values?.ToList(), updateTriggerToken);
        }

        /// <summary> Initializes a new instance of ContainerRegistryEncodedTaskRunContent. </summary>
        /// <param name="isArchiveEnabled"> The value that indicates whether archiving is enabled for the run or not. </param>
        /// <param name="agentPoolName"> The dedicated agent pool for the run. </param>
        /// <param name="logTemplate"> The template that describes the repository and tag information for run log artifact. </param>
        /// <param name="encodedTaskContent"> Base64 encoded value of the template/definition file content. </param>
        /// <param name="encodedValuesContent"> Base64 encoded value of the parameters/values file content. </param>
        /// <param name="values"> The collection of overridable values that can be passed when running a task. </param>
        /// <param name="timeoutInSeconds"> Run timeout in seconds. </param>
        /// <param name="platform"> The platform properties against which the run has to happen. </param>
        /// <param name="agentCpu"> The machine configuration of the run agent. </param>
        /// <param name="sourceLocation">
        /// The URL(absolute or relative) of the source context. It can be an URL to a tar or git repository.
        /// If it is relative URL, the relative path should be obtained from calling listBuildSourceUploadUrl API.
        /// </param>
        /// <param name="credentials"> The properties that describes a set of credentials that will be used when this run is invoked. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryEncodedTaskRunContent"/> instance for mocking. </returns>
        public static ContainerRegistryEncodedTaskRunContent ContainerRegistryEncodedTaskRunContent(bool? isArchiveEnabled = null, string agentPoolName = null, string logTemplate = null, string encodedTaskContent = null, string encodedValuesContent = null, IEnumerable<ContainerRegistryTaskOverridableValue> values = null, int? timeoutInSeconds = null, ContainerRegistryPlatformProperties platform = null, int? agentCpu = null, string sourceLocation = null, ContainerRegistryCredentials credentials = null)
        {
            values ??= new List<ContainerRegistryTaskOverridableValue>();

            return new ContainerRegistryEncodedTaskRunContent("EncodedTaskRunRequest", isArchiveEnabled, agentPoolName, logTemplate, encodedTaskContent, encodedValuesContent, values?.ToList(), timeoutInSeconds, platform, agentCpu != null ? new ContainerRegistryAgentProperties(agentCpu) : null, sourceLocation, credentials);
        }

        /// <summary> Initializes a new instance of ContainerRegistryDockerBuildStep. </summary>
        /// <param name="baseImageDependencies"> List of base image dependencies for a step. </param>
        /// <param name="contextPath"> The URL(absolute or relative) of the source context for the task step. </param>
        /// <param name="contextAccessToken"> The token (git PAT or SAS token of storage account blob) associated with the context for a step. </param>
        /// <param name="imageNames"> The fully qualified image names including the repository and tag. </param>
        /// <param name="isPushEnabled"> The value of this property indicates whether the image built should be pushed to the registry or not. </param>
        /// <param name="noCache"> The value of this property indicates whether the image cache is enabled or not. </param>
        /// <param name="dockerFilePath"> The Docker file path relative to the source context. </param>
        /// <param name="target"> The name of the target build stage for the docker build. </param>
        /// <param name="arguments"> The collection of override arguments to be used when executing this build step. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryDockerBuildStep"/> instance for mocking. </returns>
        public static ContainerRegistryDockerBuildStep ContainerRegistryDockerBuildStep(IEnumerable<ContainerRegistryBaseImageDependency> baseImageDependencies = null, string contextPath = null, string contextAccessToken = null, IEnumerable<string> imageNames = null, bool? isPushEnabled = null, bool? noCache = null, string dockerFilePath = null, string target = null, IEnumerable<ContainerRegistryRunArgument> arguments = null)
        {
            baseImageDependencies ??= new List<ContainerRegistryBaseImageDependency>();
            imageNames ??= new List<string>();
            arguments ??= new List<ContainerRegistryRunArgument>();

            return new ContainerRegistryDockerBuildStep("Docker", baseImageDependencies?.ToList(), contextPath, contextAccessToken, imageNames?.ToList(), isPushEnabled, noCache, dockerFilePath, target, arguments?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryFileTaskStep. </summary>
        /// <param name="baseImageDependencies"> List of base image dependencies for a step. </param>
        /// <param name="contextPath"> The URL(absolute or relative) of the source context for the task step. </param>
        /// <param name="contextAccessToken"> The token (git PAT or SAS token of storage account blob) associated with the context for a step. </param>
        /// <param name="taskFilePath"> The task template/definition file path relative to the source context. </param>
        /// <param name="valuesFilePath"> The task values/parameters file path relative to the source context. </param>
        /// <param name="values"> The collection of overridable values that can be passed when running a task. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryFileTaskStep"/> instance for mocking. </returns>
        public static ContainerRegistryFileTaskStep ContainerRegistryFileTaskStep(IEnumerable<ContainerRegistryBaseImageDependency> baseImageDependencies = null, string contextPath = null, string contextAccessToken = null, string taskFilePath = null, string valuesFilePath = null, IEnumerable<ContainerRegistryTaskOverridableValue> values = null)
        {
            baseImageDependencies ??= new List<ContainerRegistryBaseImageDependency>();
            values ??= new List<ContainerRegistryTaskOverridableValue>();

            return new ContainerRegistryFileTaskStep("FileTask", baseImageDependencies?.ToList(), contextPath, contextAccessToken, taskFilePath, valuesFilePath, values?.ToList());
        }

        /// <summary> Initializes a new instance of ContainerRegistryEncodedTaskStep. </summary>
        /// <param name="baseImageDependencies"> List of base image dependencies for a step. </param>
        /// <param name="contextPath"> The URL(absolute or relative) of the source context for the task step. </param>
        /// <param name="contextAccessToken"> The token (git PAT or SAS token of storage account blob) associated with the context for a step. </param>
        /// <param name="encodedTaskContent"> Base64 encoded value of the template/definition file content. </param>
        /// <param name="encodedValuesContent"> Base64 encoded value of the parameters/values file content. </param>
        /// <param name="values"> The collection of overridable values that can be passed when running a task. </param>
        /// <returns> A new <see cref="Models.ContainerRegistryEncodedTaskStep"/> instance for mocking. </returns>
        public static ContainerRegistryEncodedTaskStep ContainerRegistryEncodedTaskStep(IEnumerable<ContainerRegistryBaseImageDependency> baseImageDependencies = null, string contextPath = null, string contextAccessToken = null, string encodedTaskContent = null, string encodedValuesContent = null, IEnumerable<ContainerRegistryTaskOverridableValue> values = null)
        {
            baseImageDependencies ??= new List<ContainerRegistryBaseImageDependency>();
            values ??= new List<ContainerRegistryTaskOverridableValue>();

            return new ContainerRegistryEncodedTaskStep("EncodedTask", baseImageDependencies?.ToList(), contextPath, contextAccessToken, encodedTaskContent, encodedValuesContent, values?.ToList());
        }
    }
}
