// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.MetricsAdvisor
{
    /// <summary> The MetricsAdvisor service client. </summary>
    public partial class MetricsAdvisorClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://cognitiveservices.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of MetricsAdvisorClient for mocking. </summary>
        protected MetricsAdvisorClient()
        {
        }

        /// <summary> Initializes a new instance of MetricsAdvisorClient. </summary>
        /// <param name="endpoint"> Supported Cognitive Services endpoints (protocol and hostname, for example: https://&lt;resource-name&gt;.cognitiveservices.azure.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public MetricsAdvisorClient(Uri endpoint, TokenCredential credential, MetricsAdvisorClientsOptions options = null)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new MetricsAdvisorClientsOptions();

            ClientDiagnostics = new ClientDiagnostics(options);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
        }

        /// <summary> Get latest usage stats. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   timestamp: string (ISO 8601 Format),
        ///   activeSeriesCount: number,
        ///   allSeriesCount: number,
        ///   metricsCount: number,
        ///   dataFeedCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetActiveSeriesCountAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetActiveSeriesCount");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetActiveSeriesCountRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get latest usage stats. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   timestamp: string (ISO 8601 Format),
        ///   activeSeriesCount: number,
        ///   allSeriesCount: number,
        ///   metricsCount: number,
        ///   dataFeedCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetActiveSeriesCount(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetActiveSeriesCount");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetActiveSeriesCountRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Query series enriched by anomaly detection. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   series: [
        ///     {
        ///       dimension: Dictionary&lt;string, string&gt; (required)
        ///     }
        ///   ] (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       series: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       timestampList: [string (ISO 8601 Format)],
        ///       valueList: [number],
        ///       isAnomalyList: [boolean],
        ///       periodList: [number],
        ///       expectedValueList: [number],
        ///       lowerBoundaryList: [number],
        ///       upperBoundaryList: [number]
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetSeriesByAnomalyDetectionConfigurationAsync(Guid configurationId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetSeriesByAnomalyDetectionConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSeriesByAnomalyDetectionConfigurationRequest(configurationId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Query series enriched by anomaly detection. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   series: [
        ///     {
        ///       dimension: Dictionary&lt;string, string&gt; (required)
        ///     }
        ///   ] (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       series: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       timestampList: [string (ISO 8601 Format)],
        ///       valueList: [number],
        ///       isAnomalyList: [boolean],
        ///       periodList: [number],
        ///       expectedValueList: [number],
        ///       lowerBoundaryList: [number],
        ///       upperBoundaryList: [number]
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetSeriesByAnomalyDetectionConfiguration(Guid configurationId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetSeriesByAnomalyDetectionConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSeriesByAnomalyDetectionConfigurationRequest(configurationId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Query root cause for incident. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="incidentId"> incident id. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="incidentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="incidentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       rootCause: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       path: [string],
        ///       score: number,
        ///       description: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetRootCauseOfIncidentByAnomalyDetectionConfigurationAsync(Guid configurationId, string incidentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(incidentId, nameof(incidentId));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetRootCauseOfIncidentByAnomalyDetectionConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRootCauseOfIncidentByAnomalyDetectionConfigurationRequest(configurationId, incidentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Query root cause for incident. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="incidentId"> incident id. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="incidentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="incidentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       rootCause: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       path: [string],
        ///       score: number,
        ///       description: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetRootCauseOfIncidentByAnomalyDetectionConfiguration(Guid configurationId, string incidentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(incidentId, nameof(incidentId));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetRootCauseOfIncidentByAnomalyDetectionConfiguration");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRootCauseOfIncidentByAnomalyDetectionConfigurationRequest(configurationId, incidentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a metric feedback by its id. </summary>
        /// <param name="feedbackId"> the unique feedback ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="feedbackId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="feedbackId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///   feedbackId: MetricFeedbackId,
        ///   createdTime: string (ISO 8601 Format),
        ///   userPrincipal: string,
        ///   metricId: MetricFeedbackMetricId,
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt;
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetMetricFeedbackAsync(string feedbackId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(feedbackId, nameof(feedbackId));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetMetricFeedback");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMetricFeedbackRequest(feedbackId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get a metric feedback by its id. </summary>
        /// <param name="feedbackId"> the unique feedback ID. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="feedbackId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="feedbackId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///   feedbackId: MetricFeedbackId,
        ///   createdTime: string (ISO 8601 Format),
        ///   userPrincipal: string,
        ///   metricId: MetricFeedbackMetricId,
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt;
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetMetricFeedback(string feedbackId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(feedbackId, nameof(feedbackId));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetMetricFeedback");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMetricFeedbackRequest(feedbackId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new metric feedback. </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot; (required),
        ///   feedbackId: MetricFeedbackId,
        ///   createdTime: string (ISO 8601 Format),
        ///   userPrincipal: string,
        ///   metricId: MetricFeedbackMetricId (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   } (required)
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateMetricFeedbackAsync(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.CreateMetricFeedback");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateMetricFeedbackRequest(content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new metric feedback. </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot; (required),
        ///   feedbackId: MetricFeedbackId,
        ///   createdTime: string (ISO 8601 Format),
        ///   userPrincipal: string,
        ///   metricId: MetricFeedbackMetricId (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   } (required)
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateMetricFeedback(RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.CreateMetricFeedback");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateMetricFeedbackRequest(content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get time series data from metric. </summary>
        /// <param name="metricId"> metric unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   series: [Dictionary&lt;string, string&gt;] (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: {
        ///         metricId: MetricSeriesItemMetricId,
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       timestampList: [string (ISO 8601 Format)],
        ///       valueList: [number]
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetMetricDataAsync(Guid metricId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetMetricData");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMetricDataRequest(metricId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get time series data from metric. </summary>
        /// <param name="metricId"> metric unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   series: [Dictionary&lt;string, string&gt;] (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: {
        ///         metricId: MetricSeriesItemMetricId,
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       timestampList: [string (ISO 8601 Format)],
        ///       valueList: [number]
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetMetricData(Guid metricId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("MetricsAdvisorClient.GetMetricData");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetMetricDataRequest(metricId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Query alerts under anomaly alerting configuration. </summary>
        /// <param name="configurationId"> anomaly alerting configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   timeMode: &quot;AnomalyTime&quot; | &quot;CreatedTime&quot; | &quot;ModifiedTime&quot; (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       alertId: string,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format)
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetAlertsByAnomalyAlertingConfigurationAsync(Guid configurationId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetAlertsByAnomalyAlertingConfigurationImplementationAsync("MetricsAdvisorClient.GetAlertsByAnomalyAlertingConfiguration", configurationId, content, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetAlertsByAnomalyAlertingConfigurationImplementationAsync(string diagnosticsScopeName, Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAlertsByAnomalyAlertingConfigurationRequest(configurationId, content, skip, maxpagesize, context)
                        : CreateGetAlertsByAnomalyAlertingConfigurationNextPageRequest(nextLink, configurationId, content, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query alerts under anomaly alerting configuration. </summary>
        /// <param name="configurationId"> anomaly alerting configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   timeMode: &quot;AnomalyTime&quot; | &quot;CreatedTime&quot; | &quot;ModifiedTime&quot; (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       alertId: string,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format)
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetAlertsByAnomalyAlertingConfiguration(Guid configurationId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetAlertsByAnomalyAlertingConfigurationImplementation("MetricsAdvisorClient.GetAlertsByAnomalyAlertingConfiguration", configurationId, content, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetAlertsByAnomalyAlertingConfigurationImplementation(string diagnosticsScopeName, Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAlertsByAnomalyAlertingConfigurationRequest(configurationId, content, skip, maxpagesize, context)
                        : CreateGetAlertsByAnomalyAlertingConfigurationNextPageRequest(nextLink, configurationId, content, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query anomalies under a specific alert. </summary>
        /// <param name="configurationId"> anomaly alerting configuration unique id. </param>
        /// <param name="alertId"> alert id. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="alertId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="alertId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: AnomalyResultDataFeedId,
        ///       metricId: AnomalyResultMetricId,
        ///       anomalyDetectionConfigurationId: AnomalyResultAnomalyDetectionConfigurationId,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format),
        ///       dimension: Dictionary&lt;string, string&gt;,
        ///       property: {
        ///         anomalySeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         anomalyStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         value: number,
        ///         expectedValue: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetAnomaliesFromAlertByAnomalyAlertingConfigurationAsync(Guid configurationId, string alertId, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(alertId, nameof(alertId));

            return GetAnomaliesFromAlertByAnomalyAlertingConfigurationImplementationAsync("MetricsAdvisorClient.GetAnomaliesFromAlertByAnomalyAlertingConfiguration", configurationId, alertId, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetAnomaliesFromAlertByAnomalyAlertingConfigurationImplementationAsync(string diagnosticsScopeName, Guid configurationId, string alertId, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAnomaliesFromAlertByAnomalyAlertingConfigurationRequest(configurationId, alertId, skip, maxpagesize, context)
                        : CreateGetAnomaliesFromAlertByAnomalyAlertingConfigurationNextPageRequest(nextLink, configurationId, alertId, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query anomalies under a specific alert. </summary>
        /// <param name="configurationId"> anomaly alerting configuration unique id. </param>
        /// <param name="alertId"> alert id. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="alertId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="alertId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: AnomalyResultDataFeedId,
        ///       metricId: AnomalyResultMetricId,
        ///       anomalyDetectionConfigurationId: AnomalyResultAnomalyDetectionConfigurationId,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format),
        ///       dimension: Dictionary&lt;string, string&gt;,
        ///       property: {
        ///         anomalySeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         anomalyStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         value: number,
        ///         expectedValue: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetAnomaliesFromAlertByAnomalyAlertingConfiguration(Guid configurationId, string alertId, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(alertId, nameof(alertId));

            return GetAnomaliesFromAlertByAnomalyAlertingConfigurationImplementation("MetricsAdvisorClient.GetAnomaliesFromAlertByAnomalyAlertingConfiguration", configurationId, alertId, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetAnomaliesFromAlertByAnomalyAlertingConfigurationImplementation(string diagnosticsScopeName, Guid configurationId, string alertId, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAnomaliesFromAlertByAnomalyAlertingConfigurationRequest(configurationId, alertId, skip, maxpagesize, context)
                        : CreateGetAnomaliesFromAlertByAnomalyAlertingConfigurationNextPageRequest(nextLink, configurationId, alertId, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query incidents under a specific alert. </summary>
        /// <param name="configurationId"> anomaly alerting configuration unique id. </param>
        /// <param name="alertId"> alert id. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="alertId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="alertId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: IncidentResultDataFeedId,
        ///       metricId: IncidentResultMetricId,
        ///       anomalyDetectionConfigurationId: IncidentResultAnomalyDetectionConfigurationId,
        ///       incidentId: string,
        ///       startTime: string (ISO 8601 Format),
        ///       lastTime: string (ISO 8601 Format),
        ///       rootNode: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       property: {
        ///         maxSeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         incidentStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         valueOfRootNode: number,
        ///         expectedValueOfRootNode: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetIncidentsFromAlertByAnomalyAlertingConfigurationAsync(Guid configurationId, string alertId, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(alertId, nameof(alertId));

            return GetIncidentsFromAlertByAnomalyAlertingConfigurationImplementationAsync("MetricsAdvisorClient.GetIncidentsFromAlertByAnomalyAlertingConfiguration", configurationId, alertId, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetIncidentsFromAlertByAnomalyAlertingConfigurationImplementationAsync(string diagnosticsScopeName, Guid configurationId, string alertId, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetIncidentsFromAlertByAnomalyAlertingConfigurationRequest(configurationId, alertId, skip, maxpagesize, context)
                        : CreateGetIncidentsFromAlertByAnomalyAlertingConfigurationNextPageRequest(nextLink, configurationId, alertId, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query incidents under a specific alert. </summary>
        /// <param name="configurationId"> anomaly alerting configuration unique id. </param>
        /// <param name="alertId"> alert id. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="alertId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="alertId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: IncidentResultDataFeedId,
        ///       metricId: IncidentResultMetricId,
        ///       anomalyDetectionConfigurationId: IncidentResultAnomalyDetectionConfigurationId,
        ///       incidentId: string,
        ///       startTime: string (ISO 8601 Format),
        ///       lastTime: string (ISO 8601 Format),
        ///       rootNode: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       property: {
        ///         maxSeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         incidentStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         valueOfRootNode: number,
        ///         expectedValueOfRootNode: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetIncidentsFromAlertByAnomalyAlertingConfiguration(Guid configurationId, string alertId, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(alertId, nameof(alertId));

            return GetIncidentsFromAlertByAnomalyAlertingConfigurationImplementation("MetricsAdvisorClient.GetIncidentsFromAlertByAnomalyAlertingConfiguration", configurationId, alertId, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetIncidentsFromAlertByAnomalyAlertingConfigurationImplementation(string diagnosticsScopeName, Guid configurationId, string alertId, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetIncidentsFromAlertByAnomalyAlertingConfigurationRequest(configurationId, alertId, skip, maxpagesize, context)
                        : CreateGetIncidentsFromAlertByAnomalyAlertingConfigurationNextPageRequest(nextLink, configurationId, alertId, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query anomalies under anomaly detection configuration. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   filter: {
        ///     dimensionFilter: [
        ///       {
        ///         dimension: Dictionary&lt;string, string&gt; (required)
        ///       }
        ///     ],
        ///     severityFilter: {
        ///       min: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot; (required),
        ///       max: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot; (required)
        ///     }
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: AnomalyResultDataFeedId,
        ///       metricId: AnomalyResultMetricId,
        ///       anomalyDetectionConfigurationId: AnomalyResultAnomalyDetectionConfigurationId,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format),
        ///       dimension: Dictionary&lt;string, string&gt;,
        ///       property: {
        ///         anomalySeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         anomalyStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         value: number,
        ///         expectedValue: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetAnomaliesByAnomalyDetectionConfigurationAsync(Guid configurationId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetAnomaliesByAnomalyDetectionConfigurationImplementationAsync("MetricsAdvisorClient.GetAnomaliesByAnomalyDetectionConfiguration", configurationId, content, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetAnomaliesByAnomalyDetectionConfigurationImplementationAsync(string diagnosticsScopeName, Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAnomaliesByAnomalyDetectionConfigurationRequest(configurationId, content, skip, maxpagesize, context)
                        : CreateGetAnomaliesByAnomalyDetectionConfigurationNextPageRequest(nextLink, configurationId, content, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query anomalies under anomaly detection configuration. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   filter: {
        ///     dimensionFilter: [
        ///       {
        ///         dimension: Dictionary&lt;string, string&gt; (required)
        ///       }
        ///     ],
        ///     severityFilter: {
        ///       min: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot; (required),
        ///       max: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot; (required)
        ///     }
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: AnomalyResultDataFeedId,
        ///       metricId: AnomalyResultMetricId,
        ///       anomalyDetectionConfigurationId: AnomalyResultAnomalyDetectionConfigurationId,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format),
        ///       dimension: Dictionary&lt;string, string&gt;,
        ///       property: {
        ///         anomalySeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         anomalyStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         value: number,
        ///         expectedValue: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetAnomaliesByAnomalyDetectionConfiguration(Guid configurationId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetAnomaliesByAnomalyDetectionConfigurationImplementation("MetricsAdvisorClient.GetAnomaliesByAnomalyDetectionConfiguration", configurationId, content, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetAnomaliesByAnomalyDetectionConfigurationImplementation(string diagnosticsScopeName, Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetAnomaliesByAnomalyDetectionConfigurationRequest(configurationId, content, skip, maxpagesize, context)
                        : CreateGetAnomaliesByAnomalyDetectionConfigurationNextPageRequest(nextLink, configurationId, content, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query dimension values of anomalies. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   dimensionName: string (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDimensionOfAnomaliesByAnomalyDetectionConfigurationAsync(Guid configurationId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetDimensionOfAnomaliesByAnomalyDetectionConfigurationImplementationAsync("MetricsAdvisorClient.GetDimensionOfAnomaliesByAnomalyDetectionConfiguration", configurationId, content, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetDimensionOfAnomaliesByAnomalyDetectionConfigurationImplementationAsync(string diagnosticsScopeName, Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDimensionOfAnomaliesByAnomalyDetectionConfigurationRequest(configurationId, content, skip, maxpagesize, context)
                        : CreateGetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextPageRequest(nextLink, configurationId, content, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query dimension values of anomalies. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   dimensionName: string (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDimensionOfAnomaliesByAnomalyDetectionConfiguration(Guid configurationId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetDimensionOfAnomaliesByAnomalyDetectionConfigurationImplementation("MetricsAdvisorClient.GetDimensionOfAnomaliesByAnomalyDetectionConfiguration", configurationId, content, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetDimensionOfAnomaliesByAnomalyDetectionConfigurationImplementation(string diagnosticsScopeName, Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDimensionOfAnomaliesByAnomalyDetectionConfigurationRequest(configurationId, content, skip, maxpagesize, context)
                        : CreateGetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextPageRequest(nextLink, configurationId, content, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query incidents under anomaly detection configuration. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   filter: {
        ///     dimensionFilter: [
        ///       {
        ///         dimension: Dictionary&lt;string, string&gt; (required)
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: IncidentResultDataFeedId,
        ///       metricId: IncidentResultMetricId,
        ///       anomalyDetectionConfigurationId: IncidentResultAnomalyDetectionConfigurationId,
        ///       incidentId: string,
        ///       startTime: string (ISO 8601 Format),
        ///       lastTime: string (ISO 8601 Format),
        ///       rootNode: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       property: {
        ///         maxSeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         incidentStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         valueOfRootNode: number,
        ///         expectedValueOfRootNode: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetIncidentsByAnomalyDetectionConfigurationAsync(Guid configurationId, RequestContent content, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetIncidentsByAnomalyDetectionConfigurationImplementationAsync("MetricsAdvisorClient.GetIncidentsByAnomalyDetectionConfiguration", configurationId, content, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetIncidentsByAnomalyDetectionConfigurationImplementationAsync(string diagnosticsScopeName, Guid configurationId, RequestContent content, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetIncidentsByAnomalyDetectionConfigurationRequest(configurationId, content, maxpagesize, context)
                        : CreateGetIncidentsByAnomalyDetectionConfigurationNextPageRequest(nextLink, configurationId, content, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query incidents under anomaly detection configuration. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   filter: {
        ///     dimensionFilter: [
        ///       {
        ///         dimension: Dictionary&lt;string, string&gt; (required)
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: IncidentResultDataFeedId,
        ///       metricId: IncidentResultMetricId,
        ///       anomalyDetectionConfigurationId: IncidentResultAnomalyDetectionConfigurationId,
        ///       incidentId: string,
        ///       startTime: string (ISO 8601 Format),
        ///       lastTime: string (ISO 8601 Format),
        ///       rootNode: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       property: {
        ///         maxSeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         incidentStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         valueOfRootNode: number,
        ///         expectedValueOfRootNode: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetIncidentsByAnomalyDetectionConfiguration(Guid configurationId, RequestContent content, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetIncidentsByAnomalyDetectionConfigurationImplementation("MetricsAdvisorClient.GetIncidentsByAnomalyDetectionConfiguration", configurationId, content, maxpagesize, context);
        }

        private Pageable<BinaryData> GetIncidentsByAnomalyDetectionConfigurationImplementation(string diagnosticsScopeName, Guid configurationId, RequestContent content, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetIncidentsByAnomalyDetectionConfigurationRequest(configurationId, content, maxpagesize, context)
                        : CreateGetIncidentsByAnomalyDetectionConfigurationNextPageRequest(nextLink, configurationId, content, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query incidents under anomaly detection configuration. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="token"> the token for getting the next page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: IncidentResultDataFeedId,
        ///       metricId: IncidentResultMetricId,
        ///       anomalyDetectionConfigurationId: IncidentResultAnomalyDetectionConfigurationId,
        ///       incidentId: string,
        ///       startTime: string (ISO 8601 Format),
        ///       lastTime: string (ISO 8601 Format),
        ///       rootNode: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       property: {
        ///         maxSeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         incidentStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         valueOfRootNode: number,
        ///         expectedValueOfRootNode: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetIncidentsByAnomalyDetectionConfigurationNextPagesAsync(Guid configurationId, int? maxpagesize = null, string token = null, RequestContext context = null)
        {
            return GetIncidentsByAnomalyDetectionConfigurationNextPagesImplementationAsync("MetricsAdvisorClient.GetIncidentsByAnomalyDetectionConfigurationNextPages", configurationId, maxpagesize, token, context);
        }

        private AsyncPageable<BinaryData> GetIncidentsByAnomalyDetectionConfigurationNextPagesImplementationAsync(string diagnosticsScopeName, Guid configurationId, int? maxpagesize, string token, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetIncidentsByAnomalyDetectionConfigurationNextPagesRequest(configurationId, maxpagesize, token, context)
                        : CreateGetIncidentsByAnomalyDetectionConfigurationNextPagesNextPageRequest(nextLink, configurationId, maxpagesize, token, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query incidents under anomaly detection configuration. </summary>
        /// <param name="configurationId"> anomaly detection configuration unique id. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="token"> the token for getting the next page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: IncidentResultDataFeedId,
        ///       metricId: IncidentResultMetricId,
        ///       anomalyDetectionConfigurationId: IncidentResultAnomalyDetectionConfigurationId,
        ///       incidentId: string,
        ///       startTime: string (ISO 8601 Format),
        ///       lastTime: string (ISO 8601 Format),
        ///       rootNode: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       },
        ///       property: {
        ///         maxSeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         incidentStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         valueOfRootNode: number,
        ///         expectedValueOfRootNode: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetIncidentsByAnomalyDetectionConfigurationNextPages(Guid configurationId, int? maxpagesize = null, string token = null, RequestContext context = null)
        {
            return GetIncidentsByAnomalyDetectionConfigurationNextPagesImplementation("MetricsAdvisorClient.GetIncidentsByAnomalyDetectionConfigurationNextPages", configurationId, maxpagesize, token, context);
        }

        private Pageable<BinaryData> GetIncidentsByAnomalyDetectionConfigurationNextPagesImplementation(string diagnosticsScopeName, Guid configurationId, int? maxpagesize, string token, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetIncidentsByAnomalyDetectionConfigurationNextPagesRequest(configurationId, maxpagesize, token, context)
                        : CreateGetIncidentsByAnomalyDetectionConfigurationNextPagesNextPageRequest(nextLink, configurationId, maxpagesize, token, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List feedback on the given metric. </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   metricId: MetricFeedbackFilterMetricId (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   },
        ///   feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///   startTime: string (ISO 8601 Format),
        ///   endTime: string (ISO 8601 Format),
        ///   timeMode: &quot;MetricTimestamp&quot; | &quot;FeedbackCreatedTime&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///       feedbackId: MetricFeedbackId,
        ///       createdTime: string (ISO 8601 Format),
        ///       userPrincipal: string,
        ///       metricId: MetricFeedbackMetricId,
        ///       dimensionFilter: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetMetricFeedbacksAsync(RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricFeedbacksImplementationAsync("MetricsAdvisorClient.GetMetricFeedbacks", content, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetMetricFeedbacksImplementationAsync(string diagnosticsScopeName, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMetricFeedbacksRequest(content, skip, maxpagesize, context)
                        : CreateGetMetricFeedbacksNextPageRequest(nextLink, content, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List feedback on the given metric. </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   metricId: MetricFeedbackFilterMetricId (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   },
        ///   feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///   startTime: string (ISO 8601 Format),
        ///   endTime: string (ISO 8601 Format),
        ///   timeMode: &quot;MetricTimestamp&quot; | &quot;FeedbackCreatedTime&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///       feedbackId: MetricFeedbackId,
        ///       createdTime: string (ISO 8601 Format),
        ///       userPrincipal: string,
        ///       metricId: MetricFeedbackMetricId,
        ///       dimensionFilter: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetMetricFeedbacks(RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricFeedbacksImplementation("MetricsAdvisorClient.GetMetricFeedbacks", content, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetMetricFeedbacksImplementation(string diagnosticsScopeName, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMetricFeedbacksRequest(content, skip, maxpagesize, context)
                        : CreateGetMetricFeedbacksNextPageRequest(nextLink, content, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List series (dimension combinations) from metric. </summary>
        /// <param name="metricId"> metric unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   activeSince: string (ISO 8601 Format) (required),
        ///   dimensionFilter: Dictionary&lt;string, string[]&gt;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       metricId: MetricSeriesItemMetricId,
        ///       dimension: Dictionary&lt;string, string&gt;
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetMetricSeriesAsync(Guid metricId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricSeriesImplementationAsync("MetricsAdvisorClient.GetMetricSeries", metricId, content, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetMetricSeriesImplementationAsync(string diagnosticsScopeName, Guid metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMetricSeriesRequest(metricId, content, skip, maxpagesize, context)
                        : CreateGetMetricSeriesNextPageRequest(nextLink, metricId, content, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List series (dimension combinations) from metric. </summary>
        /// <param name="metricId"> metric unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   activeSince: string (ISO 8601 Format) (required),
        ///   dimensionFilter: Dictionary&lt;string, string[]&gt;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       metricId: MetricSeriesItemMetricId,
        ///       dimension: Dictionary&lt;string, string&gt;
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetMetricSeries(Guid metricId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricSeriesImplementation("MetricsAdvisorClient.GetMetricSeries", metricId, content, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetMetricSeriesImplementation(string diagnosticsScopeName, Guid metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMetricSeriesRequest(metricId, content, skip, maxpagesize, context)
                        : CreateGetMetricSeriesNextPageRequest(nextLink, metricId, content, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List dimension from certain metric. </summary>
        /// <param name="metricId"> metric unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="metricId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="metricId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   dimensionName: string (required),
        ///   dimensionValueFilter: string
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetMetricDimensionAsync(string metricId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(metricId, nameof(metricId));
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricDimensionImplementationAsync("MetricsAdvisorClient.GetMetricDimension", metricId, content, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetMetricDimensionImplementationAsync(string diagnosticsScopeName, string metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMetricDimensionRequest(metricId, content, skip, maxpagesize, context)
                        : CreateGetMetricDimensionNextPageRequest(nextLink, metricId, content, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> List dimension from certain metric. </summary>
        /// <param name="metricId"> metric unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="metricId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="metricId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   dimensionName: string (required),
        ///   dimensionValueFilter: string
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetMetricDimension(string metricId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(metricId, nameof(metricId));
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricDimensionImplementation("MetricsAdvisorClient.GetMetricDimension", metricId, content, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetMetricDimensionImplementation(string diagnosticsScopeName, string metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetMetricDimensionRequest(metricId, content, skip, maxpagesize, context)
                        : CreateGetMetricDimensionNextPageRequest(nextLink, metricId, content, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query anomaly detection status. </summary>
        /// <param name="metricId"> metric unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       timestamp: string (ISO 8601 Format),
        ///       status: string,
        ///       message: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetEnrichmentStatusByMetricAsync(Guid metricId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetEnrichmentStatusByMetricImplementationAsync("MetricsAdvisorClient.GetEnrichmentStatusByMetric", metricId, content, skip, maxpagesize, context);
        }

        private AsyncPageable<BinaryData> GetEnrichmentStatusByMetricImplementationAsync(string diagnosticsScopeName, Guid metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetEnrichmentStatusByMetricRequest(metricId, content, skip, maxpagesize, context)
                        : CreateGetEnrichmentStatusByMetricNextPageRequest(nextLink, metricId, content, skip, maxpagesize, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "@nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query anomaly detection status. </summary>
        /// <param name="metricId"> metric unique id. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="skip"> for paging, skipped number. </param>
        /// <param name="maxpagesize"> the maximum number of items in one page. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       timestamp: string (ISO 8601 Format),
        ///       status: string,
        ///       message: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetEnrichmentStatusByMetric(Guid metricId, RequestContent content, int? skip = null, int? maxpagesize = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            return GetEnrichmentStatusByMetricImplementation("MetricsAdvisorClient.GetEnrichmentStatusByMetric", metricId, content, skip, maxpagesize, context);
        }

        private Pageable<BinaryData> GetEnrichmentStatusByMetricImplementation(string diagnosticsScopeName, Guid metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetEnrichmentStatusByMetricRequest(metricId, content, skip, maxpagesize, context)
                        : CreateGetEnrichmentStatusByMetricNextPageRequest(nextLink, metricId, content, skip, maxpagesize, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "@nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Query alerts under anomaly alerting configuration. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   timeMode: &quot;AnomalyTime&quot; | &quot;CreatedTime&quot; | &quot;ModifiedTime&quot; (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       alertId: string,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format)
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetAlertsByAnomalyAlertingConfigurationNextAsync(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetAlertsByAnomalyAlertingConfigurationNextImplementationAsync("MetricsAdvisorClient.GetAlertsByAnomalyAlertingConfigurationNext", nextLink, content, context);
        }

        private AsyncPageable<BinaryData> GetAlertsByAnomalyAlertingConfigurationNextImplementationAsync(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                using var message = CreateGetAlertsByAnomalyAlertingConfigurationNextRequest(nextLink, content, context);
                var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", null, cancellationToken).ConfigureAwait(false);
                yield return page;
            }
        }

        /// <summary> Query alerts under anomaly alerting configuration. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   timeMode: &quot;AnomalyTime&quot; | &quot;CreatedTime&quot; | &quot;ModifiedTime&quot; (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       alertId: string,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format)
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetAlertsByAnomalyAlertingConfigurationNext(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetAlertsByAnomalyAlertingConfigurationNextImplementation("MetricsAdvisorClient.GetAlertsByAnomalyAlertingConfigurationNext", nextLink, content, context);
        }

        private Pageable<BinaryData> GetAlertsByAnomalyAlertingConfigurationNextImplementation(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                using var message = CreateGetAlertsByAnomalyAlertingConfigurationNextRequest(nextLink, content, context);
                var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", null);
                yield return page;
            }
        }

        /// <summary> Query anomalies under anomaly detection configuration. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   filter: {
        ///     dimensionFilter: [
        ///       {
        ///         dimension: Dictionary&lt;string, string&gt; (required)
        ///       }
        ///     ],
        ///     severityFilter: {
        ///       min: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot; (required),
        ///       max: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot; (required)
        ///     }
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: AnomalyResultDataFeedId,
        ///       metricId: AnomalyResultMetricId,
        ///       anomalyDetectionConfigurationId: AnomalyResultAnomalyDetectionConfigurationId,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format),
        ///       dimension: Dictionary&lt;string, string&gt;,
        ///       property: {
        ///         anomalySeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         anomalyStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         value: number,
        ///         expectedValue: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetAnomaliesByAnomalyDetectionConfigurationNextAsync(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetAnomaliesByAnomalyDetectionConfigurationNextImplementationAsync("MetricsAdvisorClient.GetAnomaliesByAnomalyDetectionConfigurationNext", nextLink, content, context);
        }

        private AsyncPageable<BinaryData> GetAnomaliesByAnomalyDetectionConfigurationNextImplementationAsync(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                using var message = CreateGetAnomaliesByAnomalyDetectionConfigurationNextRequest(nextLink, content, context);
                var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", null, cancellationToken).ConfigureAwait(false);
                yield return page;
            }
        }

        /// <summary> Query anomalies under anomaly detection configuration. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   filter: {
        ///     dimensionFilter: [
        ///       {
        ///         dimension: Dictionary&lt;string, string&gt; (required)
        ///       }
        ///     ],
        ///     severityFilter: {
        ///       min: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot; (required),
        ///       max: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot; (required)
        ///     }
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       dataFeedId: AnomalyResultDataFeedId,
        ///       metricId: AnomalyResultMetricId,
        ///       anomalyDetectionConfigurationId: AnomalyResultAnomalyDetectionConfigurationId,
        ///       timestamp: string (ISO 8601 Format),
        ///       createdTime: string (ISO 8601 Format),
        ///       modifiedTime: string (ISO 8601 Format),
        ///       dimension: Dictionary&lt;string, string&gt;,
        ///       property: {
        ///         anomalySeverity: &quot;Low&quot; | &quot;Medium&quot; | &quot;High&quot;,
        ///         anomalyStatus: &quot;Active&quot; | &quot;Resolved&quot;,
        ///         value: number,
        ///         expectedValue: number
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetAnomaliesByAnomalyDetectionConfigurationNext(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetAnomaliesByAnomalyDetectionConfigurationNextImplementation("MetricsAdvisorClient.GetAnomaliesByAnomalyDetectionConfigurationNext", nextLink, content, context);
        }

        private Pageable<BinaryData> GetAnomaliesByAnomalyDetectionConfigurationNextImplementation(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                using var message = CreateGetAnomaliesByAnomalyDetectionConfigurationNextRequest(nextLink, content, context);
                var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", null);
                yield return page;
            }
        }

        /// <summary> Query dimension values of anomalies. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   dimensionName: string (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextAsync(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextImplementationAsync("MetricsAdvisorClient.GetDimensionOfAnomaliesByAnomalyDetectionConfigurationNext", nextLink, content, context);
        }

        private AsyncPageable<BinaryData> GetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextImplementationAsync(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                using var message = CreateGetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextRequest(nextLink, content, context);
                var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", null, cancellationToken).ConfigureAwait(false);
                yield return page;
            }
        }

        /// <summary> Query dimension values of anomalies. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required),
        ///   dimensionName: string (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDimensionOfAnomaliesByAnomalyDetectionConfigurationNext(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextImplementation("MetricsAdvisorClient.GetDimensionOfAnomaliesByAnomalyDetectionConfigurationNext", nextLink, content, context);
        }

        private Pageable<BinaryData> GetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextImplementation(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                using var message = CreateGetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextRequest(nextLink, content, context);
                var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", null);
                yield return page;
            }
        }

        /// <summary> List feedback on the given metric. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   metricId: MetricFeedbackFilterMetricId (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   },
        ///   feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///   startTime: string (ISO 8601 Format),
        ///   endTime: string (ISO 8601 Format),
        ///   timeMode: &quot;MetricTimestamp&quot; | &quot;FeedbackCreatedTime&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///       feedbackId: MetricFeedbackId,
        ///       createdTime: string (ISO 8601 Format),
        ///       userPrincipal: string,
        ///       metricId: MetricFeedbackMetricId,
        ///       dimensionFilter: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetMetricFeedbacksNextAsync(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricFeedbacksNextImplementationAsync("MetricsAdvisorClient.GetMetricFeedbacksNext", nextLink, content, context);
        }

        private AsyncPageable<BinaryData> GetMetricFeedbacksNextImplementationAsync(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                using var message = CreateGetMetricFeedbacksNextRequest(nextLink, content, context);
                var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", null, cancellationToken).ConfigureAwait(false);
                yield return page;
            }
        }

        /// <summary> List feedback on the given metric. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   metricId: MetricFeedbackFilterMetricId (required),
        ///   dimensionFilter: {
        ///     dimension: Dictionary&lt;string, string&gt; (required)
        ///   },
        ///   feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///   startTime: string (ISO 8601 Format),
        ///   endTime: string (ISO 8601 Format),
        ///   timeMode: &quot;MetricTimestamp&quot; | &quot;FeedbackCreatedTime&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       feedbackType: &quot;Anomaly&quot; | &quot;ChangePoint&quot; | &quot;Period&quot; | &quot;Comment&quot;,
        ///       feedbackId: MetricFeedbackId,
        ///       createdTime: string (ISO 8601 Format),
        ///       userPrincipal: string,
        ///       metricId: MetricFeedbackMetricId,
        ///       dimensionFilter: {
        ///         dimension: Dictionary&lt;string, string&gt;
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetMetricFeedbacksNext(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricFeedbacksNextImplementation("MetricsAdvisorClient.GetMetricFeedbacksNext", nextLink, content, context);
        }

        private Pageable<BinaryData> GetMetricFeedbacksNextImplementation(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                using var message = CreateGetMetricFeedbacksNextRequest(nextLink, content, context);
                var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", null);
                yield return page;
            }
        }

        /// <summary> Get data ingestion status by data feed. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       timestamp: string (ISO 8601 Format),
        ///       status: &quot;NotStarted&quot; | &quot;Scheduled&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;NoData&quot; | &quot;Error&quot; | &quot;Paused&quot;,
        ///       message: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDataFeedIngestionStatusNextAsync(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetDataFeedIngestionStatusNextImplementationAsync("MetricsAdvisorClient.GetDataFeedIngestionStatusNext", nextLink, content, context);
        }

        private AsyncPageable<BinaryData> GetDataFeedIngestionStatusNextImplementationAsync(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                using var message = CreateGetDataFeedIngestionStatusNextRequest(nextLink, content, context);
                var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", null, cancellationToken).ConfigureAwait(false);
                yield return page;
            }
        }

        /// <summary> Get data ingestion status by data feed. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       timestamp: string (ISO 8601 Format),
        ///       status: &quot;NotStarted&quot; | &quot;Scheduled&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot; | &quot;NoData&quot; | &quot;Error&quot; | &quot;Paused&quot;,
        ///       message: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDataFeedIngestionStatusNext(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetDataFeedIngestionStatusNextImplementation("MetricsAdvisorClient.GetDataFeedIngestionStatusNext", nextLink, content, context);
        }

        private Pageable<BinaryData> GetDataFeedIngestionStatusNextImplementation(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                using var message = CreateGetDataFeedIngestionStatusNextRequest(nextLink, content, context);
                var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", null);
                yield return page;
            }
        }

        /// <summary> List series (dimension combinations) from metric. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   activeSince: string (ISO 8601 Format) (required),
        ///   dimensionFilter: Dictionary&lt;string, string[]&gt;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       metricId: MetricSeriesItemMetricId,
        ///       dimension: Dictionary&lt;string, string&gt;
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetMetricSeriesNextAsync(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricSeriesNextImplementationAsync("MetricsAdvisorClient.GetMetricSeriesNext", nextLink, content, context);
        }

        private AsyncPageable<BinaryData> GetMetricSeriesNextImplementationAsync(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                using var message = CreateGetMetricSeriesNextRequest(nextLink, content, context);
                var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", null, cancellationToken).ConfigureAwait(false);
                yield return page;
            }
        }

        /// <summary> List series (dimension combinations) from metric. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   activeSince: string (ISO 8601 Format) (required),
        ///   dimensionFilter: Dictionary&lt;string, string[]&gt;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       metricId: MetricSeriesItemMetricId,
        ///       dimension: Dictionary&lt;string, string&gt;
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetMetricSeriesNext(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricSeriesNextImplementation("MetricsAdvisorClient.GetMetricSeriesNext", nextLink, content, context);
        }

        private Pageable<BinaryData> GetMetricSeriesNextImplementation(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                using var message = CreateGetMetricSeriesNextRequest(nextLink, content, context);
                var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", null);
                yield return page;
            }
        }

        /// <summary> List dimension from certain metric. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   dimensionName: string (required),
        ///   dimensionValueFilter: string
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetMetricDimensionNextAsync(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricDimensionNextImplementationAsync("MetricsAdvisorClient.GetMetricDimensionNext", nextLink, content, context);
        }

        private AsyncPageable<BinaryData> GetMetricDimensionNextImplementationAsync(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                using var message = CreateGetMetricDimensionNextRequest(nextLink, content, context);
                var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", null, cancellationToken).ConfigureAwait(false);
                yield return page;
            }
        }

        /// <summary> List dimension from certain metric. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   dimensionName: string (required),
        ///   dimensionValueFilter: string
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetMetricDimensionNext(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetMetricDimensionNextImplementation("MetricsAdvisorClient.GetMetricDimensionNext", nextLink, content, context);
        }

        private Pageable<BinaryData> GetMetricDimensionNextImplementation(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                using var message = CreateGetMetricDimensionNextRequest(nextLink, content, context);
                var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", null);
                yield return page;
            }
        }

        /// <summary> Query anomaly detection status. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       timestamp: string (ISO 8601 Format),
        ///       status: string,
        ///       message: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetEnrichmentStatusByMetricNextAsync(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetEnrichmentStatusByMetricNextImplementationAsync("MetricsAdvisorClient.GetEnrichmentStatusByMetricNext", nextLink, content, context);
        }

        private AsyncPageable<BinaryData> GetEnrichmentStatusByMetricNextImplementationAsync(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                using var message = CreateGetEnrichmentStatusByMetricNextRequest(nextLink, content, context);
                var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", null, cancellationToken).ConfigureAwait(false);
                yield return page;
            }
        }

        /// <summary> Query anomaly detection status. </summary>
        /// <param name="nextLink"> the next link. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format) (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   @nextLink: string,
        ///   value: [
        ///     {
        ///       timestamp: string (ISO 8601 Format),
        ///       status: string,
        ///       message: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   message: string,
        ///   code: string
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetEnrichmentStatusByMetricNext(string nextLink, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(content, nameof(content));

            return GetEnrichmentStatusByMetricNextImplementation("MetricsAdvisorClient.GetEnrichmentStatusByMetricNext", nextLink, content, context);
        }

        private Pageable<BinaryData> GetEnrichmentStatusByMetricNextImplementation(string diagnosticsScopeName, string nextLink, RequestContent content, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                using var message = CreateGetEnrichmentStatusByMetricNextRequest(nextLink, content, context);
                var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", null);
                yield return page;
            }
        }

        internal HttpMessage CreateGetActiveSeriesCountRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/stats/latest", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAlertsByAnomalyAlertingConfigurationRequest(Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/alert/anomaly/configurations/", false);
            uri.AppendPath(configurationId, true);
            uri.AppendPath("/alerts/query", false);
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetAnomaliesFromAlertByAnomalyAlertingConfigurationRequest(Guid configurationId, string alertId, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/alert/anomaly/configurations/", false);
            uri.AppendPath(configurationId, true);
            uri.AppendPath("/alerts/", false);
            uri.AppendPath(alertId, true);
            uri.AppendPath("/anomalies", false);
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetIncidentsFromAlertByAnomalyAlertingConfigurationRequest(Guid configurationId, string alertId, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/alert/anomaly/configurations/", false);
            uri.AppendPath(configurationId, true);
            uri.AppendPath("/alerts/", false);
            uri.AppendPath(alertId, true);
            uri.AppendPath("/incidents", false);
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetSeriesByAnomalyDetectionConfigurationRequest(Guid configurationId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/enrichment/anomalyDetection/configurations/", false);
            uri.AppendPath(configurationId, true);
            uri.AppendPath("/series/query", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetAnomaliesByAnomalyDetectionConfigurationRequest(Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/enrichment/anomalyDetection/configurations/", false);
            uri.AppendPath(configurationId, true);
            uri.AppendPath("/anomalies/query", false);
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDimensionOfAnomaliesByAnomalyDetectionConfigurationRequest(Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/enrichment/anomalyDetection/configurations/", false);
            uri.AppendPath(configurationId, true);
            uri.AppendPath("/anomalies/dimension/query", false);
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetIncidentsByAnomalyDetectionConfigurationRequest(Guid configurationId, RequestContent content, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/enrichment/anomalyDetection/configurations/", false);
            uri.AppendPath(configurationId, true);
            uri.AppendPath("/incidents/query", false);
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetIncidentsByAnomalyDetectionConfigurationNextPagesRequest(Guid configurationId, int? maxpagesize, string token, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/enrichment/anomalyDetection/configurations/", false);
            uri.AppendPath(configurationId, true);
            uri.AppendPath("/incidents/query", false);
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            if (token != null)
            {
                uri.AppendQuery("$token", token, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetRootCauseOfIncidentByAnomalyDetectionConfigurationRequest(Guid configurationId, string incidentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/enrichment/anomalyDetection/configurations/", false);
            uri.AppendPath(configurationId, true);
            uri.AppendPath("/incidents/", false);
            uri.AppendPath(incidentId, true);
            uri.AppendPath("/rootCause", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMetricFeedbackRequest(string feedbackId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/feedback/metric/", false);
            uri.AppendPath(feedbackId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMetricFeedbacksRequest(RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/feedback/metric/query", false);
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateMetricFeedbackRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/feedback/metric", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetMetricDataRequest(Guid metricId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/metrics/", false);
            uri.AppendPath(metricId, true);
            uri.AppendPath("/data/query", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetMetricSeriesRequest(Guid metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/metrics/", false);
            uri.AppendPath(metricId, true);
            uri.AppendPath("/series/query", false);
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetMetricDimensionRequest(string metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/metrics/", false);
            uri.AppendPath(metricId, true);
            uri.AppendPath("/dimension/query", false);
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetEnrichmentStatusByMetricRequest(Guid metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/metrics/", false);
            uri.AppendPath(metricId, true);
            uri.AppendPath("/status/enrichment/anomalyDetection/query", false);
            if (skip != null)
            {
                uri.AppendQuery("$skip", skip.Value, true);
            }
            if (maxpagesize != null)
            {
                uri.AppendQuery("$maxpagesize", maxpagesize.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetAlertsByAnomalyAlertingConfigurationNextRequest(string nextLink, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetAnomaliesByAnomalyDetectionConfigurationNextRequest(string nextLink, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextRequest(string nextLink, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetMetricFeedbacksNextRequest(string nextLink, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDataFeedIngestionStatusNextRequest(string nextLink, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetMetricSeriesNextRequest(string nextLink, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetMetricDimensionNextRequest(string nextLink, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetEnrichmentStatusByMetricNextRequest(string nextLink, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendPath("/", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetAlertsByAnomalyAlertingConfigurationNextPageRequest(string nextLink, Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAnomaliesFromAlertByAnomalyAlertingConfigurationNextPageRequest(string nextLink, Guid configurationId, string alertId, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetIncidentsFromAlertByAnomalyAlertingConfigurationNextPageRequest(string nextLink, Guid configurationId, string alertId, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAnomaliesByAnomalyDetectionConfigurationNextPageRequest(string nextLink, Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextPageRequest(string nextLink, Guid configurationId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetIncidentsByAnomalyDetectionConfigurationNextPageRequest(string nextLink, Guid configurationId, RequestContent content, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetIncidentsByAnomalyDetectionConfigurationNextPagesNextPageRequest(string nextLink, Guid configurationId, int? maxpagesize, string token, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMetricFeedbacksNextPageRequest(string nextLink, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMetricSeriesNextPageRequest(string nextLink, Guid metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetMetricDimensionNextPageRequest(string nextLink, string metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetEnrichmentStatusByMetricNextPageRequest(string nextLink, Guid metricId, RequestContent content, int? skip, int? maxpagesize, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/metricsadvisor/v1.0", false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
    }
}
