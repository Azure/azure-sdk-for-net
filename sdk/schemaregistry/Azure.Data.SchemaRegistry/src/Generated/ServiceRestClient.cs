// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Data.SchemaRegistry.Models;

namespace Azure.Data.SchemaRegistry
{
    internal partial class ServiceRestClient
    {
        private Uri endpoint;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of ServiceRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> server parameter. </param>
        public ServiceRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint = null)
        {
            endpoint ??= new Uri("");

            this.endpoint = endpoint;
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateGetGroupsRequest()
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups", false);
            request.Uri = uri;
            return message;
        }

        /// <summary> Get all schema groups in namespace. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<IReadOnlyList<string>>> GetGroupsAsync(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetGroupsRequest();
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<string> value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        List<string> array = new List<string>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(item.GetString());
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get all schema groups in namespace. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<IReadOnlyList<string>> GetGroups(CancellationToken cancellationToken = default)
        {
            using var message = CreateGetGroupsRequest();
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<string> value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        List<string> array = new List<string>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(item.GetString());
                        }
                        value = array;
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSchemaByIdRequest(string schemaId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/getSchemaById/", false);
            uri.AppendPath(schemaId, true);
            request.Uri = uri;
            return message;
        }

        /// <summary> Get schema by schema ID. </summary>
        /// <param name="schemaId"> schema ID referencing specific schema in registry namespace. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<string, ServiceGetSchemaByIdHeaders>> GetSchemaByIdAsync(string schemaId, CancellationToken cancellationToken = default)
        {
            if (schemaId == null)
            {
                throw new ArgumentNullException(nameof(schemaId));
            }

            using var message = CreateGetSchemaByIdRequest(schemaId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ServiceGetSchemaByIdHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        string value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = document.RootElement.GetString();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 404:
                    return ResponseWithHeaders.FromValue<string, ServiceGetSchemaByIdHeaders>(null, headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get schema by schema ID. </summary>
        /// <param name="schemaId"> schema ID referencing specific schema in registry namespace. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<string, ServiceGetSchemaByIdHeaders> GetSchemaById(string schemaId, CancellationToken cancellationToken = default)
        {
            if (schemaId == null)
            {
                throw new ArgumentNullException(nameof(schemaId));
            }

            using var message = CreateGetSchemaByIdRequest(schemaId);
            _pipeline.Send(message, cancellationToken);
            var headers = new ServiceGetSchemaByIdHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        string value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = document.RootElement.GetString();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 404:
                    return ResponseWithHeaders.FromValue<string, ServiceGetSchemaByIdHeaders>(null, headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetGroupRequest(string groupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            request.Uri = uri;
            return message;
        }

        /// <summary> Get schema group description in registry namespace. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<SchemaGroup>> GetGroupAsync(string groupName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }

            using var message = CreateGetGroupRequest(groupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaGroup value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SchemaGroup.DeserializeSchemaGroup(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue<SchemaGroup>(null, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get schema group description in registry namespace. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<SchemaGroup> GetGroup(string groupName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }

            using var message = CreateGetGroupRequest(groupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaGroup value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SchemaGroup.DeserializeSchemaGroup(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue<SchemaGroup>(null, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCreateOrUpdateGroupRequest(string groupName, SchemaGroup body, string ifMatch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            request.Uri = uri;
            if (ifMatch != null)
            {
                request.Headers.Add("If-Match", ifMatch);
            }
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(body);
            request.Content = content;
            return message;
        }

        /// <summary> Create or update schema group with specified schema type in registry namespace. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="body"> schema group description. </param>
        /// <param name="ifMatch"> Specify an ETag value to perform update operation only on schema group with a matching Guid value. If a &apos;*&apos; is supplied then update is performed without ETag check. Supplying empty value will enforce the create-only behavior. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<ServiceCreateOrUpdateGroupHeaders>> CreateOrUpdateGroupAsync(string groupName, SchemaGroup body, string ifMatch = null, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateCreateOrUpdateGroupRequest(groupName, body, ifMatch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ServiceCreateOrUpdateGroupHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                case 409:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Create or update schema group with specified schema type in registry namespace. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="body"> schema group description. </param>
        /// <param name="ifMatch"> Specify an ETag value to perform update operation only on schema group with a matching Guid value. If a &apos;*&apos; is supplied then update is performed without ETag check. Supplying empty value will enforce the create-only behavior. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<ServiceCreateOrUpdateGroupHeaders> CreateOrUpdateGroup(string groupName, SchemaGroup body, string ifMatch = null, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateCreateOrUpdateGroupRequest(groupName, body, ifMatch);
            _pipeline.Send(message, cancellationToken);
            var headers = new ServiceCreateOrUpdateGroupHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 201:
                case 409:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteGroupRequest(string groupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            request.Uri = uri;
            return message;
        }

        /// <summary> Delete schema group in schema registry namespace. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response> DeleteGroupAsync(string groupName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }

            using var message = CreateDeleteGroupRequest(groupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                case 404:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Delete schema group in schema registry namespace. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response DeleteGroup(string groupName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }

            using var message = CreateDeleteGroupRequest(groupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                case 404:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSchemasByGroupRequest(string groupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            uri.AppendPath("/schemas", false);
            request.Uri = uri;
            return message;
        }

        /// <summary> Returns schema by group name. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<IReadOnlyList<string>, ServiceGetSchemasByGroupHeaders>> GetSchemasByGroupAsync(string groupName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }

            using var message = CreateGetSchemasByGroupRequest(groupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ServiceGetSchemasByGroupHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<string> value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        List<string> array = new List<string>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(item.GetString());
                        }
                        value = array;
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 404:
                    return ResponseWithHeaders.FromValue<IReadOnlyList<string>, ServiceGetSchemasByGroupHeaders>(null, headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Returns schema by group name. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<IReadOnlyList<string>, ServiceGetSchemasByGroupHeaders> GetSchemasByGroup(string groupName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }

            using var message = CreateGetSchemasByGroupRequest(groupName);
            _pipeline.Send(message, cancellationToken);
            var headers = new ServiceGetSchemasByGroupHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<string> value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        List<string> array = new List<string>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(item.GetString());
                        }
                        value = array;
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 404:
                    return ResponseWithHeaders.FromValue<IReadOnlyList<string>, ServiceGetSchemasByGroupHeaders>(null, headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteSchemasByGroupRequest(string groupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            uri.AppendPath("/schemas", false);
            request.Uri = uri;
            return message;
        }

        /// <summary> Deletes all schemas under specified group name. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response> DeleteSchemasByGroupAsync(string groupName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }

            using var message = CreateDeleteSchemasByGroupRequest(groupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                case 404:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Deletes all schemas under specified group name. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response DeleteSchemasByGroup(string groupName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }

            using var message = CreateDeleteSchemasByGroupRequest(groupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                case 404:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetIdBySchemaContentRequest(string groupName, string schemaName, string xSchemaType, string body)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            uri.AppendPath("/schemas/", false);
            uri.AppendPath(schemaName, true);
            request.Uri = uri;
            request.Headers.Add("X-Schema-Type", xSchemaType);
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteStringValue(body);
            request.Content = content;
            return message;
        }

        /// <summary> Get ID for schema with matching byte content and schema type. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="xSchemaType"> The String to use. </param>
        /// <param name="body"> schema content. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<SchemaId, ServiceGetIdBySchemaContentHeaders>> GetIdBySchemaContentAsync(string groupName, string schemaName, string xSchemaType, string body, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }
            if (xSchemaType == null)
            {
                throw new ArgumentNullException(nameof(xSchemaType));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateGetIdBySchemaContentRequest(groupName, schemaName, xSchemaType, body);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ServiceGetIdBySchemaContentHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaId value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SchemaId.DeserializeSchemaId(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 404:
                    return ResponseWithHeaders.FromValue<SchemaId, ServiceGetIdBySchemaContentHeaders>(null, headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get ID for schema with matching byte content and schema type. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="xSchemaType"> The String to use. </param>
        /// <param name="body"> schema content. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<SchemaId, ServiceGetIdBySchemaContentHeaders> GetIdBySchemaContent(string groupName, string schemaName, string xSchemaType, string body, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }
            if (xSchemaType == null)
            {
                throw new ArgumentNullException(nameof(xSchemaType));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateGetIdBySchemaContentRequest(groupName, schemaName, xSchemaType, body);
            _pipeline.Send(message, cancellationToken);
            var headers = new ServiceGetIdBySchemaContentHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaId value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SchemaId.DeserializeSchemaId(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 404:
                    return ResponseWithHeaders.FromValue<SchemaId, ServiceGetIdBySchemaContentHeaders>(null, headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateCreateSchemaRequest(string groupName, string schemaName, string xSchemaType, string body)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            uri.AppendPath("/schemas/", false);
            uri.AppendPath(schemaName, true);
            request.Uri = uri;
            request.Headers.Add("X-Schema-Type", xSchemaType);
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteStringValue(body);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// Register schema. If schema of specified name does not exist in specified group, schema is created at version 1. If schema of specified name exists already in specified group, schema is created at latest version + 1. If schema with identical content already exists, existing schema&apos;s ID is returned.
        /// .
        /// </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="xSchemaType"> The String to use. </param>
        /// <param name="body"> schema content. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<SchemaId, ServiceCreateSchemaHeaders>> CreateSchemaAsync(string groupName, string schemaName, string xSchemaType, string body, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }
            if (xSchemaType == null)
            {
                throw new ArgumentNullException(nameof(xSchemaType));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateCreateSchemaRequest(groupName, schemaName, xSchemaType, body);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ServiceCreateSchemaHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaId value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SchemaId.DeserializeSchemaId(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 400:
                    return ResponseWithHeaders.FromValue<SchemaId, ServiceCreateSchemaHeaders>(null, headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Register schema. If schema of specified name does not exist in specified group, schema is created at version 1. If schema of specified name exists already in specified group, schema is created at latest version + 1. If schema with identical content already exists, existing schema&apos;s ID is returned.
        /// .
        /// </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="xSchemaType"> The String to use. </param>
        /// <param name="body"> schema content. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<SchemaId, ServiceCreateSchemaHeaders> CreateSchema(string groupName, string schemaName, string xSchemaType, string body, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }
            if (xSchemaType == null)
            {
                throw new ArgumentNullException(nameof(xSchemaType));
            }
            if (body == null)
            {
                throw new ArgumentNullException(nameof(body));
            }

            using var message = CreateCreateSchemaRequest(groupName, schemaName, xSchemaType, body);
            _pipeline.Send(message, cancellationToken);
            var headers = new ServiceCreateSchemaHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaId value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SchemaId.DeserializeSchemaId(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 400:
                    return ResponseWithHeaders.FromValue<SchemaId, ServiceCreateSchemaHeaders>(null, headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetLatestSchemaRequest(string groupName, string schemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            uri.AppendPath("/schemas/", false);
            uri.AppendPath(schemaName, true);
            request.Uri = uri;
            return message;
        }

        /// <summary> Get latest version of schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<string, ServiceGetLatestSchemaHeaders>> GetLatestSchemaAsync(string groupName, string schemaName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateGetLatestSchemaRequest(groupName, schemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ServiceGetLatestSchemaHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        string value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = document.RootElement.GetString();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get latest version of schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<string, ServiceGetLatestSchemaHeaders> GetLatestSchema(string groupName, string schemaName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateGetLatestSchemaRequest(groupName, schemaName);
            _pipeline.Send(message, cancellationToken);
            var headers = new ServiceGetLatestSchemaHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        string value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = document.RootElement.GetString();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteSchemaRequest(string groupName, string schemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            uri.AppendPath("/schemas/", false);
            uri.AppendPath(schemaName, true);
            request.Uri = uri;
            return message;
        }

        /// <summary> Delete schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response> DeleteSchemaAsync(string groupName, string schemaName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateDeleteSchemaRequest(groupName, schemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                case 404:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Delete schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response DeleteSchema(string groupName, string schemaName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateDeleteSchemaRequest(groupName, schemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                case 404:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSchemaVersionsRequest(string groupName, string schemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            uri.AppendPath("/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions", false);
            request.Uri = uri;
            return message;
        }

        /// <summary> Get list of versions for specified schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<IReadOnlyList<int>, ServiceGetSchemaVersionsHeaders>> GetSchemaVersionsAsync(string groupName, string schemaName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateGetSchemaVersionsRequest(groupName, schemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ServiceGetSchemaVersionsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<int> value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        List<int> array = new List<int>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(item.GetInt32());
                        }
                        value = array;
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get list of versions for specified schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<IReadOnlyList<int>, ServiceGetSchemaVersionsHeaders> GetSchemaVersions(string groupName, string schemaName, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateGetSchemaVersionsRequest(groupName, schemaName);
            _pipeline.Send(message, cancellationToken);
            var headers = new ServiceGetSchemaVersionsHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        IReadOnlyList<int> value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        List<int> array = new List<int>();
                        foreach (var item in document.RootElement.EnumerateArray())
                        {
                            array.Add(item.GetInt32());
                        }
                        value = array;
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSchemaVersionRequest(string groupName, string schemaName, int versionNumber)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            uri.AppendPath("/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionNumber, true);
            request.Uri = uri;
            return message;
        }

        /// <summary> Get specified version of schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="versionNumber"> version number. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<string, ServiceGetSchemaVersionHeaders>> GetSchemaVersionAsync(string groupName, string schemaName, int versionNumber, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateGetSchemaVersionRequest(groupName, schemaName, versionNumber);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new ServiceGetSchemaVersionHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        string value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = document.RootElement.GetString();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 404:
                    return ResponseWithHeaders.FromValue<string, ServiceGetSchemaVersionHeaders>(null, headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Get specified version of schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="versionNumber"> version number. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<string, ServiceGetSchemaVersionHeaders> GetSchemaVersion(string groupName, string schemaName, int versionNumber, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateGetSchemaVersionRequest(groupName, schemaName, versionNumber);
            _pipeline.Send(message, cancellationToken);
            var headers = new ServiceGetSchemaVersionHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        string value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = document.RootElement.GetString();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                case 404:
                    return ResponseWithHeaders.FromValue<string, ServiceGetSchemaVersionHeaders>(null, headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateDeleteSchemaVersionRequest(string groupName, string schemaName, int versionNumber)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(endpoint);
            uri.AppendPath("/$schemagroups/", false);
            uri.AppendPath(groupName, true);
            uri.AppendPath("/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionNumber, true);
            request.Uri = uri;
            return message;
        }

        /// <summary> Delete specified version of schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="versionNumber"> version number. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response> DeleteSchemaVersionAsync(string groupName, string schemaName, int versionNumber, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateDeleteSchemaVersionRequest(groupName, schemaName, versionNumber);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary> Delete specified version of schema. </summary>
        /// <param name="groupName"> schema group. </param>
        /// <param name="schemaName"> schema name. </param>
        /// <param name="versionNumber"> version number. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response DeleteSchemaVersion(string groupName, string schemaName, int versionNumber, CancellationToken cancellationToken = default)
        {
            if (groupName == null)
            {
                throw new ArgumentNullException(nameof(groupName));
            }
            if (schemaName == null)
            {
                throw new ArgumentNullException(nameof(schemaName));
            }

            using var message = CreateDeleteSchemaVersionRequest(groupName, schemaName, versionNumber);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 204:
                    return message.Response;
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
