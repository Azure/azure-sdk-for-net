// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager;
using Azure.ResourceManager.Resources;
using Azure.ResourceManager.WorkloadOrchestration;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Mocking
{
    /// <summary> A class to add extension methods to <see cref="ResourceGroupResource"/>. </summary>
    public partial class MockableWorkloadOrchestrationResourceGroupResource : ArmResource
    {
        private ClientDiagnostics _schemasClientDiagnostics;
        private Schemas _schemasRestClient;
        private ClientDiagnostics _targetsClientDiagnostics;
        private Targets _targetsRestClient;
        private ClientDiagnostics _solutionTemplateVersionsClientDiagnostics;
        private SolutionTemplateVersions _solutionTemplateVersionsRestClient;
        private ClientDiagnostics _solutionTemplatesClientDiagnostics;
        private SolutionTemplates _solutionTemplatesRestClient;
        private ClientDiagnostics _configTemplatesClientDiagnostics;
        private ConfigTemplates _configTemplatesRestClient;

        /// <summary> Initializes a new instance of MockableWorkloadOrchestrationResourceGroupResource for mocking. </summary>
        protected MockableWorkloadOrchestrationResourceGroupResource()
        {
        }

        /// <summary> Initializes a new instance of <see cref="MockableWorkloadOrchestrationResourceGroupResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal MockableWorkloadOrchestrationResourceGroupResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
        }

        private ClientDiagnostics SchemasClientDiagnostics => _schemasClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration.Mocking", ProviderConstants.DefaultProviderNamespace, Diagnostics);

        private Schemas SchemasRestClient => _schemasRestClient ??= new Schemas(SchemasClientDiagnostics, Pipeline, Endpoint, "2025-06-01");

        private ClientDiagnostics TargetsClientDiagnostics => _targetsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration.Mocking", ProviderConstants.DefaultProviderNamespace, Diagnostics);

        private Targets TargetsRestClient => _targetsRestClient ??= new Targets(TargetsClientDiagnostics, Pipeline, Endpoint, "2025-06-01");

        private ClientDiagnostics SolutionTemplateVersionsClientDiagnostics => _solutionTemplateVersionsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration.Mocking", ProviderConstants.DefaultProviderNamespace, Diagnostics);

        private SolutionTemplateVersions SolutionTemplateVersionsRestClient => _solutionTemplateVersionsRestClient ??= new SolutionTemplateVersions(SolutionTemplateVersionsClientDiagnostics, Pipeline, Endpoint, "2025-06-01");

        private ClientDiagnostics SolutionTemplatesClientDiagnostics => _solutionTemplatesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration.Mocking", ProviderConstants.DefaultProviderNamespace, Diagnostics);

        private SolutionTemplates SolutionTemplatesRestClient => _solutionTemplatesRestClient ??= new SolutionTemplates(SolutionTemplatesClientDiagnostics, Pipeline, Endpoint, "2025-06-01");

        private ClientDiagnostics ConfigTemplatesClientDiagnostics => _configTemplatesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration.Mocking", ProviderConstants.DefaultProviderNamespace, Diagnostics);

        private ConfigTemplates ConfigTemplatesRestClient => _configTemplatesRestClient ??= new ConfigTemplates(ConfigTemplatesClientDiagnostics, Pipeline, Endpoint, "2025-06-01");

        /// <summary> Gets a collection of EdgeSchemas in the <see cref="ResourceGroupResource"/>. </summary>
        /// <returns> An object representing collection of EdgeSchemas and their operations over a EdgeSchemaResource. </returns>
        public virtual EdgeSchemaCollection GetEdgeSchemas()
        {
            return GetCachedClient(client => new EdgeSchemaCollection(client, Id));
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Schemas_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSchemaResource>> GetEdgeSchemaAsync(string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            return await GetEdgeSchemas().GetAsync(schemaName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Schemas_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSchemaResource> GetEdgeSchema(string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            return GetEdgeSchemas().Get(schemaName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeTargets in the <see cref="ResourceGroupResource"/>. </summary>
        /// <returns> An object representing collection of EdgeTargets and their operations over a EdgeTargetResource. </returns>
        public virtual EdgeTargetCollection GetEdgeTargets()
        {
            return GetCachedClient(client => new EdgeTargetCollection(client, Id));
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeTargetResource>> GetEdgeTargetAsync(string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            return await GetEdgeTargets().GetAsync(targetName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeTargetResource> GetEdgeTarget(string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            return GetEdgeTargets().Get(targetName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeSolutionTemplates in the <see cref="ResourceGroupResource"/>. </summary>
        /// <returns> An object representing collection of EdgeSolutionTemplates and their operations over a EdgeSolutionTemplateResource. </returns>
        public virtual EdgeSolutionTemplateCollection GetEdgeSolutionTemplates()
        {
            return GetCachedClient(client => new EdgeSolutionTemplateCollection(client, Id));
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplates_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSolutionTemplateResource>> GetEdgeSolutionTemplateAsync(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            return await GetEdgeSolutionTemplates().GetAsync(solutionTemplateName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplates_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSolutionTemplateResource> GetEdgeSolutionTemplate(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            return GetEdgeSolutionTemplates().Get(solutionTemplateName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeConfigTemplates in the <see cref="ResourceGroupResource"/>. </summary>
        /// <returns> An object representing collection of EdgeConfigTemplates and their operations over a EdgeConfigTemplateResource. </returns>
        public virtual EdgeConfigTemplateCollection GetEdgeConfigTemplates()
        {
            return GetCachedClient(client => new EdgeConfigTemplateCollection(client, Id));
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> ConfigTemplates_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeConfigTemplateResource>> GetEdgeConfigTemplateAsync(string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            return await GetEdgeConfigTemplates().GetAsync(configTemplateName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> ConfigTemplates_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeConfigTemplateResource> GetEdgeConfigTemplate(string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            return GetEdgeConfigTemplates().Get(configTemplateName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeDiagnostics in the <see cref="ResourceGroupResource"/>. </summary>
        /// <returns> An object representing collection of EdgeDiagnostics and their operations over a EdgeDiagnosticResource. </returns>
        public virtual EdgeDiagnosticCollection GetEdgeDiagnostics()
        {
            return GetCachedClient(client => new EdgeDiagnosticCollection(client, Id));
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Diagnostics_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeDiagnosticResource>> GetEdgeDiagnosticAsync(string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            return await GetEdgeDiagnostics().GetAsync(diagnosticName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Diagnostics_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeDiagnosticResource> GetEdgeDiagnostic(string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            return GetEdgeDiagnostics().Get(diagnosticName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeContexts in the <see cref="ResourceGroupResource"/>. </summary>
        /// <returns> An object representing collection of EdgeContexts and their operations over a EdgeContextResource. </returns>
        public virtual EdgeContextCollection GetEdgeContexts()
        {
            return GetCachedClient(client => new EdgeContextCollection(client, Id));
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Contexts_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeContextResource>> GetEdgeContextAsync(string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            return await GetEdgeContexts().GetAsync(contextName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Contexts_Get. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeContextResource> GetEdgeContext(string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            return GetEdgeContexts().Get(contextName, cancellationToken);
        }

        /// <summary>
        /// Create a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/createVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Schemas_CreateVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation<EdgeSchemaVersionResource>> CreateVersionAsync(WaitUntil waitUntil, string schemaName, EdgeSchemaVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(body, nameof(body));

            using DiagnosticScope scope = SchemasClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.CreateVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SchemasRestClient.CreateCreateVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, schemaName, EdgeSchemaVersionWithUpdateType.ToRequestContent(body), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation<EdgeSchemaVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSchemaVersionResource>(
                    new EdgeSchemaVersionOperationSource(Client),
                    SchemasClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/createVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Schemas_CreateVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation<EdgeSchemaVersionResource> CreateVersion(WaitUntil waitUntil, string schemaName, EdgeSchemaVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(body, nameof(body));

            using DiagnosticScope scope = SchemasClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.CreateVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SchemasRestClient.CreateCreateVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, schemaName, EdgeSchemaVersionWithUpdateType.ToRequestContent(body), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation<EdgeSchemaVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSchemaVersionResource>(
                    new EdgeSchemaVersionOperationSource(Client),
                    SchemasClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletion(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/removeVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Schemas_RemoveVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<RemoveVersionResult>> RemoveVersionAsync(string schemaName, EdgeVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = SchemasClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.RemoveVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SchemasRestClient.CreateRemoveVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, schemaName, EdgeVersionContent.ToRequestContent(content), context);
                Response result = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                Response<RemoveVersionResult> response = Response.FromValue(RemoveVersionResult.FromResponse(result), result);
                if (response.Value == null)
                {
                    throw new RequestFailedException(response.GetRawResponse());
                }
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/removeVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Schemas_RemoveVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<RemoveVersionResult> RemoveVersion(string schemaName, EdgeVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = SchemasClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.RemoveVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SchemasRestClient.CreateRemoveVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, schemaName, EdgeVersionContent.ToRequestContent(content), context);
                Response result = Pipeline.ProcessMessage(message, context);
                Response<RemoveVersionResult> response = Response.FromValue(RemoveVersionResult.FromResponse(result), result);
                if (response.Value == null)
                {
                    throw new RequestFailedException(response.GetRawResponse());
                }
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to deploy
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/installSolution. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_InstallSolution. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation> InstallSolutionAsync(WaitUntil waitUntil, string targetName, InstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.InstallSolution");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateInstallSolutionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, InstallSolutionContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(TargetsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to deploy
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/installSolution. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_InstallSolution. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation InstallSolution(WaitUntil waitUntil, string targetName, InstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.InstallSolution");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateInstallSolutionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, InstallSolutionContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(TargetsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletionResponse(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to uninstall
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/uninstallSolution. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_UninstallSolution. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation> UninstallSolutionAsync(WaitUntil waitUntil, string targetName, UninstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.UninstallSolution");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateUninstallSolutionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, UninstallSolutionContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(TargetsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to uninstall
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/uninstallSolution. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_UninstallSolution. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation UninstallSolution(WaitUntil waitUntil, string targetName, UninstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.UninstallSolution");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateUninstallSolutionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, UninstallSolutionContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(TargetsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletionResponse(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to remove solution version revision
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/removeRevision. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_RemoveRevision. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation> RemoveRevisionAsync(WaitUntil waitUntil, string targetName, RemoveRevisionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.RemoveRevision");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateRemoveRevisionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, RemoveRevisionContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(TargetsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to remove solution version revision
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/removeRevision. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_RemoveRevision. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation RemoveRevision(WaitUntil waitUntil, string targetName, RemoveRevisionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.RemoveRevision");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateRemoveRevisionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, RemoveRevisionContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(TargetsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletionResponse(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to resolve configuration
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/resolveConfiguration. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_ResolveConfiguration. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation<ResolvedConfiguration>> ResolveConfigurationAsync(WaitUntil waitUntil, string targetName, EdgeSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.ResolveConfiguration");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateResolveConfigurationRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, EdgeSolutionTemplateContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation<ResolvedConfiguration> operation = new WorkloadOrchestrationArmOperation<ResolvedConfiguration>(
                    new ResolvedConfigurationOperationSource(),
                    TargetsClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to resolve configuration
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/resolveConfiguration. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_ResolveConfiguration. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation<ResolvedConfiguration> ResolveConfiguration(WaitUntil waitUntil, string targetName, EdgeSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.ResolveConfiguration");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateResolveConfigurationRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, EdgeSolutionTemplateContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation<ResolvedConfiguration> operation = new WorkloadOrchestrationArmOperation<ResolvedConfiguration>(
                    new ResolvedConfigurationOperationSource(),
                    TargetsClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletion(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to review configuration
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/reviewSolutionVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_ReviewSolutionVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionVersionResource>> ReviewSolutionVersionAsync(WaitUntil waitUntil, string targetName, EdgeSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.ReviewSolutionVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateReviewSolutionVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, EdgeSolutionTemplateContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(
                    new EdgeSolutionVersionOperationSource(Client),
                    TargetsClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to review configuration
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/reviewSolutionVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_ReviewSolutionVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation<EdgeSolutionVersionResource> ReviewSolutionVersion(WaitUntil waitUntil, string targetName, EdgeSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.ReviewSolutionVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateReviewSolutionVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, EdgeSolutionTemplateContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(
                    new EdgeSolutionVersionOperationSource(Client),
                    TargetsClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletion(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to publish
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/publishSolutionVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_PublishSolutionVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionVersionResource>> PublishSolutionVersionAsync(WaitUntil waitUntil, string targetName, EdgeSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.PublishSolutionVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreatePublishSolutionVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, EdgeSolutionVersionContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(
                    new EdgeSolutionVersionOperationSource(Client),
                    TargetsClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to publish
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/publishSolutionVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_PublishSolutionVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation<EdgeSolutionVersionResource> PublishSolutionVersion(WaitUntil waitUntil, string targetName, EdgeSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.PublishSolutionVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreatePublishSolutionVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, EdgeSolutionVersionContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(
                    new EdgeSolutionVersionOperationSource(Client),
                    TargetsClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletion(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to update external validation status
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/updateExternalValidationStatus. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_UpdateExternalValidationStatus. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionVersionResource>> UpdateExternalValidationStatusAsync(WaitUntil waitUntil, string targetName, UpdateExternalValidationStatusContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.UpdateExternalValidationStatus");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateUpdateExternalValidationStatusRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, UpdateExternalValidationStatusContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(
                    new EdgeSolutionVersionOperationSource(Client),
                    TargetsClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to update external validation status
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/updateExternalValidationStatus. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> Targets_UpdateExternalValidationStatus. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation<EdgeSolutionVersionResource> UpdateExternalValidationStatus(WaitUntil waitUntil, string targetName, UpdateExternalValidationStatusContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = TargetsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.UpdateExternalValidationStatus");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = TargetsRestClient.CreateUpdateExternalValidationStatusRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, targetName, UpdateExternalValidationStatusContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(
                    new EdgeSolutionVersionOperationSource(Client),
                    TargetsClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletion(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk deploy
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkDeploySolution. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplateVersions_BulkDeploySolution. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation> BulkDeploySolutionAsync(WaitUntil waitUntil, string solutionTemplateName, string solutionTemplateVersionName, BulkDeploySolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = SolutionTemplateVersionsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.BulkDeploySolution");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SolutionTemplateVersionsRestClient.CreateBulkDeploySolutionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, solutionTemplateName, solutionTemplateVersionName, BulkDeploySolutionContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(SolutionTemplateVersionsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk deploy
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkDeploySolution. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplateVersions_BulkDeploySolution. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation BulkDeploySolution(WaitUntil waitUntil, string solutionTemplateName, string solutionTemplateVersionName, BulkDeploySolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = SolutionTemplateVersionsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.BulkDeploySolution");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SolutionTemplateVersionsRestClient.CreateBulkDeploySolutionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, solutionTemplateName, solutionTemplateVersionName, BulkDeploySolutionContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(SolutionTemplateVersionsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletionResponse(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk publish
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkPublishSolution. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplateVersions_BulkPublishSolution. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation> BulkPublishSolutionAsync(WaitUntil waitUntil, string solutionTemplateName, string solutionTemplateVersionName, BulkPublishSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = SolutionTemplateVersionsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.BulkPublishSolution");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SolutionTemplateVersionsRestClient.CreateBulkPublishSolutionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, solutionTemplateName, solutionTemplateVersionName, BulkPublishSolutionContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(SolutionTemplateVersionsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk publish
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkPublishSolution. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplateVersions_BulkPublishSolution. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation BulkPublishSolution(WaitUntil waitUntil, string solutionTemplateName, string solutionTemplateVersionName, BulkPublishSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = SolutionTemplateVersionsClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.BulkPublishSolution");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SolutionTemplateVersionsRestClient.CreateBulkPublishSolutionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, solutionTemplateName, solutionTemplateVersionName, BulkPublishSolutionContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(SolutionTemplateVersionsClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletionResponse(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/createVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplates_CreateVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionTemplateVersionResource>> CreateVersionAsync(WaitUntil waitUntil, string solutionTemplateName, EdgeSolutionTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(body, nameof(body));

            using DiagnosticScope scope = SolutionTemplatesClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.CreateVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SolutionTemplatesRestClient.CreateCreateVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, solutionTemplateName, EdgeSolutionTemplateVersionWithUpdateType.ToRequestContent(body), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation<EdgeSolutionTemplateVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSolutionTemplateVersionResource>(
                    new EdgeSolutionTemplateVersionOperationSource(Client),
                    SolutionTemplatesClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/createVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplates_CreateVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation<EdgeSolutionTemplateVersionResource> CreateVersion(WaitUntil waitUntil, string solutionTemplateName, EdgeSolutionTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(body, nameof(body));

            using DiagnosticScope scope = SolutionTemplatesClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.CreateVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SolutionTemplatesRestClient.CreateCreateVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, solutionTemplateName, EdgeSolutionTemplateVersionWithUpdateType.ToRequestContent(body), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation<EdgeSolutionTemplateVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeSolutionTemplateVersionResource>(
                    new EdgeSolutionTemplateVersionOperationSource(Client),
                    SolutionTemplatesClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletion(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/removeVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplates_RemoveVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation> RemoveVersionAsync(WaitUntil waitUntil, string solutionTemplateName, EdgeVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = SolutionTemplatesClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.RemoveVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SolutionTemplatesRestClient.CreateRemoveVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, solutionTemplateName, EdgeVersionContent.ToRequestContent(content), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(SolutionTemplatesClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/removeVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> SolutionTemplates_RemoveVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation RemoveVersion(WaitUntil waitUntil, string solutionTemplateName, EdgeVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = SolutionTemplatesClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.RemoveVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = SolutionTemplatesRestClient.CreateRemoveVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, solutionTemplateName, EdgeVersionContent.ToRequestContent(content), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation operation = new WorkloadOrchestrationArmOperation(SolutionTemplatesClientDiagnostics, Pipeline, message.Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletionResponse(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Config Template Version Resource with the specified UpdateType
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/createVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> ConfigTemplates_CreateVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<ArmOperation<EdgeConfigTemplateVersionResource>> CreateVersionAsync(WaitUntil waitUntil, string configTemplateName, ConfigTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(body, nameof(body));

            using DiagnosticScope scope = ConfigTemplatesClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.CreateVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = ConfigTemplatesRestClient.CreateCreateVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, configTemplateName, ConfigTemplateVersionWithUpdateType.ToRequestContent(body), context);
                Response response = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                WorkloadOrchestrationArmOperation<EdgeConfigTemplateVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeConfigTemplateVersionResource>(
                    new EdgeConfigTemplateVersionOperationSource(Client),
                    ConfigTemplatesClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Config Template Version Resource with the specified UpdateType
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/createVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> ConfigTemplates_CreateVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual ArmOperation<EdgeConfigTemplateVersionResource> CreateVersion(WaitUntil waitUntil, string configTemplateName, ConfigTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(body, nameof(body));

            using DiagnosticScope scope = ConfigTemplatesClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.CreateVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = ConfigTemplatesRestClient.CreateCreateVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, configTemplateName, ConfigTemplateVersionWithUpdateType.ToRequestContent(body), context);
                Response response = Pipeline.ProcessMessage(message, context);
                WorkloadOrchestrationArmOperation<EdgeConfigTemplateVersionResource> operation = new WorkloadOrchestrationArmOperation<EdgeConfigTemplateVersionResource>(
                    new EdgeConfigTemplateVersionOperationSource(Client),
                    ConfigTemplatesClientDiagnostics,
                    Pipeline,
                    message.Request,
                    response,
                    OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                {
                    operation.WaitForCompletion(cancellationToken);
                }
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/removeVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> ConfigTemplates_RemoveVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual async Task<Response<RemoveVersionResult>> RemoveVersionAsync(string configTemplateName, EdgeVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = ConfigTemplatesClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.RemoveVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = ConfigTemplatesRestClient.CreateRemoveVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, configTemplateName, EdgeVersionContent.ToRequestContent(content), context);
                Response result = await Pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
                Response<RemoveVersionResult> response = Response.FromValue(RemoveVersionResult.FromResponse(result), result);
                if (response.Value == null)
                {
                    throw new RequestFailedException(response.GetRawResponse());
                }
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term> Request Path. </term>
        /// <description> /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/removeVersion. </description>
        /// </item>
        /// <item>
        /// <term> Operation Id. </term>
        /// <description> ConfigTemplates_RemoveVersion. </description>
        /// </item>
        /// <item>
        /// <term> Default Api Version. </term>
        /// <description> 2025-06-01. </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public virtual Response<RemoveVersionResult> RemoveVersion(string configTemplateName, EdgeVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(content, nameof(content));

            using DiagnosticScope scope = ConfigTemplatesClientDiagnostics.CreateScope("MockableWorkloadOrchestrationResourceGroupResource.RemoveVersion");
            scope.Start();
            try
            {
                RequestContext context = new RequestContext
                {
                    CancellationToken = cancellationToken
                };
                HttpMessage message = ConfigTemplatesRestClient.CreateRemoveVersionRequest(Guid.Parse(Id.SubscriptionId), Id.ResourceGroupName, configTemplateName, EdgeVersionContent.ToRequestContent(content), context);
                Response result = Pipeline.ProcessMessage(message, context);
                Response<RemoveVersionResult> response = Response.FromValue(RemoveVersionResult.FromResponse(result), result);
                if (response.Value == null)
                {
                    throw new RequestFailedException(response.GetRawResponse());
                }
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
