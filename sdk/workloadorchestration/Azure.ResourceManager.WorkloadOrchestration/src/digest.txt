Directory structure:
└── src/
    ├── autorest.md
    ├── Azure.ResourceManager.WorkloadOrchestration.csproj
    └── Generated/
        ├── ArmWorkloadOrchestrationModelFactory.cs
        ├── EdgeConfigTemplateCollection.cs
        ├── EdgeConfigTemplateData.cs
        ├── EdgeConfigTemplateData.Serialization.cs
        ├── EdgeConfigTemplateResource.cs
        ├── EdgeConfigTemplateResource.Serialization.cs
        ├── EdgeConfigTemplateVersionCollection.cs
        ├── EdgeConfigTemplateVersionData.cs
        ├── EdgeConfigTemplateVersionData.Serialization.cs
        ├── EdgeConfigTemplateVersionResource.cs
        ├── EdgeConfigTemplateVersionResource.Serialization.cs
        ├── EdgeContextCollection.cs
        ├── EdgeContextData.cs
        ├── EdgeContextData.Serialization.cs
        ├── EdgeContextResource.cs
        ├── EdgeContextResource.Serialization.cs
        ├── EdgeDeploymentInstanceCollection.cs
        ├── EdgeDeploymentInstanceData.cs
        ├── EdgeDeploymentInstanceData.Serialization.cs
        ├── EdgeDeploymentInstanceHistoryCollection.cs
        ├── EdgeDeploymentInstanceHistoryData.cs
        ├── EdgeDeploymentInstanceHistoryData.Serialization.cs
        ├── EdgeDeploymentInstanceHistoryResource.cs
        ├── EdgeDeploymentInstanceHistoryResource.Serialization.cs
        ├── EdgeDeploymentInstanceResource.cs
        ├── EdgeDeploymentInstanceResource.Serialization.cs
        ├── EdgeDiagnosticCollection.cs
        ├── EdgeDiagnosticData.cs
        ├── EdgeDiagnosticData.Serialization.cs
        ├── EdgeDiagnosticResource.cs
        ├── EdgeDiagnosticResource.Serialization.cs
        ├── EdgeDynamicSchemaCollection.cs
        ├── EdgeDynamicSchemaData.cs
        ├── EdgeDynamicSchemaData.Serialization.cs
        ├── EdgeDynamicSchemaResource.cs
        ├── EdgeDynamicSchemaResource.Serialization.cs
        ├── EdgeDynamicSchemaVersionCollection.cs
        ├── EdgeDynamicSchemaVersionData.cs
        ├── EdgeDynamicSchemaVersionData.Serialization.cs
        ├── EdgeDynamicSchemaVersionResource.cs
        ├── EdgeDynamicSchemaVersionResource.Serialization.cs
        ├── EdgeExecutionCollection.cs
        ├── EdgeExecutionData.cs
        ├── EdgeExecutionData.Serialization.cs
        ├── EdgeExecutionResource.cs
        ├── EdgeExecutionResource.Serialization.cs
        ├── EdgeJobCollection.cs
        ├── EdgeJobData.cs
        ├── EdgeJobData.Serialization.cs
        ├── EdgeJobResource.cs
        ├── EdgeJobResource.Serialization.cs
        ├── EdgeSchemaCollection.cs
        ├── EdgeSchemaData.cs
        ├── EdgeSchemaData.Serialization.cs
        ├── EdgeSchemaReferenceCollection.cs
        ├── EdgeSchemaReferenceData.cs
        ├── EdgeSchemaReferenceData.Serialization.cs
        ├── EdgeSchemaReferenceResource.cs
        ├── EdgeSchemaReferenceResource.Serialization.cs
        ├── EdgeSchemaResource.cs
        ├── EdgeSchemaResource.Serialization.cs
        ├── EdgeSchemaVersionCollection.cs
        ├── EdgeSchemaVersionData.cs
        ├── EdgeSchemaVersionData.Serialization.cs
        ├── EdgeSchemaVersionResource.cs
        ├── EdgeSchemaVersionResource.Serialization.cs
        ├── EdgeSiteReferenceCollection.cs
        ├── EdgeSiteReferenceData.cs
        ├── EdgeSiteReferenceData.Serialization.cs
        ├── EdgeSiteReferenceResource.cs
        ├── EdgeSiteReferenceResource.Serialization.cs
        ├── EdgeSolutionCollection.cs
        ├── EdgeSolutionData.cs
        ├── EdgeSolutionData.Serialization.cs
        ├── EdgeSolutionResource.cs
        ├── EdgeSolutionResource.Serialization.cs
        ├── EdgeSolutionTemplateCollection.cs
        ├── EdgeSolutionTemplateData.cs
        ├── EdgeSolutionTemplateData.Serialization.cs
        ├── EdgeSolutionTemplateResource.cs
        ├── EdgeSolutionTemplateResource.Serialization.cs
        ├── EdgeSolutionTemplateVersionCollection.cs
        ├── EdgeSolutionTemplateVersionData.cs
        ├── EdgeSolutionTemplateVersionData.Serialization.cs
        ├── EdgeSolutionTemplateVersionResource.cs
        ├── EdgeSolutionTemplateVersionResource.Serialization.cs
        ├── EdgeSolutionVersionCollection.cs
        ├── EdgeSolutionVersionData.cs
        ├── EdgeSolutionVersionData.Serialization.cs
        ├── EdgeSolutionVersionResource.cs
        ├── EdgeSolutionVersionResource.Serialization.cs
        ├── EdgeTargetCollection.cs
        ├── EdgeTargetData.cs
        ├── EdgeTargetData.Serialization.cs
        ├── EdgeTargetResource.cs
        ├── EdgeTargetResource.Serialization.cs
        ├── EdgeWorkflowCollection.cs
        ├── EdgeWorkflowData.cs
        ├── EdgeWorkflowData.Serialization.cs
        ├── EdgeWorkflowResource.cs
        ├── EdgeWorkflowResource.Serialization.cs
        ├── EdgeWorkflowVersionCollection.cs
        ├── EdgeWorkflowVersionData.cs
        ├── EdgeWorkflowVersionData.Serialization.cs
        ├── EdgeWorkflowVersionResource.cs
        ├── EdgeWorkflowVersionResource.Serialization.cs
        ├── ProviderConstants.cs
        ├── Extensions/
        │   ├── MockableWorkloadOrchestrationArmClient.cs
        │   ├── MockableWorkloadOrchestrationResourceGroupResource.cs
        │   ├── MockableWorkloadOrchestrationSubscriptionResource.cs
        │   └── WorkloadOrchestrationExtensions.cs
        ├── Internal/
        │   ├── Argument.cs
        │   ├── ChangeTrackingDictionary.cs
        │   ├── ChangeTrackingList.cs
        │   ├── ModelSerializationExtensions.cs
        │   ├── Optional.cs
        │   └── Utf8JsonRequestContent.cs
        ├── LongRunningOperation/
        │   ├── EdgeConfigTemplateOperationSource.cs
        │   ├── EdgeConfigTemplateVersionOperationSource.cs
        │   ├── EdgeContextOperationSource.cs
        │   ├── EdgeDeploymentInstanceOperationSource.cs
        │   ├── EdgeDiagnosticOperationSource.cs
        │   ├── EdgeDynamicSchemaOperationSource.cs
        │   ├── EdgeDynamicSchemaVersionOperationSource.cs
        │   ├── EdgeExecutionOperationSource.cs
        │   ├── EdgeSchemaOperationSource.cs
        │   ├── EdgeSchemaVersionOperationSource.cs
        │   ├── EdgeSiteReferenceOperationSource.cs
        │   ├── EdgeSolutionOperationSource.cs
        │   ├── EdgeSolutionTemplateOperationSource.cs
        │   ├── EdgeSolutionTemplateVersionOperationSource.cs
        │   ├── EdgeSolutionVersionOperationSource.cs
        │   ├── EdgeTargetOperationSource.cs
        │   ├── EdgeWorkflowOperationSource.cs
        │   ├── EdgeWorkflowVersionOperationSource.cs
        │   ├── ResolvedConfigurationOperationSource.cs
        │   ├── WorkloadOrchestrationArmOperation.cs
        │   └── WorkloadOrchestrationArmOperationOfT.cs
        ├── Models/
        │   ├── ActiveState.cs
        │   ├── AvailableSolutionTemplateVersion.cs
        │   ├── AvailableSolutionTemplateVersion.Serialization.cs
        │   ├── AzureResourceManagerCommonTypesExtendedLocation.cs
        │   ├── AzureResourceManagerCommonTypesExtendedLocation.Serialization.cs
        │   ├── AzureResourceManagerWorkloadOrchestrationContext.cs
        │   ├── BulkDeployTargetDetails.cs
        │   ├── BulkDeployTargetDetails.Serialization.cs
        │   ├── BulkPublishTargetDetails.cs
        │   ├── BulkPublishTargetDetails.Serialization.cs
        │   ├── BulkReviewTargetDetails.cs
        │   ├── BulkReviewTargetDetails.Serialization.cs
        │   ├── Capability.cs
        │   ├── Capability.Serialization.cs
        │   ├── CMStage.cs
        │   ├── ComponentStatus.cs
        │   ├── ComponentStatus.Serialization.cs
        │   ├── ConfigTemplateListResult.cs
        │   ├── ConfigTemplateListResult.Serialization.cs
        │   ├── ConfigTemplateProperties.cs
        │   ├── ConfigTemplateProperties.Serialization.cs
        │   ├── ConfigTemplateUpdateProperties.cs
        │   ├── ConfigTemplateUpdateProperties.Serialization.cs
        │   ├── ConfigTemplateVersionListResult.cs
        │   ├── ConfigTemplateVersionListResult.Serialization.cs
        │   ├── ConfigTemplateVersionProperties.cs
        │   ├── ConfigTemplateVersionProperties.Serialization.cs
        │   ├── ConfigTemplateVersionWithUpdateType.cs
        │   ├── ConfigTemplateVersionWithUpdateType.Serialization.cs
        │   ├── ConfigurationModel.cs
        │   ├── ConfigurationType.cs
        │   ├── ContextListResult.cs
        │   ├── ContextListResult.Serialization.cs
        │   ├── ContextProperties.cs
        │   ├── ContextProperties.Serialization.cs
        │   ├── ContextUpdateProperties.cs
        │   ├── ContextUpdateProperties.Serialization.cs
        │   ├── DeployJobStepStatistics.cs
        │   ├── DeployJobStepStatistics.Serialization.cs
        │   ├── DeploymentStatus.cs
        │   ├── DeploymentStatus.Serialization.cs
        │   ├── DiagnosticListResult.cs
        │   ├── DiagnosticListResult.Serialization.cs
        │   ├── DiagnosticProperties.cs
        │   ├── DiagnosticProperties.Serialization.cs
        │   ├── DynamicSchemaListResult.cs
        │   ├── DynamicSchemaListResult.Serialization.cs
        │   ├── DynamicSchemaProperties.cs
        │   ├── DynamicSchemaProperties.Serialization.cs
        │   ├── DynamicSchemaVersionListResult.cs
        │   ├── DynamicSchemaVersionListResult.Serialization.cs
        │   ├── EdgeConfigTemplatePatch.cs
        │   ├── EdgeConfigTemplatePatch.Serialization.cs
        │   ├── EdgeContextPatch.cs
        │   ├── EdgeContextPatch.Serialization.cs
        │   ├── EdgeDeploymentInstancePatch.cs
        │   ├── EdgeDeploymentInstancePatch.Serialization.cs
        │   ├── EdgeDiagnosticPatch.cs
        │   ├── EdgeDiagnosticPatch.Serialization.cs
        │   ├── EdgeDynamicSchemaPatch.cs
        │   ├── EdgeDynamicSchemaPatch.Serialization.cs
        │   ├── EdgeDynamicSchemaVersionPatch.cs
        │   ├── EdgeDynamicSchemaVersionPatch.Serialization.cs
        │   ├── EdgeExecutionPatch.cs
        │   ├── EdgeExecutionPatch.Serialization.cs
        │   ├── EdgeSchemaPatch.cs
        │   ├── EdgeSchemaPatch.Serialization.cs
        │   ├── EdgeSchemaVersionPatch.cs
        │   ├── EdgeSchemaVersionPatch.Serialization.cs
        │   ├── EdgeSiteReferencePatch.cs
        │   ├── EdgeSiteReferencePatch.Serialization.cs
        │   ├── EdgeSolutionPatch.cs
        │   ├── EdgeSolutionPatch.Serialization.cs
        │   ├── EdgeSolutionTemplatePatch.cs
        │   ├── EdgeSolutionTemplatePatch.Serialization.cs
        │   ├── EdgeSolutionVersionPatch.cs
        │   ├── EdgeSolutionVersionPatch.Serialization.cs
        │   ├── EdgeTargetPatch.cs
        │   ├── EdgeTargetPatch.Serialization.cs
        │   ├── EdgeWorkflowPatch.cs
        │   ├── EdgeWorkflowPatch.Serialization.cs
        │   ├── EdgeWorkflowVersionPatch.cs
        │   ├── EdgeWorkflowVersionPatch.Serialization.cs
        │   ├── ErrorAction.cs
        │   ├── ErrorAction.Serialization.cs
        │   ├── ErrorActionMode.cs
        │   ├── ExecutionListResult.cs
        │   ├── ExecutionListResult.Serialization.cs
        │   ├── ExecutionProperties.cs
        │   ├── ExecutionProperties.Serialization.cs
        │   ├── ExecutionPropertiesUpdate.cs
        │   ├── ExecutionPropertiesUpdate.Serialization.cs
        │   ├── ExecutionStatus.cs
        │   ├── ExecutionStatus.Serialization.cs
        │   ├── ExtendedLocationType.cs
        │   ├── Hierarchy.cs
        │   ├── Hierarchy.Serialization.cs
        │   ├── InstanceHistoryListResult.cs
        │   ├── InstanceHistoryListResult.Serialization.cs
        │   ├── InstanceHistoryProperties.cs
        │   ├── InstanceHistoryProperties.Serialization.cs
        │   ├── InstanceListResult.cs
        │   ├── InstanceListResult.Serialization.cs
        │   ├── InstanceProperties.cs
        │   ├── InstanceProperties.Serialization.cs
        │   ├── InstancePropertiesUpdate.cs
        │   ├── InstancePropertiesUpdate.Serialization.cs
        │   ├── JobListResult.cs
        │   ├── JobListResult.Serialization.cs
        │   ├── JobParameterBase.cs
        │   ├── JobParameterBase.Serialization.cs
        │   ├── JobProperties.cs
        │   ├── JobProperties.Serialization.cs
        │   ├── JobStatus.cs
        │   ├── JobStep.cs
        │   ├── JobStep.Serialization.cs
        │   ├── JobStepStatisticsBase.cs
        │   ├── JobStepStatisticsBase.Serialization.cs
        │   ├── JobType.cs
        │   ├── OrchestratorType.cs
        │   ├── ProvisioningState.cs
        │   ├── PublishJobStepStatistics.cs
        │   ├── PublishJobStepStatistics.Serialization.cs
        │   ├── ReconciliationPolicyProperties.cs
        │   ├── ReconciliationPolicyProperties.Serialization.cs
        │   ├── ReconciliationPolicyPropertiesUpdate.cs
        │   ├── ReconciliationPolicyPropertiesUpdate.Serialization.cs
        │   ├── ReconciliationState.cs
        │   ├── ResolvedConfiguration.cs
        │   ├── ResolvedConfiguration.Serialization.cs
        │   ├── ResourceState.cs
        │   ├── SchemaListResult.cs
        │   ├── SchemaListResult.Serialization.cs
        │   ├── SchemaProperties.cs
        │   ├── SchemaProperties.Serialization.cs
        │   ├── SchemaReferenceListResult.cs
        │   ├── SchemaReferenceListResult.Serialization.cs
        │   ├── SchemaReferenceProperties.cs
        │   ├── SchemaReferenceProperties.Serialization.cs
        │   ├── SchemaVersionListResult.cs
        │   ├── SchemaVersionListResult.Serialization.cs
        │   ├── SchemaVersionProperties.cs
        │   ├── SchemaVersionProperties.Serialization.cs
        │   ├── SchemaVersionPropertiesUpdate.cs
        │   ├── SchemaVersionPropertiesUpdate.Serialization.cs
        │   ├── SchemaVersionWithUpdateType.cs
        │   ├── SchemaVersionWithUpdateType.Serialization.cs
        │   ├── SiteReferenceListResult.cs
        │   ├── SiteReferenceListResult.Serialization.cs
        │   ├── SiteReferenceProperties.cs
        │   ├── SiteReferenceProperties.Serialization.cs
        │   ├── SiteReferencePropertiesUpdate.cs
        │   ├── SiteReferencePropertiesUpdate.Serialization.cs
        │   ├── SolutionDependency.cs
        │   ├── SolutionDependency.Serialization.cs
        │   ├── SolutionListResult.cs
        │   ├── SolutionListResult.Serialization.cs
        │   ├── SolutionProperties.cs
        │   ├── SolutionProperties.Serialization.cs
        │   ├── SolutionTemplateListResult.cs
        │   ├── SolutionTemplateListResult.Serialization.cs
        │   ├── SolutionTemplateProperties.cs
        │   ├── SolutionTemplateProperties.Serialization.cs
        │   ├── SolutionTemplateUpdateProperties.cs
        │   ├── SolutionTemplateUpdateProperties.Serialization.cs
        │   ├── SolutionTemplateVersionListResult.cs
        │   ├── SolutionTemplateVersionListResult.Serialization.cs
        │   ├── SolutionTemplateVersionProperties.cs
        │   ├── SolutionTemplateVersionProperties.Serialization.cs
        │   ├── SolutionTemplateVersionWithUpdateType.cs
        │   ├── SolutionTemplateVersionWithUpdateType.Serialization.cs
        │   ├── SolutionVersionListResult.cs
        │   ├── SolutionVersionListResult.Serialization.cs
        │   ├── SolutionVersionProperties.cs
        │   ├── SolutionVersionProperties.Serialization.cs
        │   ├── SolutionVersionPropertiesUpdate.cs
        │   ├── SolutionVersionPropertiesUpdate.Serialization.cs
        │   ├── SolutionVersionSnapshot.cs
        │   ├── SolutionVersionSnapshot.Serialization.cs
        │   ├── StageMap.cs
        │   ├── StageMap.Serialization.cs
        │   ├── StageSpec.cs
        │   ├── StageSpec.Serialization.cs
        │   ├── StageStatus.cs
        │   ├── StageStatus.Serialization.cs
        │   ├── State.cs
        │   ├── StateCategory.cs
        │   ├── TargetListResult.cs
        │   ├── TargetListResult.Serialization.cs
        │   ├── TargetProperties.cs
        │   ├── TargetProperties.Serialization.cs
        │   ├── TargetSnapshot.cs
        │   ├── TargetSnapshot.Serialization.cs
        │   ├── TargetStatus.cs
        │   ├── TargetStatus.Serialization.cs
        │   ├── TargetUpdateProperties.cs
        │   ├── TargetUpdateProperties.Serialization.cs
        │   ├── TaskSpec.cs
        │   ├── TaskSpec.Serialization.cs
        │   ├── UnknownJobParameterBase.cs
        │   ├── UnknownJobParameterBase.Serialization.cs
        │   ├── UnknownJobStepStatisticsBase.cs
        │   ├── UnknownJobStepStatisticsBase.Serialization.cs
        │   ├── UpdateType.cs
        │   ├── ValidationStatus.cs
        │   ├── WorkflowListResult.cs
        │   ├── WorkflowListResult.Serialization.cs
        │   ├── WorkflowProperties.cs
        │   ├── WorkflowProperties.Serialization.cs
        │   ├── WorkflowVersionListResult.cs
        │   ├── WorkflowVersionListResult.Serialization.cs
        │   ├── WorkflowVersionProperties.cs
        │   ├── WorkflowVersionProperties.Serialization.cs
        │   ├── WorkflowVersionPropertiesUpdate.cs
        │   ├── WorkflowVersionPropertiesUpdate.Serialization.cs
        │   ├── WorkloadOrchestrationBulkDeploySolutionContent.cs
        │   ├── WorkloadOrchestrationBulkDeploySolutionContent.Serialization.cs
        │   ├── WorkloadOrchestrationBulkPublishSolutionContent.cs
        │   ├── WorkloadOrchestrationBulkPublishSolutionContent.Serialization.cs
        │   ├── WorkloadOrchestrationBulkReviewSolutionContent.cs
        │   ├── WorkloadOrchestrationBulkReviewSolutionContent.Serialization.cs
        │   ├── WorkloadOrchestrationDeployJobContent.cs
        │   ├── WorkloadOrchestrationDeployJobContent.Serialization.cs
        │   ├── WorkloadOrchestrationInstallSolutionContent.cs
        │   ├── WorkloadOrchestrationInstallSolutionContent.Serialization.cs
        │   ├── WorkloadOrchestrationPublishJobContent.cs
        │   ├── WorkloadOrchestrationPublishJobContent.Serialization.cs
        │   ├── WorkloadOrchestrationRemoveRevisionContent.cs
        │   ├── WorkloadOrchestrationRemoveRevisionContent.Serialization.cs
        │   ├── WorkloadOrchestrationRemoveVersionResult.cs
        │   ├── WorkloadOrchestrationRemoveVersionResult.Serialization.cs
        │   ├── WorkloadOrchestrationSolutionDependencyContent.cs
        │   ├── WorkloadOrchestrationSolutionDependencyContent.Serialization.cs
        │   ├── WorkloadOrchestrationSolutionTemplateContent.cs
        │   ├── WorkloadOrchestrationSolutionTemplateContent.Serialization.cs
        │   ├── WorkloadOrchestrationSolutionVersionContent.cs
        │   ├── WorkloadOrchestrationSolutionVersionContent.Serialization.cs
        │   ├── WorkloadOrchestrationTaskConfig.cs
        │   ├── WorkloadOrchestrationTaskConfig.Serialization.cs
        │   ├── WorkloadOrchestrationUninstallSolutionContent.cs
        │   ├── WorkloadOrchestrationUninstallSolutionContent.Serialization.cs
        │   ├── WorkloadOrchestrationUpdateExternalValidationStatusContent.cs
        │   ├── WorkloadOrchestrationUpdateExternalValidationStatusContent.Serialization.cs
        │   ├── WorkloadOrchestrationVersionContent.cs
        │   └── WorkloadOrchestrationVersionContent.Serialization.cs
        └── RestOperations/
            ├── ConfigTemplatesRestOperations.cs
            ├── ConfigTemplateVersionsRestOperations.cs
            ├── ContextsRestOperations.cs
            ├── DiagnosticsRestOperations.cs
            ├── DynamicSchemasRestOperations.cs
            ├── DynamicSchemaVersionsRestOperations.cs
            ├── ExecutionsRestOperations.cs
            ├── InstanceHistoriesRestOperations.cs
            ├── InstancesRestOperations.cs
            ├── JobsRestOperations.cs
            ├── SchemaReferencesRestOperations.cs
            ├── SchemasRestOperations.cs
            ├── SchemaVersionsRestOperations.cs
            ├── SiteReferencesRestOperations.cs
            ├── SolutionsRestOperations.cs
            ├── SolutionTemplatesRestOperations.cs
            ├── SolutionTemplateVersionsRestOperations.cs
            ├── SolutionVersionsRestOperations.cs
            ├── TargetsRestOperations.cs
            ├── WorkflowsRestOperations.cs
            └── WorkflowVersionsRestOperations.cs

================================================
FILE: autorest.md
================================================
# Generated code configuration

Run `dotnet build /t:GenerateCode` to generate code.

```yaml
azure-arm: true
csharp: true
library-name: WorkloadOrchestration
namespace: Azure.ResourceManager.WorkloadOrchestration
require: https://github.com/Azure/azure-rest-api-specs/blob/229dfd2b11c491c4c48a738d8f16a2629957225a/specification/edge/resource-manager/Microsoft.Edge/configurationmanager/readme.md
tag: package-2025-08-01
output-folder: $(this-folder)/Generated
clear-output-folder: true
sample-gen:
  output-folder: $(this-folder)/../tests/Generated
  clear-output-folder: true
skip-csproj: true
modelerfour:
  flatten-payloads: false
use-model-reader-writer: true
skip-lro-api-version: true

# mgmt-debug:
#  show-serialized-names: true

format-by-name-rules:
  'tenantId': 'uuid'
  'etag': 'etag'
  'location': 'azure-location'
  'locations': 'azure-location'
  '*Uri': 'Uri'
  '*Uris': 'Uri'

acronym-mapping:
  CPU: Cpu
  CPUs: Cpus
  Os: OS
  Ip: IP
  Ips: IPs|ips
  ID: Id
  IDs: Ids
  VM: Vm
  VMs: Vms
  Vmos: VmOS
  VMScaleSet: VmScaleSet
  DNS: Dns
  VPN: Vpn
  NAT: Nat
  WAN: Wan
  Ipv4: IPv4|ipv4
  Ipv6: IPv6|ipv6
  Ipsec: IPsec|ipsec
  SSO: Sso
  URI: Uri
  Etag: ETag|etag

rename-mapping:
  InstallSolutionParameter: WorkloadOrchestrationInstallSolutionContent
  BulkDeploySolutionParameter: WorkloadOrchestrationBulkDeploySolutionContent
  DeployJobParameter: WorkloadOrchestrationDeployJobContent
  BulkPublishSolutionParameter: WorkloadOrchestrationBulkPublishSolutionContent
  SolutionTemplateParameter: WorkloadOrchestrationSolutionTemplateContent
  RemoveRevisionParameter: WorkloadOrchestrationRemoveRevisionContent
  UpdateExternalValidationStatusParameter: WorkloadOrchestrationUpdateExternalValidationStatusContent
  VersionParameter: WorkloadOrchestrationVersionContent
  SolutionDependencyParameter: WorkloadOrchestrationSolutionDependencyContent
  SolutionVersionParameter: WorkloadOrchestrationSolutionVersionContent
  UninstallSolutionParameter: WorkloadOrchestrationUninstallSolutionContent
  PublishJobParameter: WorkloadOrchestrationPublishJobContent
  BulkReviewSolutionParameter: WorkloadOrchestrationBulkReviewSolutionContent
  RemoveVersionResponse: WorkloadOrchestrationRemoveVersionResult
  TaskOption: WorkloadOrchestrationTaskConfig
  # Resource and collection mappings to maintain Edge prefix for main resources
  Context: EdgeContext
  ContextCollection: EdgeContextCollection
  ContextData: EdgeContextData
  ContextResource: EdgeContextResource
  Schema: EdgeSchema
  SchemaCollection: EdgeSchemaCollection
  SchemaData: EdgeSchemaData
  SchemaResource: EdgeSchemaResource
  SchemaVersion: EdgeSchemaVersion
  SchemaVersionCollection: EdgeSchemaVersionCollection
  SchemaVersionData: EdgeSchemaVersionData
  SchemaVersionResource: EdgeSchemaVersionResource
  ConfigTemplate: EdgeConfigTemplate
  ConfigTemplateCollection: EdgeConfigTemplateCollection
  ConfigTemplateData: EdgeConfigTemplateData
  ConfigTemplateResource: EdgeConfigTemplateResource
  ConfigTemplateVersion: EdgeConfigTemplateVersion
  ConfigTemplateVersionCollection: EdgeConfigTemplateVersionCollection
  ConfigTemplateVersionData: EdgeConfigTemplateVersionData
  ConfigTemplateVersionResource: EdgeConfigTemplateVersionResource
  Target: EdgeTarget
  TargetCollection: EdgeTargetCollection
  TargetData: EdgeTargetData
  TargetResource: EdgeTargetResource
  SolutionTemplate: EdgeSolutionTemplate
  SolutionTemplateCollection: EdgeSolutionTemplateCollection
  SolutionTemplateData: EdgeSolutionTemplateData
  SolutionTemplateResource: EdgeSolutionTemplateResource
  SolutionTemplateVersion: EdgeSolutionTemplateVersion
  SolutionTemplateVersionCollection: EdgeSolutionTemplateVersionCollection
  SolutionTemplateVersionData: EdgeSolutionTemplateVersionData
  SolutionTemplateVersionResource: EdgeSolutionTemplateVersionResource
  SolutionVersion: EdgeSolutionVersion
  SolutionVersionCollection: EdgeSolutionVersionCollection
  SolutionVersionData: EdgeSolutionVersionData
  SolutionVersionResource: EdgeSolutionVersionResource
  Workflow: EdgeWorkflow
  WorkflowCollection: EdgeWorkflowCollection
  WorkflowData: EdgeWorkflowData
  WorkflowResource: EdgeWorkflowResource
  WorkflowVersion: EdgeWorkflowVersion
  WorkflowVersionCollection: EdgeWorkflowVersionCollection
  WorkflowVersionData: EdgeWorkflowVersionData
  WorkflowVersionResource: EdgeWorkflowVersionResource
  Instance: EdgeDeploymentInstance
  InstanceCollection: EdgeDeploymentInstanceCollection
  InstanceData: EdgeDeploymentInstanceData
  InstanceResource: EdgeDeploymentInstanceResource
  InstanceHistory: EdgeDeploymentInstanceHistory
  InstanceHistoryCollection: EdgeDeploymentInstanceHistoryCollection
  InstanceHistoryData: EdgeDeploymentInstanceHistoryData
  InstanceHistoryResource: EdgeDeploymentInstanceHistoryResource
  # Additional mappings for other types that need Edge prefix
  Solution: EdgeSolution
  SolutionCollection: EdgeSolutionCollection
  SolutionData: EdgeSolutionData
  SolutionResource: EdgeSolutionResource
  Job: EdgeJob
  JobCollection: EdgeJobCollection
  JobData: EdgeJobData
  JobResource: EdgeJobResource
  Execution: EdgeExecution
  ExecutionCollection: EdgeExecutionCollection
  ExecutionData: EdgeExecutionData
  ExecutionResource: EdgeExecutionResource
  Diagnostic: EdgeDiagnostic
  DiagnosticCollection: EdgeDiagnosticCollection
  DiagnosticData: EdgeDiagnosticData
  DiagnosticResource: EdgeDiagnosticResource
  DynamicSchema: EdgeDynamicSchema
  DynamicSchemaCollection: EdgeDynamicSchemaCollection
  DynamicSchemaData: EdgeDynamicSchemaData
  DynamicSchemaResource: EdgeDynamicSchemaResource
  DynamicSchemaVersion: EdgeDynamicSchemaVersion
  DynamicSchemaVersionCollection: EdgeDynamicSchemaVersionCollection
  DynamicSchemaVersionData: EdgeDynamicSchemaVersionData
  DynamicSchemaVersionResource: EdgeDynamicSchemaVersionResource
  SchemaReference: EdgeSchemaReference
  SchemaReferenceCollection: EdgeSchemaReferenceCollection
  SchemaReferenceData: EdgeSchemaReferenceData
  SchemaReferenceResource: EdgeSchemaReferenceResource
  SiteReference: EdgeSiteReference
  SiteReferenceCollection: EdgeSiteReferenceCollection
  SiteReferenceData: EdgeSiteReferenceData
  SiteReferenceResource: EdgeSiteReferenceResource
  # Patch models
  ContextPatch: EdgeContextPatch
  TargetPatch: EdgeTargetPatch
  SchemaPatch: EdgeSchemaPatch
  SchemaVersionPatch: EdgeSchemaVersionPatch
  SolutionPatch: EdgeSolutionPatch
  SolutionTemplatePatch: EdgeSolutionTemplatePatch
  SolutionVersionPatch: EdgeSolutionVersionPatch
  WorkflowPatch: EdgeWorkflowPatch
  WorkflowVersionPatch: EdgeWorkflowVersionPatch
  ConfigTemplatePatch: EdgeConfigTemplatePatch
  ConfigTemplateVersionPatch: EdgeConfigTemplateVersionPatch
  SolutionTemplateVersionPatch: EdgeSolutionTemplateVersionPatch
  Deployment: EdgeDeployment
  DeploymentCollection: EdgeDeploymentCollection
  DeploymentData: EdgeDeploymentData
  DeploymentResource: EdgeDeploymentResource
  DeploymentPatch: EdgeDeploymentPatch
  DeploymentVersion: EdgeDeploymentVersion
  DeploymentVersionCollection: EdgeDeploymentVersionCollection
  DeploymentVersionData: EdgeDeploymentVersionData
  DeploymentVersionResource: EdgeDeploymentVersionResource
  DeploymentVersionPatch: EdgeDeploymentVersionPatch

directive:
  - remove-operation: Operations_List



================================================
FILE: Azure.ResourceManager.WorkloadOrchestration.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">
    <PropertyGroup>
    <Version>1.1.0</Version>
    <PackageId>Azure.ResourceManager.WorkloadOrchestration</PackageId>
    <Description>Azure Resource Manager client SDK for Azure Workload Orchestration service.</Description>
    <PackageTags>azure;management;arm;resource manager;workload orchestration;edge</PackageTags>
  </PropertyGroup>
</Project>



================================================
FILE: Generated/ArmWorkloadOrchestrationModelFactory.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Model factory for models. </summary>
    public static partial class ArmWorkloadOrchestrationModelFactory
    {
        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeJobData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeJobData"/> instance for mocking. </returns>
        public static EdgeJobData EdgeJobData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, JobProperties properties = null, string etag = null)
        {
            return new EdgeJobData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.JobProperties"/>. </summary>
        /// <param name="jobType"> The type of job. </param>
        /// <param name="startOn"> Start time of the job (ISO8601). </param>
        /// <param name="endOn"> End time of the job (ISO8601). </param>
        /// <param name="status"> Status of the job. </param>
        /// <param name="jobParameter">
        /// Parameters for the job.
        /// Please note <see cref="JobParameterBase"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="WorkloadOrchestrationDeployJobContent"/> and <see cref="WorkloadOrchestrationPublishJobContent"/>.
        /// </param>
        /// <param name="correlationId"> Correlation ID for tracking. </param>
        /// <param name="steps"> Steps and substatuses for the job. </param>
        /// <param name="triggeredBy"> The OID or identity that triggered the job. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="errorDetails"> Error Details if any failure is there. </param>
        /// <returns> A new <see cref="Models.JobProperties"/> instance for mocking. </returns>
        public static JobProperties JobProperties(JobType jobType = default, DateTimeOffset? startOn = null, DateTimeOffset? endOn = null, JobStatus status = default, JobParameterBase jobParameter = null, string correlationId = null, IEnumerable<JobStep> steps = null, string triggeredBy = null, ProvisioningState? provisioningState = null, ResponseError errorDetails = null)
        {
            steps ??= new List<JobStep>();

            return new JobProperties(
                jobType,
                startOn,
                endOn,
                status,
                jobParameter,
                correlationId,
                steps?.ToList(),
                triggeredBy,
                provisioningState,
                errorDetails,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.JobStep"/>. </summary>
        /// <param name="name"> Name of the step. </param>
        /// <param name="status"> Status of the step. </param>
        /// <param name="startOn"> Start time of the step (ISO8601). </param>
        /// <param name="endOn"> End time of the step (ISO8601). </param>
        /// <param name="message"> Message for the step. </param>
        /// <param name="statistics">
        /// Statistics for the step
        /// Please note <see cref="JobStepStatisticsBase"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="DeployJobStepStatistics"/> and <see cref="PublishJobStepStatistics"/>.
        /// </param>
        /// <param name="steps"> Nested substeps for this step. </param>
        /// <param name="errorDetails"> Error Details if any failure is there. </param>
        /// <returns> A new <see cref="Models.JobStep"/> instance for mocking. </returns>
        public static JobStep JobStep(string name = null, JobStatus status = default, DateTimeOffset? startOn = null, DateTimeOffset? endOn = null, string message = null, JobStepStatisticsBase statistics = null, IEnumerable<JobStep> steps = null, ResponseError errorDetails = null)
        {
            steps ??= new List<JobStep>();

            return new JobStep(
                name,
                status,
                startOn,
                endOn,
                message,
                statistics,
                steps?.ToList(),
                errorDetails,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeSchemaReferenceData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeSchemaReferenceData"/> instance for mocking. </returns>
        public static EdgeSchemaReferenceData EdgeSchemaReferenceData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, SchemaReferenceProperties properties = null, string etag = null)
        {
            return new EdgeSchemaReferenceData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SchemaReferenceProperties"/>. </summary>
        /// <param name="schemaId"> Schema Id of schema reference. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.SchemaReferenceProperties"/> instance for mocking. </returns>
        public static SchemaReferenceProperties SchemaReferenceProperties(string schemaId = null, ProvisioningState? provisioningState = null)
        {
            return new SchemaReferenceProperties(schemaId, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeConfigTemplateData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeConfigTemplateData"/> instance for mocking. </returns>
        public static EdgeConfigTemplateData EdgeConfigTemplateData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ConfigTemplateProperties properties = null, string etag = null)
        {
            tags ??= new Dictionary<string, string>();

            return new EdgeConfigTemplateData(
                id,
                name,
                resourceType,
                systemData,
                tags,
                location,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.ConfigTemplateProperties"/>. </summary>
        /// <param name="description"> Description of config template. </param>
        /// <param name="latestVersion"> Latest config template version. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.ConfigTemplateProperties"/> instance for mocking. </returns>
        public static ConfigTemplateProperties ConfigTemplateProperties(string description = null, string latestVersion = null, ProvisioningState? provisioningState = null)
        {
            return new ConfigTemplateProperties(description, latestVersion, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeContextData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeContextData"/> instance for mocking. </returns>
        public static EdgeContextData EdgeContextData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ContextProperties properties = null)
        {
            tags ??= new Dictionary<string, string>();

            return new EdgeContextData(
                id,
                name,
                resourceType,
                systemData,
                tags,
                location,
                properties,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.ContextProperties"/>. </summary>
        /// <param name="capabilities"> List of Capabilities. </param>
        /// <param name="hierarchies"> List of Hierarchies. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.ContextProperties"/> instance for mocking. </returns>
        public static ContextProperties ContextProperties(IEnumerable<Capability> capabilities = null, IEnumerable<Hierarchy> hierarchies = null, ProvisioningState? provisioningState = null)
        {
            capabilities ??= new List<Capability>();
            hierarchies ??= new List<Hierarchy>();

            return new ContextProperties(capabilities?.ToList(), hierarchies?.ToList(), provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeDiagnosticData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="diagnosticProvisioningState"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeDiagnosticData"/> instance for mocking. </returns>
        public static EdgeDiagnosticData EdgeDiagnosticData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, ProvisioningState? diagnosticProvisioningState = null, AzureResourceManagerCommonTypesExtendedLocation extendedLocation = null, string etag = null)
        {
            tags ??= new Dictionary<string, string>();

            return new EdgeDiagnosticData(
                id,
                name,
                resourceType,
                systemData,
                tags,
                location,
                diagnosticProvisioningState != null ? new DiagnosticProperties(diagnosticProvisioningState, serializedAdditionalRawData: null) : null,
                extendedLocation,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeSchemaData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeSchemaData"/> instance for mocking. </returns>
        public static EdgeSchemaData EdgeSchemaData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, SchemaProperties properties = null, string etag = null)
        {
            tags ??= new Dictionary<string, string>();

            return new EdgeSchemaData(
                id,
                name,
                resourceType,
                systemData,
                tags,
                location,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SchemaProperties"/>. </summary>
        /// <param name="currentVersion"> Current Version of schema. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.SchemaProperties"/> instance for mocking. </returns>
        public static SchemaProperties SchemaProperties(string currentVersion = null, ProvisioningState? provisioningState = null)
        {
            return new SchemaProperties(currentVersion, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeSolutionTemplateData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeSolutionTemplateData"/> instance for mocking. </returns>
        public static EdgeSolutionTemplateData EdgeSolutionTemplateData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, SolutionTemplateProperties properties = null, string etag = null)
        {
            tags ??= new Dictionary<string, string>();

            return new EdgeSolutionTemplateData(
                id,
                name,
                resourceType,
                systemData,
                tags,
                location,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SolutionTemplateProperties"/>. </summary>
        /// <param name="uniqueIdentifier"> A unique identifier for the solution template, generated by the system. </param>
        /// <param name="description"> Description of Solution template. </param>
        /// <param name="capabilities"> List of capabilities. </param>
        /// <param name="latestVersion"> Latest solution template version. </param>
        /// <param name="state"> State of resource. </param>
        /// <param name="enableExternalValidation"> Flag to enable external validation. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.SolutionTemplateProperties"/> instance for mocking. </returns>
        public static SolutionTemplateProperties SolutionTemplateProperties(string uniqueIdentifier = null, string description = null, IEnumerable<string> capabilities = null, string latestVersion = null, ResourceState? state = null, bool? enableExternalValidation = null, ProvisioningState? provisioningState = null)
        {
            capabilities ??= new List<string>();

            return new SolutionTemplateProperties(
                uniqueIdentifier,
                description,
                capabilities?.ToList(),
                latestVersion,
                state,
                enableExternalValidation,
                provisioningState,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeTargetData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeTargetData"/> instance for mocking. </returns>
        public static EdgeTargetData EdgeTargetData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, string> tags = null, AzureLocation location = default, TargetProperties properties = null, string etag = null, AzureResourceManagerCommonTypesExtendedLocation extendedLocation = null)
        {
            tags ??= new Dictionary<string, string>();

            return new EdgeTargetData(
                id,
                name,
                resourceType,
                systemData,
                tags,
                location,
                properties,
                etag,
                extendedLocation,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.TargetProperties"/>. </summary>
        /// <param name="description"> Description of target. </param>
        /// <param name="displayName"> Display name of target. </param>
        /// <param name="contextId"> ArmId of Context. </param>
        /// <param name="targetSpecification"> target spec. </param>
        /// <param name="capabilities"> List of capabilities. </param>
        /// <param name="hierarchyLevel"> Hierarchy Level. </param>
        /// <param name="status"> Status of target. </param>
        /// <param name="solutionScope"> Scope of the target resource. </param>
        /// <param name="state"> State of resource. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.TargetProperties"/> instance for mocking. </returns>
        public static TargetProperties TargetProperties(string description = null, string displayName = null, ResourceIdentifier contextId = null, IDictionary<string, BinaryData> targetSpecification = null, IEnumerable<string> capabilities = null, string hierarchyLevel = null, DeploymentStatus status = null, string solutionScope = null, ResourceState? state = null, ProvisioningState? provisioningState = null)
        {
            targetSpecification ??= new Dictionary<string, BinaryData>();
            capabilities ??= new List<string>();

            return new TargetProperties(
                description,
                displayName,
                contextId,
                targetSpecification,
                capabilities?.ToList(),
                hierarchyLevel,
                status,
                solutionScope,
                state,
                provisioningState,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.DeploymentStatus"/>. </summary>
        /// <param name="lastModified"> The lastModified of the Status. </param>
        /// <param name="deployed"> Indicates if Instance is deployed. </param>
        /// <param name="expectedRunningJobId"> The expected running job id. </param>
        /// <param name="runningJobId"> The running job id. </param>
        /// <param name="status"> Deployment status. </param>
        /// <param name="statusDetails"> Status details. </param>
        /// <param name="generation"> Deployment Generation. </param>
        /// <param name="targetStatuses"> Target resource statuses. </param>
        /// <returns> A new <see cref="Models.DeploymentStatus"/> instance for mocking. </returns>
        public static DeploymentStatus DeploymentStatus(DateTimeOffset? lastModified = null, int? deployed = null, int? expectedRunningJobId = null, int? runningJobId = null, string status = null, string statusDetails = null, int? generation = null, IEnumerable<TargetStatus> targetStatuses = null)
        {
            targetStatuses ??= new List<TargetStatus>();

            return new DeploymentStatus(
                lastModified,
                deployed,
                expectedRunningJobId,
                runningJobId,
                status,
                statusDetails,
                generation,
                targetStatuses?.ToList(),
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.TargetStatus"/>. </summary>
        /// <param name="name"> Target name. </param>
        /// <param name="status"> Target status. </param>
        /// <param name="componentStatuses"> Component statuses. </param>
        /// <returns> A new <see cref="Models.TargetStatus"/> instance for mocking. </returns>
        public static TargetStatus TargetStatus(string name = null, string status = null, IEnumerable<ComponentStatus> componentStatuses = null)
        {
            componentStatuses ??= new List<ComponentStatus>();

            return new TargetStatus(name, status, componentStatuses?.ToList(), serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.ComponentStatus"/>. </summary>
        /// <param name="name"> Component name. </param>
        /// <param name="status"> Component status. </param>
        /// <returns> A new <see cref="Models.ComponentStatus"/> instance for mocking. </returns>
        public static ComponentStatus ComponentStatus(string name = null, string status = null)
        {
            return new ComponentStatus(name, status, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.ConfigTemplateVersionWithUpdateType"/>. </summary>
        /// <param name="updateType"> Update type. </param>
        /// <param name="version"> Version to create. </param>
        /// <param name="configTemplateVersion"> Config Template Version. </param>
        /// <returns> A new <see cref="Models.ConfigTemplateVersionWithUpdateType"/> instance for mocking. </returns>
        public static ConfigTemplateVersionWithUpdateType ConfigTemplateVersionWithUpdateType(UpdateType? updateType = null, string version = null, EdgeConfigTemplateVersionData configTemplateVersion = null)
        {
            return new ConfigTemplateVersionWithUpdateType(updateType, version, configTemplateVersion, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeConfigTemplateVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeConfigTemplateVersionData"/> instance for mocking. </returns>
        public static EdgeConfigTemplateVersionData EdgeConfigTemplateVersionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ConfigTemplateVersionProperties properties = null, string etag = null)
        {
            return new EdgeConfigTemplateVersionData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.ConfigTemplateVersionProperties"/>. </summary>
        /// <param name="configurations"> Configuration values. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.ConfigTemplateVersionProperties"/> instance for mocking. </returns>
        public static ConfigTemplateVersionProperties ConfigTemplateVersionProperties(string configurations = null, ProvisioningState? provisioningState = null)
        {
            return new ConfigTemplateVersionProperties(configurations, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.WorkloadOrchestrationRemoveVersionResult"/>. </summary>
        /// <param name="status"> Status for remove version response. </param>
        /// <returns> A new <see cref="Models.WorkloadOrchestrationRemoveVersionResult"/> instance for mocking. </returns>
        public static WorkloadOrchestrationRemoveVersionResult WorkloadOrchestrationRemoveVersionResult(string status = null)
        {
            return new WorkloadOrchestrationRemoveVersionResult(status, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeSiteReferenceData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeSiteReferenceData"/> instance for mocking. </returns>
        public static EdgeSiteReferenceData EdgeSiteReferenceData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, SiteReferenceProperties properties = null)
        {
            return new EdgeSiteReferenceData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SiteReferenceProperties"/>. </summary>
        /// <param name="siteId"> Azure Resource ID for Site. </param>
        /// <param name="provisioningState"> Provisioning State. </param>
        /// <returns> A new <see cref="Models.SiteReferenceProperties"/> instance for mocking. </returns>
        public static SiteReferenceProperties SiteReferenceProperties(string siteId = null, ProvisioningState? provisioningState = null)
        {
            return new SiteReferenceProperties(siteId, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.EdgeSiteReferencePatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="siteId"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.EdgeSiteReferencePatch"/> instance for mocking. </returns>
        public static EdgeSiteReferencePatch EdgeSiteReferencePatch(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string siteId = null)
        {
            return new EdgeSiteReferencePatch(
                id,
                name,
                resourceType,
                systemData,
                siteId != null ? new SiteReferencePropertiesUpdate(siteId, serializedAdditionalRawData: null) : null,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeWorkflowData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeWorkflowData"/> instance for mocking. </returns>
        public static EdgeWorkflowData EdgeWorkflowData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, WorkflowProperties properties = null, AzureResourceManagerCommonTypesExtendedLocation extendedLocation = null, string etag = null)
        {
            return new EdgeWorkflowData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.WorkflowProperties"/>. </summary>
        /// <param name="workflowTemplateId"> Workflow template Id. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.WorkflowProperties"/> instance for mocking. </returns>
        public static WorkflowProperties WorkflowProperties(string workflowTemplateId = null, ProvisioningState? provisioningState = null)
        {
            return new WorkflowProperties(workflowTemplateId, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.EdgeWorkflowPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.EdgeWorkflowPatch"/> instance for mocking. </returns>
        public static EdgeWorkflowPatch EdgeWorkflowPatch(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, WorkflowProperties properties = null)
        {
            return new EdgeWorkflowPatch(
                id,
                name,
                resourceType,
                systemData,
                properties,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeWorkflowVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeWorkflowVersionData"/> instance for mocking. </returns>
        public static EdgeWorkflowVersionData EdgeWorkflowVersionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, WorkflowVersionProperties properties = null, AzureResourceManagerCommonTypesExtendedLocation extendedLocation = null, string etag = null)
        {
            return new EdgeWorkflowVersionData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.WorkflowVersionProperties"/>. </summary>
        /// <param name="revision"> Revision number of resolved config for this workflow version. </param>
        /// <param name="configuration"> Resolved configuration values. </param>
        /// <param name="stageSpec"> A list of stage specs. </param>
        /// <param name="reviewId"> Review id of resolved config for this workflow version. </param>
        /// <param name="state"> State of workflow version. </param>
        /// <param name="specification"> Execution specification. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.WorkflowVersionProperties"/> instance for mocking. </returns>
        public static WorkflowVersionProperties WorkflowVersionProperties(int? revision = null, string configuration = null, IEnumerable<StageSpec> stageSpec = null, string reviewId = null, State? state = null, IDictionary<string, BinaryData> specification = null, ProvisioningState? provisioningState = null)
        {
            stageSpec ??= new List<StageSpec>();
            specification ??= new Dictionary<string, BinaryData>();

            return new WorkflowVersionProperties(
                revision,
                configuration,
                stageSpec?.ToList(),
                reviewId,
                state,
                specification,
                provisioningState,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.EdgeWorkflowVersionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.EdgeWorkflowVersionPatch"/> instance for mocking. </returns>
        public static EdgeWorkflowVersionPatch EdgeWorkflowVersionPatch(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, WorkflowVersionPropertiesUpdate properties = null)
        {
            return new EdgeWorkflowVersionPatch(
                id,
                name,
                resourceType,
                systemData,
                properties,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeExecutionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeExecutionData"/> instance for mocking. </returns>
        public static EdgeExecutionData EdgeExecutionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ExecutionProperties properties = null, AzureResourceManagerCommonTypesExtendedLocation extendedLocation = null, string etag = null)
        {
            return new EdgeExecutionData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.ExecutionProperties"/>. </summary>
        /// <param name="workflowVersionId"> Workflow version of execution. </param>
        /// <param name="specification"> Execution specification. </param>
        /// <param name="status"> Status of Execution. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.ExecutionProperties"/> instance for mocking. </returns>
        public static ExecutionProperties ExecutionProperties(string workflowVersionId = null, IDictionary<string, BinaryData> specification = null, ExecutionStatus status = null, ProvisioningState? provisioningState = null)
        {
            specification ??= new Dictionary<string, BinaryData>();

            return new ExecutionProperties(workflowVersionId, specification, status, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.ExecutionStatus"/>. </summary>
        /// <param name="updateOn"> The lastModified timestamp of the Status. </param>
        /// <param name="status"> Deployment status. </param>
        /// <param name="statusMessage"> status details. </param>
        /// <param name="stageHistory"> target resource statuses. </param>
        /// <returns> A new <see cref="Models.ExecutionStatus"/> instance for mocking. </returns>
        public static ExecutionStatus ExecutionStatus(DateTimeOffset? updateOn = null, int? status = null, string statusMessage = null, IEnumerable<StageStatus> stageHistory = null)
        {
            stageHistory ??= new List<StageStatus>();

            return new ExecutionStatus(updateOn, status, statusMessage, stageHistory?.ToList(), serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.StageStatus"/>. </summary>
        /// <param name="status"> Deployment status. </param>
        /// <param name="statusMessage"> Status message. </param>
        /// <param name="stage"> Current stage. </param>
        /// <param name="nextstage"> Next stage. </param>
        /// <param name="errorMessage"> Error message. </param>
        /// <param name="isActive"> whether this stage is active or inactive. </param>
        /// <param name="inputs"> The inputs of the StageHistory, Inputs holds a key-value map of user-defined parameters for the initial stage. </param>
        /// <param name="outputs"> The outputs of the StageHistory, it is different as the different input stages. </param>
        /// <returns> A new <see cref="Models.StageStatus"/> instance for mocking. </returns>
        public static StageStatus StageStatus(int? status = null, string statusMessage = null, string stage = null, string nextstage = null, string errorMessage = null, ActiveState? isActive = null, IReadOnlyDictionary<string, BinaryData> inputs = null, IReadOnlyDictionary<string, BinaryData> outputs = null)
        {
            inputs ??= new Dictionary<string, BinaryData>();
            outputs ??= new Dictionary<string, BinaryData>();

            return new StageStatus(
                status,
                statusMessage,
                stage,
                nextstage,
                errorMessage,
                isActive,
                inputs,
                outputs,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.EdgeExecutionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.EdgeExecutionPatch"/> instance for mocking. </returns>
        public static EdgeExecutionPatch EdgeExecutionPatch(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, ExecutionPropertiesUpdate properties = null)
        {
            return new EdgeExecutionPatch(
                id,
                name,
                resourceType,
                systemData,
                properties,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SchemaVersionWithUpdateType"/>. </summary>
        /// <param name="updateType"> Update type. </param>
        /// <param name="version"> Version to create. </param>
        /// <param name="schemaVersion"> Schema Version. </param>
        /// <returns> A new <see cref="Models.SchemaVersionWithUpdateType"/> instance for mocking. </returns>
        public static SchemaVersionWithUpdateType SchemaVersionWithUpdateType(UpdateType? updateType = null, string version = null, EdgeSchemaVersionData schemaVersion = null)
        {
            return new SchemaVersionWithUpdateType(updateType, version, schemaVersion, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeSchemaVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeSchemaVersionData"/> instance for mocking. </returns>
        public static EdgeSchemaVersionData EdgeSchemaVersionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, SchemaVersionProperties properties = null, string etag = null)
        {
            return new EdgeSchemaVersionData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SchemaVersionProperties"/>. </summary>
        /// <param name="value"> Value of schema version. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.SchemaVersionProperties"/> instance for mocking. </returns>
        public static SchemaVersionProperties SchemaVersionProperties(string value = null, ProvisioningState? provisioningState = null)
        {
            return new SchemaVersionProperties(value, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeDynamicSchemaData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeDynamicSchemaData"/> instance for mocking. </returns>
        public static EdgeDynamicSchemaData EdgeDynamicSchemaData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, DynamicSchemaProperties properties = null, string etag = null)
        {
            return new EdgeDynamicSchemaData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.DynamicSchemaProperties"/>. </summary>
        /// <param name="displayName"> Display name of the dynamic schema. </param>
        /// <param name="configurationType"> Type of configuration. </param>
        /// <param name="configurationModel"> Type of configuration model. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.DynamicSchemaProperties"/> instance for mocking. </returns>
        public static DynamicSchemaProperties DynamicSchemaProperties(string displayName = null, ConfigurationType? configurationType = null, ConfigurationModel? configurationModel = null, ProvisioningState? provisioningState = null)
        {
            return new DynamicSchemaProperties(displayName, configurationType, configurationModel, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.EdgeDynamicSchemaPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.EdgeDynamicSchemaPatch"/> instance for mocking. </returns>
        public static EdgeDynamicSchemaPatch EdgeDynamicSchemaPatch(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, DynamicSchemaProperties properties = null)
        {
            return new EdgeDynamicSchemaPatch(
                id,
                name,
                resourceType,
                systemData,
                properties,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeDynamicSchemaVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeDynamicSchemaVersionData"/> instance for mocking. </returns>
        public static EdgeDynamicSchemaVersionData EdgeDynamicSchemaVersionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, SchemaVersionProperties properties = null, string etag = null)
        {
            return new EdgeDynamicSchemaVersionData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.EdgeDynamicSchemaVersionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="schemaVersionPropertiesUpdateValue"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.EdgeDynamicSchemaVersionPatch"/> instance for mocking. </returns>
        public static EdgeDynamicSchemaVersionPatch EdgeDynamicSchemaVersionPatch(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string schemaVersionPropertiesUpdateValue = null)
        {
            return new EdgeDynamicSchemaVersionPatch(
                id,
                name,
                resourceType,
                systemData,
                schemaVersionPropertiesUpdateValue != null ? new SchemaVersionPropertiesUpdate(schemaVersionPropertiesUpdateValue, serializedAdditionalRawData: null) : null,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.EdgeSchemaVersionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="schemaVersionPropertiesUpdateValue"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.EdgeSchemaVersionPatch"/> instance for mocking. </returns>
        public static EdgeSchemaVersionPatch EdgeSchemaVersionPatch(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, string schemaVersionPropertiesUpdateValue = null)
        {
            return new EdgeSchemaVersionPatch(
                id,
                name,
                resourceType,
                systemData,
                schemaVersionPropertiesUpdateValue != null ? new SchemaVersionPropertiesUpdate(schemaVersionPropertiesUpdateValue, serializedAdditionalRawData: null) : null,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SolutionTemplateVersionWithUpdateType"/>. </summary>
        /// <param name="updateType"> Update type. </param>
        /// <param name="version"> Version to create. </param>
        /// <param name="solutionTemplateVersion"> Solution Template Version. </param>
        /// <returns> A new <see cref="Models.SolutionTemplateVersionWithUpdateType"/> instance for mocking. </returns>
        public static SolutionTemplateVersionWithUpdateType SolutionTemplateVersionWithUpdateType(UpdateType? updateType = null, string version = null, EdgeSolutionTemplateVersionData solutionTemplateVersion = null)
        {
            return new SolutionTemplateVersionWithUpdateType(updateType, version, solutionTemplateVersion, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeSolutionTemplateVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeSolutionTemplateVersionData"/> instance for mocking. </returns>
        public static EdgeSolutionTemplateVersionData EdgeSolutionTemplateVersionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, SolutionTemplateVersionProperties properties = null, string etag = null)
        {
            return new EdgeSolutionTemplateVersionData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SolutionTemplateVersionProperties"/>. </summary>
        /// <param name="configurations"> Config expressions for this solution version. </param>
        /// <param name="specification"> App components spec. </param>
        /// <param name="orchestratorType"> Orchestrator type. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.SolutionTemplateVersionProperties"/> instance for mocking. </returns>
        public static SolutionTemplateVersionProperties SolutionTemplateVersionProperties(string configurations = null, IDictionary<string, BinaryData> specification = null, OrchestratorType? orchestratorType = null, ProvisioningState? provisioningState = null)
        {
            specification ??= new Dictionary<string, BinaryData>();

            return new SolutionTemplateVersionProperties(configurations, specification, orchestratorType, provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.BulkPublishTargetDetails"/>. </summary>
        /// <param name="targetId"> ArmId of Target. </param>
        /// <param name="solutionInstanceName"> Name of the solution instance. </param>
        /// <param name="solutionVersionId"> ArmId of Target Solution Version. </param>
        /// <param name="solutionConfiguration"> Configuration of solution. </param>
        /// <returns> A new <see cref="Models.BulkPublishTargetDetails"/> instance for mocking. </returns>
        public static BulkPublishTargetDetails BulkPublishTargetDetails(ResourceIdentifier targetId = null, string solutionInstanceName = null, ResourceIdentifier solutionVersionId = null, string solutionConfiguration = null)
        {
            return new BulkPublishTargetDetails(targetId, solutionInstanceName, solutionVersionId, solutionConfiguration, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.BulkReviewTargetDetails"/>. </summary>
        /// <param name="targetId"> ArmId of Target. </param>
        /// <param name="solutionInstanceName"> Name of the solution instance. </param>
        /// <param name="solutionConfiguration"> Configuration of solution. </param>
        /// <returns> A new <see cref="Models.BulkReviewTargetDetails"/> instance for mocking. </returns>
        public static BulkReviewTargetDetails BulkReviewTargetDetails(ResourceIdentifier targetId = null, string solutionInstanceName = null, string solutionConfiguration = null)
        {
            return new BulkReviewTargetDetails(targetId, solutionInstanceName, solutionConfiguration, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeSolutionVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeSolutionVersionData"/> instance for mocking. </returns>
        public static EdgeSolutionVersionData EdgeSolutionVersionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, SolutionVersionProperties properties = null, AzureResourceManagerCommonTypesExtendedLocation extendedLocation = null, string etag = null)
        {
            return new EdgeSolutionVersionData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SolutionVersionProperties"/>. </summary>
        /// <param name="solutionTemplateVersionId"> Solution Template Version Id. </param>
        /// <param name="revision"> Revision number of resolved config for this solution version. </param>
        /// <param name="targetDisplayName"> Name of applicable target's display name. </param>
        /// <param name="configuration"> Resolved configuration values. </param>
        /// <param name="targetLevelConfiguration"> Configuration on the line level across all solution template versions. </param>
        /// <param name="specification"> App components spec. </param>
        /// <param name="reviewId"> Review id of resolved config for this solution version. </param>
        /// <param name="externalValidationId"> External validation id. </param>
        /// <param name="state"> State of solution instance. </param>
        /// <param name="currentStage"> Current Stage of revision. </param>
        /// <param name="stages"> Stages of revision. </param>
        /// <param name="solutionInstanceName"> Solution instance name. </param>
        /// <param name="solutionDependencies"> Solution Dependency Context. </param>
        /// <param name="errorDetails"> Error Details if any failure is there. </param>
        /// <param name="latestActionTrackingUri"> The URI for tracking the latest action performed on this solution version. </param>
        /// <param name="lastestActionTriggeredBy"> Object Id of user who triggered the latest action on this solution version. </param>
        /// <param name="actionType"> The type of the latest action performed on this solution version. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.SolutionVersionProperties"/> instance for mocking. </returns>
        public static SolutionVersionProperties SolutionVersionProperties(string solutionTemplateVersionId = null, int? revision = null, string targetDisplayName = null, string configuration = null, string targetLevelConfiguration = null, IDictionary<string, BinaryData> specification = null, string reviewId = null, string externalValidationId = null, State? state = null, StageMap currentStage = null, IEnumerable<StageMap> stages = null, string solutionInstanceName = null, IEnumerable<SolutionDependency> solutionDependencies = null, ResponseError errorDetails = null, Uri latestActionTrackingUri = null, string lastestActionTriggeredBy = null, JobType? actionType = null, ProvisioningState? provisioningState = null)
        {
            specification ??= new Dictionary<string, BinaryData>();
            stages ??= new List<StageMap>();
            solutionDependencies ??= new List<SolutionDependency>();

            return new SolutionVersionProperties(
                solutionTemplateVersionId,
                revision,
                targetDisplayName,
                configuration,
                targetLevelConfiguration,
                specification,
                reviewId,
                externalValidationId,
                state,
                currentStage,
                stages?.ToList(),
                solutionInstanceName,
                solutionDependencies?.ToList(),
                errorDetails,
                latestActionTrackingUri,
                lastestActionTriggeredBy,
                actionType,
                provisioningState,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.StageMap"/>. </summary>
        /// <param name="displayState"> Display State. </param>
        /// <param name="stage"> Stage name. </param>
        /// <param name="status"> Stage status. </param>
        /// <param name="startOn"> Stage start time. </param>
        /// <param name="endOn"> Stage end time. </param>
        /// <param name="childStages"> Child stages which represents more granular level stage status if any. </param>
        /// <returns> A new <see cref="Models.StageMap"/> instance for mocking. </returns>
        public static StageMap StageMap(string displayState = null, CMStage stage = default, StateCategory status = default, DateTimeOffset? startOn = null, DateTimeOffset? endOn = null, IEnumerable<StageMap> childStages = null)
        {
            childStages ??= new List<StageMap>();

            return new StageMap(
                displayState,
                stage,
                status,
                startOn,
                endOn,
                childStages?.ToList(),
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SolutionDependency"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version Id. </param>
        /// <param name="solutionInstanceName"> Solution Instance Name. </param>
        /// <param name="solutionTemplateVersionId"> Solution Template Version Id. </param>
        /// <param name="targetId"> Target Id. </param>
        /// <param name="dependencies"> Solution dependencies. </param>
        /// <returns> A new <see cref="Models.SolutionDependency"/> instance for mocking. </returns>
        public static SolutionDependency SolutionDependency(string solutionVersionId = null, string solutionInstanceName = null, string solutionTemplateVersionId = null, string targetId = null, IEnumerable<SolutionDependency> dependencies = null)
        {
            dependencies ??= new List<SolutionDependency>();

            return new SolutionDependency(
                solutionVersionId,
                solutionInstanceName,
                solutionTemplateVersionId,
                targetId,
                dependencies?.ToList(),
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.WorkloadOrchestrationSolutionTemplateContent"/>. </summary>
        /// <param name="solutionTemplateVersionId"> Solution Template Version ARM Id. </param>
        /// <param name="solutionInstanceName"> Solution Instance Name. </param>
        /// <param name="solutionDependencies"> Solution Dependencies. </param>
        /// <returns> A new <see cref="Models.WorkloadOrchestrationSolutionTemplateContent"/> instance for mocking. </returns>
        public static WorkloadOrchestrationSolutionTemplateContent WorkloadOrchestrationSolutionTemplateContent(string solutionTemplateVersionId = null, string solutionInstanceName = null, IEnumerable<WorkloadOrchestrationSolutionDependencyContent> solutionDependencies = null)
        {
            solutionDependencies ??= new List<WorkloadOrchestrationSolutionDependencyContent>();

            return new WorkloadOrchestrationSolutionTemplateContent(solutionTemplateVersionId, solutionInstanceName, solutionDependencies?.ToList(), serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.ResolvedConfiguration"/>. </summary>
        /// <param name="configuration"> Resolved Configuration as string. </param>
        /// <returns> A new <see cref="Models.ResolvedConfiguration"/> instance for mocking. </returns>
        public static ResolvedConfiguration ResolvedConfiguration(string configuration = null)
        {
            return new ResolvedConfiguration(configuration, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeSolutionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeSolutionData"/> instance for mocking. </returns>
        public static EdgeSolutionData EdgeSolutionData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, SolutionProperties properties = null, AzureResourceManagerCommonTypesExtendedLocation extendedLocation = null, string etag = null)
        {
            return new EdgeSolutionData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SolutionProperties"/>. </summary>
        /// <param name="solutionTemplateId"> Solution template Id. </param>
        /// <param name="displayName"> Display name of the solution. </param>
        /// <param name="availableSolutionTemplateVersions"> List of latest revisions for available solution template versions. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.SolutionProperties"/> instance for mocking. </returns>
        public static SolutionProperties SolutionProperties(string solutionTemplateId = null, string displayName = null, IEnumerable<AvailableSolutionTemplateVersion> availableSolutionTemplateVersions = null, ProvisioningState? provisioningState = null)
        {
            availableSolutionTemplateVersions ??= new List<AvailableSolutionTemplateVersion>();

            return new SolutionProperties(solutionTemplateId, displayName, availableSolutionTemplateVersions?.ToList(), provisioningState, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.AvailableSolutionTemplateVersion"/>. </summary>
        /// <param name="solutionTemplateVersion"> Solution template Version. </param>
        /// <param name="latestConfigRevision"> Latest Configuration Revision. </param>
        /// <param name="isConfigured"> Has this solution template version been configured. </param>
        /// <returns> A new <see cref="Models.AvailableSolutionTemplateVersion"/> instance for mocking. </returns>
        public static AvailableSolutionTemplateVersion AvailableSolutionTemplateVersion(string solutionTemplateVersion = null, string latestConfigRevision = null, bool isConfigured = default)
        {
            return new AvailableSolutionTemplateVersion(solutionTemplateVersion, latestConfigRevision, isConfigured, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeDeploymentInstanceData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeDeploymentInstanceData"/> instance for mocking. </returns>
        public static EdgeDeploymentInstanceData EdgeDeploymentInstanceData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, InstanceProperties properties = null, AzureResourceManagerCommonTypesExtendedLocation extendedLocation = null, string etag = null)
        {
            return new EdgeDeploymentInstanceData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.InstanceProperties"/>. </summary>
        /// <param name="solutionVersionId"> Solution version of instance. </param>
        /// <param name="targetId"> Target of instance. </param>
        /// <param name="activeState"> State of instance. </param>
        /// <param name="reconciliationPolicy"> Reconciliation policy of instance. </param>
        /// <param name="solutionScope"> Scope of instance. </param>
        /// <param name="status"> Status of instance. </param>
        /// <param name="deploymentTimestampEpoch"> Deployment timestamp of instance. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.InstanceProperties"/> instance for mocking. </returns>
        public static InstanceProperties InstanceProperties(string solutionVersionId = null, string targetId = null, ActiveState? activeState = null, ReconciliationPolicyProperties reconciliationPolicy = null, string solutionScope = null, DeploymentStatus status = null, long? deploymentTimestampEpoch = null, ProvisioningState? provisioningState = null)
        {
            return new InstanceProperties(
                solutionVersionId,
                targetId,
                activeState,
                reconciliationPolicy,
                solutionScope,
                status,
                deploymentTimestampEpoch,
                provisioningState,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.EdgeDeploymentInstancePatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.EdgeDeploymentInstancePatch"/> instance for mocking. </returns>
        public static EdgeDeploymentInstancePatch EdgeDeploymentInstancePatch(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, InstancePropertiesUpdate properties = null)
        {
            return new EdgeDeploymentInstancePatch(
                id,
                name,
                resourceType,
                systemData,
                properties,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestration.EdgeDeploymentInstanceHistoryData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <returns> A new <see cref="WorkloadOrchestration.EdgeDeploymentInstanceHistoryData"/> instance for mocking. </returns>
        public static EdgeDeploymentInstanceHistoryData EdgeDeploymentInstanceHistoryData(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, InstanceHistoryProperties properties = null, AzureResourceManagerCommonTypesExtendedLocation extendedLocation = null, string etag = null)
        {
            return new EdgeDeploymentInstanceHistoryData(
                id,
                name,
                resourceType,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.InstanceHistoryProperties"/>. </summary>
        /// <param name="solutionVersion"> Solution version of instance. </param>
        /// <param name="target"> Target of instance. </param>
        /// <param name="solutionScope"> Scope of instance. </param>
        /// <param name="activeState"> State of instance. </param>
        /// <param name="reconciliationPolicy"> Reconciliation policy of instance. </param>
        /// <param name="status"> Deployment Status of instance. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <returns> A new <see cref="Models.InstanceHistoryProperties"/> instance for mocking. </returns>
        public static InstanceHistoryProperties InstanceHistoryProperties(SolutionVersionSnapshot solutionVersion = null, TargetSnapshot target = null, string solutionScope = null, ActiveState? activeState = null, ReconciliationPolicyProperties reconciliationPolicy = null, DeploymentStatus status = null, ProvisioningState? provisioningState = null)
        {
            return new InstanceHistoryProperties(
                solutionVersion,
                target,
                solutionScope,
                activeState,
                reconciliationPolicy,
                status,
                provisioningState,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.SolutionVersionSnapshot"/>. </summary>
        /// <param name="solutionVersionId"> Solution version of instance. </param>
        /// <param name="specification"> App components spec. </param>
        /// <returns> A new <see cref="Models.SolutionVersionSnapshot"/> instance for mocking. </returns>
        public static SolutionVersionSnapshot SolutionVersionSnapshot(ResourceIdentifier solutionVersionId = null, IReadOnlyDictionary<string, BinaryData> specification = null)
        {
            specification ??= new Dictionary<string, BinaryData>();

            return new SolutionVersionSnapshot(solutionVersionId, specification, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.TargetSnapshot"/>. </summary>
        /// <param name="targetId"> Target of instance. </param>
        /// <param name="targetSpecification"> target spec. </param>
        /// <param name="solutionScope"> Scope of the target resource. </param>
        /// <returns> A new <see cref="Models.TargetSnapshot"/> instance for mocking. </returns>
        public static TargetSnapshot TargetSnapshot(ResourceIdentifier targetId = null, IReadOnlyDictionary<string, BinaryData> targetSpecification = null, string solutionScope = null)
        {
            targetSpecification ??= new Dictionary<string, BinaryData>();

            return new TargetSnapshot(targetId, targetSpecification, solutionScope, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.EdgeSolutionVersionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="solutionVersionPropertiesUpdateSpecification"> The resource-specific properties for this resource. </param>
        /// <returns> A new <see cref="Models.EdgeSolutionVersionPatch"/> instance for mocking. </returns>
        public static EdgeSolutionVersionPatch EdgeSolutionVersionPatch(ResourceIdentifier id = null, string name = null, ResourceType resourceType = default, SystemData systemData = null, IDictionary<string, BinaryData> solutionVersionPropertiesUpdateSpecification = null)
        {
            solutionVersionPropertiesUpdateSpecification ??= new Dictionary<string, BinaryData>();

            return new EdgeSolutionVersionPatch(
                id,
                name,
                resourceType,
                systemData,
                solutionVersionPropertiesUpdateSpecification != null ? new SolutionVersionPropertiesUpdate(solutionVersionPropertiesUpdateSpecification, serializedAdditionalRawData: null) : null,
                serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.WorkloadOrchestrationUninstallSolutionContent"/>. </summary>
        /// <param name="solutionTemplateId"> Solution Template ARM Id. </param>
        /// <param name="solutionInstanceName"> Solution Instance Name. </param>
        /// <returns> A new <see cref="Models.WorkloadOrchestrationUninstallSolutionContent"/> instance for mocking. </returns>
        public static WorkloadOrchestrationUninstallSolutionContent WorkloadOrchestrationUninstallSolutionContent(string solutionTemplateId = null, string solutionInstanceName = null)
        {
            return new WorkloadOrchestrationUninstallSolutionContent(solutionTemplateId, solutionInstanceName, serializedAdditionalRawData: null);
        }

        /// <summary> Initializes a new instance of <see cref="Models.WorkloadOrchestrationUpdateExternalValidationStatusContent"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version Id. </param>
        /// <param name="errorDetails"> Error Details if any failure is there. </param>
        /// <param name="externalValidationId"> External validation id. </param>
        /// <param name="validationStatus"> Validation Status of external validation. </param>
        /// <returns> A new <see cref="Models.WorkloadOrchestrationUpdateExternalValidationStatusContent"/> instance for mocking. </returns>
        public static WorkloadOrchestrationUpdateExternalValidationStatusContent WorkloadOrchestrationUpdateExternalValidationStatusContent(string solutionVersionId = null, ResponseError errorDetails = null, string externalValidationId = null, ValidationStatus validationStatus = default)
        {
            return new WorkloadOrchestrationUpdateExternalValidationStatusContent(solutionVersionId, errorDetails, externalValidationId, validationStatus, serializedAdditionalRawData: null);
        }
    }
}



================================================
FILE: Generated/EdgeConfigTemplateCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeConfigTemplateResource"/> and their operations.
    /// Each <see cref="EdgeConfigTemplateResource"/> in the collection will belong to the same instance of <see cref="ResourceGroupResource"/>.
    /// To get an <see cref="EdgeConfigTemplateCollection"/> instance call the GetEdgeConfigTemplates method from an instance of <see cref="ResourceGroupResource"/>.
    /// </summary>
    public partial class EdgeConfigTemplateCollection : ArmCollection, IEnumerable<EdgeConfigTemplateResource>, IAsyncEnumerable<EdgeConfigTemplateResource>
    {
        private readonly ClientDiagnostics _edgeConfigTemplateConfigTemplatesClientDiagnostics;
        private readonly ConfigTemplatesRestOperations _edgeConfigTemplateConfigTemplatesRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateCollection"/> class for mocking. </summary>
        protected EdgeConfigTemplateCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeConfigTemplateCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeConfigTemplateConfigTemplatesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeConfigTemplateResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeConfigTemplateResource.ResourceType, out string edgeConfigTemplateConfigTemplatesApiVersion);
            _edgeConfigTemplateConfigTemplatesRestClient = new ConfigTemplatesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeConfigTemplateConfigTemplatesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceGroupResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceGroupResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeConfigTemplateResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string configTemplateName, EdgeConfigTemplateData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateConfigTemplatesRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeConfigTemplateResource>(new EdgeConfigTemplateOperationSource(Client), _edgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, _edgeConfigTemplateConfigTemplatesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeConfigTemplateResource> CreateOrUpdate(WaitUntil waitUntil, string configTemplateName, EdgeConfigTemplateData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateConfigTemplatesRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeConfigTemplateResource>(new EdgeConfigTemplateOperationSource(Client), _edgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, _edgeConfigTemplateConfigTemplatesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        public virtual async Task<Response<EdgeConfigTemplateResource>> GetAsync(string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateConfigTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        public virtual Response<EdgeConfigTemplateResource> Get(string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateConfigTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeConfigTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeConfigTemplateResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeConfigTemplateConfigTemplatesRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeConfigTemplateConfigTemplatesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeConfigTemplateResource(Client, EdgeConfigTemplateData.DeserializeEdgeConfigTemplateData(e)), _edgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, "EdgeConfigTemplateCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeConfigTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeConfigTemplateResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeConfigTemplateConfigTemplatesRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeConfigTemplateConfigTemplatesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeConfigTemplateResource(Client, EdgeConfigTemplateData.DeserializeEdgeConfigTemplateData(e)), _edgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, "EdgeConfigTemplateCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateConfigTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        public virtual Response<bool> Exists(string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateConfigTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeConfigTemplateResource>> GetIfExistsAsync(string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateConfigTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeConfigTemplateResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        public virtual NullableResponse<EdgeConfigTemplateResource> GetIfExists(string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateConfigTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, configTemplateName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeConfigTemplateResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeConfigTemplateResource> IEnumerable<EdgeConfigTemplateResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeConfigTemplateResource> IAsyncEnumerable<EdgeConfigTemplateResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeConfigTemplateData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeConfigTemplate data model.
    /// Config Template Resource. Contains configuration expressions using the predefined expression language.
    /// </summary>
    public partial class EdgeConfigTemplateData : TrackedResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeConfigTemplateData"/>. </summary>
        /// <param name="location"> The location. </param>
        public EdgeConfigTemplateData(AzureLocation location) : base(location)
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeConfigTemplateData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeConfigTemplateData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, IDictionary<string, string> tags, AzureLocation location, ConfigTemplateProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData, tags, location)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="EdgeConfigTemplateData"/> for deserialization. </summary>
        internal EdgeConfigTemplateData()
        {
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public ConfigTemplateProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeConfigTemplateData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeConfigTemplateData : IUtf8JsonSerializable, IJsonModel<EdgeConfigTemplateData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeConfigTemplateData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeConfigTemplateData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplateData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeConfigTemplateData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeConfigTemplateData IJsonModel<EdgeConfigTemplateData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplateData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeConfigTemplateData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeConfigTemplateData(document.RootElement, options);
        }

        internal static EdgeConfigTemplateData DeserializeEdgeConfigTemplateData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ConfigTemplateProperties properties = default;
            string etag = default;
            IDictionary<string, string> tags = default;
            AzureLocation location = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = ConfigTemplateProperties.DeserializeConfigTemplateProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("location"u8))
                {
                    location = new AzureLocation(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeConfigTemplateData(
                id,
                name,
                type,
                systemData,
                tags ?? new ChangeTrackingDictionary<string, string>(),
                location,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeConfigTemplateData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplateData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeConfigTemplateData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeConfigTemplateData IPersistableModel<EdgeConfigTemplateData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplateData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeConfigTemplateData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeConfigTemplateData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeConfigTemplateData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeConfigTemplateResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeConfigTemplate along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeConfigTemplateResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeConfigTemplateResource method.
    /// Otherwise you can get one from its parent resource <see cref="ResourceGroupResource"/> using the GetEdgeConfigTemplate method.
    /// </summary>
    public partial class EdgeConfigTemplateResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeConfigTemplateResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="configTemplateName"> The configTemplateName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string configTemplateName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeConfigTemplateConfigTemplatesClientDiagnostics;
        private readonly ConfigTemplatesRestOperations _edgeConfigTemplateConfigTemplatesRestClient;
        private readonly EdgeConfigTemplateData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/configTemplates";

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateResource"/> class for mocking. </summary>
        protected EdgeConfigTemplateResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeConfigTemplateResource(ArmClient client, EdgeConfigTemplateData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeConfigTemplateResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeConfigTemplateConfigTemplatesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeConfigTemplateConfigTemplatesApiVersion);
            _edgeConfigTemplateConfigTemplatesRestClient = new ConfigTemplatesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeConfigTemplateConfigTemplatesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeConfigTemplateData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeConfigTemplateVersionResources in the EdgeConfigTemplate. </summary>
        /// <returns> An object representing collection of EdgeConfigTemplateVersionResources and their operations over a EdgeConfigTemplateVersionResource. </returns>
        public virtual EdgeConfigTemplateVersionCollection GetEdgeConfigTemplateVersions()
        {
            return GetCachedClient(client => new EdgeConfigTemplateVersionCollection(client, Id));
        }

        /// <summary>
        /// Get a Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeConfigTemplateVersionResource>> GetEdgeConfigTemplateVersionAsync(string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeConfigTemplateVersions().GetAsync(configTemplateVersionName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeConfigTemplateVersionResource> GetEdgeConfigTemplateVersion(string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            return GetEdgeConfigTemplateVersions().Get(configTemplateVersionName, cancellationToken);
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeConfigTemplateResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateConfigTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeConfigTemplateResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.Get");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateConfigTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateConfigTemplatesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, _edgeConfigTemplateConfigTemplatesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateConfigTemplatesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, _edgeConfigTemplateConfigTemplatesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<Response<EdgeConfigTemplateResource>> UpdateAsync(EdgeConfigTemplatePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateConfigTemplatesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new EdgeConfigTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual Response<EdgeConfigTemplateResource> Update(EdgeConfigTemplatePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.Update");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateConfigTemplatesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken);
                return Response.FromValue(new EdgeConfigTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Config Template Version Resource with the specified UpdateType
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/createVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_CreateVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeConfigTemplateVersionResource>> CreateVersionAsync(WaitUntil waitUntil, ConfigTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.CreateVersion");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateConfigTemplatesRestClient.CreateVersionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeConfigTemplateVersionResource>(new EdgeConfigTemplateVersionOperationSource(Client), _edgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, _edgeConfigTemplateConfigTemplatesRestClient.CreateCreateVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Config Template Version Resource with the specified UpdateType
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/createVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_CreateVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        public virtual ArmOperation<EdgeConfigTemplateVersionResource> CreateVersion(WaitUntil waitUntil, ConfigTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.CreateVersion");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateConfigTemplatesRestClient.CreateVersion(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeConfigTemplateVersionResource>(new EdgeConfigTemplateVersionOperationSource(Client), _edgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, _edgeConfigTemplateConfigTemplatesRestClient.CreateCreateVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/removeVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_RemoveVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<Response<WorkloadOrchestrationRemoveVersionResult>> RemoveVersionAsync(WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.RemoveVersion");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateConfigTemplatesRestClient.RemoveVersionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/removeVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_RemoveVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual Response<WorkloadOrchestrationRemoveVersionResult> RemoveVersion(WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.RemoveVersion");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateConfigTemplatesRestClient.RemoveVersion(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual async Task<Response<EdgeConfigTemplateResource>> AddTagAsync(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.AddTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues[key] = value;
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeConfigTemplateConfigTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeConfigTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeConfigTemplatePatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = await UpdateAsync(patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual Response<EdgeConfigTemplateResource> AddTag(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.AddTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues[key] = value;
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeConfigTemplateConfigTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeConfigTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeConfigTemplatePatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = Update(patch, cancellationToken: cancellationToken);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual async Task<Response<EdgeConfigTemplateResource>> SetTagsAsync(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.SetTags");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    await GetTagResource().DeleteAsync(WaitUntil.Completed, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeConfigTemplateConfigTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeConfigTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeConfigTemplatePatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = await UpdateAsync(patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual Response<EdgeConfigTemplateResource> SetTags(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.SetTags");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    GetTagResource().Delete(WaitUntil.Completed, cancellationToken: cancellationToken);
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeConfigTemplateConfigTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeConfigTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeConfigTemplatePatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = Update(patch, cancellationToken: cancellationToken);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual async Task<Response<EdgeConfigTemplateResource>> RemoveTagAsync(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.RemoveTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.Remove(key);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeConfigTemplateConfigTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeConfigTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeConfigTemplatePatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = await UpdateAsync(patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual Response<EdgeConfigTemplateResource> RemoveTag(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeConfigTemplateConfigTemplatesClientDiagnostics.CreateScope("EdgeConfigTemplateResource.RemoveTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.Remove(key);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeConfigTemplateConfigTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeConfigTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeConfigTemplatePatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = Update(patch, cancellationToken: cancellationToken);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeConfigTemplateResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeConfigTemplateResource : IJsonModel<EdgeConfigTemplateData>
    {
        private static EdgeConfigTemplateData s_dataDeserializationInstance;
        private static EdgeConfigTemplateData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeConfigTemplateData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeConfigTemplateData>)Data).Write(writer, options);

        EdgeConfigTemplateData IJsonModel<EdgeConfigTemplateData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeConfigTemplateData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeConfigTemplateData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeConfigTemplateData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeConfigTemplateData IPersistableModel<EdgeConfigTemplateData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeConfigTemplateData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeConfigTemplateData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeConfigTemplateData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeConfigTemplateVersionCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeConfigTemplateVersionResource"/> and their operations.
    /// Each <see cref="EdgeConfigTemplateVersionResource"/> in the collection will belong to the same instance of <see cref="EdgeConfigTemplateResource"/>.
    /// To get an <see cref="EdgeConfigTemplateVersionCollection"/> instance call the GetEdgeConfigTemplateVersions method from an instance of <see cref="EdgeConfigTemplateResource"/>.
    /// </summary>
    public partial class EdgeConfigTemplateVersionCollection : ArmCollection, IEnumerable<EdgeConfigTemplateVersionResource>, IAsyncEnumerable<EdgeConfigTemplateVersionResource>
    {
        private readonly ClientDiagnostics _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics;
        private readonly ConfigTemplateVersionsRestOperations _edgeConfigTemplateVersionConfigTemplateVersionsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateVersionCollection"/> class for mocking. </summary>
        protected EdgeConfigTemplateVersionCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateVersionCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeConfigTemplateVersionCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeConfigTemplateVersionResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeConfigTemplateVersionResource.ResourceType, out string edgeConfigTemplateVersionConfigTemplateVersionsApiVersion);
            _edgeConfigTemplateVersionConfigTemplateVersionsRestClient = new ConfigTemplateVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeConfigTemplateVersionConfigTemplateVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeConfigTemplateResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeConfigTemplateResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Get a Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateVersionName"/> is null. </exception>
        public virtual async Task<Response<EdgeConfigTemplateVersionResource>> GetAsync(string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateVersionName, nameof(configTemplateVersionName));

            using var scope = _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics.CreateScope("EdgeConfigTemplateVersionCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, configTemplateVersionName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateVersionName"/> is null. </exception>
        public virtual Response<EdgeConfigTemplateVersionResource> Get(string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateVersionName, nameof(configTemplateVersionName));

            using var scope = _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics.CreateScope("EdgeConfigTemplateVersionCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, configTemplateVersionName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Config Template Version Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_ListByConfigTemplate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeConfigTemplateVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeConfigTemplateVersionResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.CreateListByConfigTemplateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.CreateListByConfigTemplateNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeConfigTemplateVersionResource(Client, EdgeConfigTemplateVersionData.DeserializeEdgeConfigTemplateVersionData(e)), _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics, Pipeline, "EdgeConfigTemplateVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Config Template Version Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_ListByConfigTemplate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeConfigTemplateVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeConfigTemplateVersionResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.CreateListByConfigTemplateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.CreateListByConfigTemplateNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeConfigTemplateVersionResource(Client, EdgeConfigTemplateVersionData.DeserializeEdgeConfigTemplateVersionData(e)), _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics, Pipeline, "EdgeConfigTemplateVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateVersionName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateVersionName, nameof(configTemplateVersionName));

            using var scope = _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics.CreateScope("EdgeConfigTemplateVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, configTemplateVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateVersionName"/> is null. </exception>
        public virtual Response<bool> Exists(string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateVersionName, nameof(configTemplateVersionName));

            using var scope = _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics.CreateScope("EdgeConfigTemplateVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, configTemplateVersionName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateVersionName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeConfigTemplateVersionResource>> GetIfExistsAsync(string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateVersionName, nameof(configTemplateVersionName));

            using var scope = _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics.CreateScope("EdgeConfigTemplateVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, configTemplateVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeConfigTemplateVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateVersionName"/> is null. </exception>
        public virtual NullableResponse<EdgeConfigTemplateVersionResource> GetIfExists(string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(configTemplateVersionName, nameof(configTemplateVersionName));

            using var scope = _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics.CreateScope("EdgeConfigTemplateVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, configTemplateVersionName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeConfigTemplateVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeConfigTemplateVersionResource> IEnumerable<EdgeConfigTemplateVersionResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeConfigTemplateVersionResource> IAsyncEnumerable<EdgeConfigTemplateVersionResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeConfigTemplateVersionData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeConfigTemplateVersion data model.
    /// Config Template Version Resource
    /// </summary>
    public partial class EdgeConfigTemplateVersionData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeConfigTemplateVersionData"/>. </summary>
        public EdgeConfigTemplateVersionData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeConfigTemplateVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeConfigTemplateVersionData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, ConfigTemplateVersionProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public ConfigTemplateVersionProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeConfigTemplateVersionData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeConfigTemplateVersionData : IUtf8JsonSerializable, IJsonModel<EdgeConfigTemplateVersionData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeConfigTemplateVersionData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeConfigTemplateVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplateVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeConfigTemplateVersionData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeConfigTemplateVersionData IJsonModel<EdgeConfigTemplateVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplateVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeConfigTemplateVersionData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeConfigTemplateVersionData(document.RootElement, options);
        }

        internal static EdgeConfigTemplateVersionData DeserializeEdgeConfigTemplateVersionData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ConfigTemplateVersionProperties properties = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = ConfigTemplateVersionProperties.DeserializeConfigTemplateVersionProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeConfigTemplateVersionData(
                id,
                name,
                type,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeConfigTemplateVersionData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplateVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeConfigTemplateVersionData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeConfigTemplateVersionData IPersistableModel<EdgeConfigTemplateVersionData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplateVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeConfigTemplateVersionData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeConfigTemplateVersionData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeConfigTemplateVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeConfigTemplateVersionResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeConfigTemplateVersion along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeConfigTemplateVersionResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeConfigTemplateVersionResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeConfigTemplateResource"/> using the GetEdgeConfigTemplateVersion method.
    /// </summary>
    public partial class EdgeConfigTemplateVersionResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeConfigTemplateVersionResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="configTemplateName"> The configTemplateName. </param>
        /// <param name="configTemplateVersionName"> The configTemplateVersionName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string configTemplateName, string configTemplateVersionName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics;
        private readonly ConfigTemplateVersionsRestOperations _edgeConfigTemplateVersionConfigTemplateVersionsRestClient;
        private readonly EdgeConfigTemplateVersionData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/configTemplates/versions";

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateVersionResource"/> class for mocking. </summary>
        protected EdgeConfigTemplateVersionResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeConfigTemplateVersionResource(ArmClient client, EdgeConfigTemplateVersionData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeConfigTemplateVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeConfigTemplateVersionResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeConfigTemplateVersionConfigTemplateVersionsApiVersion);
            _edgeConfigTemplateVersionConfigTemplateVersionsRestClient = new ConfigTemplateVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeConfigTemplateVersionConfigTemplateVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeConfigTemplateVersionData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get a Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeConfigTemplateVersionResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics.CreateScope("EdgeConfigTemplateVersionResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Config Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}/versions/{configTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeConfigTemplateVersionResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeConfigTemplateVersionConfigTemplateVersionsClientDiagnostics.CreateScope("EdgeConfigTemplateVersionResource.Get");
            scope.Start();
            try
            {
                var response = _edgeConfigTemplateVersionConfigTemplateVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeConfigTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeConfigTemplateVersionResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeConfigTemplateVersionResource : IJsonModel<EdgeConfigTemplateVersionData>
    {
        private static EdgeConfigTemplateVersionData s_dataDeserializationInstance;
        private static EdgeConfigTemplateVersionData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeConfigTemplateVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeConfigTemplateVersionData>)Data).Write(writer, options);

        EdgeConfigTemplateVersionData IJsonModel<EdgeConfigTemplateVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeConfigTemplateVersionData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeConfigTemplateVersionData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeConfigTemplateVersionData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeConfigTemplateVersionData IPersistableModel<EdgeConfigTemplateVersionData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeConfigTemplateVersionData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeConfigTemplateVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeConfigTemplateVersionData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeContextCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeContextResource"/> and their operations.
    /// Each <see cref="EdgeContextResource"/> in the collection will belong to the same instance of <see cref="ResourceGroupResource"/>.
    /// To get an <see cref="EdgeContextCollection"/> instance call the GetEdgeContexts method from an instance of <see cref="ResourceGroupResource"/>.
    /// </summary>
    public partial class EdgeContextCollection : ArmCollection, IEnumerable<EdgeContextResource>, IAsyncEnumerable<EdgeContextResource>
    {
        private readonly ClientDiagnostics _edgeContextContextsClientDiagnostics;
        private readonly ContextsRestOperations _edgeContextContextsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeContextCollection"/> class for mocking. </summary>
        protected EdgeContextCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeContextCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeContextCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeContextContextsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeContextResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeContextResource.ResourceType, out string edgeContextContextsApiVersion);
            _edgeContextContextsRestClient = new ContextsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeContextContextsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceGroupResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceGroupResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeContextResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string contextName, EdgeContextData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeContextContextsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, contextName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeContextResource>(new EdgeContextOperationSource(Client), _edgeContextContextsClientDiagnostics, Pipeline, _edgeContextContextsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, contextName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeContextResource> CreateOrUpdate(WaitUntil waitUntil, string contextName, EdgeContextData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeContextContextsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, contextName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeContextResource>(new EdgeContextOperationSource(Client), _edgeContextContextsClientDiagnostics, Pipeline, _edgeContextContextsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, contextName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        public virtual async Task<Response<EdgeContextResource>> GetAsync(string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeContextContextsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, contextName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeContextResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        public virtual Response<EdgeContextResource> Get(string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeContextContextsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, contextName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeContextResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeContextResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeContextResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeContextContextsRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeContextContextsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeContextResource(Client, EdgeContextData.DeserializeEdgeContextData(e)), _edgeContextContextsClientDiagnostics, Pipeline, "EdgeContextCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeContextResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeContextResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeContextContextsRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeContextContextsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeContextResource(Client, EdgeContextData.DeserializeEdgeContextData(e)), _edgeContextContextsClientDiagnostics, Pipeline, "EdgeContextCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeContextContextsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, contextName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        public virtual Response<bool> Exists(string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeContextContextsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, contextName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeContextResource>> GetIfExistsAsync(string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeContextContextsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, contextName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeContextResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeContextResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        public virtual NullableResponse<EdgeContextResource> GetIfExists(string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeContextContextsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, contextName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeContextResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeContextResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeContextResource> IEnumerable<EdgeContextResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeContextResource> IAsyncEnumerable<EdgeContextResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeContextData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeContext data model.
    /// Context Resource
    /// </summary>
    public partial class EdgeContextData : TrackedResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeContextData"/>. </summary>
        /// <param name="location"> The location. </param>
        public EdgeContextData(AzureLocation location) : base(location)
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeContextData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeContextData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, IDictionary<string, string> tags, AzureLocation location, ContextProperties properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData, tags, location)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="EdgeContextData"/> for deserialization. </summary>
        internal EdgeContextData()
        {
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public ContextProperties Properties { get; set; }
    }
}



================================================
FILE: Generated/EdgeContextData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeContextData : IUtf8JsonSerializable, IJsonModel<EdgeContextData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeContextData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeContextData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeContextData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeContextData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeContextData IJsonModel<EdgeContextData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeContextData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeContextData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeContextData(document.RootElement, options);
        }

        internal static EdgeContextData DeserializeEdgeContextData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ContextProperties properties = default;
            IDictionary<string, string> tags = default;
            AzureLocation location = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = ContextProperties.DeserializeContextProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("location"u8))
                {
                    location = new AzureLocation(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeContextData(
                id,
                name,
                type,
                systemData,
                tags ?? new ChangeTrackingDictionary<string, string>(),
                location,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeContextData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeContextData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeContextData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeContextData IPersistableModel<EdgeContextData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeContextData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeContextData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeContextData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeContextData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeContextResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeContext along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeContextResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeContextResource method.
    /// Otherwise you can get one from its parent resource <see cref="ResourceGroupResource"/> using the GetEdgeContext method.
    /// </summary>
    public partial class EdgeContextResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeContextResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="contextName"> The contextName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string contextName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeContextContextsClientDiagnostics;
        private readonly ContextsRestOperations _edgeContextContextsRestClient;
        private readonly EdgeContextData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/contexts";

        /// <summary> Initializes a new instance of the <see cref="EdgeContextResource"/> class for mocking. </summary>
        protected EdgeContextResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeContextResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeContextResource(ArmClient client, EdgeContextData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeContextResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeContextResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeContextContextsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeContextContextsApiVersion);
            _edgeContextContextsRestClient = new ContextsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeContextContextsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeContextData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeSiteReferenceResources in the EdgeContext. </summary>
        /// <returns> An object representing collection of EdgeSiteReferenceResources and their operations over a EdgeSiteReferenceResource. </returns>
        public virtual EdgeSiteReferenceCollection GetEdgeSiteReferences()
        {
            return GetCachedClient(client => new EdgeSiteReferenceCollection(client, Id));
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSiteReferenceResource>> GetEdgeSiteReferenceAsync(string siteReferenceName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeSiteReferences().GetAsync(siteReferenceName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSiteReferenceResource> GetEdgeSiteReference(string siteReferenceName, CancellationToken cancellationToken = default)
        {
            return GetEdgeSiteReferences().Get(siteReferenceName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeWorkflowResources in the EdgeContext. </summary>
        /// <returns> An object representing collection of EdgeWorkflowResources and their operations over a EdgeWorkflowResource. </returns>
        public virtual EdgeWorkflowCollection GetEdgeWorkflows()
        {
            return GetCachedClient(client => new EdgeWorkflowCollection(client, Id));
        }

        /// <summary>
        /// Get a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeWorkflowResource>> GetEdgeWorkflowAsync(string workflowName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeWorkflows().GetAsync(workflowName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeWorkflowResource> GetEdgeWorkflow(string workflowName, CancellationToken cancellationToken = default)
        {
            return GetEdgeWorkflows().Get(workflowName, cancellationToken);
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeContextResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeContextContextsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeContextResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeContextResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.Get");
            scope.Start();
            try
            {
                var response = _edgeContextContextsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeContextResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeContextContextsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeContextContextsClientDiagnostics, Pipeline, _edgeContextContextsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeContextContextsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeContextContextsClientDiagnostics, Pipeline, _edgeContextContextsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update an Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeContextResource>> UpdateAsync(WaitUntil waitUntil, EdgeContextPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeContextContextsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeContextResource>(new EdgeContextOperationSource(Client), _edgeContextContextsClientDiagnostics, Pipeline, _edgeContextContextsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update an Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeContextResource> Update(WaitUntil waitUntil, EdgeContextPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.Update");
            scope.Start();
            try
            {
                var response = _edgeContextContextsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeContextResource>(new EdgeContextOperationSource(Client), _edgeContextContextsClientDiagnostics, Pipeline, _edgeContextContextsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual async Task<Response<EdgeContextResource>> AddTagAsync(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.AddTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues[key] = value;
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeContextContextsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeContextResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeContextPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = await UpdateAsync(WaitUntil.Completed, patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual Response<EdgeContextResource> AddTag(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.AddTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues[key] = value;
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeContextContextsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeContextResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeContextPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = Update(WaitUntil.Completed, patch, cancellationToken: cancellationToken);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual async Task<Response<EdgeContextResource>> SetTagsAsync(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.SetTags");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    await GetTagResource().DeleteAsync(WaitUntil.Completed, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeContextContextsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeContextResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeContextPatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = await UpdateAsync(WaitUntil.Completed, patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual Response<EdgeContextResource> SetTags(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.SetTags");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    GetTagResource().Delete(WaitUntil.Completed, cancellationToken: cancellationToken);
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeContextContextsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeContextResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeContextPatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = Update(WaitUntil.Completed, patch, cancellationToken: cancellationToken);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual async Task<Response<EdgeContextResource>> RemoveTagAsync(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.RemoveTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.Remove(key);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeContextContextsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeContextResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeContextPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = await UpdateAsync(WaitUntil.Completed, patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual Response<EdgeContextResource> RemoveTag(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeContextContextsClientDiagnostics.CreateScope("EdgeContextResource.RemoveTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.Remove(key);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeContextContextsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeContextResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeContextPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = Update(WaitUntil.Completed, patch, cancellationToken: cancellationToken);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeContextResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeContextResource : IJsonModel<EdgeContextData>
    {
        private static EdgeContextData s_dataDeserializationInstance;
        private static EdgeContextData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeContextData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeContextData>)Data).Write(writer, options);

        EdgeContextData IJsonModel<EdgeContextData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeContextData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeContextData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeContextData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeContextData IPersistableModel<EdgeContextData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeContextData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeContextData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeContextData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeDeploymentInstanceResource"/> and their operations.
    /// Each <see cref="EdgeDeploymentInstanceResource"/> in the collection will belong to the same instance of <see cref="EdgeSolutionResource"/>.
    /// To get an <see cref="EdgeDeploymentInstanceCollection"/> instance call the GetEdgeDeploymentInstances method from an instance of <see cref="EdgeSolutionResource"/>.
    /// </summary>
    public partial class EdgeDeploymentInstanceCollection : ArmCollection, IEnumerable<EdgeDeploymentInstanceResource>, IAsyncEnumerable<EdgeDeploymentInstanceResource>
    {
        private readonly ClientDiagnostics _edgeDeploymentInstanceInstancesClientDiagnostics;
        private readonly InstancesRestOperations _edgeDeploymentInstanceInstancesRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceCollection"/> class for mocking. </summary>
        protected EdgeDeploymentInstanceCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeDeploymentInstanceCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDeploymentInstanceInstancesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeDeploymentInstanceResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeDeploymentInstanceResource.ResourceType, out string edgeDeploymentInstanceInstancesApiVersion);
            _edgeDeploymentInstanceInstancesRestClient = new InstancesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDeploymentInstanceInstancesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeSolutionResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeSolutionResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeDeploymentInstanceResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string instanceName, EdgeDeploymentInstanceData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceInstancesRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDeploymentInstanceResource>(new EdgeDeploymentInstanceOperationSource(Client), _edgeDeploymentInstanceInstancesClientDiagnostics, Pipeline, _edgeDeploymentInstanceInstancesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeDeploymentInstanceResource> CreateOrUpdate(WaitUntil waitUntil, string instanceName, EdgeDeploymentInstanceData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceInstancesRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDeploymentInstanceResource>(new EdgeDeploymentInstanceOperationSource(Client), _edgeDeploymentInstanceInstancesClientDiagnostics, Pipeline, _edgeDeploymentInstanceInstancesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> is null. </exception>
        public virtual async Task<Response<EdgeDeploymentInstanceResource>> GetAsync(string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceInstancesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> is null. </exception>
        public virtual Response<EdgeDeploymentInstanceResource> Get(string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceInstancesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Instance Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_ListBySolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeDeploymentInstanceResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeDeploymentInstanceResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDeploymentInstanceInstancesRestClient.CreateListBySolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDeploymentInstanceInstancesRestClient.CreateListBySolutionNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeDeploymentInstanceResource(Client, EdgeDeploymentInstanceData.DeserializeEdgeDeploymentInstanceData(e)), _edgeDeploymentInstanceInstancesClientDiagnostics, Pipeline, "EdgeDeploymentInstanceCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Instance Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_ListBySolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeDeploymentInstanceResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeDeploymentInstanceResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDeploymentInstanceInstancesRestClient.CreateListBySolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDeploymentInstanceInstancesRestClient.CreateListBySolutionNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeDeploymentInstanceResource(Client, EdgeDeploymentInstanceData.DeserializeEdgeDeploymentInstanceData(e)), _edgeDeploymentInstanceInstancesClientDiagnostics, Pipeline, "EdgeDeploymentInstanceCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceInstancesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> is null. </exception>
        public virtual Response<bool> Exists(string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceInstancesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeDeploymentInstanceResource>> GetIfExistsAsync(string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceInstancesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDeploymentInstanceResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> is null. </exception>
        public virtual NullableResponse<EdgeDeploymentInstanceResource> GetIfExists(string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceInstancesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, instanceName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDeploymentInstanceResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeDeploymentInstanceResource> IEnumerable<EdgeDeploymentInstanceResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeDeploymentInstanceResource> IAsyncEnumerable<EdgeDeploymentInstanceResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeDeploymentInstance data model.
    /// Instance Resource. Represents a deployment object.
    /// </summary>
    public partial class EdgeDeploymentInstanceData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeDeploymentInstanceData"/>. </summary>
        public EdgeDeploymentInstanceData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDeploymentInstanceData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeDeploymentInstanceData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, InstanceProperties properties, AzureResourceManagerCommonTypesExtendedLocation extendedLocation, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ExtendedLocation = extendedLocation;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public InstanceProperties Properties { get; set; }
        /// <summary> The complex type of the extended location. </summary>
        public AzureResourceManagerCommonTypesExtendedLocation ExtendedLocation { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDeploymentInstanceData : IUtf8JsonSerializable, IJsonModel<EdgeDeploymentInstanceData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeDeploymentInstanceData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeDeploymentInstanceData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstanceData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDeploymentInstanceData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (Optional.IsDefined(ExtendedLocation))
            {
                writer.WritePropertyName("extendedLocation"u8);
                writer.WriteObjectValue(ExtendedLocation, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeDeploymentInstanceData IJsonModel<EdgeDeploymentInstanceData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstanceData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDeploymentInstanceData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeDeploymentInstanceData(document.RootElement, options);
        }

        internal static EdgeDeploymentInstanceData DeserializeEdgeDeploymentInstanceData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            InstanceProperties properties = default;
            AzureResourceManagerCommonTypesExtendedLocation extendedLocation = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = InstanceProperties.DeserializeInstanceProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("extendedLocation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    extendedLocation = AzureResourceManagerCommonTypesExtendedLocation.DeserializeAzureResourceManagerCommonTypesExtendedLocation(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeDeploymentInstanceData(
                id,
                name,
                type,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeDeploymentInstanceData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstanceData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeDeploymentInstanceData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeDeploymentInstanceData IPersistableModel<EdgeDeploymentInstanceData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstanceData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeDeploymentInstanceData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeDeploymentInstanceData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeDeploymentInstanceData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceHistoryCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeDeploymentInstanceHistoryResource"/> and their operations.
    /// Each <see cref="EdgeDeploymentInstanceHistoryResource"/> in the collection will belong to the same instance of <see cref="EdgeDeploymentInstanceResource"/>.
    /// To get an <see cref="EdgeDeploymentInstanceHistoryCollection"/> instance call the GetEdgeDeploymentInstanceHistories method from an instance of <see cref="EdgeDeploymentInstanceResource"/>.
    /// </summary>
    public partial class EdgeDeploymentInstanceHistoryCollection : ArmCollection, IEnumerable<EdgeDeploymentInstanceHistoryResource>, IAsyncEnumerable<EdgeDeploymentInstanceHistoryResource>
    {
        private readonly ClientDiagnostics _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics;
        private readonly InstanceHistoriesRestOperations _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceHistoryCollection"/> class for mocking. </summary>
        protected EdgeDeploymentInstanceHistoryCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceHistoryCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeDeploymentInstanceHistoryCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeDeploymentInstanceHistoryResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeDeploymentInstanceHistoryResource.ResourceType, out string edgeDeploymentInstanceHistoryInstanceHistoriesApiVersion);
            _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient = new InstanceHistoriesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDeploymentInstanceHistoryInstanceHistoriesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeDeploymentInstanceResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeDeploymentInstanceResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Get InstanceHistory Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceHistoryName"/> is null. </exception>
        public virtual async Task<Response<EdgeDeploymentInstanceHistoryResource>> GetAsync(string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceHistoryName, nameof(instanceHistoryName));

            using var scope = _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics.CreateScope("EdgeDeploymentInstanceHistoryCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, instanceHistoryName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceHistoryResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get InstanceHistory Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceHistoryName"/> is null. </exception>
        public virtual Response<EdgeDeploymentInstanceHistoryResource> Get(string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceHistoryName, nameof(instanceHistoryName));

            using var scope = _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics.CreateScope("EdgeDeploymentInstanceHistoryCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, instanceHistoryName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceHistoryResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List InstanceHistory Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_ListByInstance</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeDeploymentInstanceHistoryResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeDeploymentInstanceHistoryResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.CreateListByInstanceRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.CreateListByInstanceNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeDeploymentInstanceHistoryResource(Client, EdgeDeploymentInstanceHistoryData.DeserializeEdgeDeploymentInstanceHistoryData(e)), _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics, Pipeline, "EdgeDeploymentInstanceHistoryCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List InstanceHistory Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_ListByInstance</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeDeploymentInstanceHistoryResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeDeploymentInstanceHistoryResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.CreateListByInstanceRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.CreateListByInstanceNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeDeploymentInstanceHistoryResource(Client, EdgeDeploymentInstanceHistoryData.DeserializeEdgeDeploymentInstanceHistoryData(e)), _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics, Pipeline, "EdgeDeploymentInstanceHistoryCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceHistoryName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceHistoryName, nameof(instanceHistoryName));

            using var scope = _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics.CreateScope("EdgeDeploymentInstanceHistoryCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, instanceHistoryName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceHistoryName"/> is null. </exception>
        public virtual Response<bool> Exists(string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceHistoryName, nameof(instanceHistoryName));

            using var scope = _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics.CreateScope("EdgeDeploymentInstanceHistoryCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, instanceHistoryName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceHistoryName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeDeploymentInstanceHistoryResource>> GetIfExistsAsync(string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceHistoryName, nameof(instanceHistoryName));

            using var scope = _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics.CreateScope("EdgeDeploymentInstanceHistoryCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, instanceHistoryName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDeploymentInstanceHistoryResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceHistoryResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceHistoryName"/> is null. </exception>
        public virtual NullableResponse<EdgeDeploymentInstanceHistoryResource> GetIfExists(string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(instanceHistoryName, nameof(instanceHistoryName));

            using var scope = _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics.CreateScope("EdgeDeploymentInstanceHistoryCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, instanceHistoryName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDeploymentInstanceHistoryResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceHistoryResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeDeploymentInstanceHistoryResource> IEnumerable<EdgeDeploymentInstanceHistoryResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeDeploymentInstanceHistoryResource> IAsyncEnumerable<EdgeDeploymentInstanceHistoryResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceHistoryData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeDeploymentInstanceHistory data model.
    /// InstanceHistory Resource
    /// </summary>
    public partial class EdgeDeploymentInstanceHistoryData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeDeploymentInstanceHistoryData"/>. </summary>
        public EdgeDeploymentInstanceHistoryData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDeploymentInstanceHistoryData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeDeploymentInstanceHistoryData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, InstanceHistoryProperties properties, AzureResourceManagerCommonTypesExtendedLocation extendedLocation, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ExtendedLocation = extendedLocation;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public InstanceHistoryProperties Properties { get; set; }
        /// <summary> The complex type of the extended location. </summary>
        public AzureResourceManagerCommonTypesExtendedLocation ExtendedLocation { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceHistoryData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDeploymentInstanceHistoryData : IUtf8JsonSerializable, IJsonModel<EdgeDeploymentInstanceHistoryData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeDeploymentInstanceHistoryData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeDeploymentInstanceHistoryData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstanceHistoryData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDeploymentInstanceHistoryData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (Optional.IsDefined(ExtendedLocation))
            {
                writer.WritePropertyName("extendedLocation"u8);
                writer.WriteObjectValue(ExtendedLocation, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeDeploymentInstanceHistoryData IJsonModel<EdgeDeploymentInstanceHistoryData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstanceHistoryData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDeploymentInstanceHistoryData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeDeploymentInstanceHistoryData(document.RootElement, options);
        }

        internal static EdgeDeploymentInstanceHistoryData DeserializeEdgeDeploymentInstanceHistoryData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            InstanceHistoryProperties properties = default;
            AzureResourceManagerCommonTypesExtendedLocation extendedLocation = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = InstanceHistoryProperties.DeserializeInstanceHistoryProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("extendedLocation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    extendedLocation = AzureResourceManagerCommonTypesExtendedLocation.DeserializeAzureResourceManagerCommonTypesExtendedLocation(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeDeploymentInstanceHistoryData(
                id,
                name,
                type,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeDeploymentInstanceHistoryData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstanceHistoryData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeDeploymentInstanceHistoryData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeDeploymentInstanceHistoryData IPersistableModel<EdgeDeploymentInstanceHistoryData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstanceHistoryData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeDeploymentInstanceHistoryData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeDeploymentInstanceHistoryData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeDeploymentInstanceHistoryData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceHistoryResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeDeploymentInstanceHistory along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeDeploymentInstanceHistoryResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeDeploymentInstanceHistoryResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeDeploymentInstanceResource"/> using the GetEdgeDeploymentInstanceHistory method.
    /// </summary>
    public partial class EdgeDeploymentInstanceHistoryResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeDeploymentInstanceHistoryResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="targetName"> The targetName. </param>
        /// <param name="solutionName"> The solutionName. </param>
        /// <param name="instanceName"> The instanceName. </param>
        /// <param name="instanceHistoryName"> The instanceHistoryName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, string instanceHistoryName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics;
        private readonly InstanceHistoriesRestOperations _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient;
        private readonly EdgeDeploymentInstanceHistoryData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/targets/solutions/instances/histories";

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceHistoryResource"/> class for mocking. </summary>
        protected EdgeDeploymentInstanceHistoryResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceHistoryResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeDeploymentInstanceHistoryResource(ArmClient client, EdgeDeploymentInstanceHistoryData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceHistoryResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeDeploymentInstanceHistoryResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeDeploymentInstanceHistoryInstanceHistoriesApiVersion);
            _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient = new InstanceHistoriesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDeploymentInstanceHistoryInstanceHistoriesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeDeploymentInstanceHistoryData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get InstanceHistory Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeDeploymentInstanceHistoryResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics.CreateScope("EdgeDeploymentInstanceHistoryResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceHistoryResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get InstanceHistory Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeDeploymentInstanceHistoryResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDeploymentInstanceHistoryInstanceHistoriesClientDiagnostics.CreateScope("EdgeDeploymentInstanceHistoryResource.Get");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceHistoryInstanceHistoriesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceHistoryResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceHistoryResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDeploymentInstanceHistoryResource : IJsonModel<EdgeDeploymentInstanceHistoryData>
    {
        private static EdgeDeploymentInstanceHistoryData s_dataDeserializationInstance;
        private static EdgeDeploymentInstanceHistoryData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeDeploymentInstanceHistoryData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDeploymentInstanceHistoryData>)Data).Write(writer, options);

        EdgeDeploymentInstanceHistoryData IJsonModel<EdgeDeploymentInstanceHistoryData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDeploymentInstanceHistoryData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeDeploymentInstanceHistoryData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeDeploymentInstanceHistoryData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeDeploymentInstanceHistoryData IPersistableModel<EdgeDeploymentInstanceHistoryData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeDeploymentInstanceHistoryData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeDeploymentInstanceHistoryData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeDeploymentInstanceHistoryData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeDeploymentInstance along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeDeploymentInstanceResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeDeploymentInstanceResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeSolutionResource"/> using the GetEdgeDeploymentInstance method.
    /// </summary>
    public partial class EdgeDeploymentInstanceResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeDeploymentInstanceResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="targetName"> The targetName. </param>
        /// <param name="solutionName"> The solutionName. </param>
        /// <param name="instanceName"> The instanceName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeDeploymentInstanceInstancesClientDiagnostics;
        private readonly InstancesRestOperations _edgeDeploymentInstanceInstancesRestClient;
        private readonly EdgeDeploymentInstanceData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/targets/solutions/instances";

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceResource"/> class for mocking. </summary>
        protected EdgeDeploymentInstanceResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeDeploymentInstanceResource(ArmClient client, EdgeDeploymentInstanceData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDeploymentInstanceResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeDeploymentInstanceResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDeploymentInstanceInstancesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeDeploymentInstanceInstancesApiVersion);
            _edgeDeploymentInstanceInstancesRestClient = new InstancesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDeploymentInstanceInstancesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeDeploymentInstanceData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeDeploymentInstanceHistoryResources in the EdgeDeploymentInstance. </summary>
        /// <returns> An object representing collection of EdgeDeploymentInstanceHistoryResources and their operations over a EdgeDeploymentInstanceHistoryResource. </returns>
        public virtual EdgeDeploymentInstanceHistoryCollection GetEdgeDeploymentInstanceHistories()
        {
            return GetCachedClient(client => new EdgeDeploymentInstanceHistoryCollection(client, Id));
        }

        /// <summary>
        /// Get InstanceHistory Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceHistoryName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeDeploymentInstanceHistoryResource>> GetEdgeDeploymentInstanceHistoryAsync(string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeDeploymentInstanceHistories().GetAsync(instanceHistoryName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get InstanceHistory Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}/histories/{instanceHistoryName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InstanceHistories_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceHistoryResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceHistoryName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeDeploymentInstanceHistoryResource> GetEdgeDeploymentInstanceHistory(string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            return GetEdgeDeploymentInstanceHistories().Get(instanceHistoryName, cancellationToken);
        }

        /// <summary>
        /// Get Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeDeploymentInstanceResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceInstancesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeDeploymentInstanceResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceResource.Get");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceInstancesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDeploymentInstanceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceInstancesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeDeploymentInstanceInstancesClientDiagnostics, Pipeline, _edgeDeploymentInstanceInstancesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceInstancesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeDeploymentInstanceInstancesClientDiagnostics, Pipeline, _edgeDeploymentInstanceInstancesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update an Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeDeploymentInstanceResource>> UpdateAsync(WaitUntil waitUntil, EdgeDeploymentInstancePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeDeploymentInstanceInstancesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDeploymentInstanceResource>(new EdgeDeploymentInstanceOperationSource(Client), _edgeDeploymentInstanceInstancesClientDiagnostics, Pipeline, _edgeDeploymentInstanceInstancesRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update an Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeDeploymentInstanceResource> Update(WaitUntil waitUntil, EdgeDeploymentInstancePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeDeploymentInstanceInstancesClientDiagnostics.CreateScope("EdgeDeploymentInstanceResource.Update");
            scope.Start();
            try
            {
                var response = _edgeDeploymentInstanceInstancesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDeploymentInstanceResource>(new EdgeDeploymentInstanceOperationSource(Client), _edgeDeploymentInstanceInstancesClientDiagnostics, Pipeline, _edgeDeploymentInstanceInstancesRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeDeploymentInstanceResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDeploymentInstanceResource : IJsonModel<EdgeDeploymentInstanceData>
    {
        private static EdgeDeploymentInstanceData s_dataDeserializationInstance;
        private static EdgeDeploymentInstanceData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeDeploymentInstanceData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDeploymentInstanceData>)Data).Write(writer, options);

        EdgeDeploymentInstanceData IJsonModel<EdgeDeploymentInstanceData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDeploymentInstanceData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeDeploymentInstanceData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeDeploymentInstanceData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeDeploymentInstanceData IPersistableModel<EdgeDeploymentInstanceData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeDeploymentInstanceData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeDeploymentInstanceData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeDeploymentInstanceData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeDiagnosticCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeDiagnosticResource"/> and their operations.
    /// Each <see cref="EdgeDiagnosticResource"/> in the collection will belong to the same instance of <see cref="ResourceGroupResource"/>.
    /// To get an <see cref="EdgeDiagnosticCollection"/> instance call the GetEdgeDiagnostics method from an instance of <see cref="ResourceGroupResource"/>.
    /// </summary>
    public partial class EdgeDiagnosticCollection : ArmCollection, IEnumerable<EdgeDiagnosticResource>, IAsyncEnumerable<EdgeDiagnosticResource>
    {
        private readonly ClientDiagnostics _edgeDiagnosticDiagnosticsClientDiagnostics;
        private readonly DiagnosticsRestOperations _edgeDiagnosticDiagnosticsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeDiagnosticCollection"/> class for mocking. </summary>
        protected EdgeDiagnosticCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDiagnosticCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeDiagnosticCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDiagnosticDiagnosticsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeDiagnosticResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeDiagnosticResource.ResourceType, out string edgeDiagnosticDiagnosticsApiVersion);
            _edgeDiagnosticDiagnosticsRestClient = new DiagnosticsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDiagnosticDiagnosticsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceGroupResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceGroupResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Creates new or updates existing Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeDiagnosticResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string diagnosticName, EdgeDiagnosticData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeDiagnosticDiagnosticsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDiagnosticResource>(new EdgeDiagnosticOperationSource(Client), _edgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, _edgeDiagnosticDiagnosticsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates new or updates existing Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeDiagnosticResource> CreateOrUpdate(WaitUntil waitUntil, string diagnosticName, EdgeDiagnosticData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeDiagnosticDiagnosticsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDiagnosticResource>(new EdgeDiagnosticOperationSource(Client), _edgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, _edgeDiagnosticDiagnosticsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        public virtual async Task<Response<EdgeDiagnosticResource>> GetAsync(string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeDiagnosticDiagnosticsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDiagnosticResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        public virtual Response<EdgeDiagnosticResource> Get(string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeDiagnosticDiagnosticsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDiagnosticResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns a collection of Diagnostic resources within the resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeDiagnosticResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeDiagnosticResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDiagnosticDiagnosticsRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDiagnosticDiagnosticsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeDiagnosticResource(Client, EdgeDiagnosticData.DeserializeEdgeDiagnosticData(e)), _edgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, "EdgeDiagnosticCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Returns a collection of Diagnostic resources within the resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeDiagnosticResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeDiagnosticResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDiagnosticDiagnosticsRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDiagnosticDiagnosticsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeDiagnosticResource(Client, EdgeDiagnosticData.DeserializeEdgeDiagnosticData(e)), _edgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, "EdgeDiagnosticCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeDiagnosticDiagnosticsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        public virtual Response<bool> Exists(string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeDiagnosticDiagnosticsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeDiagnosticResource>> GetIfExistsAsync(string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeDiagnosticDiagnosticsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDiagnosticResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDiagnosticResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        public virtual NullableResponse<EdgeDiagnosticResource> GetIfExists(string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeDiagnosticDiagnosticsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, diagnosticName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDiagnosticResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDiagnosticResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeDiagnosticResource> IEnumerable<EdgeDiagnosticResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeDiagnosticResource> IAsyncEnumerable<EdgeDiagnosticResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeDiagnosticData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeDiagnostic data model.
    /// A Diagnostic resource.
    /// </summary>
    public partial class EdgeDiagnosticData : TrackedResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeDiagnosticData"/>. </summary>
        /// <param name="location"> The location. </param>
        public EdgeDiagnosticData(AzureLocation location) : base(location)
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDiagnosticData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeDiagnosticData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, IDictionary<string, string> tags, AzureLocation location, DiagnosticProperties properties, AzureResourceManagerCommonTypesExtendedLocation extendedLocation, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData, tags, location)
        {
            Properties = properties;
            ExtendedLocation = extendedLocation;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDiagnosticData"/> for deserialization. </summary>
        internal EdgeDiagnosticData()
        {
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        internal DiagnosticProperties Properties { get; set; }
        /// <summary> The status of the last operation. </summary>
        public ProvisioningState? DiagnosticProvisioningState
        {
            get => Properties is null ? default : Properties.ProvisioningState;
        }

        /// <summary> The complex type of the extended location. </summary>
        public AzureResourceManagerCommonTypesExtendedLocation ExtendedLocation { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeDiagnosticData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDiagnosticData : IUtf8JsonSerializable, IJsonModel<EdgeDiagnosticData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeDiagnosticData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeDiagnosticData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDiagnosticData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDiagnosticData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (Optional.IsDefined(ExtendedLocation))
            {
                writer.WritePropertyName("extendedLocation"u8);
                writer.WriteObjectValue(ExtendedLocation, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeDiagnosticData IJsonModel<EdgeDiagnosticData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDiagnosticData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDiagnosticData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeDiagnosticData(document.RootElement, options);
        }

        internal static EdgeDiagnosticData DeserializeEdgeDiagnosticData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            DiagnosticProperties properties = default;
            AzureResourceManagerCommonTypesExtendedLocation extendedLocation = default;
            string etag = default;
            IDictionary<string, string> tags = default;
            AzureLocation location = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = DiagnosticProperties.DeserializeDiagnosticProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("extendedLocation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    extendedLocation = AzureResourceManagerCommonTypesExtendedLocation.DeserializeAzureResourceManagerCommonTypesExtendedLocation(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("location"u8))
                {
                    location = new AzureLocation(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeDiagnosticData(
                id,
                name,
                type,
                systemData,
                tags ?? new ChangeTrackingDictionary<string, string>(),
                location,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeDiagnosticData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDiagnosticData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeDiagnosticData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeDiagnosticData IPersistableModel<EdgeDiagnosticData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDiagnosticData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeDiagnosticData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeDiagnosticData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeDiagnosticData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeDiagnosticResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeDiagnostic along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeDiagnosticResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeDiagnosticResource method.
    /// Otherwise you can get one from its parent resource <see cref="ResourceGroupResource"/> using the GetEdgeDiagnostic method.
    /// </summary>
    public partial class EdgeDiagnosticResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeDiagnosticResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="diagnosticName"> The diagnosticName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string diagnosticName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeDiagnosticDiagnosticsClientDiagnostics;
        private readonly DiagnosticsRestOperations _edgeDiagnosticDiagnosticsRestClient;
        private readonly EdgeDiagnosticData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/diagnostics";

        /// <summary> Initializes a new instance of the <see cref="EdgeDiagnosticResource"/> class for mocking. </summary>
        protected EdgeDiagnosticResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDiagnosticResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeDiagnosticResource(ArmClient client, EdgeDiagnosticData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDiagnosticResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeDiagnosticResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDiagnosticDiagnosticsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeDiagnosticDiagnosticsApiVersion);
            _edgeDiagnosticDiagnosticsRestClient = new DiagnosticsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDiagnosticDiagnosticsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeDiagnosticData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeDiagnosticResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeDiagnosticDiagnosticsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDiagnosticResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeDiagnosticResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.Get");
            scope.Start();
            try
            {
                var response = _edgeDiagnosticDiagnosticsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDiagnosticResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeDiagnosticDiagnosticsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, _edgeDiagnosticDiagnosticsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeDiagnosticDiagnosticsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, _edgeDiagnosticDiagnosticsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates existing Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeDiagnosticResource>> UpdateAsync(WaitUntil waitUntil, EdgeDiagnosticPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeDiagnosticDiagnosticsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDiagnosticResource>(new EdgeDiagnosticOperationSource(Client), _edgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, _edgeDiagnosticDiagnosticsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates existing Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeDiagnosticResource> Update(WaitUntil waitUntil, EdgeDiagnosticPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.Update");
            scope.Start();
            try
            {
                var response = _edgeDiagnosticDiagnosticsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDiagnosticResource>(new EdgeDiagnosticOperationSource(Client), _edgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, _edgeDiagnosticDiagnosticsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual async Task<Response<EdgeDiagnosticResource>> AddTagAsync(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.AddTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues[key] = value;
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeDiagnosticDiagnosticsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeDiagnosticResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeDiagnosticPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = await UpdateAsync(WaitUntil.Completed, patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual Response<EdgeDiagnosticResource> AddTag(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.AddTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues[key] = value;
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeDiagnosticDiagnosticsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeDiagnosticResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeDiagnosticPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = Update(WaitUntil.Completed, patch, cancellationToken: cancellationToken);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual async Task<Response<EdgeDiagnosticResource>> SetTagsAsync(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.SetTags");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    await GetTagResource().DeleteAsync(WaitUntil.Completed, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeDiagnosticDiagnosticsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeDiagnosticResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeDiagnosticPatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = await UpdateAsync(WaitUntil.Completed, patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual Response<EdgeDiagnosticResource> SetTags(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.SetTags");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    GetTagResource().Delete(WaitUntil.Completed, cancellationToken: cancellationToken);
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeDiagnosticDiagnosticsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeDiagnosticResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeDiagnosticPatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = Update(WaitUntil.Completed, patch, cancellationToken: cancellationToken);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual async Task<Response<EdgeDiagnosticResource>> RemoveTagAsync(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.RemoveTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.Remove(key);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeDiagnosticDiagnosticsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeDiagnosticResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeDiagnosticPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = await UpdateAsync(WaitUntil.Completed, patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual Response<EdgeDiagnosticResource> RemoveTag(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeDiagnosticDiagnosticsClientDiagnostics.CreateScope("EdgeDiagnosticResource.RemoveTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.Remove(key);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeDiagnosticDiagnosticsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeDiagnosticResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeDiagnosticPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = Update(WaitUntil.Completed, patch, cancellationToken: cancellationToken);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeDiagnosticResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDiagnosticResource : IJsonModel<EdgeDiagnosticData>
    {
        private static EdgeDiagnosticData s_dataDeserializationInstance;
        private static EdgeDiagnosticData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeDiagnosticData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDiagnosticData>)Data).Write(writer, options);

        EdgeDiagnosticData IJsonModel<EdgeDiagnosticData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDiagnosticData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeDiagnosticData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeDiagnosticData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeDiagnosticData IPersistableModel<EdgeDiagnosticData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeDiagnosticData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeDiagnosticData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeDiagnosticData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeDynamicSchemaResource"/> and their operations.
    /// Each <see cref="EdgeDynamicSchemaResource"/> in the collection will belong to the same instance of <see cref="EdgeSchemaResource"/>.
    /// To get an <see cref="EdgeDynamicSchemaCollection"/> instance call the GetEdgeDynamicSchemas method from an instance of <see cref="EdgeSchemaResource"/>.
    /// </summary>
    public partial class EdgeDynamicSchemaCollection : ArmCollection, IEnumerable<EdgeDynamicSchemaResource>, IAsyncEnumerable<EdgeDynamicSchemaResource>
    {
        private readonly ClientDiagnostics _edgeDynamicSchemaDynamicSchemasClientDiagnostics;
        private readonly DynamicSchemasRestOperations _edgeDynamicSchemaDynamicSchemasRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaCollection"/> class for mocking. </summary>
        protected EdgeDynamicSchemaCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeDynamicSchemaCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDynamicSchemaDynamicSchemasClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeDynamicSchemaResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeDynamicSchemaResource.ResourceType, out string edgeDynamicSchemaDynamicSchemasApiVersion);
            _edgeDynamicSchemaDynamicSchemasRestClient = new DynamicSchemasRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDynamicSchemaDynamicSchemasApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeSchemaResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeSchemaResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeDynamicSchemaResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string dynamicSchemaName, EdgeDynamicSchemaData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaDynamicSchemasRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDynamicSchemaResource>(new EdgeDynamicSchemaOperationSource(Client), _edgeDynamicSchemaDynamicSchemasClientDiagnostics, Pipeline, _edgeDynamicSchemaDynamicSchemasRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeDynamicSchemaResource> CreateOrUpdate(WaitUntil waitUntil, string dynamicSchemaName, EdgeDynamicSchemaData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaDynamicSchemasRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDynamicSchemaResource>(new EdgeDynamicSchemaOperationSource(Client), _edgeDynamicSchemaDynamicSchemasClientDiagnostics, Pipeline, _edgeDynamicSchemaDynamicSchemasRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> is null. </exception>
        public virtual async Task<Response<EdgeDynamicSchemaResource>> GetAsync(string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaDynamicSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> is null. </exception>
        public virtual Response<EdgeDynamicSchemaResource> Get(string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaDynamicSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List by Schema
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_ListBySchema</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeDynamicSchemaResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeDynamicSchemaResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDynamicSchemaDynamicSchemasRestClient.CreateListBySchemaRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDynamicSchemaDynamicSchemasRestClient.CreateListBySchemaNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeDynamicSchemaResource(Client, EdgeDynamicSchemaData.DeserializeEdgeDynamicSchemaData(e)), _edgeDynamicSchemaDynamicSchemasClientDiagnostics, Pipeline, "EdgeDynamicSchemaCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by Schema
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_ListBySchema</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeDynamicSchemaResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeDynamicSchemaResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDynamicSchemaDynamicSchemasRestClient.CreateListBySchemaRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDynamicSchemaDynamicSchemasRestClient.CreateListBySchemaNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeDynamicSchemaResource(Client, EdgeDynamicSchemaData.DeserializeEdgeDynamicSchemaData(e)), _edgeDynamicSchemaDynamicSchemasClientDiagnostics, Pipeline, "EdgeDynamicSchemaCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaDynamicSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> is null. </exception>
        public virtual Response<bool> Exists(string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaDynamicSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeDynamicSchemaResource>> GetIfExistsAsync(string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaDynamicSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDynamicSchemaResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> is null. </exception>
        public virtual NullableResponse<EdgeDynamicSchemaResource> GetIfExists(string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaDynamicSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, dynamicSchemaName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDynamicSchemaResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeDynamicSchemaResource> IEnumerable<EdgeDynamicSchemaResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeDynamicSchemaResource> IAsyncEnumerable<EdgeDynamicSchemaResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeDynamicSchema data model.
    /// DynamicSchema Resource
    /// </summary>
    public partial class EdgeDynamicSchemaData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeDynamicSchemaData"/>. </summary>
        public EdgeDynamicSchemaData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDynamicSchemaData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeDynamicSchemaData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, DynamicSchemaProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public DynamicSchemaProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDynamicSchemaData : IUtf8JsonSerializable, IJsonModel<EdgeDynamicSchemaData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeDynamicSchemaData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeDynamicSchemaData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDynamicSchemaData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeDynamicSchemaData IJsonModel<EdgeDynamicSchemaData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDynamicSchemaData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeDynamicSchemaData(document.RootElement, options);
        }

        internal static EdgeDynamicSchemaData DeserializeEdgeDynamicSchemaData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            DynamicSchemaProperties properties = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = DynamicSchemaProperties.DeserializeDynamicSchemaProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeDynamicSchemaData(
                id,
                name,
                type,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeDynamicSchemaData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeDynamicSchemaData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeDynamicSchemaData IPersistableModel<EdgeDynamicSchemaData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeDynamicSchemaData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeDynamicSchemaData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeDynamicSchemaData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeDynamicSchema along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeDynamicSchemaResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeDynamicSchemaResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeSchemaResource"/> using the GetEdgeDynamicSchema method.
    /// </summary>
    public partial class EdgeDynamicSchemaResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeDynamicSchemaResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="schemaName"> The schemaName. </param>
        /// <param name="dynamicSchemaName"> The dynamicSchemaName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeDynamicSchemaDynamicSchemasClientDiagnostics;
        private readonly DynamicSchemasRestOperations _edgeDynamicSchemaDynamicSchemasRestClient;
        private readonly EdgeDynamicSchemaData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/schemas/dynamicSchemas";

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaResource"/> class for mocking. </summary>
        protected EdgeDynamicSchemaResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeDynamicSchemaResource(ArmClient client, EdgeDynamicSchemaData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeDynamicSchemaResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDynamicSchemaDynamicSchemasClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeDynamicSchemaDynamicSchemasApiVersion);
            _edgeDynamicSchemaDynamicSchemasRestClient = new DynamicSchemasRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDynamicSchemaDynamicSchemasApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeDynamicSchemaData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeDynamicSchemaVersionResources in the EdgeDynamicSchema. </summary>
        /// <returns> An object representing collection of EdgeDynamicSchemaVersionResources and their operations over a EdgeDynamicSchemaVersionResource. </returns>
        public virtual EdgeDynamicSchemaVersionCollection GetEdgeDynamicSchemaVersions()
        {
            return GetCachedClient(client => new EdgeDynamicSchemaVersionCollection(client, Id));
        }

        /// <summary>
        /// Get a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeDynamicSchemaVersionResource>> GetEdgeDynamicSchemaVersionAsync(string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeDynamicSchemaVersions().GetAsync(dynamicSchemaVersionName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeDynamicSchemaVersionResource> GetEdgeDynamicSchemaVersion(string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            return GetEdgeDynamicSchemaVersions().Get(dynamicSchemaVersionName, cancellationToken);
        }

        /// <summary>
        /// Get a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeDynamicSchemaResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaDynamicSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeDynamicSchemaResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaResource.Get");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaDynamicSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaDynamicSchemasRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeDynamicSchemaDynamicSchemasClientDiagnostics, Pipeline, _edgeDynamicSchemaDynamicSchemasRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaDynamicSchemasRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeDynamicSchemaDynamicSchemasClientDiagnostics, Pipeline, _edgeDynamicSchemaDynamicSchemasRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<Response<EdgeDynamicSchemaResource>> UpdateAsync(EdgeDynamicSchemaPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaDynamicSchemasRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new EdgeDynamicSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual Response<EdgeDynamicSchemaResource> Update(EdgeDynamicSchemaPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeDynamicSchemaDynamicSchemasClientDiagnostics.CreateScope("EdgeDynamicSchemaResource.Update");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaDynamicSchemasRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken);
                return Response.FromValue(new EdgeDynamicSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDynamicSchemaResource : IJsonModel<EdgeDynamicSchemaData>
    {
        private static EdgeDynamicSchemaData s_dataDeserializationInstance;
        private static EdgeDynamicSchemaData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeDynamicSchemaData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDynamicSchemaData>)Data).Write(writer, options);

        EdgeDynamicSchemaData IJsonModel<EdgeDynamicSchemaData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDynamicSchemaData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeDynamicSchemaData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeDynamicSchemaData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeDynamicSchemaData IPersistableModel<EdgeDynamicSchemaData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeDynamicSchemaData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeDynamicSchemaData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeDynamicSchemaData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaVersionCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeDynamicSchemaVersionResource"/> and their operations.
    /// Each <see cref="EdgeDynamicSchemaVersionResource"/> in the collection will belong to the same instance of <see cref="EdgeDynamicSchemaResource"/>.
    /// To get an <see cref="EdgeDynamicSchemaVersionCollection"/> instance call the GetEdgeDynamicSchemaVersions method from an instance of <see cref="EdgeDynamicSchemaResource"/>.
    /// </summary>
    public partial class EdgeDynamicSchemaVersionCollection : ArmCollection, IEnumerable<EdgeDynamicSchemaVersionResource>, IAsyncEnumerable<EdgeDynamicSchemaVersionResource>
    {
        private readonly ClientDiagnostics _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics;
        private readonly DynamicSchemaVersionsRestOperations _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaVersionCollection"/> class for mocking. </summary>
        protected EdgeDynamicSchemaVersionCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaVersionCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeDynamicSchemaVersionCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeDynamicSchemaVersionResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeDynamicSchemaVersionResource.ResourceType, out string edgeDynamicSchemaVersionDynamicSchemaVersionsApiVersion);
            _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient = new DynamicSchemaVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDynamicSchemaVersionDynamicSchemaVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeDynamicSchemaResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeDynamicSchemaResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeDynamicSchemaVersionResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDynamicSchemaVersionResource>(new EdgeDynamicSchemaVersionOperationSource(Client), _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics, Pipeline, _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeDynamicSchemaVersionResource> CreateOrUpdate(WaitUntil waitUntil, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeDynamicSchemaVersionResource>(new EdgeDynamicSchemaVersionOperationSource(Client), _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics, Pipeline, _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        public virtual async Task<Response<EdgeDynamicSchemaVersionResource>> GetAsync(string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        public virtual Response<EdgeDynamicSchemaVersionResource> Get(string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List by Dynamic Schema
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_ListByDynamicSchema</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeDynamicSchemaVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeDynamicSchemaVersionResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateListByDynamicSchemaRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateListByDynamicSchemaNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeDynamicSchemaVersionResource(Client, EdgeDynamicSchemaVersionData.DeserializeEdgeDynamicSchemaVersionData(e)), _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics, Pipeline, "EdgeDynamicSchemaVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by Dynamic Schema
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_ListByDynamicSchema</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeDynamicSchemaVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeDynamicSchemaVersionResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateListByDynamicSchemaRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateListByDynamicSchemaNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeDynamicSchemaVersionResource(Client, EdgeDynamicSchemaVersionData.DeserializeEdgeDynamicSchemaVersionData(e)), _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics, Pipeline, "EdgeDynamicSchemaVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        public virtual Response<bool> Exists(string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeDynamicSchemaVersionResource>> GetIfExistsAsync(string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDynamicSchemaVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        public virtual NullableResponse<EdgeDynamicSchemaVersionResource> GetIfExists(string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, dynamicSchemaVersionName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeDynamicSchemaVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeDynamicSchemaVersionResource> IEnumerable<EdgeDynamicSchemaVersionResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeDynamicSchemaVersionResource> IAsyncEnumerable<EdgeDynamicSchemaVersionResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaVersionData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeDynamicSchemaVersion data model.
    /// Dynamic Schema Version Resource
    /// </summary>
    public partial class EdgeDynamicSchemaVersionData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeDynamicSchemaVersionData"/>. </summary>
        public EdgeDynamicSchemaVersionData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDynamicSchemaVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeDynamicSchemaVersionData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SchemaVersionProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public SchemaVersionProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaVersionData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDynamicSchemaVersionData : IUtf8JsonSerializable, IJsonModel<EdgeDynamicSchemaVersionData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeDynamicSchemaVersionData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeDynamicSchemaVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDynamicSchemaVersionData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeDynamicSchemaVersionData IJsonModel<EdgeDynamicSchemaVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDynamicSchemaVersionData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeDynamicSchemaVersionData(document.RootElement, options);
        }

        internal static EdgeDynamicSchemaVersionData DeserializeEdgeDynamicSchemaVersionData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SchemaVersionProperties properties = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SchemaVersionProperties.DeserializeSchemaVersionProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeDynamicSchemaVersionData(
                id,
                name,
                type,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeDynamicSchemaVersionData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeDynamicSchemaVersionData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeDynamicSchemaVersionData IPersistableModel<EdgeDynamicSchemaVersionData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeDynamicSchemaVersionData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeDynamicSchemaVersionData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeDynamicSchemaVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaVersionResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeDynamicSchemaVersion along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeDynamicSchemaVersionResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeDynamicSchemaVersionResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeDynamicSchemaResource"/> using the GetEdgeDynamicSchemaVersion method.
    /// </summary>
    public partial class EdgeDynamicSchemaVersionResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeDynamicSchemaVersionResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="schemaName"> The schemaName. </param>
        /// <param name="dynamicSchemaName"> The dynamicSchemaName. </param>
        /// <param name="dynamicSchemaVersionName"> The dynamicSchemaVersionName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics;
        private readonly DynamicSchemaVersionsRestOperations _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient;
        private readonly EdgeDynamicSchemaVersionData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/schemas/dynamicSchemas/versions";

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaVersionResource"/> class for mocking. </summary>
        protected EdgeDynamicSchemaVersionResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeDynamicSchemaVersionResource(ArmClient client, EdgeDynamicSchemaVersionData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeDynamicSchemaVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeDynamicSchemaVersionResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeDynamicSchemaVersionDynamicSchemaVersionsApiVersion);
            _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient = new DynamicSchemaVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeDynamicSchemaVersionDynamicSchemaVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeDynamicSchemaVersionData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeDynamicSchemaVersionResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeDynamicSchemaVersionResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionResource.Get");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeDynamicSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics, Pipeline, _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics, Pipeline, _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<Response<EdgeDynamicSchemaVersionResource>> UpdateAsync(EdgeDynamicSchemaVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new EdgeDynamicSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Dynamic Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}/versions/{dynamicSchemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemaVersions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual Response<EdgeDynamicSchemaVersionResource> Update(EdgeDynamicSchemaVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeDynamicSchemaVersionDynamicSchemaVersionsClientDiagnostics.CreateScope("EdgeDynamicSchemaVersionResource.Update");
            scope.Start();
            try
            {
                var response = _edgeDynamicSchemaVersionDynamicSchemaVersionsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken);
                return Response.FromValue(new EdgeDynamicSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeDynamicSchemaVersionResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeDynamicSchemaVersionResource : IJsonModel<EdgeDynamicSchemaVersionData>
    {
        private static EdgeDynamicSchemaVersionData s_dataDeserializationInstance;
        private static EdgeDynamicSchemaVersionData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeDynamicSchemaVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDynamicSchemaVersionData>)Data).Write(writer, options);

        EdgeDynamicSchemaVersionData IJsonModel<EdgeDynamicSchemaVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeDynamicSchemaVersionData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeDynamicSchemaVersionData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeDynamicSchemaVersionData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeDynamicSchemaVersionData IPersistableModel<EdgeDynamicSchemaVersionData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeDynamicSchemaVersionData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeDynamicSchemaVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeDynamicSchemaVersionData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeExecutionCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeExecutionResource"/> and their operations.
    /// Each <see cref="EdgeExecutionResource"/> in the collection will belong to the same instance of <see cref="EdgeWorkflowVersionResource"/>.
    /// To get an <see cref="EdgeExecutionCollection"/> instance call the GetEdgeExecutions method from an instance of <see cref="EdgeWorkflowVersionResource"/>.
    /// </summary>
    public partial class EdgeExecutionCollection : ArmCollection, IEnumerable<EdgeExecutionResource>, IAsyncEnumerable<EdgeExecutionResource>
    {
        private readonly ClientDiagnostics _edgeExecutionExecutionsClientDiagnostics;
        private readonly ExecutionsRestOperations _edgeExecutionExecutionsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeExecutionCollection"/> class for mocking. </summary>
        protected EdgeExecutionCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeExecutionCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeExecutionCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeExecutionExecutionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeExecutionResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeExecutionResource.ResourceType, out string edgeExecutionExecutionsApiVersion);
            _edgeExecutionExecutionsRestClient = new ExecutionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeExecutionExecutionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeWorkflowVersionResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeWorkflowVersionResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeExecutionResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string executionName, EdgeExecutionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeExecutionExecutionsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeExecutionResource>(new EdgeExecutionOperationSource(Client), _edgeExecutionExecutionsClientDiagnostics, Pipeline, _edgeExecutionExecutionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeExecutionResource> CreateOrUpdate(WaitUntil waitUntil, string executionName, EdgeExecutionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeExecutionExecutionsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeExecutionResource>(new EdgeExecutionOperationSource(Client), _edgeExecutionExecutionsClientDiagnostics, Pipeline, _edgeExecutionExecutionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> is null. </exception>
        public virtual async Task<Response<EdgeExecutionResource>> GetAsync(string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeExecutionExecutionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeExecutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> is null. </exception>
        public virtual Response<EdgeExecutionResource> Get(string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeExecutionExecutionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeExecutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Execution Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_ListByWorkflowVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeExecutionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeExecutionResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeExecutionExecutionsRestClient.CreateListByWorkflowVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeExecutionExecutionsRestClient.CreateListByWorkflowVersionNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeExecutionResource(Client, EdgeExecutionData.DeserializeEdgeExecutionData(e)), _edgeExecutionExecutionsClientDiagnostics, Pipeline, "EdgeExecutionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Execution Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_ListByWorkflowVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeExecutionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeExecutionResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeExecutionExecutionsRestClient.CreateListByWorkflowVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeExecutionExecutionsRestClient.CreateListByWorkflowVersionNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeExecutionResource(Client, EdgeExecutionData.DeserializeEdgeExecutionData(e)), _edgeExecutionExecutionsClientDiagnostics, Pipeline, "EdgeExecutionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeExecutionExecutionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> is null. </exception>
        public virtual Response<bool> Exists(string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeExecutionExecutionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeExecutionResource>> GetIfExistsAsync(string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeExecutionExecutionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeExecutionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeExecutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> is null. </exception>
        public virtual NullableResponse<EdgeExecutionResource> GetIfExists(string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeExecutionExecutionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, executionName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeExecutionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeExecutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeExecutionResource> IEnumerable<EdgeExecutionResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeExecutionResource> IAsyncEnumerable<EdgeExecutionResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeExecutionData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeExecution data model.
    /// Execution Resource
    /// </summary>
    public partial class EdgeExecutionData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeExecutionData"/>. </summary>
        public EdgeExecutionData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeExecutionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeExecutionData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, ExecutionProperties properties, AzureResourceManagerCommonTypesExtendedLocation extendedLocation, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ExtendedLocation = extendedLocation;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public ExecutionProperties Properties { get; set; }
        /// <summary> The complex type of the extended location. </summary>
        public AzureResourceManagerCommonTypesExtendedLocation ExtendedLocation { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeExecutionData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeExecutionData : IUtf8JsonSerializable, IJsonModel<EdgeExecutionData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeExecutionData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeExecutionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeExecutionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeExecutionData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (Optional.IsDefined(ExtendedLocation))
            {
                writer.WritePropertyName("extendedLocation"u8);
                writer.WriteObjectValue(ExtendedLocation, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeExecutionData IJsonModel<EdgeExecutionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeExecutionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeExecutionData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeExecutionData(document.RootElement, options);
        }

        internal static EdgeExecutionData DeserializeEdgeExecutionData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ExecutionProperties properties = default;
            AzureResourceManagerCommonTypesExtendedLocation extendedLocation = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = ExecutionProperties.DeserializeExecutionProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("extendedLocation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    extendedLocation = AzureResourceManagerCommonTypesExtendedLocation.DeserializeAzureResourceManagerCommonTypesExtendedLocation(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeExecutionData(
                id,
                name,
                type,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeExecutionData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeExecutionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeExecutionData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeExecutionData IPersistableModel<EdgeExecutionData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeExecutionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeExecutionData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeExecutionData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeExecutionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeExecutionResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeExecution along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeExecutionResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeExecutionResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeWorkflowVersionResource"/> using the GetEdgeExecution method.
    /// </summary>
    public partial class EdgeExecutionResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeExecutionResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="contextName"> The contextName. </param>
        /// <param name="workflowName"> The workflowName. </param>
        /// <param name="versionName"> The versionName. </param>
        /// <param name="executionName"> The executionName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeExecutionExecutionsClientDiagnostics;
        private readonly ExecutionsRestOperations _edgeExecutionExecutionsRestClient;
        private readonly EdgeExecutionData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/contexts/workflows/versions/executions";

        /// <summary> Initializes a new instance of the <see cref="EdgeExecutionResource"/> class for mocking. </summary>
        protected EdgeExecutionResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeExecutionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeExecutionResource(ArmClient client, EdgeExecutionData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeExecutionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeExecutionResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeExecutionExecutionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeExecutionExecutionsApiVersion);
            _edgeExecutionExecutionsRestClient = new ExecutionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeExecutionExecutionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeExecutionData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeExecutionResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeExecutionExecutionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeExecutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeExecutionResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionResource.Get");
            scope.Start();
            try
            {
                var response = _edgeExecutionExecutionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeExecutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeExecutionExecutionsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeExecutionExecutionsClientDiagnostics, Pipeline, _edgeExecutionExecutionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeExecutionExecutionsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeExecutionExecutionsClientDiagnostics, Pipeline, _edgeExecutionExecutionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update an Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeExecutionResource>> UpdateAsync(WaitUntil waitUntil, EdgeExecutionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeExecutionExecutionsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeExecutionResource>(new EdgeExecutionOperationSource(Client), _edgeExecutionExecutionsClientDiagnostics, Pipeline, _edgeExecutionExecutionsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update an Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeExecutionResource> Update(WaitUntil waitUntil, EdgeExecutionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeExecutionExecutionsClientDiagnostics.CreateScope("EdgeExecutionResource.Update");
            scope.Start();
            try
            {
                var response = _edgeExecutionExecutionsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeExecutionResource>(new EdgeExecutionOperationSource(Client), _edgeExecutionExecutionsClientDiagnostics, Pipeline, _edgeExecutionExecutionsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Parent.Name, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeExecutionResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeExecutionResource : IJsonModel<EdgeExecutionData>
    {
        private static EdgeExecutionData s_dataDeserializationInstance;
        private static EdgeExecutionData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeExecutionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeExecutionData>)Data).Write(writer, options);

        EdgeExecutionData IJsonModel<EdgeExecutionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeExecutionData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeExecutionData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeExecutionData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeExecutionData IPersistableModel<EdgeExecutionData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeExecutionData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeExecutionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeExecutionData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeJobCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeJobResource"/> and their operations.
    /// Each <see cref="EdgeJobResource"/> in the collection will belong to the same instance of <see cref="ArmResource"/>.
    /// To get an <see cref="EdgeJobCollection"/> instance call the GetEdgeJobs method from an instance of <see cref="ArmResource"/>.
    /// </summary>
    public partial class EdgeJobCollection : ArmCollection, IEnumerable<EdgeJobResource>, IAsyncEnumerable<EdgeJobResource>
    {
        private readonly ClientDiagnostics _edgeJobJobsClientDiagnostics;
        private readonly JobsRestOperations _edgeJobJobsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeJobCollection"/> class for mocking. </summary>
        protected EdgeJobCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeJobCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeJobCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeJobJobsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeJobResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeJobResource.ResourceType, out string edgeJobJobsApiVersion);
            _edgeJobJobsRestClient = new JobsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeJobJobsApiVersion);
        }

        /// <summary>
        /// Get a Job resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="jobName"/> is null. </exception>
        public virtual async Task<Response<EdgeJobResource>> GetAsync(string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            using var scope = _edgeJobJobsClientDiagnostics.CreateScope("EdgeJobCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeJobJobsRestClient.GetAsync(Id, jobName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeJobResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Job resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="jobName"/> is null. </exception>
        public virtual Response<EdgeJobResource> Get(string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            using var scope = _edgeJobJobsClientDiagnostics.CreateScope("EdgeJobCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeJobJobsRestClient.Get(Id, jobName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeJobResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Jobs by parent resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_ListByTarget</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeJobResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeJobResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeJobJobsRestClient.CreateListByTargetRequest(Id);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeJobJobsRestClient.CreateListByTargetNextPageRequest(nextLink, Id);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeJobResource(Client, EdgeJobData.DeserializeEdgeJobData(e)), _edgeJobJobsClientDiagnostics, Pipeline, "EdgeJobCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Jobs by parent resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_ListByTarget</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeJobResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeJobResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeJobJobsRestClient.CreateListByTargetRequest(Id);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeJobJobsRestClient.CreateListByTargetNextPageRequest(nextLink, Id);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeJobResource(Client, EdgeJobData.DeserializeEdgeJobData(e)), _edgeJobJobsClientDiagnostics, Pipeline, "EdgeJobCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="jobName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            using var scope = _edgeJobJobsClientDiagnostics.CreateScope("EdgeJobCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeJobJobsRestClient.GetAsync(Id, jobName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="jobName"/> is null. </exception>
        public virtual Response<bool> Exists(string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            using var scope = _edgeJobJobsClientDiagnostics.CreateScope("EdgeJobCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeJobJobsRestClient.Get(Id, jobName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="jobName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeJobResource>> GetIfExistsAsync(string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            using var scope = _edgeJobJobsClientDiagnostics.CreateScope("EdgeJobCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeJobJobsRestClient.GetAsync(Id, jobName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeJobResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeJobResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="jobName"/> is null. </exception>
        public virtual NullableResponse<EdgeJobResource> GetIfExists(string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            using var scope = _edgeJobJobsClientDiagnostics.CreateScope("EdgeJobCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeJobJobsRestClient.Get(Id, jobName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeJobResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeJobResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeJobResource> IEnumerable<EdgeJobResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeJobResource> IAsyncEnumerable<EdgeJobResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeJobData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeJob data model.
    /// Job extension resource for tracking job execution and substatuses.
    /// </summary>
    public partial class EdgeJobData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeJobData"/>. </summary>
        public EdgeJobData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeJobData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeJobData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, JobProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public JobProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeJobData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeJobData : IUtf8JsonSerializable, IJsonModel<EdgeJobData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeJobData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeJobData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeJobData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeJobData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeJobData IJsonModel<EdgeJobData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeJobData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeJobData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeJobData(document.RootElement, options);
        }

        internal static EdgeJobData DeserializeEdgeJobData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            JobProperties properties = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = JobProperties.DeserializeJobProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeJobData(
                id,
                name,
                type,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeJobData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeJobData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeJobData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeJobData IPersistableModel<EdgeJobData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeJobData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeJobData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeJobData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeJobData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeJobResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeJob along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeJobResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeJobResource method.
    /// Otherwise you can get one from its parent resource <see cref="ArmResource"/> using the GetEdgeJob method.
    /// </summary>
    public partial class EdgeJobResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeJobResource"/> instance. </summary>
        /// <param name="resourceUri"> The resourceUri. </param>
        /// <param name="jobName"> The jobName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string resourceUri, string jobName)
        {
            var resourceId = $"{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeJobJobsClientDiagnostics;
        private readonly JobsRestOperations _edgeJobJobsRestClient;
        private readonly EdgeJobData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/jobs";

        /// <summary> Initializes a new instance of the <see cref="EdgeJobResource"/> class for mocking. </summary>
        protected EdgeJobResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeJobResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeJobResource(ArmClient client, EdgeJobData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeJobResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeJobResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeJobJobsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeJobJobsApiVersion);
            _edgeJobJobsRestClient = new JobsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeJobJobsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeJobData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get a Job resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeJobResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeJobJobsClientDiagnostics.CreateScope("EdgeJobResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeJobJobsRestClient.GetAsync(Id.Parent, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeJobResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Job resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeJobResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeJobJobsClientDiagnostics.CreateScope("EdgeJobResource.Get");
            scope.Start();
            try
            {
                var response = _edgeJobJobsRestClient.Get(Id.Parent, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeJobResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeJobResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeJobResource : IJsonModel<EdgeJobData>
    {
        private static EdgeJobData s_dataDeserializationInstance;
        private static EdgeJobData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeJobData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeJobData>)Data).Write(writer, options);

        EdgeJobData IJsonModel<EdgeJobData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeJobData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeJobData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeJobData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeJobData IPersistableModel<EdgeJobData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeJobData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeJobData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeJobData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeSchemaCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeSchemaResource"/> and their operations.
    /// Each <see cref="EdgeSchemaResource"/> in the collection will belong to the same instance of <see cref="ResourceGroupResource"/>.
    /// To get an <see cref="EdgeSchemaCollection"/> instance call the GetEdgeSchemas method from an instance of <see cref="ResourceGroupResource"/>.
    /// </summary>
    public partial class EdgeSchemaCollection : ArmCollection, IEnumerable<EdgeSchemaResource>, IAsyncEnumerable<EdgeSchemaResource>
    {
        private readonly ClientDiagnostics _edgeSchemaSchemasClientDiagnostics;
        private readonly SchemasRestOperations _edgeSchemaSchemasRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaCollection"/> class for mocking. </summary>
        protected EdgeSchemaCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeSchemaCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSchemaSchemasClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSchemaResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeSchemaResource.ResourceType, out string edgeSchemaSchemasApiVersion);
            _edgeSchemaSchemasRestClient = new SchemasRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSchemaSchemasApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceGroupResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceGroupResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSchemaResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string schemaName, EdgeSchemaData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeSchemaSchemasRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, schemaName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSchemaResource>(new EdgeSchemaOperationSource(Client), _edgeSchemaSchemasClientDiagnostics, Pipeline, _edgeSchemaSchemasRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, schemaName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeSchemaResource> CreateOrUpdate(WaitUntil waitUntil, string schemaName, EdgeSchemaData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeSchemaSchemasRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, schemaName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSchemaResource>(new EdgeSchemaOperationSource(Client), _edgeSchemaSchemasClientDiagnostics, Pipeline, _edgeSchemaSchemasRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, schemaName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        public virtual async Task<Response<EdgeSchemaResource>> GetAsync(string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeSchemaSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, schemaName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        public virtual Response<EdgeSchemaResource> Get(string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeSchemaSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, schemaName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSchemaResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSchemaResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSchemaSchemasRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSchemaSchemasRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSchemaResource(Client, EdgeSchemaData.DeserializeEdgeSchemaData(e)), _edgeSchemaSchemasClientDiagnostics, Pipeline, "EdgeSchemaCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSchemaResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSchemaResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSchemaSchemasRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSchemaSchemasRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSchemaResource(Client, EdgeSchemaData.DeserializeEdgeSchemaData(e)), _edgeSchemaSchemasClientDiagnostics, Pipeline, "EdgeSchemaCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeSchemaSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, schemaName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        public virtual Response<bool> Exists(string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeSchemaSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, schemaName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeSchemaResource>> GetIfExistsAsync(string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeSchemaSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, schemaName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSchemaResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        public virtual NullableResponse<EdgeSchemaResource> GetIfExists(string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeSchemaSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, schemaName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSchemaResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeSchemaResource> IEnumerable<EdgeSchemaResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeSchemaResource> IAsyncEnumerable<EdgeSchemaResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeSchemaData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeSchema data model.
    /// Schema Resource
    /// </summary>
    public partial class EdgeSchemaData : TrackedResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaData"/>. </summary>
        /// <param name="location"> The location. </param>
        public EdgeSchemaData(AzureLocation location) : base(location)
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSchemaData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, IDictionary<string, string> tags, AzureLocation location, SchemaProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData, tags, location)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaData"/> for deserialization. </summary>
        internal EdgeSchemaData()
        {
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public SchemaProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeSchemaData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSchemaData : IUtf8JsonSerializable, IJsonModel<EdgeSchemaData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSchemaData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSchemaData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeSchemaData IJsonModel<EdgeSchemaData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSchemaData(document.RootElement, options);
        }

        internal static EdgeSchemaData DeserializeEdgeSchemaData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SchemaProperties properties = default;
            string etag = default;
            IDictionary<string, string> tags = default;
            AzureLocation location = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SchemaProperties.DeserializeSchemaProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("location"u8))
                {
                    location = new AzureLocation(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSchemaData(
                id,
                name,
                type,
                systemData,
                tags ?? new ChangeTrackingDictionary<string, string>(),
                location,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSchemaData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSchemaData IPersistableModel<EdgeSchemaData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSchemaData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSchemaData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeSchemaReferenceCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeSchemaReferenceResource"/> and their operations.
    /// Each <see cref="EdgeSchemaReferenceResource"/> in the collection will belong to the same instance of <see cref="ArmResource"/>.
    /// To get an <see cref="EdgeSchemaReferenceCollection"/> instance call the GetEdgeSchemaReferences method from an instance of <see cref="ArmResource"/>.
    /// </summary>
    public partial class EdgeSchemaReferenceCollection : ArmCollection, IEnumerable<EdgeSchemaReferenceResource>, IAsyncEnumerable<EdgeSchemaReferenceResource>
    {
        private readonly ClientDiagnostics _edgeSchemaReferenceSchemaReferencesClientDiagnostics;
        private readonly SchemaReferencesRestOperations _edgeSchemaReferenceSchemaReferencesRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaReferenceCollection"/> class for mocking. </summary>
        protected EdgeSchemaReferenceCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaReferenceCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeSchemaReferenceCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSchemaReferenceSchemaReferencesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSchemaReferenceResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeSchemaReferenceResource.ResourceType, out string edgeSchemaReferenceSchemaReferencesApiVersion);
            _edgeSchemaReferenceSchemaReferencesRestClient = new SchemaReferencesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSchemaReferenceSchemaReferencesApiVersion);
        }

        /// <summary>
        /// Get a Schema Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaReferenceName"/> is null. </exception>
        public virtual async Task<Response<EdgeSchemaReferenceResource>> GetAsync(string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaReferenceName, nameof(schemaReferenceName));

            using var scope = _edgeSchemaReferenceSchemaReferencesClientDiagnostics.CreateScope("EdgeSchemaReferenceCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeSchemaReferenceSchemaReferencesRestClient.GetAsync(Id, schemaReferenceName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Schema Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaReferenceName"/> is null. </exception>
        public virtual Response<EdgeSchemaReferenceResource> Get(string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaReferenceName, nameof(schemaReferenceName));

            using var scope = _edgeSchemaReferenceSchemaReferencesClientDiagnostics.CreateScope("EdgeSchemaReferenceCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeSchemaReferenceSchemaReferencesRestClient.Get(Id, schemaReferenceName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSchemaReferenceResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSchemaReferenceResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSchemaReferenceSchemaReferencesRestClient.CreateListByResourceGroupRequest(Id);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSchemaReferenceSchemaReferencesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSchemaReferenceResource(Client, EdgeSchemaReferenceData.DeserializeEdgeSchemaReferenceData(e)), _edgeSchemaReferenceSchemaReferencesClientDiagnostics, Pipeline, "EdgeSchemaReferenceCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSchemaReferenceResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSchemaReferenceResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSchemaReferenceSchemaReferencesRestClient.CreateListByResourceGroupRequest(Id);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSchemaReferenceSchemaReferencesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSchemaReferenceResource(Client, EdgeSchemaReferenceData.DeserializeEdgeSchemaReferenceData(e)), _edgeSchemaReferenceSchemaReferencesClientDiagnostics, Pipeline, "EdgeSchemaReferenceCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaReferenceName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaReferenceName, nameof(schemaReferenceName));

            using var scope = _edgeSchemaReferenceSchemaReferencesClientDiagnostics.CreateScope("EdgeSchemaReferenceCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeSchemaReferenceSchemaReferencesRestClient.GetAsync(Id, schemaReferenceName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaReferenceName"/> is null. </exception>
        public virtual Response<bool> Exists(string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaReferenceName, nameof(schemaReferenceName));

            using var scope = _edgeSchemaReferenceSchemaReferencesClientDiagnostics.CreateScope("EdgeSchemaReferenceCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeSchemaReferenceSchemaReferencesRestClient.Get(Id, schemaReferenceName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaReferenceName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeSchemaReferenceResource>> GetIfExistsAsync(string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaReferenceName, nameof(schemaReferenceName));

            using var scope = _edgeSchemaReferenceSchemaReferencesClientDiagnostics.CreateScope("EdgeSchemaReferenceCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeSchemaReferenceSchemaReferencesRestClient.GetAsync(Id, schemaReferenceName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSchemaReferenceResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaReferenceName"/> is null. </exception>
        public virtual NullableResponse<EdgeSchemaReferenceResource> GetIfExists(string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaReferenceName, nameof(schemaReferenceName));

            using var scope = _edgeSchemaReferenceSchemaReferencesClientDiagnostics.CreateScope("EdgeSchemaReferenceCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeSchemaReferenceSchemaReferencesRestClient.Get(Id, schemaReferenceName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSchemaReferenceResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeSchemaReferenceResource> IEnumerable<EdgeSchemaReferenceResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeSchemaReferenceResource> IAsyncEnumerable<EdgeSchemaReferenceResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeSchemaReferenceData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeSchemaReference data model.
    /// Schema Reference Resource
    /// </summary>
    public partial class EdgeSchemaReferenceData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaReferenceData"/>. </summary>
        public EdgeSchemaReferenceData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaReferenceData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSchemaReferenceData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SchemaReferenceProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public SchemaReferenceProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeSchemaReferenceData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSchemaReferenceData : IUtf8JsonSerializable, IJsonModel<EdgeSchemaReferenceData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSchemaReferenceData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSchemaReferenceData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaReferenceData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaReferenceData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeSchemaReferenceData IJsonModel<EdgeSchemaReferenceData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaReferenceData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaReferenceData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSchemaReferenceData(document.RootElement, options);
        }

        internal static EdgeSchemaReferenceData DeserializeEdgeSchemaReferenceData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SchemaReferenceProperties properties = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SchemaReferenceProperties.DeserializeSchemaReferenceProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSchemaReferenceData(
                id,
                name,
                type,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSchemaReferenceData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaReferenceData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaReferenceData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSchemaReferenceData IPersistableModel<EdgeSchemaReferenceData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaReferenceData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSchemaReferenceData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaReferenceData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSchemaReferenceData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeSchemaReferenceResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeSchemaReference along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeSchemaReferenceResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeSchemaReferenceResource method.
    /// Otherwise you can get one from its parent resource <see cref="ArmResource"/> using the GetEdgeSchemaReference method.
    /// </summary>
    public partial class EdgeSchemaReferenceResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeSchemaReferenceResource"/> instance. </summary>
        /// <param name="resourceUri"> The resourceUri. </param>
        /// <param name="schemaReferenceName"> The schemaReferenceName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string resourceUri, string schemaReferenceName)
        {
            var resourceId = $"{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeSchemaReferenceSchemaReferencesClientDiagnostics;
        private readonly SchemaReferencesRestOperations _edgeSchemaReferenceSchemaReferencesRestClient;
        private readonly EdgeSchemaReferenceData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/schemaReferences";

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaReferenceResource"/> class for mocking. </summary>
        protected EdgeSchemaReferenceResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaReferenceResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeSchemaReferenceResource(ArmClient client, EdgeSchemaReferenceData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaReferenceResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeSchemaReferenceResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSchemaReferenceSchemaReferencesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeSchemaReferenceSchemaReferencesApiVersion);
            _edgeSchemaReferenceSchemaReferencesRestClient = new SchemaReferencesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSchemaReferenceSchemaReferencesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeSchemaReferenceData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get a Schema Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeSchemaReferenceResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaReferenceSchemaReferencesClientDiagnostics.CreateScope("EdgeSchemaReferenceResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeSchemaReferenceSchemaReferencesRestClient.GetAsync(Id.Parent, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Schema Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeSchemaReferenceResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaReferenceSchemaReferencesClientDiagnostics.CreateScope("EdgeSchemaReferenceResource.Get");
            scope.Start();
            try
            {
                var response = _edgeSchemaReferenceSchemaReferencesRestClient.Get(Id.Parent, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeSchemaReferenceResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSchemaReferenceResource : IJsonModel<EdgeSchemaReferenceData>
    {
        private static EdgeSchemaReferenceData s_dataDeserializationInstance;
        private static EdgeSchemaReferenceData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeSchemaReferenceData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSchemaReferenceData>)Data).Write(writer, options);

        EdgeSchemaReferenceData IJsonModel<EdgeSchemaReferenceData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSchemaReferenceData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeSchemaReferenceData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeSchemaReferenceData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeSchemaReferenceData IPersistableModel<EdgeSchemaReferenceData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeSchemaReferenceData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeSchemaReferenceData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeSchemaReferenceData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeSchemaResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeSchema along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeSchemaResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeSchemaResource method.
    /// Otherwise you can get one from its parent resource <see cref="ResourceGroupResource"/> using the GetEdgeSchema method.
    /// </summary>
    public partial class EdgeSchemaResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeSchemaResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="schemaName"> The schemaName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string schemaName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeSchemaSchemasClientDiagnostics;
        private readonly SchemasRestOperations _edgeSchemaSchemasRestClient;
        private readonly EdgeSchemaData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/schemas";

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaResource"/> class for mocking. </summary>
        protected EdgeSchemaResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeSchemaResource(ArmClient client, EdgeSchemaData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeSchemaResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSchemaSchemasClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeSchemaSchemasApiVersion);
            _edgeSchemaSchemasRestClient = new SchemasRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSchemaSchemasApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeSchemaData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeDynamicSchemaResources in the EdgeSchema. </summary>
        /// <returns> An object representing collection of EdgeDynamicSchemaResources and their operations over a EdgeDynamicSchemaResource. </returns>
        public virtual EdgeDynamicSchemaCollection GetEdgeDynamicSchemas()
        {
            return GetCachedClient(client => new EdgeDynamicSchemaCollection(client, Id));
        }

        /// <summary>
        /// Get a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeDynamicSchemaResource>> GetEdgeDynamicSchemaAsync(string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeDynamicSchemas().GetAsync(dynamicSchemaName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a DynamicSchema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/dynamicSchemas/{dynamicSchemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>DynamicSchemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDynamicSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeDynamicSchemaResource> GetEdgeDynamicSchema(string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            return GetEdgeDynamicSchemas().Get(dynamicSchemaName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeSchemaVersionResources in the EdgeSchema. </summary>
        /// <returns> An object representing collection of EdgeSchemaVersionResources and their operations over a EdgeSchemaVersionResource. </returns>
        public virtual EdgeSchemaVersionCollection GetEdgeSchemaVersions()
        {
            return GetCachedClient(client => new EdgeSchemaVersionCollection(client, Id));
        }

        /// <summary>
        /// Get a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSchemaVersionResource>> GetEdgeSchemaVersionAsync(string schemaVersionName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeSchemaVersions().GetAsync(schemaVersionName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSchemaVersionResource> GetEdgeSchemaVersion(string schemaVersionName, CancellationToken cancellationToken = default)
        {
            return GetEdgeSchemaVersions().Get(schemaVersionName, cancellationToken);
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeSchemaResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeSchemaSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeSchemaResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.Get");
            scope.Start();
            try
            {
                var response = _edgeSchemaSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeSchemaSchemasRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSchemaSchemasClientDiagnostics, Pipeline, _edgeSchemaSchemasRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeSchemaSchemasRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSchemaSchemasClientDiagnostics, Pipeline, _edgeSchemaSchemasRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<Response<EdgeSchemaResource>> UpdateAsync(EdgeSchemaPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeSchemaSchemasRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new EdgeSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual Response<EdgeSchemaResource> Update(EdgeSchemaPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.Update");
            scope.Start();
            try
            {
                var response = _edgeSchemaSchemasRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken);
                return Response.FromValue(new EdgeSchemaResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/createVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_CreateVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSchemaVersionResource>> CreateVersionAsync(WaitUntil waitUntil, SchemaVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.CreateVersion");
            scope.Start();
            try
            {
                var response = await _edgeSchemaSchemasRestClient.CreateVersionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSchemaVersionResource>(new EdgeSchemaVersionOperationSource(Client), _edgeSchemaSchemasClientDiagnostics, Pipeline, _edgeSchemaSchemasRestClient.CreateCreateVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/createVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_CreateVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        public virtual ArmOperation<EdgeSchemaVersionResource> CreateVersion(WaitUntil waitUntil, SchemaVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.CreateVersion");
            scope.Start();
            try
            {
                var response = _edgeSchemaSchemasRestClient.CreateVersion(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSchemaVersionResource>(new EdgeSchemaVersionOperationSource(Client), _edgeSchemaSchemasClientDiagnostics, Pipeline, _edgeSchemaSchemasRestClient.CreateCreateVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/removeVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_RemoveVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<Response<WorkloadOrchestrationRemoveVersionResult>> RemoveVersionAsync(WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.RemoveVersion");
            scope.Start();
            try
            {
                var response = await _edgeSchemaSchemasRestClient.RemoveVersionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/removeVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_RemoveVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual Response<WorkloadOrchestrationRemoveVersionResult> RemoveVersion(WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.RemoveVersion");
            scope.Start();
            try
            {
                var response = _edgeSchemaSchemasRestClient.RemoveVersion(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual async Task<Response<EdgeSchemaResource>> AddTagAsync(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.AddTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues[key] = value;
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeSchemaSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeSchemaResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeSchemaPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = await UpdateAsync(patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual Response<EdgeSchemaResource> AddTag(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.AddTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues[key] = value;
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeSchemaSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeSchemaResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeSchemaPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = Update(patch, cancellationToken: cancellationToken);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual async Task<Response<EdgeSchemaResource>> SetTagsAsync(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.SetTags");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    await GetTagResource().DeleteAsync(WaitUntil.Completed, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeSchemaSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeSchemaResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeSchemaPatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = await UpdateAsync(patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual Response<EdgeSchemaResource> SetTags(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.SetTags");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    GetTagResource().Delete(WaitUntil.Completed, cancellationToken: cancellationToken);
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeSchemaSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeSchemaResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeSchemaPatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = Update(patch, cancellationToken: cancellationToken);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual async Task<Response<EdgeSchemaResource>> RemoveTagAsync(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.RemoveTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.Remove(key);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeSchemaSchemasRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeSchemaResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeSchemaPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = await UpdateAsync(patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual Response<EdgeSchemaResource> RemoveTag(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeSchemaSchemasClientDiagnostics.CreateScope("EdgeSchemaResource.RemoveTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.Remove(key);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeSchemaSchemasRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeSchemaResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeSchemaPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = Update(patch, cancellationToken: cancellationToken);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeSchemaResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSchemaResource : IJsonModel<EdgeSchemaData>
    {
        private static EdgeSchemaData s_dataDeserializationInstance;
        private static EdgeSchemaData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeSchemaData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSchemaData>)Data).Write(writer, options);

        EdgeSchemaData IJsonModel<EdgeSchemaData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSchemaData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeSchemaData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeSchemaData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeSchemaData IPersistableModel<EdgeSchemaData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeSchemaData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeSchemaData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeSchemaData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeSchemaVersionCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeSchemaVersionResource"/> and their operations.
    /// Each <see cref="EdgeSchemaVersionResource"/> in the collection will belong to the same instance of <see cref="EdgeSchemaResource"/>.
    /// To get an <see cref="EdgeSchemaVersionCollection"/> instance call the GetEdgeSchemaVersions method from an instance of <see cref="EdgeSchemaResource"/>.
    /// </summary>
    public partial class EdgeSchemaVersionCollection : ArmCollection, IEnumerable<EdgeSchemaVersionResource>, IAsyncEnumerable<EdgeSchemaVersionResource>
    {
        private readonly ClientDiagnostics _edgeSchemaVersionSchemaVersionsClientDiagnostics;
        private readonly SchemaVersionsRestOperations _edgeSchemaVersionSchemaVersionsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaVersionCollection"/> class for mocking. </summary>
        protected EdgeSchemaVersionCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaVersionCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeSchemaVersionCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSchemaVersionSchemaVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSchemaVersionResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeSchemaVersionResource.ResourceType, out string edgeSchemaVersionSchemaVersionsApiVersion);
            _edgeSchemaVersionSchemaVersionsRestClient = new SchemaVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSchemaVersionSchemaVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeSchemaResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeSchemaResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSchemaVersionResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string schemaVersionName, EdgeSchemaVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeSchemaVersionSchemaVersionsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSchemaVersionResource>(new EdgeSchemaVersionOperationSource(Client), _edgeSchemaVersionSchemaVersionsClientDiagnostics, Pipeline, _edgeSchemaVersionSchemaVersionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeSchemaVersionResource> CreateOrUpdate(WaitUntil waitUntil, string schemaVersionName, EdgeSchemaVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeSchemaVersionSchemaVersionsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSchemaVersionResource>(new EdgeSchemaVersionOperationSource(Client), _edgeSchemaVersionSchemaVersionsClientDiagnostics, Pipeline, _edgeSchemaVersionSchemaVersionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> is null. </exception>
        public virtual async Task<Response<EdgeSchemaVersionResource>> GetAsync(string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeSchemaVersionSchemaVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> is null. </exception>
        public virtual Response<EdgeSchemaVersionResource> Get(string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeSchemaVersionSchemaVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_ListBySchema</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSchemaVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSchemaVersionResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSchemaVersionSchemaVersionsRestClient.CreateListBySchemaRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSchemaVersionSchemaVersionsRestClient.CreateListBySchemaNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSchemaVersionResource(Client, EdgeSchemaVersionData.DeserializeEdgeSchemaVersionData(e)), _edgeSchemaVersionSchemaVersionsClientDiagnostics, Pipeline, "EdgeSchemaVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_ListBySchema</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSchemaVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSchemaVersionResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSchemaVersionSchemaVersionsRestClient.CreateListBySchemaRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSchemaVersionSchemaVersionsRestClient.CreateListBySchemaNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSchemaVersionResource(Client, EdgeSchemaVersionData.DeserializeEdgeSchemaVersionData(e)), _edgeSchemaVersionSchemaVersionsClientDiagnostics, Pipeline, "EdgeSchemaVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeSchemaVersionSchemaVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> is null. </exception>
        public virtual Response<bool> Exists(string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeSchemaVersionSchemaVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeSchemaVersionResource>> GetIfExistsAsync(string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeSchemaVersionSchemaVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSchemaVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersionName"/> is null. </exception>
        public virtual NullableResponse<EdgeSchemaVersionResource> GetIfExists(string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeSchemaVersionSchemaVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, schemaVersionName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSchemaVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeSchemaVersionResource> IEnumerable<EdgeSchemaVersionResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeSchemaVersionResource> IAsyncEnumerable<EdgeSchemaVersionResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeSchemaVersionData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeSchemaVersion data model.
    /// Schema Version Resource
    /// </summary>
    public partial class EdgeSchemaVersionData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaVersionData"/>. </summary>
        public EdgeSchemaVersionData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSchemaVersionData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SchemaVersionProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public SchemaVersionProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeSchemaVersionData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSchemaVersionData : IUtf8JsonSerializable, IJsonModel<EdgeSchemaVersionData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSchemaVersionData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSchemaVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaVersionData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeSchemaVersionData IJsonModel<EdgeSchemaVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaVersionData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSchemaVersionData(document.RootElement, options);
        }

        internal static EdgeSchemaVersionData DeserializeEdgeSchemaVersionData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SchemaVersionProperties properties = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SchemaVersionProperties.DeserializeSchemaVersionProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSchemaVersionData(
                id,
                name,
                type,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSchemaVersionData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaVersionData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSchemaVersionData IPersistableModel<EdgeSchemaVersionData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSchemaVersionData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaVersionData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSchemaVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeSchemaVersionResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeSchemaVersion along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeSchemaVersionResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeSchemaVersionResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeSchemaResource"/> using the GetEdgeSchemaVersion method.
    /// </summary>
    public partial class EdgeSchemaVersionResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeSchemaVersionResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="schemaName"> The schemaName. </param>
        /// <param name="schemaVersionName"> The schemaVersionName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeSchemaVersionSchemaVersionsClientDiagnostics;
        private readonly SchemaVersionsRestOperations _edgeSchemaVersionSchemaVersionsRestClient;
        private readonly EdgeSchemaVersionData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/schemas/versions";

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaVersionResource"/> class for mocking. </summary>
        protected EdgeSchemaVersionResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeSchemaVersionResource(ArmClient client, EdgeSchemaVersionData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSchemaVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeSchemaVersionResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSchemaVersionSchemaVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeSchemaVersionSchemaVersionsApiVersion);
            _edgeSchemaVersionSchemaVersionsRestClient = new SchemaVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSchemaVersionSchemaVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeSchemaVersionData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeSchemaVersionResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeSchemaVersionSchemaVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeSchemaVersionResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionResource.Get");
            scope.Start();
            try
            {
                var response = _edgeSchemaVersionSchemaVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeSchemaVersionSchemaVersionsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSchemaVersionSchemaVersionsClientDiagnostics, Pipeline, _edgeSchemaVersionSchemaVersionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeSchemaVersionSchemaVersionsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSchemaVersionSchemaVersionsClientDiagnostics, Pipeline, _edgeSchemaVersionSchemaVersionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<Response<EdgeSchemaVersionResource>> UpdateAsync(EdgeSchemaVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeSchemaVersionSchemaVersionsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new EdgeSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Schema Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}/versions/{schemaVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaVersions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual Response<EdgeSchemaVersionResource> Update(EdgeSchemaVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSchemaVersionSchemaVersionsClientDiagnostics.CreateScope("EdgeSchemaVersionResource.Update");
            scope.Start();
            try
            {
                var response = _edgeSchemaVersionSchemaVersionsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken);
                return Response.FromValue(new EdgeSchemaVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeSchemaVersionResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSchemaVersionResource : IJsonModel<EdgeSchemaVersionData>
    {
        private static EdgeSchemaVersionData s_dataDeserializationInstance;
        private static EdgeSchemaVersionData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeSchemaVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSchemaVersionData>)Data).Write(writer, options);

        EdgeSchemaVersionData IJsonModel<EdgeSchemaVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSchemaVersionData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeSchemaVersionData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeSchemaVersionData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeSchemaVersionData IPersistableModel<EdgeSchemaVersionData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeSchemaVersionData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeSchemaVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeSchemaVersionData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeSiteReferenceCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeSiteReferenceResource"/> and their operations.
    /// Each <see cref="EdgeSiteReferenceResource"/> in the collection will belong to the same instance of <see cref="EdgeContextResource"/>.
    /// To get an <see cref="EdgeSiteReferenceCollection"/> instance call the GetEdgeSiteReferences method from an instance of <see cref="EdgeContextResource"/>.
    /// </summary>
    public partial class EdgeSiteReferenceCollection : ArmCollection, IEnumerable<EdgeSiteReferenceResource>, IAsyncEnumerable<EdgeSiteReferenceResource>
    {
        private readonly ClientDiagnostics _edgeSiteReferenceSiteReferencesClientDiagnostics;
        private readonly SiteReferencesRestOperations _edgeSiteReferenceSiteReferencesRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeSiteReferenceCollection"/> class for mocking. </summary>
        protected EdgeSiteReferenceCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSiteReferenceCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeSiteReferenceCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSiteReferenceSiteReferencesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSiteReferenceResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeSiteReferenceResource.ResourceType, out string edgeSiteReferenceSiteReferencesApiVersion);
            _edgeSiteReferenceSiteReferencesRestClient = new SiteReferencesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSiteReferenceSiteReferencesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeContextResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeContextResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSiteReferenceResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string siteReferenceName, EdgeSiteReferenceData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeSiteReferenceSiteReferencesRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSiteReferenceResource>(new EdgeSiteReferenceOperationSource(Client), _edgeSiteReferenceSiteReferencesClientDiagnostics, Pipeline, _edgeSiteReferenceSiteReferencesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeSiteReferenceResource> CreateOrUpdate(WaitUntil waitUntil, string siteReferenceName, EdgeSiteReferenceData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeSiteReferenceSiteReferencesRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSiteReferenceResource>(new EdgeSiteReferenceOperationSource(Client), _edgeSiteReferenceSiteReferencesClientDiagnostics, Pipeline, _edgeSiteReferenceSiteReferencesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> is null. </exception>
        public virtual async Task<Response<EdgeSiteReferenceResource>> GetAsync(string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeSiteReferenceSiteReferencesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSiteReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> is null. </exception>
        public virtual Response<EdgeSiteReferenceResource> Get(string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeSiteReferenceSiteReferencesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSiteReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Site Reference Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_ListByContext</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSiteReferenceResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSiteReferenceResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSiteReferenceSiteReferencesRestClient.CreateListByContextRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSiteReferenceSiteReferencesRestClient.CreateListByContextNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSiteReferenceResource(Client, EdgeSiteReferenceData.DeserializeEdgeSiteReferenceData(e)), _edgeSiteReferenceSiteReferencesClientDiagnostics, Pipeline, "EdgeSiteReferenceCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Site Reference Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_ListByContext</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSiteReferenceResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSiteReferenceResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSiteReferenceSiteReferencesRestClient.CreateListByContextRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSiteReferenceSiteReferencesRestClient.CreateListByContextNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSiteReferenceResource(Client, EdgeSiteReferenceData.DeserializeEdgeSiteReferenceData(e)), _edgeSiteReferenceSiteReferencesClientDiagnostics, Pipeline, "EdgeSiteReferenceCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeSiteReferenceSiteReferencesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> is null. </exception>
        public virtual Response<bool> Exists(string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeSiteReferenceSiteReferencesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeSiteReferenceResource>> GetIfExistsAsync(string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeSiteReferenceSiteReferencesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSiteReferenceResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSiteReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="siteReferenceName"/> is null. </exception>
        public virtual NullableResponse<EdgeSiteReferenceResource> GetIfExists(string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeSiteReferenceSiteReferencesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, siteReferenceName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSiteReferenceResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSiteReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeSiteReferenceResource> IEnumerable<EdgeSiteReferenceResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeSiteReferenceResource> IAsyncEnumerable<EdgeSiteReferenceResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeSiteReferenceData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeSiteReference data model.
    /// Site Reference Resource
    /// </summary>
    public partial class EdgeSiteReferenceData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSiteReferenceData"/>. </summary>
        public EdgeSiteReferenceData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSiteReferenceData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSiteReferenceData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SiteReferenceProperties properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public SiteReferenceProperties Properties { get; set; }
    }
}



================================================
FILE: Generated/EdgeSiteReferenceData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSiteReferenceData : IUtf8JsonSerializable, IJsonModel<EdgeSiteReferenceData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSiteReferenceData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSiteReferenceData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSiteReferenceData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSiteReferenceData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeSiteReferenceData IJsonModel<EdgeSiteReferenceData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSiteReferenceData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSiteReferenceData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSiteReferenceData(document.RootElement, options);
        }

        internal static EdgeSiteReferenceData DeserializeEdgeSiteReferenceData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SiteReferenceProperties properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SiteReferenceProperties.DeserializeSiteReferenceProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSiteReferenceData(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSiteReferenceData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSiteReferenceData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSiteReferenceData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSiteReferenceData IPersistableModel<EdgeSiteReferenceData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSiteReferenceData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSiteReferenceData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSiteReferenceData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSiteReferenceData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeSiteReferenceResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeSiteReference along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeSiteReferenceResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeSiteReferenceResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeContextResource"/> using the GetEdgeSiteReference method.
    /// </summary>
    public partial class EdgeSiteReferenceResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeSiteReferenceResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="contextName"> The contextName. </param>
        /// <param name="siteReferenceName"> The siteReferenceName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeSiteReferenceSiteReferencesClientDiagnostics;
        private readonly SiteReferencesRestOperations _edgeSiteReferenceSiteReferencesRestClient;
        private readonly EdgeSiteReferenceData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/contexts/siteReferences";

        /// <summary> Initializes a new instance of the <see cref="EdgeSiteReferenceResource"/> class for mocking. </summary>
        protected EdgeSiteReferenceResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSiteReferenceResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeSiteReferenceResource(ArmClient client, EdgeSiteReferenceData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSiteReferenceResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeSiteReferenceResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSiteReferenceSiteReferencesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeSiteReferenceSiteReferencesApiVersion);
            _edgeSiteReferenceSiteReferencesRestClient = new SiteReferencesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSiteReferenceSiteReferencesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeSiteReferenceData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeSiteReferenceResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeSiteReferenceSiteReferencesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSiteReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeSiteReferenceResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceResource.Get");
            scope.Start();
            try
            {
                var response = _edgeSiteReferenceSiteReferencesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSiteReferenceResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeSiteReferenceSiteReferencesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSiteReferenceSiteReferencesClientDiagnostics, Pipeline, _edgeSiteReferenceSiteReferencesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeSiteReferenceSiteReferencesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSiteReferenceSiteReferencesClientDiagnostics, Pipeline, _edgeSiteReferenceSiteReferencesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSiteReferenceResource>> UpdateAsync(WaitUntil waitUntil, EdgeSiteReferencePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeSiteReferenceSiteReferencesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSiteReferenceResource>(new EdgeSiteReferenceOperationSource(Client), _edgeSiteReferenceSiteReferencesClientDiagnostics, Pipeline, _edgeSiteReferenceSiteReferencesRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Site Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/siteReferences/{siteReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SiteReferences_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSiteReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeSiteReferenceResource> Update(WaitUntil waitUntil, EdgeSiteReferencePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSiteReferenceSiteReferencesClientDiagnostics.CreateScope("EdgeSiteReferenceResource.Update");
            scope.Start();
            try
            {
                var response = _edgeSiteReferenceSiteReferencesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSiteReferenceResource>(new EdgeSiteReferenceOperationSource(Client), _edgeSiteReferenceSiteReferencesClientDiagnostics, Pipeline, _edgeSiteReferenceSiteReferencesRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeSiteReferenceResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSiteReferenceResource : IJsonModel<EdgeSiteReferenceData>
    {
        private static EdgeSiteReferenceData s_dataDeserializationInstance;
        private static EdgeSiteReferenceData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeSiteReferenceData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSiteReferenceData>)Data).Write(writer, options);

        EdgeSiteReferenceData IJsonModel<EdgeSiteReferenceData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSiteReferenceData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeSiteReferenceData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeSiteReferenceData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeSiteReferenceData IPersistableModel<EdgeSiteReferenceData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeSiteReferenceData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeSiteReferenceData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeSiteReferenceData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeSolutionCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeSolutionResource"/> and their operations.
    /// Each <see cref="EdgeSolutionResource"/> in the collection will belong to the same instance of <see cref="EdgeTargetResource"/>.
    /// To get an <see cref="EdgeSolutionCollection"/> instance call the GetEdgeSolutions method from an instance of <see cref="EdgeTargetResource"/>.
    /// </summary>
    public partial class EdgeSolutionCollection : ArmCollection, IEnumerable<EdgeSolutionResource>, IAsyncEnumerable<EdgeSolutionResource>
    {
        private readonly ClientDiagnostics _edgeSolutionSolutionsClientDiagnostics;
        private readonly SolutionsRestOperations _edgeSolutionSolutionsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionCollection"/> class for mocking. </summary>
        protected EdgeSolutionCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeSolutionCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSolutionSolutionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSolutionResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeSolutionResource.ResourceType, out string edgeSolutionSolutionsApiVersion);
            _edgeSolutionSolutionsRestClient = new SolutionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSolutionSolutionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeTargetResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeTargetResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Solution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string solutionName, EdgeSolutionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeSolutionSolutionsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionResource>(new EdgeSolutionOperationSource(Client), _edgeSolutionSolutionsClientDiagnostics, Pipeline, _edgeSolutionSolutionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Solution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionResource> CreateOrUpdate(WaitUntil waitUntil, string solutionName, EdgeSolutionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeSolutionSolutionsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionResource>(new EdgeSolutionOperationSource(Client), _edgeSolutionSolutionsClientDiagnostics, Pipeline, _edgeSolutionSolutionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> is null. </exception>
        public virtual async Task<Response<EdgeSolutionResource>> GetAsync(string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeSolutionSolutionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> is null. </exception>
        public virtual Response<EdgeSolutionResource> Get(string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeSolutionSolutionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Solution resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_ListByTarget</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSolutionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSolutionResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSolutionSolutionsRestClient.CreateListByTargetRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSolutionSolutionsRestClient.CreateListByTargetNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionResource(Client, EdgeSolutionData.DeserializeEdgeSolutionData(e)), _edgeSolutionSolutionsClientDiagnostics, Pipeline, "EdgeSolutionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Solution resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_ListByTarget</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSolutionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSolutionResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSolutionSolutionsRestClient.CreateListByTargetRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSolutionSolutionsRestClient.CreateListByTargetNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionResource(Client, EdgeSolutionData.DeserializeEdgeSolutionData(e)), _edgeSolutionSolutionsClientDiagnostics, Pipeline, "EdgeSolutionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeSolutionSolutionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> is null. </exception>
        public virtual Response<bool> Exists(string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeSolutionSolutionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeSolutionResource>> GetIfExistsAsync(string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeSolutionSolutionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSolutionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> is null. </exception>
        public virtual NullableResponse<EdgeSolutionResource> GetIfExists(string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeSolutionSolutionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSolutionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeSolutionResource> IEnumerable<EdgeSolutionResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeSolutionResource> IAsyncEnumerable<EdgeSolutionResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeSolutionData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeSolution data model.
    /// Solution Resource attached to a Target
    /// </summary>
    public partial class EdgeSolutionData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionData"/>. </summary>
        public EdgeSolutionData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSolutionData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SolutionProperties properties, AzureResourceManagerCommonTypesExtendedLocation extendedLocation, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ExtendedLocation = extendedLocation;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public SolutionProperties Properties { get; set; }
        /// <summary> The complex type of the extended location. </summary>
        public AzureResourceManagerCommonTypesExtendedLocation ExtendedLocation { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeSolutionData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSolutionData : IUtf8JsonSerializable, IJsonModel<EdgeSolutionData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSolutionData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSolutionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (Optional.IsDefined(ExtendedLocation))
            {
                writer.WritePropertyName("extendedLocation"u8);
                writer.WriteObjectValue(ExtendedLocation, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeSolutionData IJsonModel<EdgeSolutionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSolutionData(document.RootElement, options);
        }

        internal static EdgeSolutionData DeserializeEdgeSolutionData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SolutionProperties properties = default;
            AzureResourceManagerCommonTypesExtendedLocation extendedLocation = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SolutionProperties.DeserializeSolutionProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("extendedLocation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    extendedLocation = AzureResourceManagerCommonTypesExtendedLocation.DeserializeAzureResourceManagerCommonTypesExtendedLocation(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSolutionData(
                id,
                name,
                type,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSolutionData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSolutionData IPersistableModel<EdgeSolutionData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSolutionData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSolutionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeSolutionResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeSolution along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeSolutionResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeSolutionResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeTargetResource"/> using the GetEdgeSolution method.
    /// </summary>
    public partial class EdgeSolutionResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeSolutionResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="targetName"> The targetName. </param>
        /// <param name="solutionName"> The solutionName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeSolutionSolutionsClientDiagnostics;
        private readonly SolutionsRestOperations _edgeSolutionSolutionsRestClient;
        private readonly EdgeSolutionData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/targets/solutions";

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionResource"/> class for mocking. </summary>
        protected EdgeSolutionResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeSolutionResource(ArmClient client, EdgeSolutionData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeSolutionResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSolutionSolutionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeSolutionSolutionsApiVersion);
            _edgeSolutionSolutionsRestClient = new SolutionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSolutionSolutionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeSolutionData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeDeploymentInstanceResources in the EdgeSolution. </summary>
        /// <returns> An object representing collection of EdgeDeploymentInstanceResources and their operations over a EdgeDeploymentInstanceResource. </returns>
        public virtual EdgeDeploymentInstanceCollection GetEdgeDeploymentInstances()
        {
            return GetCachedClient(client => new EdgeDeploymentInstanceCollection(client, Id));
        }

        /// <summary>
        /// Get Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeDeploymentInstanceResource>> GetEdgeDeploymentInstanceAsync(string instanceName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeDeploymentInstances().GetAsync(instanceName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get Instance Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/instances/{instanceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Instances_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDeploymentInstanceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeDeploymentInstanceResource> GetEdgeDeploymentInstance(string instanceName, CancellationToken cancellationToken = default)
        {
            return GetEdgeDeploymentInstances().Get(instanceName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeSolutionVersionResources in the EdgeSolution. </summary>
        /// <returns> An object representing collection of EdgeSolutionVersionResources and their operations over a EdgeSolutionVersionResource. </returns>
        public virtual EdgeSolutionVersionCollection GetEdgeSolutionVersions()
        {
            return GetCachedClient(client => new EdgeSolutionVersionCollection(client, Id));
        }

        /// <summary>
        /// Get a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSolutionVersionResource>> GetEdgeSolutionVersionAsync(string solutionVersionName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeSolutionVersions().GetAsync(solutionVersionName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSolutionVersionResource> GetEdgeSolutionVersion(string solutionVersionName, CancellationToken cancellationToken = default)
        {
            return GetEdgeSolutionVersions().Get(solutionVersionName, cancellationToken);
        }

        /// <summary>
        /// Get a Solution resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeSolutionResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeSolutionSolutionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeSolutionResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionResource.Get");
            scope.Start();
            try
            {
                var response = _edgeSolutionSolutionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Solution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeSolutionSolutionsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionSolutionsClientDiagnostics, Pipeline, _edgeSolutionSolutionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Solution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeSolutionSolutionsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionSolutionsClientDiagnostics, Pipeline, _edgeSolutionSolutionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update a Solution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionResource>> UpdateAsync(WaitUntil waitUntil, EdgeSolutionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeSolutionSolutionsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionResource>(new EdgeSolutionOperationSource(Client), _edgeSolutionSolutionsClientDiagnostics, Pipeline, _edgeSolutionSolutionsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update a Solution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionResource> Update(WaitUntil waitUntil, EdgeSolutionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSolutionSolutionsClientDiagnostics.CreateScope("EdgeSolutionResource.Update");
            scope.Start();
            try
            {
                var response = _edgeSolutionSolutionsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionResource>(new EdgeSolutionOperationSource(Client), _edgeSolutionSolutionsClientDiagnostics, Pipeline, _edgeSolutionSolutionsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeSolutionResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSolutionResource : IJsonModel<EdgeSolutionData>
    {
        private static EdgeSolutionData s_dataDeserializationInstance;
        private static EdgeSolutionData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeSolutionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSolutionData>)Data).Write(writer, options);

        EdgeSolutionData IJsonModel<EdgeSolutionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSolutionData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeSolutionData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeSolutionData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeSolutionData IPersistableModel<EdgeSolutionData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeSolutionData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeSolutionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeSolutionData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeSolutionTemplateResource"/> and their operations.
    /// Each <see cref="EdgeSolutionTemplateResource"/> in the collection will belong to the same instance of <see cref="ResourceGroupResource"/>.
    /// To get an <see cref="EdgeSolutionTemplateCollection"/> instance call the GetEdgeSolutionTemplates method from an instance of <see cref="ResourceGroupResource"/>.
    /// </summary>
    public partial class EdgeSolutionTemplateCollection : ArmCollection, IEnumerable<EdgeSolutionTemplateResource>, IAsyncEnumerable<EdgeSolutionTemplateResource>
    {
        private readonly ClientDiagnostics _edgeSolutionTemplateSolutionTemplatesClientDiagnostics;
        private readonly SolutionTemplatesRestOperations _edgeSolutionTemplateSolutionTemplatesRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateCollection"/> class for mocking. </summary>
        protected EdgeSolutionTemplateCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeSolutionTemplateCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSolutionTemplateSolutionTemplatesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSolutionTemplateResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeSolutionTemplateResource.ResourceType, out string edgeSolutionTemplateSolutionTemplatesApiVersion);
            _edgeSolutionTemplateSolutionTemplatesRestClient = new SolutionTemplatesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSolutionTemplateSolutionTemplatesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceGroupResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceGroupResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionTemplateResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string solutionTemplateName, EdgeSolutionTemplateData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateSolutionTemplatesRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionTemplateResource>(new EdgeSolutionTemplateOperationSource(Client), _edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, _edgeSolutionTemplateSolutionTemplatesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionTemplateResource> CreateOrUpdate(WaitUntil waitUntil, string solutionTemplateName, EdgeSolutionTemplateData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateSolutionTemplatesRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionTemplateResource>(new EdgeSolutionTemplateOperationSource(Client), _edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, _edgeSolutionTemplateSolutionTemplatesRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        public virtual async Task<Response<EdgeSolutionTemplateResource>> GetAsync(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateSolutionTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        public virtual Response<EdgeSolutionTemplateResource> Get(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateSolutionTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSolutionTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSolutionTemplateResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSolutionTemplateSolutionTemplatesRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSolutionTemplateSolutionTemplatesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionTemplateResource(Client, EdgeSolutionTemplateData.DeserializeEdgeSolutionTemplateData(e)), _edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, "EdgeSolutionTemplateCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSolutionTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSolutionTemplateResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSolutionTemplateSolutionTemplatesRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSolutionTemplateSolutionTemplatesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionTemplateResource(Client, EdgeSolutionTemplateData.DeserializeEdgeSolutionTemplateData(e)), _edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, "EdgeSolutionTemplateCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateSolutionTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        public virtual Response<bool> Exists(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateSolutionTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeSolutionTemplateResource>> GetIfExistsAsync(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateSolutionTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSolutionTemplateResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        public virtual NullableResponse<EdgeSolutionTemplateResource> GetIfExists(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateSolutionTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, solutionTemplateName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSolutionTemplateResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeSolutionTemplateResource> IEnumerable<EdgeSolutionTemplateResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeSolutionTemplateResource> IAsyncEnumerable<EdgeSolutionTemplateResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeSolutionTemplate data model.
    /// Solution Template Resource. Contains capabilities and operations for creating versions.
    /// </summary>
    public partial class EdgeSolutionTemplateData : TrackedResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionTemplateData"/>. </summary>
        /// <param name="location"> The location. </param>
        public EdgeSolutionTemplateData(AzureLocation location) : base(location)
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionTemplateData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSolutionTemplateData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, IDictionary<string, string> tags, AzureLocation location, SolutionTemplateProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData, tags, location)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionTemplateData"/> for deserialization. </summary>
        internal EdgeSolutionTemplateData()
        {
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public SolutionTemplateProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSolutionTemplateData : IUtf8JsonSerializable, IJsonModel<EdgeSolutionTemplateData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSolutionTemplateData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSolutionTemplateData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplateData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionTemplateData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeSolutionTemplateData IJsonModel<EdgeSolutionTemplateData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplateData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionTemplateData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSolutionTemplateData(document.RootElement, options);
        }

        internal static EdgeSolutionTemplateData DeserializeEdgeSolutionTemplateData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SolutionTemplateProperties properties = default;
            string etag = default;
            IDictionary<string, string> tags = default;
            AzureLocation location = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SolutionTemplateProperties.DeserializeSolutionTemplateProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("location"u8))
                {
                    location = new AzureLocation(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSolutionTemplateData(
                id,
                name,
                type,
                systemData,
                tags ?? new ChangeTrackingDictionary<string, string>(),
                location,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSolutionTemplateData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplateData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionTemplateData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSolutionTemplateData IPersistableModel<EdgeSolutionTemplateData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplateData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSolutionTemplateData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionTemplateData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSolutionTemplateData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeSolutionTemplate along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeSolutionTemplateResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeSolutionTemplateResource method.
    /// Otherwise you can get one from its parent resource <see cref="ResourceGroupResource"/> using the GetEdgeSolutionTemplate method.
    /// </summary>
    public partial class EdgeSolutionTemplateResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeSolutionTemplateResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="solutionTemplateName"> The solutionTemplateName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string solutionTemplateName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeSolutionTemplateSolutionTemplatesClientDiagnostics;
        private readonly SolutionTemplatesRestOperations _edgeSolutionTemplateSolutionTemplatesRestClient;
        private readonly EdgeSolutionTemplateData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/solutionTemplates";

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateResource"/> class for mocking. </summary>
        protected EdgeSolutionTemplateResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeSolutionTemplateResource(ArmClient client, EdgeSolutionTemplateData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeSolutionTemplateResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSolutionTemplateSolutionTemplatesClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeSolutionTemplateSolutionTemplatesApiVersion);
            _edgeSolutionTemplateSolutionTemplatesRestClient = new SolutionTemplatesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSolutionTemplateSolutionTemplatesApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeSolutionTemplateData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeSolutionTemplateVersionResources in the EdgeSolutionTemplate. </summary>
        /// <returns> An object representing collection of EdgeSolutionTemplateVersionResources and their operations over a EdgeSolutionTemplateVersionResource. </returns>
        public virtual EdgeSolutionTemplateVersionCollection GetEdgeSolutionTemplateVersions()
        {
            return GetCachedClient(client => new EdgeSolutionTemplateVersionCollection(client, Id));
        }

        /// <summary>
        /// Get a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSolutionTemplateVersionResource>> GetEdgeSolutionTemplateVersionAsync(string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeSolutionTemplateVersions().GetAsync(solutionTemplateVersionName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSolutionTemplateVersionResource> GetEdgeSolutionTemplateVersion(string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            return GetEdgeSolutionTemplateVersions().Get(solutionTemplateVersionName, cancellationToken);
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeSolutionTemplateResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateSolutionTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeSolutionTemplateResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.Get");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateSolutionTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateSolutionTemplatesRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, _edgeSolutionTemplateSolutionTemplatesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateSolutionTemplatesRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, _edgeSolutionTemplateSolutionTemplatesRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<Response<EdgeSolutionTemplateResource>> UpdateAsync(EdgeSolutionTemplatePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateSolutionTemplatesRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                return Response.FromValue(new EdgeSolutionTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual Response<EdgeSolutionTemplateResource> Update(EdgeSolutionTemplatePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.Update");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateSolutionTemplatesRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken);
                return Response.FromValue(new EdgeSolutionTemplateResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/createVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_CreateVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionTemplateVersionResource>> CreateVersionAsync(WaitUntil waitUntil, SolutionTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.CreateVersion");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateSolutionTemplatesRestClient.CreateVersionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionTemplateVersionResource>(new EdgeSolutionTemplateVersionOperationSource(Client), _edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, _edgeSolutionTemplateSolutionTemplatesRestClient.CreateCreateVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/createVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_CreateVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionTemplateVersionResource> CreateVersion(WaitUntil waitUntil, SolutionTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.CreateVersion");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateSolutionTemplatesRestClient.CreateVersion(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionTemplateVersionResource>(new EdgeSolutionTemplateVersionOperationSource(Client), _edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, _edgeSolutionTemplateSolutionTemplatesRestClient.CreateCreateVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/removeVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_RemoveVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation> RemoveVersionAsync(WaitUntil waitUntil, WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.RemoveVersion");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateSolutionTemplatesRestClient.RemoveVersionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, _edgeSolutionTemplateSolutionTemplatesRestClient.CreateRemoveVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Remove Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/removeVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_RemoveVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation RemoveVersion(WaitUntil waitUntil, WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.RemoveVersion");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateSolutionTemplatesRestClient.RemoveVersion(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, _edgeSolutionTemplateSolutionTemplatesRestClient.CreateRemoveVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual async Task<Response<EdgeSolutionTemplateResource>> AddTagAsync(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.AddTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues[key] = value;
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeSolutionTemplateSolutionTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeSolutionTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeSolutionTemplatePatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = await UpdateAsync(patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual Response<EdgeSolutionTemplateResource> AddTag(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.AddTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues[key] = value;
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeSolutionTemplateSolutionTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeSolutionTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeSolutionTemplatePatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = Update(patch, cancellationToken: cancellationToken);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual async Task<Response<EdgeSolutionTemplateResource>> SetTagsAsync(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.SetTags");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    await GetTagResource().DeleteAsync(WaitUntil.Completed, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeSolutionTemplateSolutionTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeSolutionTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeSolutionTemplatePatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = await UpdateAsync(patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual Response<EdgeSolutionTemplateResource> SetTags(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.SetTags");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    GetTagResource().Delete(WaitUntil.Completed, cancellationToken: cancellationToken);
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeSolutionTemplateSolutionTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeSolutionTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeSolutionTemplatePatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = Update(patch, cancellationToken: cancellationToken);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual async Task<Response<EdgeSolutionTemplateResource>> RemoveTagAsync(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.RemoveTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.Remove(key);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeSolutionTemplateSolutionTemplatesRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeSolutionTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeSolutionTemplatePatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = await UpdateAsync(patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual Response<EdgeSolutionTemplateResource> RemoveTag(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeSolutionTemplateSolutionTemplatesClientDiagnostics.CreateScope("EdgeSolutionTemplateResource.RemoveTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.Remove(key);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeSolutionTemplateSolutionTemplatesRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeSolutionTemplateResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeSolutionTemplatePatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = Update(patch, cancellationToken: cancellationToken);
                    return result;
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSolutionTemplateResource : IJsonModel<EdgeSolutionTemplateData>
    {
        private static EdgeSolutionTemplateData s_dataDeserializationInstance;
        private static EdgeSolutionTemplateData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeSolutionTemplateData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSolutionTemplateData>)Data).Write(writer, options);

        EdgeSolutionTemplateData IJsonModel<EdgeSolutionTemplateData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSolutionTemplateData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeSolutionTemplateData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeSolutionTemplateData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeSolutionTemplateData IPersistableModel<EdgeSolutionTemplateData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeSolutionTemplateData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeSolutionTemplateData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeSolutionTemplateData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateVersionCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeSolutionTemplateVersionResource"/> and their operations.
    /// Each <see cref="EdgeSolutionTemplateVersionResource"/> in the collection will belong to the same instance of <see cref="EdgeSolutionTemplateResource"/>.
    /// To get an <see cref="EdgeSolutionTemplateVersionCollection"/> instance call the GetEdgeSolutionTemplateVersions method from an instance of <see cref="EdgeSolutionTemplateResource"/>.
    /// </summary>
    public partial class EdgeSolutionTemplateVersionCollection : ArmCollection, IEnumerable<EdgeSolutionTemplateVersionResource>, IAsyncEnumerable<EdgeSolutionTemplateVersionResource>
    {
        private readonly ClientDiagnostics _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics;
        private readonly SolutionTemplateVersionsRestOperations _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateVersionCollection"/> class for mocking. </summary>
        protected EdgeSolutionTemplateVersionCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateVersionCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeSolutionTemplateVersionCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSolutionTemplateVersionResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeSolutionTemplateVersionResource.ResourceType, out string edgeSolutionTemplateVersionSolutionTemplateVersionsApiVersion);
            _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient = new SolutionTemplateVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSolutionTemplateVersionSolutionTemplateVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeSolutionTemplateResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeSolutionTemplateResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Get a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersionName"/> is null. </exception>
        public virtual async Task<Response<EdgeSolutionTemplateVersionResource>> GetAsync(string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionTemplateVersionName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersionName"/> is null. </exception>
        public virtual Response<EdgeSolutionTemplateVersionResource> Get(string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionTemplateVersionName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Solution Template Version Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_ListBySolutionTemplate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSolutionTemplateVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSolutionTemplateVersionResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateListBySolutionTemplateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateListBySolutionTemplateNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionTemplateVersionResource(Client, EdgeSolutionTemplateVersionData.DeserializeEdgeSolutionTemplateVersionData(e)), _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics, Pipeline, "EdgeSolutionTemplateVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Solution Template Version Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_ListBySolutionTemplate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSolutionTemplateVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSolutionTemplateVersionResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateListBySolutionTemplateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateListBySolutionTemplateNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionTemplateVersionResource(Client, EdgeSolutionTemplateVersionData.DeserializeEdgeSolutionTemplateVersionData(e)), _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics, Pipeline, "EdgeSolutionTemplateVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersionName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionTemplateVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersionName"/> is null. </exception>
        public virtual Response<bool> Exists(string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionTemplateVersionName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersionName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeSolutionTemplateVersionResource>> GetIfExistsAsync(string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionTemplateVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSolutionTemplateVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersionName"/> is null. </exception>
        public virtual NullableResponse<EdgeSolutionTemplateVersionResource> GetIfExists(string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, solutionTemplateVersionName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSolutionTemplateVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeSolutionTemplateVersionResource> IEnumerable<EdgeSolutionTemplateVersionResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeSolutionTemplateVersionResource> IAsyncEnumerable<EdgeSolutionTemplateVersionResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateVersionData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeSolutionTemplateVersion data model.
    /// Solution Template Version Resource. Contains configurations that use expressions which can be resolved hierarchically along with edge specifications.
    /// </summary>
    public partial class EdgeSolutionTemplateVersionData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionTemplateVersionData"/>. </summary>
        public EdgeSolutionTemplateVersionData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionTemplateVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSolutionTemplateVersionData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SolutionTemplateVersionProperties properties, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public SolutionTemplateVersionProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateVersionData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSolutionTemplateVersionData : IUtf8JsonSerializable, IJsonModel<EdgeSolutionTemplateVersionData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSolutionTemplateVersionData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSolutionTemplateVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplateVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionTemplateVersionData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeSolutionTemplateVersionData IJsonModel<EdgeSolutionTemplateVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplateVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionTemplateVersionData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSolutionTemplateVersionData(document.RootElement, options);
        }

        internal static EdgeSolutionTemplateVersionData DeserializeEdgeSolutionTemplateVersionData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SolutionTemplateVersionProperties properties = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SolutionTemplateVersionProperties.DeserializeSolutionTemplateVersionProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSolutionTemplateVersionData(
                id,
                name,
                type,
                systemData,
                properties,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSolutionTemplateVersionData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplateVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionTemplateVersionData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSolutionTemplateVersionData IPersistableModel<EdgeSolutionTemplateVersionData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplateVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSolutionTemplateVersionData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionTemplateVersionData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSolutionTemplateVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateVersionResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeSolutionTemplateVersion along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeSolutionTemplateVersionResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeSolutionTemplateVersionResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeSolutionTemplateResource"/> using the GetEdgeSolutionTemplateVersion method.
    /// </summary>
    public partial class EdgeSolutionTemplateVersionResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeSolutionTemplateVersionResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="solutionTemplateName"> The solutionTemplateName. </param>
        /// <param name="solutionTemplateVersionName"> The solutionTemplateVersionName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics;
        private readonly SolutionTemplateVersionsRestOperations _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient;
        private readonly EdgeSolutionTemplateVersionData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/solutionTemplates/versions";

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateVersionResource"/> class for mocking. </summary>
        protected EdgeSolutionTemplateVersionResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeSolutionTemplateVersionResource(ArmClient client, EdgeSolutionTemplateVersionData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionTemplateVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeSolutionTemplateVersionResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeSolutionTemplateVersionSolutionTemplateVersionsApiVersion);
            _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient = new SolutionTemplateVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSolutionTemplateVersionSolutionTemplateVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeSolutionTemplateVersionData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeSolutionTemplateVersionResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution Template Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeSolutionTemplateVersionResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionResource.Get");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionTemplateVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk deploy
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkDeploySolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_BulkDeploySolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation> BulkDeploySolutionAsync(WaitUntil waitUntil, WorkloadOrchestrationBulkDeploySolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionResource.BulkDeploySolution");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.BulkDeploySolutionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics, Pipeline, _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateBulkDeploySolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk deploy
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkDeploySolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_BulkDeploySolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation BulkDeploySolution(WaitUntil waitUntil, WorkloadOrchestrationBulkDeploySolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionResource.BulkDeploySolution");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.BulkDeploySolution(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics, Pipeline, _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateBulkDeploySolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk publish
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkPublishSolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_BulkPublishSolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation> BulkPublishSolutionAsync(WaitUntil waitUntil, WorkloadOrchestrationBulkPublishSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionResource.BulkPublishSolution");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.BulkPublishSolutionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics, Pipeline, _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateBulkPublishSolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk publish
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkPublishSolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_BulkPublishSolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation BulkPublishSolution(WaitUntil waitUntil, WorkloadOrchestrationBulkPublishSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionResource.BulkPublishSolution");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.BulkPublishSolution(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics, Pipeline, _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateBulkPublishSolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk review
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkReviewSolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_BulkReviewSolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation> BulkReviewSolutionAsync(WaitUntil waitUntil, WorkloadOrchestrationBulkReviewSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionResource.BulkReviewSolution");
            scope.Start();
            try
            {
                var response = await _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.BulkReviewSolutionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics, Pipeline, _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateBulkReviewSolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request for bulk review
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}/versions/{solutionTemplateVersionName}/bulkReviewSolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplateVersions_BulkReviewSolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation BulkReviewSolution(WaitUntil waitUntil, WorkloadOrchestrationBulkReviewSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics.CreateScope("EdgeSolutionTemplateVersionResource.BulkReviewSolution");
            scope.Start();
            try
            {
                var response = _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.BulkReviewSolution(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionTemplateVersionSolutionTemplateVersionsClientDiagnostics, Pipeline, _edgeSolutionTemplateVersionSolutionTemplateVersionsRestClient.CreateBulkReviewSolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeSolutionTemplateVersionResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSolutionTemplateVersionResource : IJsonModel<EdgeSolutionTemplateVersionData>
    {
        private static EdgeSolutionTemplateVersionData s_dataDeserializationInstance;
        private static EdgeSolutionTemplateVersionData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeSolutionTemplateVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSolutionTemplateVersionData>)Data).Write(writer, options);

        EdgeSolutionTemplateVersionData IJsonModel<EdgeSolutionTemplateVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSolutionTemplateVersionData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeSolutionTemplateVersionData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeSolutionTemplateVersionData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeSolutionTemplateVersionData IPersistableModel<EdgeSolutionTemplateVersionData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeSolutionTemplateVersionData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeSolutionTemplateVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeSolutionTemplateVersionData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeSolutionVersionCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeSolutionVersionResource"/> and their operations.
    /// Each <see cref="EdgeSolutionVersionResource"/> in the collection will belong to the same instance of <see cref="EdgeSolutionResource"/>.
    /// To get an <see cref="EdgeSolutionVersionCollection"/> instance call the GetEdgeSolutionVersions method from an instance of <see cref="EdgeSolutionResource"/>.
    /// </summary>
    public partial class EdgeSolutionVersionCollection : ArmCollection, IEnumerable<EdgeSolutionVersionResource>, IAsyncEnumerable<EdgeSolutionVersionResource>
    {
        private readonly ClientDiagnostics _edgeSolutionVersionSolutionVersionsClientDiagnostics;
        private readonly SolutionVersionsRestOperations _edgeSolutionVersionSolutionVersionsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionVersionCollection"/> class for mocking. </summary>
        protected EdgeSolutionVersionCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionVersionCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeSolutionVersionCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSolutionVersionSolutionVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSolutionVersionResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeSolutionVersionResource.ResourceType, out string edgeSolutionVersionSolutionVersionsApiVersion);
            _edgeSolutionVersionSolutionVersionsRestClient = new SolutionVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSolutionVersionSolutionVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeSolutionResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeSolutionResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionVersionResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string solutionVersionName, EdgeSolutionVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeSolutionVersionSolutionVersionsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeSolutionVersionSolutionVersionsClientDiagnostics, Pipeline, _edgeSolutionVersionSolutionVersionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionVersionResource> CreateOrUpdate(WaitUntil waitUntil, string solutionVersionName, EdgeSolutionVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeSolutionVersionSolutionVersionsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeSolutionVersionSolutionVersionsClientDiagnostics, Pipeline, _edgeSolutionVersionSolutionVersionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> is null. </exception>
        public virtual async Task<Response<EdgeSolutionVersionResource>> GetAsync(string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeSolutionVersionSolutionVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> is null. </exception>
        public virtual Response<EdgeSolutionVersionResource> Get(string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeSolutionVersionSolutionVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Solution Version Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_ListBySolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSolutionVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSolutionVersionResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSolutionVersionSolutionVersionsRestClient.CreateListBySolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSolutionVersionSolutionVersionsRestClient.CreateListBySolutionNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionVersionResource(Client, EdgeSolutionVersionData.DeserializeEdgeSolutionVersionData(e)), _edgeSolutionVersionSolutionVersionsClientDiagnostics, Pipeline, "EdgeSolutionVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Solution Version Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_ListBySolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSolutionVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSolutionVersionResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeSolutionVersionSolutionVersionsRestClient.CreateListBySolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeSolutionVersionSolutionVersionsRestClient.CreateListBySolutionNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionVersionResource(Client, EdgeSolutionVersionData.DeserializeEdgeSolutionVersionData(e)), _edgeSolutionVersionSolutionVersionsClientDiagnostics, Pipeline, "EdgeSolutionVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeSolutionVersionSolutionVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> is null. </exception>
        public virtual Response<bool> Exists(string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeSolutionVersionSolutionVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeSolutionVersionResource>> GetIfExistsAsync(string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeSolutionVersionSolutionVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSolutionVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionName"/> is null. </exception>
        public virtual NullableResponse<EdgeSolutionVersionResource> GetIfExists(string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeSolutionVersionSolutionVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, solutionVersionName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeSolutionVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeSolutionVersionResource> IEnumerable<EdgeSolutionVersionResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeSolutionVersionResource> IAsyncEnumerable<EdgeSolutionVersionResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeSolutionVersionData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeSolutionVersion data model.
    /// Solution Version Resource. It has the resolved configuration along with edge specification.
    /// </summary>
    public partial class EdgeSolutionVersionData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionVersionData"/>. </summary>
        public EdgeSolutionVersionData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSolutionVersionData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SolutionVersionProperties properties, AzureResourceManagerCommonTypesExtendedLocation extendedLocation, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ExtendedLocation = extendedLocation;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public SolutionVersionProperties Properties { get; set; }
        /// <summary> The complex type of the extended location. </summary>
        public AzureResourceManagerCommonTypesExtendedLocation ExtendedLocation { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeSolutionVersionData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSolutionVersionData : IUtf8JsonSerializable, IJsonModel<EdgeSolutionVersionData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSolutionVersionData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSolutionVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionVersionData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (Optional.IsDefined(ExtendedLocation))
            {
                writer.WritePropertyName("extendedLocation"u8);
                writer.WriteObjectValue(ExtendedLocation, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeSolutionVersionData IJsonModel<EdgeSolutionVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionVersionData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSolutionVersionData(document.RootElement, options);
        }

        internal static EdgeSolutionVersionData DeserializeEdgeSolutionVersionData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SolutionVersionProperties properties = default;
            AzureResourceManagerCommonTypesExtendedLocation extendedLocation = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SolutionVersionProperties.DeserializeSolutionVersionProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("extendedLocation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    extendedLocation = AzureResourceManagerCommonTypesExtendedLocation.DeserializeAzureResourceManagerCommonTypesExtendedLocation(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSolutionVersionData(
                id,
                name,
                type,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSolutionVersionData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionVersionData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSolutionVersionData IPersistableModel<EdgeSolutionVersionData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSolutionVersionData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionVersionData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSolutionVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeSolutionVersionResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeSolutionVersion along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeSolutionVersionResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeSolutionVersionResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeSolutionResource"/> using the GetEdgeSolutionVersion method.
    /// </summary>
    public partial class EdgeSolutionVersionResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeSolutionVersionResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="targetName"> The targetName. </param>
        /// <param name="solutionName"> The solutionName. </param>
        /// <param name="solutionVersionName"> The solutionVersionName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeSolutionVersionSolutionVersionsClientDiagnostics;
        private readonly SolutionVersionsRestOperations _edgeSolutionVersionSolutionVersionsRestClient;
        private readonly EdgeSolutionVersionData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/targets/solutions/versions";

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionVersionResource"/> class for mocking. </summary>
        protected EdgeSolutionVersionResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeSolutionVersionResource(ArmClient client, EdgeSolutionVersionData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeSolutionVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeSolutionVersionResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeSolutionVersionSolutionVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeSolutionVersionSolutionVersionsApiVersion);
            _edgeSolutionVersionSolutionVersionsRestClient = new SolutionVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeSolutionVersionSolutionVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeSolutionVersionData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary>
        /// Get a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeSolutionVersionResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeSolutionVersionSolutionVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeSolutionVersionResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionResource.Get");
            scope.Start();
            try
            {
                var response = _edgeSolutionVersionSolutionVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeSolutionVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeSolutionVersionSolutionVersionsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionVersionSolutionVersionsClientDiagnostics, Pipeline, _edgeSolutionVersionSolutionVersionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeSolutionVersionSolutionVersionsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeSolutionVersionSolutionVersionsClientDiagnostics, Pipeline, _edgeSolutionVersionSolutionVersionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionVersionResource>> UpdateAsync(WaitUntil waitUntil, EdgeSolutionVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeSolutionVersionSolutionVersionsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeSolutionVersionSolutionVersionsClientDiagnostics, Pipeline, _edgeSolutionVersionSolutionVersionsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update a Solution Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}/versions/{solutionVersionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionVersions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionVersionResource> Update(WaitUntil waitUntil, EdgeSolutionVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeSolutionVersionSolutionVersionsClientDiagnostics.CreateScope("EdgeSolutionVersionResource.Update");
            scope.Start();
            try
            {
                var response = _edgeSolutionVersionSolutionVersionsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeSolutionVersionSolutionVersionsClientDiagnostics, Pipeline, _edgeSolutionVersionSolutionVersionsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeSolutionVersionResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeSolutionVersionResource : IJsonModel<EdgeSolutionVersionData>
    {
        private static EdgeSolutionVersionData s_dataDeserializationInstance;
        private static EdgeSolutionVersionData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeSolutionVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSolutionVersionData>)Data).Write(writer, options);

        EdgeSolutionVersionData IJsonModel<EdgeSolutionVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeSolutionVersionData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeSolutionVersionData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeSolutionVersionData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeSolutionVersionData IPersistableModel<EdgeSolutionVersionData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeSolutionVersionData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeSolutionVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeSolutionVersionData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeTargetCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeTargetResource"/> and their operations.
    /// Each <see cref="EdgeTargetResource"/> in the collection will belong to the same instance of <see cref="ResourceGroupResource"/>.
    /// To get an <see cref="EdgeTargetCollection"/> instance call the GetEdgeTargets method from an instance of <see cref="ResourceGroupResource"/>.
    /// </summary>
    public partial class EdgeTargetCollection : ArmCollection, IEnumerable<EdgeTargetResource>, IAsyncEnumerable<EdgeTargetResource>
    {
        private readonly ClientDiagnostics _edgeTargetTargetsClientDiagnostics;
        private readonly TargetsRestOperations _edgeTargetTargetsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeTargetCollection"/> class for mocking. </summary>
        protected EdgeTargetCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeTargetCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeTargetCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeTargetTargetsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeTargetResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeTargetResource.ResourceType, out string edgeTargetTargetsApiVersion);
            _edgeTargetTargetsRestClient = new TargetsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeTargetTargetsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceGroupResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceGroupResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeTargetResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string targetName, EdgeTargetData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, targetName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeTargetResource>(new EdgeTargetOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, targetName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeTargetResource> CreateOrUpdate(WaitUntil waitUntil, string targetName, EdgeTargetData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, targetName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeTargetResource>(new EdgeTargetOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, targetName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        public virtual async Task<Response<EdgeTargetResource>> GetAsync(string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, targetName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeTargetResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        public virtual Response<EdgeTargetResource> Get(string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, targetName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeTargetResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeTargetResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeTargetResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeTargetTargetsRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeTargetTargetsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeTargetResource(Client, EdgeTargetData.DeserializeEdgeTargetData(e)), _edgeTargetTargetsClientDiagnostics, Pipeline, "EdgeTargetCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by specified resource group
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ListByResourceGroup</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeTargetResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeTargetResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeTargetTargetsRestClient.CreateListByResourceGroupRequest(Id.SubscriptionId, Id.ResourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeTargetTargetsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeTargetResource(Client, EdgeTargetData.DeserializeEdgeTargetData(e)), _edgeTargetTargetsClientDiagnostics, Pipeline, "EdgeTargetCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, targetName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        public virtual Response<bool> Exists(string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, targetName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeTargetResource>> GetIfExistsAsync(string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, targetName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeTargetResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeTargetResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        public virtual NullableResponse<EdgeTargetResource> GetIfExists(string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, targetName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeTargetResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeTargetResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeTargetResource> IEnumerable<EdgeTargetResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeTargetResource> IAsyncEnumerable<EdgeTargetResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeTargetData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeTarget data model.
    /// Target Resource. Represents a resource to be deployed on the edge.
    /// </summary>
    public partial class EdgeTargetData : TrackedResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeTargetData"/>. </summary>
        /// <param name="location"> The location. </param>
        public EdgeTargetData(AzureLocation location) : base(location)
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeTargetData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="tags"> The tags. </param>
        /// <param name="location"> The location. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeTargetData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, IDictionary<string, string> tags, AzureLocation location, TargetProperties properties, string etag, AzureResourceManagerCommonTypesExtendedLocation extendedLocation, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData, tags, location)
        {
            Properties = properties;
            ETag = etag;
            ExtendedLocation = extendedLocation;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="EdgeTargetData"/> for deserialization. </summary>
        internal EdgeTargetData()
        {
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public TargetProperties Properties { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
        /// <summary> The complex type of the extended location. </summary>
        public AzureResourceManagerCommonTypesExtendedLocation ExtendedLocation { get; set; }
    }
}



================================================
FILE: Generated/EdgeTargetData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeTargetData : IUtf8JsonSerializable, IJsonModel<EdgeTargetData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeTargetData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeTargetData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeTargetData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeTargetData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
            if (Optional.IsDefined(ExtendedLocation))
            {
                writer.WritePropertyName("extendedLocation"u8);
                writer.WriteObjectValue(ExtendedLocation, options);
            }
        }

        EdgeTargetData IJsonModel<EdgeTargetData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeTargetData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeTargetData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeTargetData(document.RootElement, options);
        }

        internal static EdgeTargetData DeserializeEdgeTargetData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            TargetProperties properties = default;
            string etag = default;
            AzureResourceManagerCommonTypesExtendedLocation extendedLocation = default;
            IDictionary<string, string> tags = default;
            AzureLocation location = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = TargetProperties.DeserializeTargetProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("extendedLocation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    extendedLocation = AzureResourceManagerCommonTypesExtendedLocation.DeserializeAzureResourceManagerCommonTypesExtendedLocation(property.Value, options);
                    continue;
                }
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("location"u8))
                {
                    location = new AzureLocation(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeTargetData(
                id,
                name,
                type,
                systemData,
                tags ?? new ChangeTrackingDictionary<string, string>(),
                location,
                properties,
                etag,
                extendedLocation,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeTargetData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeTargetData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeTargetData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeTargetData IPersistableModel<EdgeTargetData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeTargetData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeTargetData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeTargetData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeTargetData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeTargetResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.Resources;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeTarget along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeTargetResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeTargetResource method.
    /// Otherwise you can get one from its parent resource <see cref="ResourceGroupResource"/> using the GetEdgeTarget method.
    /// </summary>
    public partial class EdgeTargetResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeTargetResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="targetName"> The targetName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string targetName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeTargetTargetsClientDiagnostics;
        private readonly TargetsRestOperations _edgeTargetTargetsRestClient;
        private readonly EdgeTargetData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/targets";

        /// <summary> Initializes a new instance of the <see cref="EdgeTargetResource"/> class for mocking. </summary>
        protected EdgeTargetResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeTargetResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeTargetResource(ArmClient client, EdgeTargetData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeTargetResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeTargetResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeTargetTargetsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeTargetTargetsApiVersion);
            _edgeTargetTargetsRestClient = new TargetsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeTargetTargetsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeTargetData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeSolutionResources in the EdgeTarget. </summary>
        /// <returns> An object representing collection of EdgeSolutionResources and their operations over a EdgeSolutionResource. </returns>
        public virtual EdgeSolutionCollection GetEdgeSolutions()
        {
            return GetCachedClient(client => new EdgeSolutionCollection(client, Id));
        }

        /// <summary>
        /// Get a Solution resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSolutionResource>> GetEdgeSolutionAsync(string solutionName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeSolutions().GetAsync(solutionName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Solution resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/solutions/{solutionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Solutions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSolutionResource> GetEdgeSolution(string solutionName, CancellationToken cancellationToken = default)
        {
            return GetEdgeSolutions().Get(solutionName, cancellationToken);
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeTargetResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeTargetResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeTargetResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.Get");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeTargetResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="forceDelete"> Force delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, bool? forceDelete = null, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, forceDelete, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, forceDelete).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="forceDelete"> Force delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, bool? forceDelete = null, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, forceDelete, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, forceDelete).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeTargetResource>> UpdateAsync(WaitUntil waitUntil, EdgeTargetPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeTargetResource>(new EdgeTargetOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeTargetResource> Update(WaitUntil waitUntil, EdgeTargetPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.Update");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeTargetResource>(new EdgeTargetOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to deploy
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/installSolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_InstallSolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation> InstallSolutionAsync(WaitUntil waitUntil, WorkloadOrchestrationInstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.InstallSolution");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.InstallSolutionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateInstallSolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to deploy
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/installSolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_InstallSolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation InstallSolution(WaitUntil waitUntil, WorkloadOrchestrationInstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.InstallSolution");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.InstallSolution(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateInstallSolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to publish
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/publishSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_PublishSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionVersionResource>> PublishSolutionVersionAsync(WaitUntil waitUntil, WorkloadOrchestrationSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.PublishSolutionVersion");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.PublishSolutionVersionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreatePublishSolutionVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to publish
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/publishSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_PublishSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionVersionResource> PublishSolutionVersion(WaitUntil waitUntil, WorkloadOrchestrationSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.PublishSolutionVersion");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.PublishSolutionVersion(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreatePublishSolutionVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to remove solution version revision
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/removeRevision</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_RemoveRevision</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation> RemoveRevisionAsync(WaitUntil waitUntil, WorkloadOrchestrationRemoveRevisionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.RemoveRevision");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.RemoveRevisionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateRemoveRevisionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to remove solution version revision
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/removeRevision</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_RemoveRevision</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation RemoveRevision(WaitUntil waitUntil, WorkloadOrchestrationRemoveRevisionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.RemoveRevision");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.RemoveRevision(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateRemoveRevisionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to resolve configuration
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/resolveConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ResolveConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation<ResolvedConfiguration>> ResolveConfigurationAsync(WaitUntil waitUntil, WorkloadOrchestrationSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.ResolveConfiguration");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.ResolveConfigurationAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<ResolvedConfiguration>(new ResolvedConfigurationOperationSource(), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateResolveConfigurationRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to resolve configuration
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/resolveConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ResolveConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation<ResolvedConfiguration> ResolveConfiguration(WaitUntil waitUntil, WorkloadOrchestrationSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.ResolveConfiguration");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.ResolveConfiguration(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<ResolvedConfiguration>(new ResolvedConfigurationOperationSource(), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateResolveConfigurationRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to review configuration
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/reviewSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ReviewSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionVersionResource>> ReviewSolutionVersionAsync(WaitUntil waitUntil, WorkloadOrchestrationSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.ReviewSolutionVersion");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.ReviewSolutionVersionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateReviewSolutionVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to review configuration
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/reviewSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ReviewSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionVersionResource> ReviewSolutionVersion(WaitUntil waitUntil, WorkloadOrchestrationSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.ReviewSolutionVersion");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.ReviewSolutionVersion(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateReviewSolutionVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to uninstall
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/uninstallSolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_UninstallSolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation> UninstallSolutionAsync(WaitUntil waitUntil, WorkloadOrchestrationUninstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.UninstallSolution");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.UninstallSolutionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateUninstallSolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to uninstall
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/uninstallSolution</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_UninstallSolution</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation UninstallSolution(WaitUntil waitUntil, WorkloadOrchestrationUninstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.UninstallSolution");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.UninstallSolution(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateUninstallSolutionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to unstage solution version
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/unstageSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_UnstageSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionVersionResource>> UnstageSolutionVersionAsync(WaitUntil waitUntil, WorkloadOrchestrationSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.UnstageSolutionVersion");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.UnstageSolutionVersionAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateUnstageSolutionVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to unstage solution version
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/unstageSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_UnstageSolutionVersion</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionVersionResource> UnstageSolutionVersion(WaitUntil waitUntil, WorkloadOrchestrationSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.UnstageSolutionVersion");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.UnstageSolutionVersion(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateUnstageSolutionVersionRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to update external validation status
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/updateExternalValidationStatus</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_UpdateExternalValidationStatus</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeSolutionVersionResource>> UpdateExternalValidationStatusAsync(WaitUntil waitUntil, WorkloadOrchestrationUpdateExternalValidationStatusContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.UpdateExternalValidationStatus");
            scope.Start();
            try
            {
                var response = await _edgeTargetTargetsRestClient.UpdateExternalValidationStatusAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateUpdateExternalValidationStatusRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Post request to update external validation status
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}/updateExternalValidationStatus</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_UpdateExternalValidationStatus</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        public virtual ArmOperation<EdgeSolutionVersionResource> UpdateExternalValidationStatus(WaitUntil waitUntil, WorkloadOrchestrationUpdateExternalValidationStatusContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.UpdateExternalValidationStatus");
            scope.Start();
            try
            {
                var response = _edgeTargetTargetsRestClient.UpdateExternalValidationStatus(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeSolutionVersionResource>(new EdgeSolutionVersionOperationSource(Client), _edgeTargetTargetsClientDiagnostics, Pipeline, _edgeTargetTargetsRestClient.CreateUpdateExternalValidationStatusRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual async Task<Response<EdgeTargetResource>> AddTagAsync(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.AddTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues[key] = value;
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeTargetTargetsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeTargetResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeTargetPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = await UpdateAsync(WaitUntil.Completed, patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Add a tag to the current resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="value"> The value for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> or <paramref name="value"/> is null. </exception>
        public virtual Response<EdgeTargetResource> AddTag(string key, string value, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));
            Argument.AssertNotNull(value, nameof(value));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.AddTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues[key] = value;
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeTargetTargetsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeTargetResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeTargetPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags[key] = value;
                    var result = Update(WaitUntil.Completed, patch, cancellationToken: cancellationToken);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual async Task<Response<EdgeTargetResource>> SetTagsAsync(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.SetTags");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    await GetTagResource().DeleteAsync(WaitUntil.Completed, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeTargetTargetsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeTargetResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeTargetPatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = await UpdateAsync(WaitUntil.Completed, patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Replace the tags on the resource with the given set.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="tags"> The set of tags to use as replacement. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="tags"/> is null. </exception>
        public virtual Response<EdgeTargetResource> SetTags(IDictionary<string, string> tags, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(tags, nameof(tags));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.SetTags");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    GetTagResource().Delete(WaitUntil.Completed, cancellationToken: cancellationToken);
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.ReplaceWith(tags);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeTargetTargetsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeTargetResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeTargetPatch();
                    patch.Tags.ReplaceWith(tags);
                    var result = Update(WaitUntil.Completed, patch, cancellationToken: cancellationToken);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual async Task<Response<EdgeTargetResource>> RemoveTagAsync(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.RemoveTag");
            scope.Start();
            try
            {
                if (await CanUseTagResourceAsync(cancellationToken: cancellationToken).ConfigureAwait(false))
                {
                    var originalTags = await GetTagResource().GetAsync(cancellationToken).ConfigureAwait(false);
                    originalTags.Value.Data.TagValues.Remove(key);
                    await GetTagResource().CreateOrUpdateAsync(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken).ConfigureAwait(false);
                    var originalResponse = await _edgeTargetTargetsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(new EdgeTargetResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = (await GetAsync(cancellationToken: cancellationToken).ConfigureAwait(false)).Value.Data;
                    var patch = new EdgeTargetPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = await UpdateAsync(WaitUntil.Completed, patch, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Removes a tag by key from the resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="key"> The key for the tag. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="key"/> is null. </exception>
        public virtual Response<EdgeTargetResource> RemoveTag(string key, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(key, nameof(key));

            using var scope = _edgeTargetTargetsClientDiagnostics.CreateScope("EdgeTargetResource.RemoveTag");
            scope.Start();
            try
            {
                if (CanUseTagResource(cancellationToken: cancellationToken))
                {
                    var originalTags = GetTagResource().Get(cancellationToken);
                    originalTags.Value.Data.TagValues.Remove(key);
                    GetTagResource().CreateOrUpdate(WaitUntil.Completed, originalTags.Value.Data, cancellationToken: cancellationToken);
                    var originalResponse = _edgeTargetTargetsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, cancellationToken);
                    return Response.FromValue(new EdgeTargetResource(Client, originalResponse.Value), originalResponse.GetRawResponse());
                }
                else
                {
                    var current = Get(cancellationToken: cancellationToken).Value.Data;
                    var patch = new EdgeTargetPatch();
                    foreach (var tag in current.Tags)
                    {
                        patch.Tags.Add(tag);
                    }
                    patch.Tags.Remove(key);
                    var result = Update(WaitUntil.Completed, patch, cancellationToken: cancellationToken);
                    return Response.FromValue(result.Value, result.GetRawResponse());
                }
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeTargetResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeTargetResource : IJsonModel<EdgeTargetData>
    {
        private static EdgeTargetData s_dataDeserializationInstance;
        private static EdgeTargetData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeTargetData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeTargetData>)Data).Write(writer, options);

        EdgeTargetData IJsonModel<EdgeTargetData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeTargetData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeTargetData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeTargetData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeTargetData IPersistableModel<EdgeTargetData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeTargetData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeTargetData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeTargetData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeWorkflowCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeWorkflowResource"/> and their operations.
    /// Each <see cref="EdgeWorkflowResource"/> in the collection will belong to the same instance of <see cref="EdgeContextResource"/>.
    /// To get an <see cref="EdgeWorkflowCollection"/> instance call the GetEdgeWorkflows method from an instance of <see cref="EdgeContextResource"/>.
    /// </summary>
    public partial class EdgeWorkflowCollection : ArmCollection, IEnumerable<EdgeWorkflowResource>, IAsyncEnumerable<EdgeWorkflowResource>
    {
        private readonly ClientDiagnostics _edgeWorkflowWorkflowsClientDiagnostics;
        private readonly WorkflowsRestOperations _edgeWorkflowWorkflowsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowCollection"/> class for mocking. </summary>
        protected EdgeWorkflowCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeWorkflowCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeWorkflowWorkflowsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeWorkflowResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeWorkflowResource.ResourceType, out string edgeWorkflowWorkflowsApiVersion);
            _edgeWorkflowWorkflowsRestClient = new WorkflowsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeWorkflowWorkflowsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeContextResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeContextResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeWorkflowResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string workflowName, EdgeWorkflowData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowWorkflowsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeWorkflowResource>(new EdgeWorkflowOperationSource(Client), _edgeWorkflowWorkflowsClientDiagnostics, Pipeline, _edgeWorkflowWorkflowsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeWorkflowResource> CreateOrUpdate(WaitUntil waitUntil, string workflowName, EdgeWorkflowData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeWorkflowWorkflowsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeWorkflowResource>(new EdgeWorkflowOperationSource(Client), _edgeWorkflowWorkflowsClientDiagnostics, Pipeline, _edgeWorkflowWorkflowsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> is null. </exception>
        public virtual async Task<Response<EdgeWorkflowResource>> GetAsync(string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowWorkflowsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> is null. </exception>
        public virtual Response<EdgeWorkflowResource> Get(string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeWorkflowWorkflowsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Workflow resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_ListByContext</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeWorkflowResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeWorkflowResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeWorkflowWorkflowsRestClient.CreateListByContextRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeWorkflowWorkflowsRestClient.CreateListByContextNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeWorkflowResource(Client, EdgeWorkflowData.DeserializeEdgeWorkflowData(e)), _edgeWorkflowWorkflowsClientDiagnostics, Pipeline, "EdgeWorkflowCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Workflow resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_ListByContext</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeWorkflowResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeWorkflowResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeWorkflowWorkflowsRestClient.CreateListByContextRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeWorkflowWorkflowsRestClient.CreateListByContextNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeWorkflowResource(Client, EdgeWorkflowData.DeserializeEdgeWorkflowData(e)), _edgeWorkflowWorkflowsClientDiagnostics, Pipeline, "EdgeWorkflowCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowWorkflowsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> is null. </exception>
        public virtual Response<bool> Exists(string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeWorkflowWorkflowsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeWorkflowResource>> GetIfExistsAsync(string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowWorkflowsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeWorkflowResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowName"/> is null. </exception>
        public virtual NullableResponse<EdgeWorkflowResource> GetIfExists(string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeWorkflowWorkflowsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Name, workflowName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeWorkflowResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeWorkflowResource> IEnumerable<EdgeWorkflowResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeWorkflowResource> IAsyncEnumerable<EdgeWorkflowResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeWorkflowData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeWorkflow data model.
    /// Workflow Resource
    /// </summary>
    public partial class EdgeWorkflowData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeWorkflowData"/>. </summary>
        public EdgeWorkflowData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeWorkflowData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeWorkflowData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, WorkflowProperties properties, AzureResourceManagerCommonTypesExtendedLocation extendedLocation, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ExtendedLocation = extendedLocation;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public WorkflowProperties Properties { get; set; }
        /// <summary> The complex type of the extended location. </summary>
        public AzureResourceManagerCommonTypesExtendedLocation ExtendedLocation { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeWorkflowData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeWorkflowData : IUtf8JsonSerializable, IJsonModel<EdgeWorkflowData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeWorkflowData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeWorkflowData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeWorkflowData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (Optional.IsDefined(ExtendedLocation))
            {
                writer.WritePropertyName("extendedLocation"u8);
                writer.WriteObjectValue(ExtendedLocation, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeWorkflowData IJsonModel<EdgeWorkflowData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeWorkflowData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeWorkflowData(document.RootElement, options);
        }

        internal static EdgeWorkflowData DeserializeEdgeWorkflowData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            WorkflowProperties properties = default;
            AzureResourceManagerCommonTypesExtendedLocation extendedLocation = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = WorkflowProperties.DeserializeWorkflowProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("extendedLocation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    extendedLocation = AzureResourceManagerCommonTypesExtendedLocation.DeserializeAzureResourceManagerCommonTypesExtendedLocation(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeWorkflowData(
                id,
                name,
                type,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeWorkflowData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeWorkflowData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeWorkflowData IPersistableModel<EdgeWorkflowData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeWorkflowData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeWorkflowData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeWorkflowData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeWorkflowResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeWorkflow along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeWorkflowResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeWorkflowResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeContextResource"/> using the GetEdgeWorkflow method.
    /// </summary>
    public partial class EdgeWorkflowResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeWorkflowResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="contextName"> The contextName. </param>
        /// <param name="workflowName"> The workflowName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string contextName, string workflowName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeWorkflowWorkflowsClientDiagnostics;
        private readonly WorkflowsRestOperations _edgeWorkflowWorkflowsRestClient;
        private readonly EdgeWorkflowData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/contexts/workflows";

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowResource"/> class for mocking. </summary>
        protected EdgeWorkflowResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeWorkflowResource(ArmClient client, EdgeWorkflowData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeWorkflowResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeWorkflowWorkflowsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeWorkflowWorkflowsApiVersion);
            _edgeWorkflowWorkflowsRestClient = new WorkflowsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeWorkflowWorkflowsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeWorkflowData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeWorkflowVersionResources in the EdgeWorkflow. </summary>
        /// <returns> An object representing collection of EdgeWorkflowVersionResources and their operations over a EdgeWorkflowVersionResource. </returns>
        public virtual EdgeWorkflowVersionCollection GetEdgeWorkflowVersions()
        {
            return GetCachedClient(client => new EdgeWorkflowVersionCollection(client, Id));
        }

        /// <summary>
        /// Get a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeWorkflowVersionResource>> GetEdgeWorkflowVersionAsync(string versionName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeWorkflowVersions().GetAsync(versionName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeWorkflowVersionResource> GetEdgeWorkflowVersion(string versionName, CancellationToken cancellationToken = default)
        {
            return GetEdgeWorkflowVersions().Get(versionName, cancellationToken);
        }

        /// <summary>
        /// Get a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeWorkflowResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowWorkflowsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeWorkflowResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowResource.Get");
            scope.Start();
            try
            {
                var response = _edgeWorkflowWorkflowsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowWorkflowsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeWorkflowWorkflowsClientDiagnostics, Pipeline, _edgeWorkflowWorkflowsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeWorkflowWorkflowsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeWorkflowWorkflowsClientDiagnostics, Pipeline, _edgeWorkflowWorkflowsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeWorkflowResource>> UpdateAsync(WaitUntil waitUntil, EdgeWorkflowPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowWorkflowsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeWorkflowResource>(new EdgeWorkflowOperationSource(Client), _edgeWorkflowWorkflowsClientDiagnostics, Pipeline, _edgeWorkflowWorkflowsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update a Workflow resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Workflows_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeWorkflowResource> Update(WaitUntil waitUntil, EdgeWorkflowPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeWorkflowWorkflowsClientDiagnostics.CreateScope("EdgeWorkflowResource.Update");
            scope.Start();
            try
            {
                var response = _edgeWorkflowWorkflowsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeWorkflowResource>(new EdgeWorkflowOperationSource(Client), _edgeWorkflowWorkflowsClientDiagnostics, Pipeline, _edgeWorkflowWorkflowsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeWorkflowResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeWorkflowResource : IJsonModel<EdgeWorkflowData>
    {
        private static EdgeWorkflowData s_dataDeserializationInstance;
        private static EdgeWorkflowData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeWorkflowData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeWorkflowData>)Data).Write(writer, options);

        EdgeWorkflowData IJsonModel<EdgeWorkflowData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeWorkflowData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeWorkflowData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeWorkflowData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeWorkflowData IPersistableModel<EdgeWorkflowData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeWorkflowData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeWorkflowData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeWorkflowData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/EdgeWorkflowVersionCollection.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing a collection of <see cref="EdgeWorkflowVersionResource"/> and their operations.
    /// Each <see cref="EdgeWorkflowVersionResource"/> in the collection will belong to the same instance of <see cref="EdgeWorkflowResource"/>.
    /// To get an <see cref="EdgeWorkflowVersionCollection"/> instance call the GetEdgeWorkflowVersions method from an instance of <see cref="EdgeWorkflowResource"/>.
    /// </summary>
    public partial class EdgeWorkflowVersionCollection : ArmCollection, IEnumerable<EdgeWorkflowVersionResource>, IAsyncEnumerable<EdgeWorkflowVersionResource>
    {
        private readonly ClientDiagnostics _edgeWorkflowVersionWorkflowVersionsClientDiagnostics;
        private readonly WorkflowVersionsRestOperations _edgeWorkflowVersionWorkflowVersionsRestClient;

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowVersionCollection"/> class for mocking. </summary>
        protected EdgeWorkflowVersionCollection()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowVersionCollection"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the parent resource that is the target of operations. </param>
        internal EdgeWorkflowVersionCollection(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeWorkflowVersionWorkflowVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeWorkflowVersionResource.ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(EdgeWorkflowVersionResource.ResourceType, out string edgeWorkflowVersionWorkflowVersionsApiVersion);
            _edgeWorkflowVersionWorkflowVersionsRestClient = new WorkflowVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeWorkflowVersionWorkflowVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != EdgeWorkflowResource.ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, EdgeWorkflowResource.ResourceType), nameof(id));
        }

        /// <summary>
        /// Create or update a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> or <paramref name="data"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeWorkflowVersionResource>> CreateOrUpdateAsync(WaitUntil waitUntil, string versionName, EdgeWorkflowVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowVersionWorkflowVersionsRestClient.CreateOrUpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, data, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeWorkflowVersionResource>(new EdgeWorkflowVersionOperationSource(Client), _edgeWorkflowVersionWorkflowVersionsClientDiagnostics, Pipeline, _edgeWorkflowVersionWorkflowVersionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create or update a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_CreateOrUpdate</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> or <paramref name="data"/> is null. </exception>
        public virtual ArmOperation<EdgeWorkflowVersionResource> CreateOrUpdate(WaitUntil waitUntil, string versionName, EdgeWorkflowVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNull(data, nameof(data));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionCollection.CreateOrUpdate");
            scope.Start();
            try
            {
                var response = _edgeWorkflowVersionWorkflowVersionsRestClient.CreateOrUpdate(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, data, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeWorkflowVersionResource>(new EdgeWorkflowVersionOperationSource(Client), _edgeWorkflowVersionWorkflowVersionsClientDiagnostics, Pipeline, _edgeWorkflowVersionWorkflowVersionsRestClient.CreateCreateOrUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, data).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> is null. </exception>
        public virtual async Task<Response<EdgeWorkflowVersionResource>> GetAsync(string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionCollection.Get");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowVersionWorkflowVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> is null. </exception>
        public virtual Response<EdgeWorkflowVersionResource> Get(string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionCollection.Get");
            scope.Start();
            try
            {
                var response = _edgeWorkflowVersionWorkflowVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Workflow Version Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_ListByWorkflow</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeWorkflowVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeWorkflowVersionResource> GetAllAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeWorkflowVersionWorkflowVersionsRestClient.CreateListByWorkflowRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeWorkflowVersionWorkflowVersionsRestClient.CreateListByWorkflowNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeWorkflowVersionResource(Client, EdgeWorkflowVersionData.DeserializeEdgeWorkflowVersionData(e)), _edgeWorkflowVersionWorkflowVersionsClientDiagnostics, Pipeline, "EdgeWorkflowVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Workflow Version Resources
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_ListByWorkflow</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeWorkflowVersionResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeWorkflowVersionResource> GetAll(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => _edgeWorkflowVersionWorkflowVersionsRestClient.CreateListByWorkflowRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => _edgeWorkflowVersionWorkflowVersionsRestClient.CreateListByWorkflowNextPageRequest(nextLink, Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeWorkflowVersionResource(Client, EdgeWorkflowVersionData.DeserializeEdgeWorkflowVersionData(e)), _edgeWorkflowVersionWorkflowVersionsClientDiagnostics, Pipeline, "EdgeWorkflowVersionCollection.GetAll", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> is null. </exception>
        public virtual async Task<Response<bool>> ExistsAsync(string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowVersionWorkflowVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Checks to see if the resource exists in azure.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> is null. </exception>
        public virtual Response<bool> Exists(string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionCollection.Exists");
            scope.Start();
            try
            {
                var response = _edgeWorkflowVersionWorkflowVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, cancellationToken: cancellationToken);
                return Response.FromValue(response.Value != null, response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> is null. </exception>
        public virtual async Task<NullableResponse<EdgeWorkflowVersionResource>> GetIfExistsAsync(string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowVersionWorkflowVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, cancellationToken: cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    return new NoValueResponse<EdgeWorkflowVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Tries to get details for this resource from the service.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentException"> <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ArgumentNullException"> <paramref name="versionName"/> is null. </exception>
        public virtual NullableResponse<EdgeWorkflowVersionResource> GetIfExists(string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionCollection.GetIfExists");
            scope.Start();
            try
            {
                var response = _edgeWorkflowVersionWorkflowVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Name, Id.Name, versionName, cancellationToken: cancellationToken);
                if (response.Value == null)
                    return new NoValueResponse<EdgeWorkflowVersionResource>(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        IEnumerator<EdgeWorkflowVersionResource> IEnumerable<EdgeWorkflowVersionResource>.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetAll().GetEnumerator();
        }

        IAsyncEnumerator<EdgeWorkflowVersionResource> IAsyncEnumerable<EdgeWorkflowVersionResource>.GetAsyncEnumerator(CancellationToken cancellationToken)
        {
            return GetAllAsync(cancellationToken: cancellationToken).GetAsyncEnumerator(cancellationToken);
        }
    }
}



================================================
FILE: Generated/EdgeWorkflowVersionData.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A class representing the EdgeWorkflowVersion data model.
    /// Workflow Version Resource
    /// </summary>
    public partial class EdgeWorkflowVersionData : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeWorkflowVersionData"/>. </summary>
        public EdgeWorkflowVersionData()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeWorkflowVersionData"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="extendedLocation"> The complex type of the extended location. </param>
        /// <param name="etag"> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeWorkflowVersionData(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, WorkflowVersionProperties properties, AzureResourceManagerCommonTypesExtendedLocation extendedLocation, string etag, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            ExtendedLocation = extendedLocation;
            ETag = etag;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public WorkflowVersionProperties Properties { get; set; }
        /// <summary> The complex type of the extended location. </summary>
        public AzureResourceManagerCommonTypesExtendedLocation ExtendedLocation { get; set; }
        /// <summary> If eTag is provided in the response body, it may also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. </summary>
        public string ETag { get; }
    }
}



================================================
FILE: Generated/EdgeWorkflowVersionData.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeWorkflowVersionData : IUtf8JsonSerializable, IJsonModel<EdgeWorkflowVersionData>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeWorkflowVersionData>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeWorkflowVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeWorkflowVersionData)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (Optional.IsDefined(ExtendedLocation))
            {
                writer.WritePropertyName("extendedLocation"u8);
                writer.WriteObjectValue(ExtendedLocation, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ETag))
            {
                writer.WritePropertyName("eTag"u8);
                writer.WriteStringValue(ETag);
            }
        }

        EdgeWorkflowVersionData IJsonModel<EdgeWorkflowVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowVersionData>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeWorkflowVersionData)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeWorkflowVersionData(document.RootElement, options);
        }

        internal static EdgeWorkflowVersionData DeserializeEdgeWorkflowVersionData(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            WorkflowVersionProperties properties = default;
            AzureResourceManagerCommonTypesExtendedLocation extendedLocation = default;
            string etag = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = WorkflowVersionProperties.DeserializeWorkflowVersionProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("extendedLocation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    extendedLocation = AzureResourceManagerCommonTypesExtendedLocation.DeserializeAzureResourceManagerCommonTypesExtendedLocation(property.Value, options);
                    continue;
                }
                if (property.NameEquals("eTag"u8))
                {
                    etag = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeWorkflowVersionData(
                id,
                name,
                type,
                systemData,
                properties,
                extendedLocation,
                etag,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeWorkflowVersionData>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeWorkflowVersionData)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeWorkflowVersionData IPersistableModel<EdgeWorkflowVersionData>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowVersionData>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeWorkflowVersionData(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeWorkflowVersionData)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeWorkflowVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/EdgeWorkflowVersionResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// A Class representing an EdgeWorkflowVersion along with the instance operations that can be performed on it.
    /// If you have a <see cref="ResourceIdentifier"/> you can construct an <see cref="EdgeWorkflowVersionResource"/>
    /// from an instance of <see cref="ArmClient"/> using the GetEdgeWorkflowVersionResource method.
    /// Otherwise you can get one from its parent resource <see cref="EdgeWorkflowResource"/> using the GetEdgeWorkflowVersion method.
    /// </summary>
    public partial class EdgeWorkflowVersionResource : ArmResource
    {
        /// <summary> Generate the resource identifier of a <see cref="EdgeWorkflowVersionResource"/> instance. </summary>
        /// <param name="subscriptionId"> The subscriptionId. </param>
        /// <param name="resourceGroupName"> The resourceGroupName. </param>
        /// <param name="contextName"> The contextName. </param>
        /// <param name="workflowName"> The workflowName. </param>
        /// <param name="versionName"> The versionName. </param>
        public static ResourceIdentifier CreateResourceIdentifier(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName)
        {
            var resourceId = $"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}";
            return new ResourceIdentifier(resourceId);
        }

        private readonly ClientDiagnostics _edgeWorkflowVersionWorkflowVersionsClientDiagnostics;
        private readonly WorkflowVersionsRestOperations _edgeWorkflowVersionWorkflowVersionsRestClient;
        private readonly EdgeWorkflowVersionData _data;

        /// <summary> Gets the resource type for the operations. </summary>
        public static readonly ResourceType ResourceType = "Microsoft.Edge/contexts/workflows/versions";

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowVersionResource"/> class for mocking. </summary>
        protected EdgeWorkflowVersionResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="data"> The resource that is the target of operations. </param>
        internal EdgeWorkflowVersionResource(ArmClient client, EdgeWorkflowVersionData data) : this(client, data.Id)
        {
            HasData = true;
            _data = data;
        }

        /// <summary> Initializes a new instance of the <see cref="EdgeWorkflowVersionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal EdgeWorkflowVersionResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
            _edgeWorkflowVersionWorkflowVersionsClientDiagnostics = new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", ResourceType.Namespace, Diagnostics);
            TryGetApiVersion(ResourceType, out string edgeWorkflowVersionWorkflowVersionsApiVersion);
            _edgeWorkflowVersionWorkflowVersionsRestClient = new WorkflowVersionsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, edgeWorkflowVersionWorkflowVersionsApiVersion);
#if DEBUG
			ValidateResourceId(Id);
#endif
        }

        /// <summary> Gets whether or not the current instance has data. </summary>
        public virtual bool HasData { get; }

        /// <summary> Gets the data representing this Feature. </summary>
        /// <exception cref="InvalidOperationException"> Throws if there is no data loaded in the current instance. </exception>
        public virtual EdgeWorkflowVersionData Data
        {
            get
            {
                if (!HasData)
                    throw new InvalidOperationException("The current instance does not have data, you must call Get first.");
                return _data;
            }
        }

        internal static void ValidateResourceId(ResourceIdentifier id)
        {
            if (id.ResourceType != ResourceType)
                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Invalid resource type {0} expected {1}", id.ResourceType, ResourceType), nameof(id));
        }

        /// <summary> Gets a collection of EdgeExecutionResources in the EdgeWorkflowVersion. </summary>
        /// <returns> An object representing collection of EdgeExecutionResources and their operations over a EdgeExecutionResource. </returns>
        public virtual EdgeExecutionCollection GetEdgeExecutions()
        {
            return GetCachedClient(client => new EdgeExecutionCollection(client, Id));
        }

        /// <summary>
        /// Get Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeExecutionResource>> GetEdgeExecutionAsync(string executionName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeExecutions().GetAsync(executionName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get Execution Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}/executions/{executionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Executions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeExecutionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="executionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeExecutionResource> GetEdgeExecution(string executionName, CancellationToken cancellationToken = default)
        {
            return GetEdgeExecutions().Get(executionName, cancellationToken);
        }

        /// <summary>
        /// Get a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<EdgeWorkflowVersionResource>> GetAsync(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionResource.Get");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowVersionWorkflowVersionsRestClient.GetAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<EdgeWorkflowVersionResource> Get(CancellationToken cancellationToken = default)
        {
            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionResource.Get");
            scope.Start();
            try
            {
                var response = _edgeWorkflowVersionWorkflowVersionsRestClient.Get(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                if (response.Value == null)
                    throw new RequestFailedException(response.GetRawResponse());
                return Response.FromValue(new EdgeWorkflowVersionResource(Client, response.Value), response.GetRawResponse());
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAsync(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionResource.Delete");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowVersionWorkflowVersionsRestClient.DeleteAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation(_edgeWorkflowVersionWorkflowVersionsClientDiagnostics, Pipeline, _edgeWorkflowVersionWorkflowVersionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete a Workflow Version Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Delete</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation Delete(WaitUntil waitUntil, CancellationToken cancellationToken = default)
        {
            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionResource.Delete");
            scope.Start();
            try
            {
                var response = _edgeWorkflowVersionWorkflowVersionsRestClient.Delete(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation(_edgeWorkflowVersionWorkflowVersionsClientDiagnostics, Pipeline, _edgeWorkflowVersionWorkflowVersionsRestClient.CreateDeleteRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update an WorkflowVersion Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual async Task<ArmOperation<EdgeWorkflowVersionResource>> UpdateAsync(WaitUntil waitUntil, EdgeWorkflowVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionResource.Update");
            scope.Start();
            try
            {
                var response = await _edgeWorkflowVersionWorkflowVersionsRestClient.UpdateAsync(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken).ConfigureAwait(false);
                var operation = new WorkloadOrchestrationArmOperation<EdgeWorkflowVersionResource>(new EdgeWorkflowVersionOperationSource(Client), _edgeWorkflowVersionWorkflowVersionsClientDiagnostics, Pipeline, _edgeWorkflowVersionWorkflowVersionsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// update an WorkflowVersion Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}/workflows/{workflowName}/versions/{versionName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>WorkflowVersions_Update</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeWorkflowVersionResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="patch"/> is null. </exception>
        public virtual ArmOperation<EdgeWorkflowVersionResource> Update(WaitUntil waitUntil, EdgeWorkflowVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(patch, nameof(patch));

            using var scope = _edgeWorkflowVersionWorkflowVersionsClientDiagnostics.CreateScope("EdgeWorkflowVersionResource.Update");
            scope.Start();
            try
            {
                var response = _edgeWorkflowVersionWorkflowVersionsRestClient.Update(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch, cancellationToken);
                var operation = new WorkloadOrchestrationArmOperation<EdgeWorkflowVersionResource>(new EdgeWorkflowVersionOperationSource(Client), _edgeWorkflowVersionWorkflowVersionsClientDiagnostics, Pipeline, _edgeWorkflowVersionWorkflowVersionsRestClient.CreateUpdateRequest(Id.SubscriptionId, Id.ResourceGroupName, Id.Parent.Parent.Name, Id.Parent.Name, Id.Name, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}



================================================
FILE: Generated/EdgeWorkflowVersionResource.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    public partial class EdgeWorkflowVersionResource : IJsonModel<EdgeWorkflowVersionData>
    {
        private static EdgeWorkflowVersionData s_dataDeserializationInstance;
        private static EdgeWorkflowVersionData DataDeserializationInstance => s_dataDeserializationInstance ??= new();

        void IJsonModel<EdgeWorkflowVersionData>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options) => ((IJsonModel<EdgeWorkflowVersionData>)Data).Write(writer, options);

        EdgeWorkflowVersionData IJsonModel<EdgeWorkflowVersionData>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) => ((IJsonModel<EdgeWorkflowVersionData>)DataDeserializationInstance).Create(ref reader, options);

        BinaryData IPersistableModel<EdgeWorkflowVersionData>.Write(ModelReaderWriterOptions options) => ModelReaderWriter.Write<EdgeWorkflowVersionData>(Data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        EdgeWorkflowVersionData IPersistableModel<EdgeWorkflowVersionData>.Create(BinaryData data, ModelReaderWriterOptions options) => ModelReaderWriter.Read<EdgeWorkflowVersionData>(data, options, AzureResourceManagerWorkloadOrchestrationContext.Default);

        string IPersistableModel<EdgeWorkflowVersionData>.GetFormatFromOptions(ModelReaderWriterOptions options) => ((IPersistableModel<EdgeWorkflowVersionData>)DataDeserializationInstance).GetFormatFromOptions(options);
    }
}



================================================
FILE: Generated/ProviderConstants.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal static class ProviderConstants
    {
        public static string DefaultProviderNamespace { get; } = ClientDiagnostics.GetResourceProviderNamespace(typeof(ProviderConstants).Assembly);
    }
}



================================================
FILE: Generated/Extensions/MockableWorkloadOrchestrationArmClient.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Mocking
{
    /// <summary> A class to add extension methods to ArmClient. </summary>
    public partial class MockableWorkloadOrchestrationArmClient : ArmResource
    {
        /// <summary> Initializes a new instance of the <see cref="MockableWorkloadOrchestrationArmClient"/> class for mocking. </summary>
        protected MockableWorkloadOrchestrationArmClient()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="MockableWorkloadOrchestrationArmClient"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal MockableWorkloadOrchestrationArmClient(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
        }

        internal MockableWorkloadOrchestrationArmClient(ArmClient client) : this(client, ResourceIdentifier.Root)
        {
        }

        private string GetApiVersionOrNull(ResourceType resourceType)
        {
            TryGetApiVersion(resourceType, out string apiVersion);
            return apiVersion;
        }

        /// <summary> Gets a collection of EdgeJobResources in the ArmClient. </summary>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <returns> An object representing collection of EdgeJobResources and their operations over a EdgeJobResource. </returns>
        public virtual EdgeJobCollection GetEdgeJobs(ResourceIdentifier scope)
        {
            return new EdgeJobCollection(Client, scope);
        }

        /// <summary>
        /// Get a Job resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeJobResource>> GetEdgeJobAsync(ResourceIdentifier scope, string jobName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeJobs(scope).GetAsync(jobName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Job resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeJobResource> GetEdgeJob(ResourceIdentifier scope, string jobName, CancellationToken cancellationToken = default)
        {
            return GetEdgeJobs(scope).Get(jobName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeSchemaReferenceResources in the ArmClient. </summary>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <returns> An object representing collection of EdgeSchemaReferenceResources and their operations over a EdgeSchemaReferenceResource. </returns>
        public virtual EdgeSchemaReferenceCollection GetEdgeSchemaReferences(ResourceIdentifier scope)
        {
            return new EdgeSchemaReferenceCollection(Client, scope);
        }

        /// <summary>
        /// Get a Schema Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSchemaReferenceResource>> GetEdgeSchemaReferenceAsync(ResourceIdentifier scope, string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeSchemaReferences(scope).GetAsync(schemaReferenceName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Schema Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSchemaReferenceResource> GetEdgeSchemaReference(ResourceIdentifier scope, string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            return GetEdgeSchemaReferences(scope).Get(schemaReferenceName, cancellationToken);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeJobResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeJobResource.CreateResourceIdentifier" /> to create an <see cref="EdgeJobResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeJobResource"/> object. </returns>
        public virtual EdgeJobResource GetEdgeJobResource(ResourceIdentifier id)
        {
            EdgeJobResource.ValidateResourceId(id);
            return new EdgeJobResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSchemaReferenceResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSchemaReferenceResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSchemaReferenceResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeSchemaReferenceResource"/> object. </returns>
        public virtual EdgeSchemaReferenceResource GetEdgeSchemaReferenceResource(ResourceIdentifier id)
        {
            EdgeSchemaReferenceResource.ValidateResourceId(id);
            return new EdgeSchemaReferenceResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeConfigTemplateResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeConfigTemplateResource.CreateResourceIdentifier" /> to create an <see cref="EdgeConfigTemplateResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeConfigTemplateResource"/> object. </returns>
        public virtual EdgeConfigTemplateResource GetEdgeConfigTemplateResource(ResourceIdentifier id)
        {
            EdgeConfigTemplateResource.ValidateResourceId(id);
            return new EdgeConfigTemplateResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeContextResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeContextResource.CreateResourceIdentifier" /> to create an <see cref="EdgeContextResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeContextResource"/> object. </returns>
        public virtual EdgeContextResource GetEdgeContextResource(ResourceIdentifier id)
        {
            EdgeContextResource.ValidateResourceId(id);
            return new EdgeContextResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDiagnosticResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDiagnosticResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDiagnosticResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeDiagnosticResource"/> object. </returns>
        public virtual EdgeDiagnosticResource GetEdgeDiagnosticResource(ResourceIdentifier id)
        {
            EdgeDiagnosticResource.ValidateResourceId(id);
            return new EdgeDiagnosticResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSchemaResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSchemaResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSchemaResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeSchemaResource"/> object. </returns>
        public virtual EdgeSchemaResource GetEdgeSchemaResource(ResourceIdentifier id)
        {
            EdgeSchemaResource.ValidateResourceId(id);
            return new EdgeSchemaResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSolutionTemplateResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSolutionTemplateResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSolutionTemplateResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeSolutionTemplateResource"/> object. </returns>
        public virtual EdgeSolutionTemplateResource GetEdgeSolutionTemplateResource(ResourceIdentifier id)
        {
            EdgeSolutionTemplateResource.ValidateResourceId(id);
            return new EdgeSolutionTemplateResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeTargetResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeTargetResource.CreateResourceIdentifier" /> to create an <see cref="EdgeTargetResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeTargetResource"/> object. </returns>
        public virtual EdgeTargetResource GetEdgeTargetResource(ResourceIdentifier id)
        {
            EdgeTargetResource.ValidateResourceId(id);
            return new EdgeTargetResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeConfigTemplateVersionResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeConfigTemplateVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeConfigTemplateVersionResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeConfigTemplateVersionResource"/> object. </returns>
        public virtual EdgeConfigTemplateVersionResource GetEdgeConfigTemplateVersionResource(ResourceIdentifier id)
        {
            EdgeConfigTemplateVersionResource.ValidateResourceId(id);
            return new EdgeConfigTemplateVersionResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSiteReferenceResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSiteReferenceResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSiteReferenceResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeSiteReferenceResource"/> object. </returns>
        public virtual EdgeSiteReferenceResource GetEdgeSiteReferenceResource(ResourceIdentifier id)
        {
            EdgeSiteReferenceResource.ValidateResourceId(id);
            return new EdgeSiteReferenceResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeWorkflowResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeWorkflowResource.CreateResourceIdentifier" /> to create an <see cref="EdgeWorkflowResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeWorkflowResource"/> object. </returns>
        public virtual EdgeWorkflowResource GetEdgeWorkflowResource(ResourceIdentifier id)
        {
            EdgeWorkflowResource.ValidateResourceId(id);
            return new EdgeWorkflowResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeWorkflowVersionResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeWorkflowVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeWorkflowVersionResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeWorkflowVersionResource"/> object. </returns>
        public virtual EdgeWorkflowVersionResource GetEdgeWorkflowVersionResource(ResourceIdentifier id)
        {
            EdgeWorkflowVersionResource.ValidateResourceId(id);
            return new EdgeWorkflowVersionResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeExecutionResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeExecutionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeExecutionResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeExecutionResource"/> object. </returns>
        public virtual EdgeExecutionResource GetEdgeExecutionResource(ResourceIdentifier id)
        {
            EdgeExecutionResource.ValidateResourceId(id);
            return new EdgeExecutionResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDynamicSchemaResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDynamicSchemaResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDynamicSchemaResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeDynamicSchemaResource"/> object. </returns>
        public virtual EdgeDynamicSchemaResource GetEdgeDynamicSchemaResource(ResourceIdentifier id)
        {
            EdgeDynamicSchemaResource.ValidateResourceId(id);
            return new EdgeDynamicSchemaResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDynamicSchemaVersionResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDynamicSchemaVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDynamicSchemaVersionResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeDynamicSchemaVersionResource"/> object. </returns>
        public virtual EdgeDynamicSchemaVersionResource GetEdgeDynamicSchemaVersionResource(ResourceIdentifier id)
        {
            EdgeDynamicSchemaVersionResource.ValidateResourceId(id);
            return new EdgeDynamicSchemaVersionResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSchemaVersionResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSchemaVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSchemaVersionResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeSchemaVersionResource"/> object. </returns>
        public virtual EdgeSchemaVersionResource GetEdgeSchemaVersionResource(ResourceIdentifier id)
        {
            EdgeSchemaVersionResource.ValidateResourceId(id);
            return new EdgeSchemaVersionResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSolutionTemplateVersionResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSolutionTemplateVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSolutionTemplateVersionResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeSolutionTemplateVersionResource"/> object. </returns>
        public virtual EdgeSolutionTemplateVersionResource GetEdgeSolutionTemplateVersionResource(ResourceIdentifier id)
        {
            EdgeSolutionTemplateVersionResource.ValidateResourceId(id);
            return new EdgeSolutionTemplateVersionResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSolutionResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSolutionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSolutionResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeSolutionResource"/> object. </returns>
        public virtual EdgeSolutionResource GetEdgeSolutionResource(ResourceIdentifier id)
        {
            EdgeSolutionResource.ValidateResourceId(id);
            return new EdgeSolutionResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDeploymentInstanceResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDeploymentInstanceResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDeploymentInstanceResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeDeploymentInstanceResource"/> object. </returns>
        public virtual EdgeDeploymentInstanceResource GetEdgeDeploymentInstanceResource(ResourceIdentifier id)
        {
            EdgeDeploymentInstanceResource.ValidateResourceId(id);
            return new EdgeDeploymentInstanceResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDeploymentInstanceHistoryResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDeploymentInstanceHistoryResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDeploymentInstanceHistoryResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeDeploymentInstanceHistoryResource"/> object. </returns>
        public virtual EdgeDeploymentInstanceHistoryResource GetEdgeDeploymentInstanceHistoryResource(ResourceIdentifier id)
        {
            EdgeDeploymentInstanceHistoryResource.ValidateResourceId(id);
            return new EdgeDeploymentInstanceHistoryResource(Client, id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSolutionVersionResource"/> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSolutionVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSolutionVersionResource"/> <see cref="ResourceIdentifier"/> from its components.
        /// </summary>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <returns> Returns a <see cref="EdgeSolutionVersionResource"/> object. </returns>
        public virtual EdgeSolutionVersionResource GetEdgeSolutionVersionResource(ResourceIdentifier id)
        {
            EdgeSolutionVersionResource.ValidateResourceId(id);
            return new EdgeSolutionVersionResource(Client, id);
        }
    }
}



================================================
FILE: Generated/Extensions/MockableWorkloadOrchestrationResourceGroupResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Mocking
{
    /// <summary> A class to add extension methods to ResourceGroupResource. </summary>
    public partial class MockableWorkloadOrchestrationResourceGroupResource : ArmResource
    {
        /// <summary> Initializes a new instance of the <see cref="MockableWorkloadOrchestrationResourceGroupResource"/> class for mocking. </summary>
        protected MockableWorkloadOrchestrationResourceGroupResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="MockableWorkloadOrchestrationResourceGroupResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal MockableWorkloadOrchestrationResourceGroupResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
        }

        private string GetApiVersionOrNull(ResourceType resourceType)
        {
            TryGetApiVersion(resourceType, out string apiVersion);
            return apiVersion;
        }

        /// <summary> Gets a collection of EdgeConfigTemplateResources in the ResourceGroupResource. </summary>
        /// <returns> An object representing collection of EdgeConfigTemplateResources and their operations over a EdgeConfigTemplateResource. </returns>
        public virtual EdgeConfigTemplateCollection GetEdgeConfigTemplates()
        {
            return GetCachedClient(client => new EdgeConfigTemplateCollection(client, Id));
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeConfigTemplateResource>> GetEdgeConfigTemplateAsync(string configTemplateName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeConfigTemplates().GetAsync(configTemplateName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeConfigTemplateResource> GetEdgeConfigTemplate(string configTemplateName, CancellationToken cancellationToken = default)
        {
            return GetEdgeConfigTemplates().Get(configTemplateName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeContextResources in the ResourceGroupResource. </summary>
        /// <returns> An object representing collection of EdgeContextResources and their operations over a EdgeContextResource. </returns>
        public virtual EdgeContextCollection GetEdgeContexts()
        {
            return GetCachedClient(client => new EdgeContextCollection(client, Id));
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeContextResource>> GetEdgeContextAsync(string contextName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeContexts().GetAsync(contextName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeContextResource> GetEdgeContext(string contextName, CancellationToken cancellationToken = default)
        {
            return GetEdgeContexts().Get(contextName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeDiagnosticResources in the ResourceGroupResource. </summary>
        /// <returns> An object representing collection of EdgeDiagnosticResources and their operations over a EdgeDiagnosticResource. </returns>
        public virtual EdgeDiagnosticCollection GetEdgeDiagnostics()
        {
            return GetCachedClient(client => new EdgeDiagnosticCollection(client, Id));
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeDiagnosticResource>> GetEdgeDiagnosticAsync(string diagnosticName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeDiagnostics().GetAsync(diagnosticName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeDiagnosticResource> GetEdgeDiagnostic(string diagnosticName, CancellationToken cancellationToken = default)
        {
            return GetEdgeDiagnostics().Get(diagnosticName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeSchemaResources in the ResourceGroupResource. </summary>
        /// <returns> An object representing collection of EdgeSchemaResources and their operations over a EdgeSchemaResource. </returns>
        public virtual EdgeSchemaCollection GetEdgeSchemas()
        {
            return GetCachedClient(client => new EdgeSchemaCollection(client, Id));
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSchemaResource>> GetEdgeSchemaAsync(string schemaName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeSchemas().GetAsync(schemaName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSchemaResource> GetEdgeSchema(string schemaName, CancellationToken cancellationToken = default)
        {
            return GetEdgeSchemas().Get(schemaName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeSolutionTemplateResources in the ResourceGroupResource. </summary>
        /// <returns> An object representing collection of EdgeSolutionTemplateResources and their operations over a EdgeSolutionTemplateResource. </returns>
        public virtual EdgeSolutionTemplateCollection GetEdgeSolutionTemplates()
        {
            return GetCachedClient(client => new EdgeSolutionTemplateCollection(client, Id));
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeSolutionTemplateResource>> GetEdgeSolutionTemplateAsync(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeSolutionTemplates().GetAsync(solutionTemplateName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeSolutionTemplateResource> GetEdgeSolutionTemplate(string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            return GetEdgeSolutionTemplates().Get(solutionTemplateName, cancellationToken);
        }

        /// <summary> Gets a collection of EdgeTargetResources in the ResourceGroupResource. </summary>
        /// <returns> An object representing collection of EdgeTargetResources and their operations over a EdgeTargetResource. </returns>
        public virtual EdgeTargetCollection GetEdgeTargets()
        {
            return GetCachedClient(client => new EdgeTargetCollection(client, Id));
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual async Task<Response<EdgeTargetResource>> GetEdgeTargetAsync(string targetName, CancellationToken cancellationToken = default)
        {
            return await GetEdgeTargets().GetAsync(targetName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public virtual Response<EdgeTargetResource> GetEdgeTarget(string targetName, CancellationToken cancellationToken = default)
        {
            return GetEdgeTargets().Get(targetName, cancellationToken);
        }
    }
}



================================================
FILE: Generated/Extensions/MockableWorkloadOrchestrationSubscriptionResource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Threading;
using Autorest.CSharp.Core;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration.Mocking
{
    /// <summary> A class to add extension methods to SubscriptionResource. </summary>
    public partial class MockableWorkloadOrchestrationSubscriptionResource : ArmResource
    {
        private ClientDiagnostics _edgeConfigTemplateConfigTemplatesClientDiagnostics;
        private ConfigTemplatesRestOperations _edgeConfigTemplateConfigTemplatesRestClient;
        private ClientDiagnostics _edgeContextContextsClientDiagnostics;
        private ContextsRestOperations _edgeContextContextsRestClient;
        private ClientDiagnostics _edgeDiagnosticDiagnosticsClientDiagnostics;
        private DiagnosticsRestOperations _edgeDiagnosticDiagnosticsRestClient;
        private ClientDiagnostics _edgeSchemaSchemasClientDiagnostics;
        private SchemasRestOperations _edgeSchemaSchemasRestClient;
        private ClientDiagnostics _edgeSolutionTemplateSolutionTemplatesClientDiagnostics;
        private SolutionTemplatesRestOperations _edgeSolutionTemplateSolutionTemplatesRestClient;
        private ClientDiagnostics _edgeTargetTargetsClientDiagnostics;
        private TargetsRestOperations _edgeTargetTargetsRestClient;

        /// <summary> Initializes a new instance of the <see cref="MockableWorkloadOrchestrationSubscriptionResource"/> class for mocking. </summary>
        protected MockableWorkloadOrchestrationSubscriptionResource()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="MockableWorkloadOrchestrationSubscriptionResource"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal MockableWorkloadOrchestrationSubscriptionResource(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
        }

        private ClientDiagnostics EdgeConfigTemplateConfigTemplatesClientDiagnostics => _edgeConfigTemplateConfigTemplatesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeConfigTemplateResource.ResourceType.Namespace, Diagnostics);
        private ConfigTemplatesRestOperations EdgeConfigTemplateConfigTemplatesRestClient => _edgeConfigTemplateConfigTemplatesRestClient ??= new ConfigTemplatesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, GetApiVersionOrNull(EdgeConfigTemplateResource.ResourceType));
        private ClientDiagnostics EdgeContextContextsClientDiagnostics => _edgeContextContextsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeContextResource.ResourceType.Namespace, Diagnostics);
        private ContextsRestOperations EdgeContextContextsRestClient => _edgeContextContextsRestClient ??= new ContextsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, GetApiVersionOrNull(EdgeContextResource.ResourceType));
        private ClientDiagnostics EdgeDiagnosticDiagnosticsClientDiagnostics => _edgeDiagnosticDiagnosticsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeDiagnosticResource.ResourceType.Namespace, Diagnostics);
        private DiagnosticsRestOperations EdgeDiagnosticDiagnosticsRestClient => _edgeDiagnosticDiagnosticsRestClient ??= new DiagnosticsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, GetApiVersionOrNull(EdgeDiagnosticResource.ResourceType));
        private ClientDiagnostics EdgeSchemaSchemasClientDiagnostics => _edgeSchemaSchemasClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSchemaResource.ResourceType.Namespace, Diagnostics);
        private SchemasRestOperations EdgeSchemaSchemasRestClient => _edgeSchemaSchemasRestClient ??= new SchemasRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, GetApiVersionOrNull(EdgeSchemaResource.ResourceType));
        private ClientDiagnostics EdgeSolutionTemplateSolutionTemplatesClientDiagnostics => _edgeSolutionTemplateSolutionTemplatesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeSolutionTemplateResource.ResourceType.Namespace, Diagnostics);
        private SolutionTemplatesRestOperations EdgeSolutionTemplateSolutionTemplatesRestClient => _edgeSolutionTemplateSolutionTemplatesRestClient ??= new SolutionTemplatesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, GetApiVersionOrNull(EdgeSolutionTemplateResource.ResourceType));
        private ClientDiagnostics EdgeTargetTargetsClientDiagnostics => _edgeTargetTargetsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.WorkloadOrchestration", EdgeTargetResource.ResourceType.Namespace, Diagnostics);
        private TargetsRestOperations EdgeTargetTargetsRestClient => _edgeTargetTargetsRestClient ??= new TargetsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint, GetApiVersionOrNull(EdgeTargetResource.ResourceType));

        private string GetApiVersionOrNull(ResourceType resourceType)
        {
            TryGetApiVersion(resourceType, out string apiVersion);
            return apiVersion;
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/configTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeConfigTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeConfigTemplateResource> GetEdgeConfigTemplatesAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeConfigTemplateConfigTemplatesRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeConfigTemplateConfigTemplatesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeConfigTemplateResource(Client, EdgeConfigTemplateData.DeserializeEdgeConfigTemplateData(e)), EdgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeConfigTemplates", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/configTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeConfigTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeConfigTemplateResource> GetEdgeConfigTemplates(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeConfigTemplateConfigTemplatesRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeConfigTemplateConfigTemplatesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeConfigTemplateResource(Client, EdgeConfigTemplateData.DeserializeEdgeConfigTemplateData(e)), EdgeConfigTemplateConfigTemplatesClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeConfigTemplates", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/contexts</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeContextResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeContextResource> GetEdgeContextsAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeContextContextsRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeContextContextsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeContextResource(Client, EdgeContextData.DeserializeEdgeContextData(e)), EdgeContextContextsClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeContexts", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/contexts</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeContextResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeContextResource> GetEdgeContexts(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeContextContextsRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeContextContextsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeContextResource(Client, EdgeContextData.DeserializeEdgeContextData(e)), EdgeContextContextsClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeContexts", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Lists Diagnostics resources within an Azure subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/diagnostics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeDiagnosticResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeDiagnosticResource> GetEdgeDiagnosticsAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeDiagnosticDiagnosticsRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeDiagnosticDiagnosticsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeDiagnosticResource(Client, EdgeDiagnosticData.DeserializeEdgeDiagnosticData(e)), EdgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeDiagnostics", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Lists Diagnostics resources within an Azure subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/diagnostics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeDiagnosticResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeDiagnosticResource> GetEdgeDiagnostics(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeDiagnosticDiagnosticsRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeDiagnosticDiagnosticsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeDiagnosticResource(Client, EdgeDiagnosticData.DeserializeEdgeDiagnosticData(e)), EdgeDiagnosticDiagnosticsClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeDiagnostics", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/schemas</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSchemaResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSchemaResource> GetEdgeSchemasAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeSchemaSchemasRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeSchemaSchemasRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSchemaResource(Client, EdgeSchemaData.DeserializeEdgeSchemaData(e)), EdgeSchemaSchemasClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeSchemas", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/schemas</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSchemaResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSchemaResource> GetEdgeSchemas(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeSchemaSchemasRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeSchemaSchemasRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSchemaResource(Client, EdgeSchemaData.DeserializeEdgeSchemaData(e)), EdgeSchemaSchemasClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeSchemas", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/solutionTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeSolutionTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeSolutionTemplateResource> GetEdgeSolutionTemplatesAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeSolutionTemplateSolutionTemplatesRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeSolutionTemplateSolutionTemplatesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionTemplateResource(Client, EdgeSolutionTemplateData.DeserializeEdgeSolutionTemplateData(e)), EdgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeSolutionTemplates", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/solutionTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeSolutionTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeSolutionTemplateResource> GetEdgeSolutionTemplates(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeSolutionTemplateSolutionTemplatesRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeSolutionTemplateSolutionTemplatesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeSolutionTemplateResource(Client, EdgeSolutionTemplateData.DeserializeEdgeSolutionTemplateData(e)), EdgeSolutionTemplateSolutionTemplatesClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeSolutionTemplates", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/targets</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="EdgeTargetResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<EdgeTargetResource> GetEdgeTargetsAsync(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeTargetTargetsRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeTargetTargetsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => new EdgeTargetResource(Client, EdgeTargetData.DeserializeEdgeTargetData(e)), EdgeTargetTargetsClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeTargets", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/targets</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="EdgeTargetResource"/> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<EdgeTargetResource> GetEdgeTargets(CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => EdgeTargetTargetsRestClient.CreateListBySubscriptionRequest(Id.SubscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => EdgeTargetTargetsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, Id.SubscriptionId);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => new EdgeTargetResource(Client, EdgeTargetData.DeserializeEdgeTargetData(e)), EdgeTargetTargetsClientDiagnostics, Pipeline, "MockableWorkloadOrchestrationSubscriptionResource.GetEdgeTargets", "value", "nextLink", cancellationToken);
        }
    }
}



================================================
FILE: Generated/Extensions/WorkloadOrchestrationExtensions.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.ResourceManager.Resources;
using Azure.ResourceManager.WorkloadOrchestration.Mocking;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary> A class to add extension methods to Azure.ResourceManager.WorkloadOrchestration. </summary>
    public static partial class WorkloadOrchestrationExtensions
    {
        private static MockableWorkloadOrchestrationArmClient GetMockableWorkloadOrchestrationArmClient(ArmClient client)
        {
            return client.GetCachedClient(client0 => new MockableWorkloadOrchestrationArmClient(client0));
        }

        private static MockableWorkloadOrchestrationResourceGroupResource GetMockableWorkloadOrchestrationResourceGroupResource(ArmResource resource)
        {
            return resource.GetCachedClient(client => new MockableWorkloadOrchestrationResourceGroupResource(client, resource.Id));
        }

        private static MockableWorkloadOrchestrationSubscriptionResource GetMockableWorkloadOrchestrationSubscriptionResource(ArmResource resource)
        {
            return resource.GetCachedClient(client => new MockableWorkloadOrchestrationSubscriptionResource(client, resource.Id));
        }

        /// <summary>
        /// Gets a collection of EdgeJobResources in the ArmClient.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeJobs(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> An object representing collection of EdgeJobResources and their operations over a EdgeJobResource. </returns>
        public static EdgeJobCollection GetEdgeJobs(this ArmClient client, ResourceIdentifier scope)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeJobs(scope);
        }

        /// <summary>
        /// Get a Job resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeJobAsync(ResourceIdentifier,string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> or <paramref name="jobName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static async Task<Response<EdgeJobResource>> GetEdgeJobAsync(this ArmClient client, ResourceIdentifier scope, string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(client, nameof(client));

            return await GetMockableWorkloadOrchestrationArmClient(client).GetEdgeJobAsync(scope, jobName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Job resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/jobs/{jobName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Jobs_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeJobResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeJob(ResourceIdentifier,string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> or <paramref name="jobName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static Response<EdgeJobResource> GetEdgeJob(this ArmClient client, ResourceIdentifier scope, string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeJob(scope, jobName, cancellationToken);
        }

        /// <summary>
        /// Gets a collection of EdgeSchemaReferenceResources in the ArmClient.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSchemaReferences(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> An object representing collection of EdgeSchemaReferenceResources and their operations over a EdgeSchemaReferenceResource. </returns>
        public static EdgeSchemaReferenceCollection GetEdgeSchemaReferences(this ArmClient client, ResourceIdentifier scope)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSchemaReferences(scope);
        }

        /// <summary>
        /// Get a Schema Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSchemaReferenceAsync(ResourceIdentifier,string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> or <paramref name="schemaReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static async Task<Response<EdgeSchemaReferenceResource>> GetEdgeSchemaReferenceAsync(this ArmClient client, ResourceIdentifier scope, string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(client, nameof(client));

            return await GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSchemaReferenceAsync(scope, schemaReferenceName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Schema Reference Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/{resourceUri}/providers/Microsoft.Edge/schemaReferences/{schemaReferenceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SchemaReferences_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaReferenceResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSchemaReference(ResourceIdentifier,string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="scope"> The scope that the resource will apply against. </param>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> or <paramref name="schemaReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static Response<EdgeSchemaReferenceResource> GetEdgeSchemaReference(this ArmClient client, ResourceIdentifier scope, string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSchemaReference(scope, schemaReferenceName, cancellationToken);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeJobResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeJobResource.CreateResourceIdentifier" /> to create an <see cref="EdgeJobResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeJobResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeJobResource"/> object. </returns>
        public static EdgeJobResource GetEdgeJobResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeJobResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSchemaReferenceResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSchemaReferenceResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSchemaReferenceResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSchemaReferenceResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeSchemaReferenceResource"/> object. </returns>
        public static EdgeSchemaReferenceResource GetEdgeSchemaReferenceResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSchemaReferenceResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeConfigTemplateResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeConfigTemplateResource.CreateResourceIdentifier" /> to create an <see cref="EdgeConfigTemplateResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeConfigTemplateResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeConfigTemplateResource"/> object. </returns>
        public static EdgeConfigTemplateResource GetEdgeConfigTemplateResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeConfigTemplateResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeContextResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeContextResource.CreateResourceIdentifier" /> to create an <see cref="EdgeContextResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeContextResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeContextResource"/> object. </returns>
        public static EdgeContextResource GetEdgeContextResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeContextResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDiagnosticResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDiagnosticResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDiagnosticResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeDiagnosticResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeDiagnosticResource"/> object. </returns>
        public static EdgeDiagnosticResource GetEdgeDiagnosticResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeDiagnosticResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSchemaResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSchemaResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSchemaResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSchemaResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeSchemaResource"/> object. </returns>
        public static EdgeSchemaResource GetEdgeSchemaResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSchemaResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSolutionTemplateResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSolutionTemplateResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSolutionTemplateResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSolutionTemplateResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeSolutionTemplateResource"/> object. </returns>
        public static EdgeSolutionTemplateResource GetEdgeSolutionTemplateResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSolutionTemplateResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeTargetResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeTargetResource.CreateResourceIdentifier" /> to create an <see cref="EdgeTargetResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeTargetResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeTargetResource"/> object. </returns>
        public static EdgeTargetResource GetEdgeTargetResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeTargetResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeConfigTemplateVersionResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeConfigTemplateVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeConfigTemplateVersionResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeConfigTemplateVersionResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeConfigTemplateVersionResource"/> object. </returns>
        public static EdgeConfigTemplateVersionResource GetEdgeConfigTemplateVersionResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeConfigTemplateVersionResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSiteReferenceResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSiteReferenceResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSiteReferenceResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSiteReferenceResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeSiteReferenceResource"/> object. </returns>
        public static EdgeSiteReferenceResource GetEdgeSiteReferenceResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSiteReferenceResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeWorkflowResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeWorkflowResource.CreateResourceIdentifier" /> to create an <see cref="EdgeWorkflowResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeWorkflowResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeWorkflowResource"/> object. </returns>
        public static EdgeWorkflowResource GetEdgeWorkflowResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeWorkflowResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeWorkflowVersionResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeWorkflowVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeWorkflowVersionResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeWorkflowVersionResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeWorkflowVersionResource"/> object. </returns>
        public static EdgeWorkflowVersionResource GetEdgeWorkflowVersionResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeWorkflowVersionResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeExecutionResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeExecutionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeExecutionResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeExecutionResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeExecutionResource"/> object. </returns>
        public static EdgeExecutionResource GetEdgeExecutionResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeExecutionResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDynamicSchemaResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDynamicSchemaResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDynamicSchemaResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeDynamicSchemaResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeDynamicSchemaResource"/> object. </returns>
        public static EdgeDynamicSchemaResource GetEdgeDynamicSchemaResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeDynamicSchemaResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDynamicSchemaVersionResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDynamicSchemaVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDynamicSchemaVersionResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeDynamicSchemaVersionResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeDynamicSchemaVersionResource"/> object. </returns>
        public static EdgeDynamicSchemaVersionResource GetEdgeDynamicSchemaVersionResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeDynamicSchemaVersionResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSchemaVersionResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSchemaVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSchemaVersionResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSchemaVersionResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeSchemaVersionResource"/> object. </returns>
        public static EdgeSchemaVersionResource GetEdgeSchemaVersionResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSchemaVersionResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSolutionTemplateVersionResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSolutionTemplateVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSolutionTemplateVersionResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSolutionTemplateVersionResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeSolutionTemplateVersionResource"/> object. </returns>
        public static EdgeSolutionTemplateVersionResource GetEdgeSolutionTemplateVersionResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSolutionTemplateVersionResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSolutionResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSolutionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSolutionResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSolutionResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeSolutionResource"/> object. </returns>
        public static EdgeSolutionResource GetEdgeSolutionResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSolutionResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDeploymentInstanceResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDeploymentInstanceResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDeploymentInstanceResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeDeploymentInstanceResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeDeploymentInstanceResource"/> object. </returns>
        public static EdgeDeploymentInstanceResource GetEdgeDeploymentInstanceResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeDeploymentInstanceResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeDeploymentInstanceHistoryResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeDeploymentInstanceHistoryResource.CreateResourceIdentifier" /> to create an <see cref="EdgeDeploymentInstanceHistoryResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeDeploymentInstanceHistoryResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeDeploymentInstanceHistoryResource"/> object. </returns>
        public static EdgeDeploymentInstanceHistoryResource GetEdgeDeploymentInstanceHistoryResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeDeploymentInstanceHistoryResource(id);
        }

        /// <summary>
        /// Gets an object representing an <see cref="EdgeSolutionVersionResource" /> along with the instance operations that can be performed on it but with no data.
        /// You can use <see cref="EdgeSolutionVersionResource.CreateResourceIdentifier" /> to create an <see cref="EdgeSolutionVersionResource" /> <see cref="ResourceIdentifier" /> from its components.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationArmClient.GetEdgeSolutionVersionResource(ResourceIdentifier)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="client"> The <see cref="ArmClient" /> instance the method will execute against. </param>
        /// <param name="id"> The resource ID of the resource to get. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="client"/> is null. </exception>
        /// <returns> Returns a <see cref="EdgeSolutionVersionResource"/> object. </returns>
        public static EdgeSolutionVersionResource GetEdgeSolutionVersionResource(this ArmClient client, ResourceIdentifier id)
        {
            Argument.AssertNotNull(client, nameof(client));

            return GetMockableWorkloadOrchestrationArmClient(client).GetEdgeSolutionVersionResource(id);
        }

        /// <summary>
        /// Gets a collection of EdgeConfigTemplateResources in the ResourceGroupResource.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeConfigTemplates()"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> is null. </exception>
        /// <returns> An object representing collection of EdgeConfigTemplateResources and their operations over a EdgeConfigTemplateResource. </returns>
        public static EdgeConfigTemplateCollection GetEdgeConfigTemplates(this ResourceGroupResource resourceGroupResource)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeConfigTemplates();
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeConfigTemplateAsync(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static async Task<Response<EdgeConfigTemplateResource>> GetEdgeConfigTemplateAsync(this ResourceGroupResource resourceGroupResource, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return await GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeConfigTemplateAsync(configTemplateName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Config Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/configTemplates/{configTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeConfigTemplate(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static Response<EdgeConfigTemplateResource> GetEdgeConfigTemplate(this ResourceGroupResource resourceGroupResource, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeConfigTemplate(configTemplateName, cancellationToken);
        }

        /// <summary>
        /// Gets a collection of EdgeContextResources in the ResourceGroupResource.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeContexts()"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> is null. </exception>
        /// <returns> An object representing collection of EdgeContextResources and their operations over a EdgeContextResource. </returns>
        public static EdgeContextCollection GetEdgeContexts(this ResourceGroupResource resourceGroupResource)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeContexts();
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeContextAsync(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static async Task<Response<EdgeContextResource>> GetEdgeContextAsync(this ResourceGroupResource resourceGroupResource, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return await GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeContextAsync(contextName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get Context Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/contexts/{contextName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeContext(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static Response<EdgeContextResource> GetEdgeContext(this ResourceGroupResource resourceGroupResource, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeContext(contextName, cancellationToken);
        }

        /// <summary>
        /// Gets a collection of EdgeDiagnosticResources in the ResourceGroupResource.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeDiagnostics()"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> is null. </exception>
        /// <returns> An object representing collection of EdgeDiagnosticResources and their operations over a EdgeDiagnosticResource. </returns>
        public static EdgeDiagnosticCollection GetEdgeDiagnostics(this ResourceGroupResource resourceGroupResource)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeDiagnostics();
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeDiagnosticAsync(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static async Task<Response<EdgeDiagnosticResource>> GetEdgeDiagnosticAsync(this ResourceGroupResource resourceGroupResource, string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return await GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeDiagnosticAsync(diagnosticName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Returns details of specified Diagnostic resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/diagnostics/{diagnosticName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeDiagnostic(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static Response<EdgeDiagnosticResource> GetEdgeDiagnostic(this ResourceGroupResource resourceGroupResource, string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeDiagnostic(diagnosticName, cancellationToken);
        }

        /// <summary>
        /// Gets a collection of EdgeSchemaResources in the ResourceGroupResource.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeSchemas()"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> is null. </exception>
        /// <returns> An object representing collection of EdgeSchemaResources and their operations over a EdgeSchemaResource. </returns>
        public static EdgeSchemaCollection GetEdgeSchemas(this ResourceGroupResource resourceGroupResource)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeSchemas();
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeSchemaAsync(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static async Task<Response<EdgeSchemaResource>> GetEdgeSchemaAsync(this ResourceGroupResource resourceGroupResource, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return await GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeSchemaAsync(schemaName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Schema Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/schemas/{schemaName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeSchema(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static Response<EdgeSchemaResource> GetEdgeSchema(this ResourceGroupResource resourceGroupResource, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeSchema(schemaName, cancellationToken);
        }

        /// <summary>
        /// Gets a collection of EdgeSolutionTemplateResources in the ResourceGroupResource.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeSolutionTemplates()"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> is null. </exception>
        /// <returns> An object representing collection of EdgeSolutionTemplateResources and their operations over a EdgeSolutionTemplateResource. </returns>
        public static EdgeSolutionTemplateCollection GetEdgeSolutionTemplates(this ResourceGroupResource resourceGroupResource)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeSolutionTemplates();
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeSolutionTemplateAsync(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static async Task<Response<EdgeSolutionTemplateResource>> GetEdgeSolutionTemplateAsync(this ResourceGroupResource resourceGroupResource, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return await GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeSolutionTemplateAsync(solutionTemplateName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Solution Template Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/solutionTemplates/{solutionTemplateName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeSolutionTemplate(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static Response<EdgeSolutionTemplateResource> GetEdgeSolutionTemplate(this ResourceGroupResource resourceGroupResource, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeSolutionTemplate(solutionTemplateName, cancellationToken);
        }

        /// <summary>
        /// Gets a collection of EdgeTargetResources in the ResourceGroupResource.
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeTargets()"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> is null. </exception>
        /// <returns> An object representing collection of EdgeTargetResources and their operations over a EdgeTargetResource. </returns>
        public static EdgeTargetCollection GetEdgeTargets(this ResourceGroupResource resourceGroupResource)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeTargets();
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeTargetAsync(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static async Task<Response<EdgeTargetResource>> GetEdgeTargetAsync(this ResourceGroupResource resourceGroupResource, string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return await GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeTargetAsync(targetName, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Get a Target Resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Edge/targets/{targetName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_Get</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationResourceGroupResource.GetEdgeTarget(string,CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="resourceGroupResource"> The <see cref="ResourceGroupResource" /> instance the method will execute against. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupResource"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        [ForwardsClientCalls]
        public static Response<EdgeTargetResource> GetEdgeTarget(this ResourceGroupResource resourceGroupResource, string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceGroupResource, nameof(resourceGroupResource));

            return GetMockableWorkloadOrchestrationResourceGroupResource(resourceGroupResource).GetEdgeTarget(targetName, cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/configTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeConfigTemplates(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> An async collection of <see cref="EdgeConfigTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public static AsyncPageable<EdgeConfigTemplateResource> GetEdgeConfigTemplatesAsync(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeConfigTemplatesAsync(cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/configTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ConfigTemplates_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeConfigTemplateResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeConfigTemplates(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> A collection of <see cref="EdgeConfigTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public static Pageable<EdgeConfigTemplateResource> GetEdgeConfigTemplates(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeConfigTemplates(cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/contexts</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeContexts(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> An async collection of <see cref="EdgeContextResource"/> that may take multiple service requests to iterate over. </returns>
        public static AsyncPageable<EdgeContextResource> GetEdgeContextsAsync(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeContextsAsync(cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/contexts</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Contexts_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeContextResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeContexts(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> A collection of <see cref="EdgeContextResource"/> that may take multiple service requests to iterate over. </returns>
        public static Pageable<EdgeContextResource> GetEdgeContexts(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeContexts(cancellationToken);
        }

        /// <summary>
        /// Lists Diagnostics resources within an Azure subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/diagnostics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeDiagnostics(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> An async collection of <see cref="EdgeDiagnosticResource"/> that may take multiple service requests to iterate over. </returns>
        public static AsyncPageable<EdgeDiagnosticResource> GetEdgeDiagnosticsAsync(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeDiagnosticsAsync(cancellationToken);
        }

        /// <summary>
        /// Lists Diagnostics resources within an Azure subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/diagnostics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Diagnostics_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeDiagnosticResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeDiagnostics(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> A collection of <see cref="EdgeDiagnosticResource"/> that may take multiple service requests to iterate over. </returns>
        public static Pageable<EdgeDiagnosticResource> GetEdgeDiagnostics(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeDiagnostics(cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/schemas</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeSchemas(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> An async collection of <see cref="EdgeSchemaResource"/> that may take multiple service requests to iterate over. </returns>
        public static AsyncPageable<EdgeSchemaResource> GetEdgeSchemasAsync(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeSchemasAsync(cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/schemas</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Schemas_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSchemaResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeSchemas(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> A collection of <see cref="EdgeSchemaResource"/> that may take multiple service requests to iterate over. </returns>
        public static Pageable<EdgeSchemaResource> GetEdgeSchemas(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeSchemas(cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/solutionTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeSolutionTemplates(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> An async collection of <see cref="EdgeSolutionTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public static AsyncPageable<EdgeSolutionTemplateResource> GetEdgeSolutionTemplatesAsync(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeSolutionTemplatesAsync(cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/solutionTemplates</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>SolutionTemplates_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeSolutionTemplateResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeSolutionTemplates(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> A collection of <see cref="EdgeSolutionTemplateResource"/> that may take multiple service requests to iterate over. </returns>
        public static Pageable<EdgeSolutionTemplateResource> GetEdgeSolutionTemplates(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeSolutionTemplates(cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/targets</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeTargets(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> An async collection of <see cref="EdgeTargetResource"/> that may take multiple service requests to iterate over. </returns>
        public static AsyncPageable<EdgeTargetResource> GetEdgeTargetsAsync(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeTargetsAsync(cancellationToken);
        }

        /// <summary>
        /// List by subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.Edge/targets</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>Targets_ListBySubscription</description>
        /// </item>
        /// <item>
        /// <term>Default Api Version</term>
        /// <description>2025-08-01</description>
        /// </item>
        /// <item>
        /// <term>Resource</term>
        /// <description><see cref="EdgeTargetResource"/></description>
        /// </item>
        /// </list>
        /// <item>
        /// <term>Mocking</term>
        /// <description>To mock this method, please mock <see cref="MockableWorkloadOrchestrationSubscriptionResource.GetEdgeTargets(CancellationToken)"/> instead.</description>
        /// </item>
        /// </summary>
        /// <param name="subscriptionResource"> The <see cref="SubscriptionResource" /> instance the method will execute against. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionResource"/> is null. </exception>
        /// <returns> A collection of <see cref="EdgeTargetResource"/> that may take multiple service requests to iterate over. </returns>
        public static Pageable<EdgeTargetResource> GetEdgeTargets(this SubscriptionResource subscriptionResource, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(subscriptionResource, nameof(subscriptionResource));

            return GetMockableWorkloadOrchestrationSubscriptionResource(subscriptionResource).GetEdgeTargets(cancellationToken);
        }
    }
}



================================================
FILE: Generated/Internal/Argument.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal static class Argument
    {
        public static void AssertNotNull<T>(T value, string name)
        {
            if (value is null)
            {
                throw new ArgumentNullException(name);
            }
        }

        public static void AssertNotNull<T>(T? value, string name)
        where T : struct
        {
            if (!value.HasValue)
            {
                throw new ArgumentNullException(name);
            }
        }

        public static void AssertNotNullOrEmpty<T>(IEnumerable<T> value, string name)
        {
            if (value is null)
            {
                throw new ArgumentNullException(name);
            }
            if (value is ICollection<T> collectionOfT && collectionOfT.Count == 0)
            {
                throw new ArgumentException("Value cannot be an empty collection.", name);
            }
            if (value is ICollection collection && collection.Count == 0)
            {
                throw new ArgumentException("Value cannot be an empty collection.", name);
            }
            using IEnumerator<T> e = value.GetEnumerator();
            if (!e.MoveNext())
            {
                throw new ArgumentException("Value cannot be an empty collection.", name);
            }
        }

        public static void AssertNotNullOrEmpty(string value, string name)
        {
            if (value is null)
            {
                throw new ArgumentNullException(name);
            }
            if (value.Length == 0)
            {
                throw new ArgumentException("Value cannot be an empty string.", name);
            }
        }

        public static void AssertNotNullOrWhiteSpace(string value, string name)
        {
            if (value is null)
            {
                throw new ArgumentNullException(name);
            }
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Value cannot be empty or contain only white-space characters.", name);
            }
        }

        public static void AssertNotDefault<T>(ref T value, string name)
        where T : struct, IEquatable<T>
        {
            if (value.Equals(default))
            {
                throw new ArgumentException("Value cannot be empty.", name);
            }
        }

        public static void AssertInRange<T>(T value, T minimum, T maximum, string name)
        where T : notnull, IComparable<T>
        {
            if (minimum.CompareTo(value) > 0)
            {
                throw new ArgumentOutOfRangeException(name, "Value is less than the minimum allowed.");
            }
            if (maximum.CompareTo(value) < 0)
            {
                throw new ArgumentOutOfRangeException(name, "Value is greater than the maximum allowed.");
            }
        }

        public static void AssertEnumDefined(Type enumType, object value, string name)
        {
            if (!Enum.IsDefined(enumType, value))
            {
                throw new ArgumentException($"Value not defined for {enumType.FullName}.", name);
            }
        }

        public static T CheckNotNull<T>(T value, string name)
        where T : class
        {
            AssertNotNull(value, name);
            return value;
        }

        public static string CheckNotNullOrEmpty(string value, string name)
        {
            AssertNotNullOrEmpty(value, name);
            return value;
        }

        public static void AssertNull<T>(T value, string name, string message = null)
        {
            if (value != null)
            {
                throw new ArgumentException(message ?? "Value must be null.", name);
            }
        }
    }
}



================================================
FILE: Generated/Internal/ChangeTrackingDictionary.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class ChangeTrackingDictionary<TKey, TValue> : IDictionary<TKey, TValue>, IReadOnlyDictionary<TKey, TValue> where TKey : notnull
    {
        private IDictionary<TKey, TValue> _innerDictionary;

        public ChangeTrackingDictionary()
        {
        }

        public ChangeTrackingDictionary(IDictionary<TKey, TValue> dictionary)
        {
            if (dictionary == null)
            {
                return;
            }
            _innerDictionary = new Dictionary<TKey, TValue>(dictionary);
        }

        public ChangeTrackingDictionary(IReadOnlyDictionary<TKey, TValue> dictionary)
        {
            if (dictionary == null)
            {
                return;
            }
            _innerDictionary = new Dictionary<TKey, TValue>();
            foreach (var pair in dictionary)
            {
                _innerDictionary.Add(pair);
            }
        }

        public bool IsUndefined => _innerDictionary == null;

        public int Count => IsUndefined ? 0 : EnsureDictionary().Count;

        public bool IsReadOnly => IsUndefined ? false : EnsureDictionary().IsReadOnly;

        public ICollection<TKey> Keys => IsUndefined ? Array.Empty<TKey>() : EnsureDictionary().Keys;

        public ICollection<TValue> Values => IsUndefined ? Array.Empty<TValue>() : EnsureDictionary().Values;

        public TValue this[TKey key]
        {
            get
            {
                if (IsUndefined)
                {
                    throw new KeyNotFoundException(nameof(key));
                }
                return EnsureDictionary()[key];
            }
            set
            {
                EnsureDictionary()[key] = value;
            }
        }

        IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => Keys;

        IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => Values;

        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
        {
            if (IsUndefined)
            {
                IEnumerator<KeyValuePair<TKey, TValue>> enumerateEmpty()
                {
                    yield break;
                }
                return enumerateEmpty();
            }
            return EnsureDictionary().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public void Add(KeyValuePair<TKey, TValue> item)
        {
            EnsureDictionary().Add(item);
        }

        public void Clear()
        {
            EnsureDictionary().Clear();
        }

        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureDictionary().Contains(item);
        }

        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int index)
        {
            if (IsUndefined)
            {
                return;
            }
            EnsureDictionary().CopyTo(array, index);
        }

        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureDictionary().Remove(item);
        }

        public void Add(TKey key, TValue value)
        {
            EnsureDictionary().Add(key, value);
        }

        public bool ContainsKey(TKey key)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureDictionary().ContainsKey(key);
        }

        public bool Remove(TKey key)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureDictionary().Remove(key);
        }

        public bool TryGetValue(TKey key, out TValue value)
        {
            if (IsUndefined)
            {
                value = default;
                return false;
            }
            return EnsureDictionary().TryGetValue(key, out value);
        }

        public IDictionary<TKey, TValue> EnsureDictionary()
        {
            return _innerDictionary ??= new Dictionary<TKey, TValue>();
        }
    }
}



================================================
FILE: Generated/Internal/ChangeTrackingList.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class ChangeTrackingList<T> : IList<T>, IReadOnlyList<T>
    {
        private IList<T> _innerList;

        public ChangeTrackingList()
        {
        }

        public ChangeTrackingList(IList<T> innerList)
        {
            if (innerList != null)
            {
                _innerList = innerList;
            }
        }

        public ChangeTrackingList(IReadOnlyList<T> innerList)
        {
            if (innerList != null)
            {
                _innerList = innerList.ToList();
            }
        }

        public bool IsUndefined => _innerList == null;

        public int Count => IsUndefined ? 0 : EnsureList().Count;

        public bool IsReadOnly => IsUndefined ? false : EnsureList().IsReadOnly;

        public T this[int index]
        {
            get
            {
                if (IsUndefined)
                {
                    throw new ArgumentOutOfRangeException(nameof(index));
                }
                return EnsureList()[index];
            }
            set
            {
                if (IsUndefined)
                {
                    throw new ArgumentOutOfRangeException(nameof(index));
                }
                EnsureList()[index] = value;
            }
        }

        public void Reset()
        {
            _innerList = null;
        }

        public IEnumerator<T> GetEnumerator()
        {
            if (IsUndefined)
            {
                IEnumerator<T> enumerateEmpty()
                {
                    yield break;
                }
                return enumerateEmpty();
            }
            return EnsureList().GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public void Add(T item)
        {
            EnsureList().Add(item);
        }

        public void Clear()
        {
            EnsureList().Clear();
        }

        public bool Contains(T item)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureList().Contains(item);
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            if (IsUndefined)
            {
                return;
            }
            EnsureList().CopyTo(array, arrayIndex);
        }

        public bool Remove(T item)
        {
            if (IsUndefined)
            {
                return false;
            }
            return EnsureList().Remove(item);
        }

        public int IndexOf(T item)
        {
            if (IsUndefined)
            {
                return -1;
            }
            return EnsureList().IndexOf(item);
        }

        public void Insert(int index, T item)
        {
            EnsureList().Insert(index, item);
        }

        public void RemoveAt(int index)
        {
            if (IsUndefined)
            {
                throw new ArgumentOutOfRangeException(nameof(index));
            }
            EnsureList().RemoveAt(index);
        }

        public IList<T> EnsureList()
        {
            return _innerList ??= new List<T>();
        }
    }
}



================================================
FILE: Generated/Internal/ModelSerializationExtensions.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Text.Json;
using System.Xml;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal static class ModelSerializationExtensions
    {
        internal static readonly JsonDocumentOptions JsonDocumentOptions = new JsonDocumentOptions { MaxDepth = 256 };
        internal static readonly ModelReaderWriterOptions WireOptions = new ModelReaderWriterOptions("W");
        internal static readonly ModelReaderWriterOptions WireV3Options = new ModelReaderWriterOptions("W|v3");
        internal static readonly ModelReaderWriterOptions JsonV3Options = new ModelReaderWriterOptions("J|v3");
        internal static readonly BinaryData SentinelValue = BinaryData.FromBytes("\"__EMPTY__\""u8.ToArray());

        public static object GetObject(this JsonElement element)
        {
            switch (element.ValueKind)
            {
                case JsonValueKind.String:
                    return element.GetString();
                case JsonValueKind.Number:
                    if (element.TryGetInt32(out int intValue))
                    {
                        return intValue;
                    }
                    if (element.TryGetInt64(out long longValue))
                    {
                        return longValue;
                    }
                    return element.GetDouble();
                case JsonValueKind.True:
                    return true;
                case JsonValueKind.False:
                    return false;
                case JsonValueKind.Undefined:
                case JsonValueKind.Null:
                    return null;
                case JsonValueKind.Object:
                    var dictionary = new Dictionary<string, object>();
                    foreach (var jsonProperty in element.EnumerateObject())
                    {
                        dictionary.Add(jsonProperty.Name, jsonProperty.Value.GetObject());
                    }
                    return dictionary;
                case JsonValueKind.Array:
                    var list = new List<object>();
                    foreach (var item in element.EnumerateArray())
                    {
                        list.Add(item.GetObject());
                    }
                    return list.ToArray();
                default:
                    throw new NotSupportedException($"Not supported value kind {element.ValueKind}");
            }
        }

        public static byte[] GetBytesFromBase64(this JsonElement element, string format)
        {
            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }

            return format switch
            {
                "U" => TypeFormatters.FromBase64UrlString(element.GetRequiredString()),
                "D" => element.GetBytesFromBase64(),
                _ => throw new ArgumentException($"Format is not supported: '{format}'", nameof(format))
            };
        }

        public static DateTimeOffset GetDateTimeOffset(this JsonElement element, string format) => format switch
        {
            "U" when element.ValueKind == JsonValueKind.Number => DateTimeOffset.FromUnixTimeSeconds(element.GetInt64()),
            _ => TypeFormatters.ParseDateTimeOffset(element.GetString(), format)
        };

        public static TimeSpan GetTimeSpan(this JsonElement element, string format) => TypeFormatters.ParseTimeSpan(element.GetString(), format);

        public static char GetChar(this JsonElement element)
        {
            if (element.ValueKind == JsonValueKind.String)
            {
                var text = element.GetString();
                if (text == null || text.Length != 1)
                {
                    throw new NotSupportedException($"Cannot convert \"{text}\" to a char");
                }
                return text[0];
            }
            else
            {
                throw new NotSupportedException($"Cannot convert {element.ValueKind} to a char");
            }
        }

        [Conditional("DEBUG")]
        public static void ThrowNonNullablePropertyIsNull(this JsonProperty property)
        {
            throw new JsonException($"A property '{property.Name}' defined as non-nullable but received as null from the service. This exception only happens in DEBUG builds of the library and would be ignored in the release build");
        }

        public static string GetRequiredString(this JsonElement element)
        {
            var value = element.GetString();
            if (value == null)
            {
                throw new InvalidOperationException($"The requested operation requires an element of type 'String', but the target element has type '{element.ValueKind}'.");
            }
            return value;
        }

        public static void WriteStringValue(this Utf8JsonWriter writer, DateTimeOffset value, string format)
        {
            writer.WriteStringValue(TypeFormatters.ToString(value, format));
        }

        public static void WriteStringValue(this Utf8JsonWriter writer, DateTime value, string format)
        {
            writer.WriteStringValue(TypeFormatters.ToString(value, format));
        }

        public static void WriteStringValue(this Utf8JsonWriter writer, TimeSpan value, string format)
        {
            writer.WriteStringValue(TypeFormatters.ToString(value, format));
        }

        public static void WriteStringValue(this Utf8JsonWriter writer, char value)
        {
            writer.WriteStringValue(value.ToString(CultureInfo.InvariantCulture));
        }

        public static void WriteBase64StringValue(this Utf8JsonWriter writer, byte[] value, string format)
        {
            if (value == null)
            {
                writer.WriteNullValue();
                return;
            }
            switch (format)
            {
                case "U":
                    writer.WriteStringValue(TypeFormatters.ToBase64UrlString(value));
                    break;
                case "D":
                    writer.WriteBase64StringValue(value);
                    break;
                default:
                    throw new ArgumentException($"Format is not supported: '{format}'", nameof(format));
            }
        }

        public static void WriteNumberValue(this Utf8JsonWriter writer, DateTimeOffset value, string format)
        {
            if (format != "U")
            {
                throw new ArgumentOutOfRangeException(nameof(format), "Only 'U' format is supported when writing a DateTimeOffset as a Number.");
            }
            writer.WriteNumberValue(value.ToUnixTimeSeconds());
        }

        public static void WriteObjectValue<T>(this Utf8JsonWriter writer, T value, ModelReaderWriterOptions options = null)
        {
            switch (value)
            {
                case null:
                    writer.WriteNullValue();
                    break;
                case IJsonModel<T> jsonModel:
                    jsonModel.Write(writer, options ?? WireOptions);
                    break;
                case IUtf8JsonSerializable serializable:
                    serializable.Write(writer);
                    break;
                case byte[] bytes:
                    writer.WriteBase64StringValue(bytes);
                    break;
                case BinaryData bytes0:
                    writer.WriteBase64StringValue(bytes0);
                    break;
                case JsonElement json:
                    json.WriteTo(writer);
                    break;
                case int i:
                    writer.WriteNumberValue(i);
                    break;
                case decimal d:
                    writer.WriteNumberValue(d);
                    break;
                case double d0:
                    if (double.IsNaN(d0))
                    {
                        writer.WriteStringValue("NaN");
                    }
                    else
                    {
                        writer.WriteNumberValue(d0);
                    }
                    break;
                case float f:
                    writer.WriteNumberValue(f);
                    break;
                case long l:
                    writer.WriteNumberValue(l);
                    break;
                case string s:
                    writer.WriteStringValue(s);
                    break;
                case bool b:
                    writer.WriteBooleanValue(b);
                    break;
                case Guid g:
                    writer.WriteStringValue(g);
                    break;
                case DateTimeOffset dateTimeOffset:
                    writer.WriteStringValue(dateTimeOffset, "O");
                    break;
                case DateTime dateTime:
                    writer.WriteStringValue(dateTime, "O");
                    break;
                case IEnumerable<KeyValuePair<string, object>> enumerable:
                    writer.WriteStartObject();
                    foreach (var pair in enumerable)
                    {
                        writer.WritePropertyName(pair.Key);
                        writer.WriteObjectValue<object>(pair.Value, options);
                    }
                    writer.WriteEndObject();
                    break;
                case IEnumerable<object> objectEnumerable:
                    writer.WriteStartArray();
                    foreach (var item in objectEnumerable)
                    {
                        writer.WriteObjectValue<object>(item, options);
                    }
                    writer.WriteEndArray();
                    break;
                case TimeSpan timeSpan:
                    writer.WriteStringValue(timeSpan, "P");
                    break;
                default:
                    throw new NotSupportedException($"Not supported type {value.GetType()}");
            }
        }

        public static void WriteObjectValue(this Utf8JsonWriter writer, object value, ModelReaderWriterOptions options = null)
        {
            writer.WriteObjectValue<object>(value, options);
        }

        internal static bool IsSentinelValue(BinaryData value)
        {
            ReadOnlySpan<byte> sentinelSpan = SentinelValue.ToMemory().Span;
            ReadOnlySpan<byte> valueSpan = value.ToMemory().Span;
            return sentinelSpan.SequenceEqual(valueSpan);
        }

        internal static class TypeFormatters
        {
            private const string RoundtripZFormat = "yyyy-MM-ddTHH:mm:ss.fffffffZ";
            public const string DefaultNumberFormat = "G";

            public static string ToString(bool value) => value ? "true" : "false";

            public static string ToString(DateTime value, string format) => value.Kind switch
            {
                DateTimeKind.Utc => ToString((DateTimeOffset)value, format),
                _ => throw new NotSupportedException($"DateTime {value} has a Kind of {value.Kind}. Azure SDK requires it to be UTC. You can call DateTime.SpecifyKind to change Kind property value to DateTimeKind.Utc.")
            };

            public static string ToString(DateTimeOffset value, string format) => format switch
            {
                "D" => value.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture),
                "U" => value.ToUnixTimeSeconds().ToString(CultureInfo.InvariantCulture),
                "O" => value.ToUniversalTime().ToString(RoundtripZFormat, CultureInfo.InvariantCulture),
                "o" => value.ToUniversalTime().ToString(RoundtripZFormat, CultureInfo.InvariantCulture),
                "R" => value.ToString("r", CultureInfo.InvariantCulture),
                _ => value.ToString(format, CultureInfo.InvariantCulture)
            };

            public static string ToString(TimeSpan value, string format) => format switch
            {
                "P" => XmlConvert.ToString(value),
                _ => value.ToString(format, CultureInfo.InvariantCulture)
            };

            public static string ToString(byte[] value, string format) => format switch
            {
                "U" => ToBase64UrlString(value),
                "D" => Convert.ToBase64String(value),
                _ => throw new ArgumentException($"Format is not supported: '{format}'", nameof(format))
            };

            public static string ToBase64UrlString(byte[] value)
            {
                int numWholeOrPartialInputBlocks = checked(value.Length + 2) / 3;
                int size = checked(numWholeOrPartialInputBlocks * 4);
                char[] output = new char[size];

                int numBase64Chars = Convert.ToBase64CharArray(value, 0, value.Length, output, 0);

                int i = 0;
                for (; i < numBase64Chars; i++)
                {
                    char ch = output[i];
                    if (ch == '+')
                    {
                        output[i] = '-';
                    }
                    else
                    {
                        if (ch == '/')
                        {
                            output[i] = '_';
                        }
                        else
                        {
                            if (ch == '=')
                            {
                                break;
                            }
                        }
                    }
                }

                return new string(output, 0, i);
            }

            public static byte[] FromBase64UrlString(string value)
            {
                int paddingCharsToAdd = (value.Length % 4) switch
                {
                    0 => 0,
                    2 => 2,
                    3 => 1,
                    _ => throw new InvalidOperationException("Malformed input")
                };
                char[] output = new char[(value.Length + paddingCharsToAdd)];
                int i = 0;
                for (; i < value.Length; i++)
                {
                    char ch = value[i];
                    if (ch == '-')
                    {
                        output[i] = '+';
                    }
                    else
                    {
                        if (ch == '_')
                        {
                            output[i] = '/';
                        }
                        else
                        {
                            output[i] = ch;
                        }
                    }
                }

                for (; i < output.Length; i++)
                {
                    output[i] = '=';
                }

                return Convert.FromBase64CharArray(output, 0, output.Length);
            }

            public static DateTimeOffset ParseDateTimeOffset(string value, string format) => format switch
            {
                "U" => DateTimeOffset.FromUnixTimeSeconds(long.Parse(value, CultureInfo.InvariantCulture)),
                _ => DateTimeOffset.Parse(value, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal)
            };

            public static TimeSpan ParseTimeSpan(string value, string format) => format switch
            {
                "P" => XmlConvert.ToTimeSpan(value),
                _ => TimeSpan.ParseExact(value, format, CultureInfo.InvariantCulture)
            };

            public static string ConvertToString(object value, string format = null) => value switch
            {
                null => "null",
                string s => s,
                bool b => ToString(b),
                int or float or double or long or decimal => ((IFormattable)value).ToString(DefaultNumberFormat, CultureInfo.InvariantCulture),
                byte[] b0 when format != null => ToString(b0, format),
                IEnumerable<string> s0 => string.Join(",", s0),
                DateTimeOffset dateTime when format != null => ToString(dateTime, format),
                TimeSpan timeSpan when format != null => ToString(timeSpan, format),
                TimeSpan timeSpan0 => XmlConvert.ToString(timeSpan0),
                Guid guid => guid.ToString(),
                BinaryData binaryData => ConvertToString(binaryData.ToArray(), format),
                _ => value.ToString()
            };
        }
    }
}



================================================
FILE: Generated/Internal/Optional.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Collections.Generic;
using System.Text.Json;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal static class Optional
    {
        public static bool IsCollectionDefined<T>(IEnumerable<T> collection)
        {
            return !(collection is ChangeTrackingList<T> changeTrackingList && changeTrackingList.IsUndefined);
        }

        public static bool IsCollectionDefined<TKey, TValue>(IDictionary<TKey, TValue> collection)
        {
            return !(collection is ChangeTrackingDictionary<TKey, TValue> changeTrackingDictionary && changeTrackingDictionary.IsUndefined);
        }

        public static bool IsCollectionDefined<TKey, TValue>(IReadOnlyDictionary<TKey, TValue> collection)
        {
            return !(collection is ChangeTrackingDictionary<TKey, TValue> changeTrackingDictionary && changeTrackingDictionary.IsUndefined);
        }

        public static bool IsDefined<T>(T? value)
        where T : struct
        {
            return value.HasValue;
        }

        public static bool IsDefined(object value)
        {
            return value != null;
        }

        public static bool IsDefined(JsonElement value)
        {
            return value.ValueKind != JsonValueKind.Undefined;
        }

        public static bool IsDefined(string value)
        {
            return value != null;
        }
    }
}



================================================
FILE: Generated/Internal/Utf8JsonRequestContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class Utf8JsonRequestContent : RequestContent
    {
        private readonly MemoryStream _stream;
        private readonly RequestContent _content;

        public Utf8JsonRequestContent()
        {
            _stream = new MemoryStream();
            _content = Create(_stream);
            JsonWriter = new Utf8JsonWriter(_stream);
        }

        public Utf8JsonWriter JsonWriter { get; }

        public override async Task WriteToAsync(Stream stream, CancellationToken cancellationToken = default)
        {
            await JsonWriter.FlushAsync().ConfigureAwait(false);
            await _content.WriteToAsync(stream, cancellationToken).ConfigureAwait(false);
        }

        public override void WriteTo(Stream stream, CancellationToken cancellationToken = default)
        {
            JsonWriter.Flush();
            _content.WriteTo(stream, cancellationToken);
        }

        public override bool TryComputeLength(out long length)
        {
            length = JsonWriter.BytesCommitted + JsonWriter.BytesPending;
            return true;
        }

        public override void Dispose()
        {
            JsonWriter.Dispose();
            _content.Dispose();
            _stream.Dispose();
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeConfigTemplateOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeConfigTemplateOperationSource : IOperationSource<EdgeConfigTemplateResource>
    {
        private readonly ArmClient _client;

        internal EdgeConfigTemplateOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeConfigTemplateResource IOperationSource<EdgeConfigTemplateResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeConfigTemplateData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeConfigTemplateResource(_client, data);
        }

        async ValueTask<EdgeConfigTemplateResource> IOperationSource<EdgeConfigTemplateResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeConfigTemplateData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeConfigTemplateResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeConfigTemplateVersionOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeConfigTemplateVersionOperationSource : IOperationSource<EdgeConfigTemplateVersionResource>
    {
        private readonly ArmClient _client;

        internal EdgeConfigTemplateVersionOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeConfigTemplateVersionResource IOperationSource<EdgeConfigTemplateVersionResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeConfigTemplateVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeConfigTemplateVersionResource(_client, data);
        }

        async ValueTask<EdgeConfigTemplateVersionResource> IOperationSource<EdgeConfigTemplateVersionResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeConfigTemplateVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeConfigTemplateVersionResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeContextOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeContextOperationSource : IOperationSource<EdgeContextResource>
    {
        private readonly ArmClient _client;

        internal EdgeContextOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeContextResource IOperationSource<EdgeContextResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeContextData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeContextResource(_client, data);
        }

        async ValueTask<EdgeContextResource> IOperationSource<EdgeContextResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeContextData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeContextResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeDeploymentInstanceOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeDeploymentInstanceOperationSource : IOperationSource<EdgeDeploymentInstanceResource>
    {
        private readonly ArmClient _client;

        internal EdgeDeploymentInstanceOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeDeploymentInstanceResource IOperationSource<EdgeDeploymentInstanceResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeDeploymentInstanceData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeDeploymentInstanceResource(_client, data);
        }

        async ValueTask<EdgeDeploymentInstanceResource> IOperationSource<EdgeDeploymentInstanceResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeDeploymentInstanceData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeDeploymentInstanceResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeDiagnosticOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeDiagnosticOperationSource : IOperationSource<EdgeDiagnosticResource>
    {
        private readonly ArmClient _client;

        internal EdgeDiagnosticOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeDiagnosticResource IOperationSource<EdgeDiagnosticResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeDiagnosticData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeDiagnosticResource(_client, data);
        }

        async ValueTask<EdgeDiagnosticResource> IOperationSource<EdgeDiagnosticResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeDiagnosticData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeDiagnosticResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeDynamicSchemaOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeDynamicSchemaOperationSource : IOperationSource<EdgeDynamicSchemaResource>
    {
        private readonly ArmClient _client;

        internal EdgeDynamicSchemaOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeDynamicSchemaResource IOperationSource<EdgeDynamicSchemaResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeDynamicSchemaData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeDynamicSchemaResource(_client, data);
        }

        async ValueTask<EdgeDynamicSchemaResource> IOperationSource<EdgeDynamicSchemaResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeDynamicSchemaData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeDynamicSchemaResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeDynamicSchemaVersionOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeDynamicSchemaVersionOperationSource : IOperationSource<EdgeDynamicSchemaVersionResource>
    {
        private readonly ArmClient _client;

        internal EdgeDynamicSchemaVersionOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeDynamicSchemaVersionResource IOperationSource<EdgeDynamicSchemaVersionResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeDynamicSchemaVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeDynamicSchemaVersionResource(_client, data);
        }

        async ValueTask<EdgeDynamicSchemaVersionResource> IOperationSource<EdgeDynamicSchemaVersionResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeDynamicSchemaVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeDynamicSchemaVersionResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeExecutionOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeExecutionOperationSource : IOperationSource<EdgeExecutionResource>
    {
        private readonly ArmClient _client;

        internal EdgeExecutionOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeExecutionResource IOperationSource<EdgeExecutionResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeExecutionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeExecutionResource(_client, data);
        }

        async ValueTask<EdgeExecutionResource> IOperationSource<EdgeExecutionResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeExecutionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeExecutionResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeSchemaOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeSchemaOperationSource : IOperationSource<EdgeSchemaResource>
    {
        private readonly ArmClient _client;

        internal EdgeSchemaOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeSchemaResource IOperationSource<EdgeSchemaResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSchemaData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeSchemaResource(_client, data);
        }

        async ValueTask<EdgeSchemaResource> IOperationSource<EdgeSchemaResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSchemaData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeSchemaResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeSchemaVersionOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeSchemaVersionOperationSource : IOperationSource<EdgeSchemaVersionResource>
    {
        private readonly ArmClient _client;

        internal EdgeSchemaVersionOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeSchemaVersionResource IOperationSource<EdgeSchemaVersionResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSchemaVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeSchemaVersionResource(_client, data);
        }

        async ValueTask<EdgeSchemaVersionResource> IOperationSource<EdgeSchemaVersionResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSchemaVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeSchemaVersionResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeSiteReferenceOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeSiteReferenceOperationSource : IOperationSource<EdgeSiteReferenceResource>
    {
        private readonly ArmClient _client;

        internal EdgeSiteReferenceOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeSiteReferenceResource IOperationSource<EdgeSiteReferenceResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSiteReferenceData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeSiteReferenceResource(_client, data);
        }

        async ValueTask<EdgeSiteReferenceResource> IOperationSource<EdgeSiteReferenceResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSiteReferenceData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeSiteReferenceResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeSolutionOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeSolutionOperationSource : IOperationSource<EdgeSolutionResource>
    {
        private readonly ArmClient _client;

        internal EdgeSolutionOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeSolutionResource IOperationSource<EdgeSolutionResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSolutionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeSolutionResource(_client, data);
        }

        async ValueTask<EdgeSolutionResource> IOperationSource<EdgeSolutionResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSolutionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeSolutionResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeSolutionTemplateOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeSolutionTemplateOperationSource : IOperationSource<EdgeSolutionTemplateResource>
    {
        private readonly ArmClient _client;

        internal EdgeSolutionTemplateOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeSolutionTemplateResource IOperationSource<EdgeSolutionTemplateResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSolutionTemplateData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeSolutionTemplateResource(_client, data);
        }

        async ValueTask<EdgeSolutionTemplateResource> IOperationSource<EdgeSolutionTemplateResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSolutionTemplateData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeSolutionTemplateResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeSolutionTemplateVersionOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeSolutionTemplateVersionOperationSource : IOperationSource<EdgeSolutionTemplateVersionResource>
    {
        private readonly ArmClient _client;

        internal EdgeSolutionTemplateVersionOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeSolutionTemplateVersionResource IOperationSource<EdgeSolutionTemplateVersionResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSolutionTemplateVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeSolutionTemplateVersionResource(_client, data);
        }

        async ValueTask<EdgeSolutionTemplateVersionResource> IOperationSource<EdgeSolutionTemplateVersionResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSolutionTemplateVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeSolutionTemplateVersionResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeSolutionVersionOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeSolutionVersionOperationSource : IOperationSource<EdgeSolutionVersionResource>
    {
        private readonly ArmClient _client;

        internal EdgeSolutionVersionOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeSolutionVersionResource IOperationSource<EdgeSolutionVersionResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSolutionVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeSolutionVersionResource(_client, data);
        }

        async ValueTask<EdgeSolutionVersionResource> IOperationSource<EdgeSolutionVersionResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeSolutionVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeSolutionVersionResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeTargetOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeTargetOperationSource : IOperationSource<EdgeTargetResource>
    {
        private readonly ArmClient _client;

        internal EdgeTargetOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeTargetResource IOperationSource<EdgeTargetResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeTargetData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeTargetResource(_client, data);
        }

        async ValueTask<EdgeTargetResource> IOperationSource<EdgeTargetResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeTargetData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeTargetResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeWorkflowOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeWorkflowOperationSource : IOperationSource<EdgeWorkflowResource>
    {
        private readonly ArmClient _client;

        internal EdgeWorkflowOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeWorkflowResource IOperationSource<EdgeWorkflowResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeWorkflowData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeWorkflowResource(_client, data);
        }

        async ValueTask<EdgeWorkflowResource> IOperationSource<EdgeWorkflowResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeWorkflowData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeWorkflowResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/EdgeWorkflowVersionOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class EdgeWorkflowVersionOperationSource : IOperationSource<EdgeWorkflowVersionResource>
    {
        private readonly ArmClient _client;

        internal EdgeWorkflowVersionOperationSource(ArmClient client)
        {
            _client = client;
        }

        EdgeWorkflowVersionResource IOperationSource<EdgeWorkflowVersionResource>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeWorkflowVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return new EdgeWorkflowVersionResource(_client, data);
        }

        async ValueTask<EdgeWorkflowVersionResource> IOperationSource<EdgeWorkflowVersionResource>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            var data = ModelReaderWriter.Read<EdgeWorkflowVersionData>(response.Content, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            return await Task.FromResult(new EdgeWorkflowVersionResource(_client, data)).ConfigureAwait(false);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/ResolvedConfigurationOperationSource.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal class ResolvedConfigurationOperationSource : IOperationSource<ResolvedConfiguration>
    {
        ResolvedConfiguration IOperationSource<ResolvedConfiguration>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            using var document = JsonDocument.Parse(response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
            return ResolvedConfiguration.DeserializeResolvedConfiguration(document.RootElement);
        }

        async ValueTask<ResolvedConfiguration> IOperationSource<ResolvedConfiguration>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            using var document = await JsonDocument.ParseAsync(response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
            return ResolvedConfiguration.DeserializeResolvedConfiguration(document.RootElement);
        }
    }
}



================================================
FILE: Generated/LongRunningOperation/WorkloadOrchestrationArmOperation.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
#pragma warning disable SA1649 // File name should match first type name
    internal class WorkloadOrchestrationArmOperation : ArmOperation
#pragma warning restore SA1649 // File name should match first type name
    {
        private readonly OperationInternal _operation;
        private readonly RehydrationToken? _completeRehydrationToken;
        private readonly NextLinkOperationImplementation _nextLinkOperation;
        private readonly string _operationId;

        /// <summary> Initializes a new instance of WorkloadOrchestrationArmOperation for mocking. </summary>
        protected WorkloadOrchestrationArmOperation()
        {
        }

        internal WorkloadOrchestrationArmOperation(Response response, RehydrationToken? rehydrationToken = null)
        {
            _operation = OperationInternal.Succeeded(response);
            _completeRehydrationToken = rehydrationToken;
            _operationId = GetOperationId(rehydrationToken);
        }

        internal WorkloadOrchestrationArmOperation(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride = false, string apiVersionOverrideValue = null)
        {
            var nextLinkOperation = NextLinkOperationImplementation.Create(pipeline, request.Method, request.Uri.ToUri(), response, finalStateVia, skipApiVersionOverride, apiVersionOverrideValue);
            if (nextLinkOperation is NextLinkOperationImplementation nextLinkOperationValue)
            {
                _nextLinkOperation = nextLinkOperationValue;
                _operationId = _nextLinkOperation.OperationId;
            }
            else
            {
                _completeRehydrationToken = NextLinkOperationImplementation.GetRehydrationToken(request.Method, request.Uri.ToUri(), response, finalStateVia);
                _operationId = GetOperationId(_completeRehydrationToken);
            }
            _operation = new OperationInternal(nextLinkOperation, clientDiagnostics, response, "WorkloadOrchestrationArmOperation", fallbackStrategy: new SequentialDelayStrategy());
        }

        private string GetOperationId(RehydrationToken? rehydrationToken)
        {
            if (rehydrationToken is null)
            {
                return null;
            }
            var data = ModelReaderWriter.Write(rehydrationToken, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            using var document = JsonDocument.Parse(data);
            var lroDetails = document.RootElement;
            return lroDetails.GetProperty("id").GetString();
        }
        /// <inheritdoc />
        public override string Id => _operationId ?? NextLinkOperationImplementation.NotSet;

        /// <inheritdoc />
        public override RehydrationToken? GetRehydrationToken() => _nextLinkOperation?.GetRehydrationToken() ?? _completeRehydrationToken;

        /// <inheritdoc />
        public override bool HasCompleted => _operation.HasCompleted;

        /// <inheritdoc />
        public override Response GetRawResponse() => _operation.RawResponse;

        /// <inheritdoc />
        public override Response UpdateStatus(CancellationToken cancellationToken = default) => _operation.UpdateStatus(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default) => _operation.UpdateStatusAsync(cancellationToken);

        /// <inheritdoc />
        public override Response WaitForCompletionResponse(CancellationToken cancellationToken = default) => _operation.WaitForCompletionResponse(cancellationToken);

        /// <inheritdoc />
        public override Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken = default) => _operation.WaitForCompletionResponse(pollingInterval, cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken = default) => _operation.WaitForCompletionResponseAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default) => _operation.WaitForCompletionResponseAsync(pollingInterval, cancellationToken);
    }
}



================================================
FILE: Generated/LongRunningOperation/WorkloadOrchestrationArmOperationOfT.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.ResourceManager.WorkloadOrchestration
{
#pragma warning disable SA1649 // File name should match first type name
    internal class WorkloadOrchestrationArmOperation<T> : ArmOperation<T>
#pragma warning restore SA1649 // File name should match first type name
    {
        private readonly OperationInternal<T> _operation;
        private readonly RehydrationToken? _completeRehydrationToken;
        private readonly NextLinkOperationImplementation _nextLinkOperation;
        private readonly string _operationId;

        /// <summary> Initializes a new instance of WorkloadOrchestrationArmOperation for mocking. </summary>
        protected WorkloadOrchestrationArmOperation()
        {
        }

        internal WorkloadOrchestrationArmOperation(Response<T> response, RehydrationToken? rehydrationToken = null)
        {
            _operation = OperationInternal<T>.Succeeded(response.GetRawResponse(), response.Value);
            _completeRehydrationToken = rehydrationToken;
            _operationId = GetOperationId(rehydrationToken);
        }

        internal WorkloadOrchestrationArmOperation(IOperationSource<T> source, ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, OperationFinalStateVia finalStateVia, bool skipApiVersionOverride = false, string apiVersionOverrideValue = null)
        {
            var nextLinkOperation = NextLinkOperationImplementation.Create(pipeline, request.Method, request.Uri.ToUri(), response, finalStateVia, skipApiVersionOverride, apiVersionOverrideValue);
            if (nextLinkOperation is NextLinkOperationImplementation nextLinkOperationValue)
            {
                _nextLinkOperation = nextLinkOperationValue;
                _operationId = _nextLinkOperation.OperationId;
            }
            else
            {
                _completeRehydrationToken = NextLinkOperationImplementation.GetRehydrationToken(request.Method, request.Uri.ToUri(), response, finalStateVia);
                _operationId = GetOperationId(_completeRehydrationToken);
            }
            _operation = new OperationInternal<T>(NextLinkOperationImplementation.Create(source, nextLinkOperation), clientDiagnostics, response, "WorkloadOrchestrationArmOperation", fallbackStrategy: new SequentialDelayStrategy());
        }

        private string GetOperationId(RehydrationToken? rehydrationToken)
        {
            if (rehydrationToken is null)
            {
                return null;
            }
            var data = ModelReaderWriter.Write(rehydrationToken, ModelReaderWriterOptions.Json, AzureResourceManagerWorkloadOrchestrationContext.Default);
            using var document = JsonDocument.Parse(data);
            var lroDetails = document.RootElement;
            return lroDetails.GetProperty("id").GetString();
        }
        /// <inheritdoc />
        public override string Id => _operationId ?? NextLinkOperationImplementation.NotSet;

        /// <inheritdoc />
        public override RehydrationToken? GetRehydrationToken() => _nextLinkOperation?.GetRehydrationToken() ?? _completeRehydrationToken;

        /// <inheritdoc />
        public override T Value => _operation.Value;

        /// <inheritdoc />
        public override bool HasValue => _operation.HasValue;

        /// <inheritdoc />
        public override bool HasCompleted => _operation.HasCompleted;

        /// <inheritdoc />
        public override Response GetRawResponse() => _operation.RawResponse;

        /// <inheritdoc />
        public override Response UpdateStatus(CancellationToken cancellationToken = default) => _operation.UpdateStatus(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default) => _operation.UpdateStatusAsync(cancellationToken);

        /// <inheritdoc />
        public override Response<T> WaitForCompletion(CancellationToken cancellationToken = default) => _operation.WaitForCompletion(cancellationToken);

        /// <inheritdoc />
        public override Response<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken = default) => _operation.WaitForCompletion(pollingInterval, cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<T>> WaitForCompletionAsync(CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(pollingInterval, cancellationToken);
    }
}



================================================
FILE: Generated/Models/ActiveState.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Instance State. </summary>
    public readonly partial struct ActiveState : IEquatable<ActiveState>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="ActiveState"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public ActiveState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string ActiveValue = "active";
        private const string InactiveValue = "inactive";

        /// <summary> Instance is active. </summary>
        public static ActiveState Active { get; } = new ActiveState(ActiveValue);
        /// <summary> Instance is inactive. </summary>
        public static ActiveState Inactive { get; } = new ActiveState(InactiveValue);
        /// <summary> Determines if two <see cref="ActiveState"/> values are the same. </summary>
        public static bool operator ==(ActiveState left, ActiveState right) => left.Equals(right);
        /// <summary> Determines if two <see cref="ActiveState"/> values are not the same. </summary>
        public static bool operator !=(ActiveState left, ActiveState right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="ActiveState"/>. </summary>
        public static implicit operator ActiveState(string value) => new ActiveState(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is ActiveState other && Equals(other);
        /// <inheritdoc />
        public bool Equals(ActiveState other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/AvailableSolutionTemplateVersion.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Available Solution template Version along with latest revision. </summary>
    public partial class AvailableSolutionTemplateVersion
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="AvailableSolutionTemplateVersion"/>. </summary>
        /// <param name="solutionTemplateVersion"> Solution template Version. </param>
        /// <param name="latestConfigRevision"> Latest Configuration Revision. </param>
        /// <param name="isConfigured"> Has this solution template version been configured. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersion"/> or <paramref name="latestConfigRevision"/> is null. </exception>
        internal AvailableSolutionTemplateVersion(string solutionTemplateVersion, string latestConfigRevision, bool isConfigured)
        {
            Argument.AssertNotNull(solutionTemplateVersion, nameof(solutionTemplateVersion));
            Argument.AssertNotNull(latestConfigRevision, nameof(latestConfigRevision));

            SolutionTemplateVersion = solutionTemplateVersion;
            LatestConfigRevision = latestConfigRevision;
            IsConfigured = isConfigured;
        }

        /// <summary> Initializes a new instance of <see cref="AvailableSolutionTemplateVersion"/>. </summary>
        /// <param name="solutionTemplateVersion"> Solution template Version. </param>
        /// <param name="latestConfigRevision"> Latest Configuration Revision. </param>
        /// <param name="isConfigured"> Has this solution template version been configured. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal AvailableSolutionTemplateVersion(string solutionTemplateVersion, string latestConfigRevision, bool isConfigured, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionTemplateVersion = solutionTemplateVersion;
            LatestConfigRevision = latestConfigRevision;
            IsConfigured = isConfigured;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="AvailableSolutionTemplateVersion"/> for deserialization. </summary>
        internal AvailableSolutionTemplateVersion()
        {
        }

        /// <summary> Solution template Version. </summary>
        public string SolutionTemplateVersion { get; }
        /// <summary> Latest Configuration Revision. </summary>
        public string LatestConfigRevision { get; }
        /// <summary> Has this solution template version been configured. </summary>
        public bool IsConfigured { get; }
    }
}



================================================
FILE: Generated/Models/AvailableSolutionTemplateVersion.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class AvailableSolutionTemplateVersion : IUtf8JsonSerializable, IJsonModel<AvailableSolutionTemplateVersion>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<AvailableSolutionTemplateVersion>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<AvailableSolutionTemplateVersion>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<AvailableSolutionTemplateVersion>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(AvailableSolutionTemplateVersion)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionTemplateVersion"u8);
            writer.WriteStringValue(SolutionTemplateVersion);
            writer.WritePropertyName("latestConfigRevision"u8);
            writer.WriteStringValue(LatestConfigRevision);
            writer.WritePropertyName("isConfigured"u8);
            writer.WriteBooleanValue(IsConfigured);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        AvailableSolutionTemplateVersion IJsonModel<AvailableSolutionTemplateVersion>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<AvailableSolutionTemplateVersion>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(AvailableSolutionTemplateVersion)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeAvailableSolutionTemplateVersion(document.RootElement, options);
        }

        internal static AvailableSolutionTemplateVersion DeserializeAvailableSolutionTemplateVersion(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionTemplateVersion = default;
            string latestConfigRevision = default;
            bool isConfigured = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionTemplateVersion"u8))
                {
                    solutionTemplateVersion = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("latestConfigRevision"u8))
                {
                    latestConfigRevision = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("isConfigured"u8))
                {
                    isConfigured = property.Value.GetBoolean();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new AvailableSolutionTemplateVersion(solutionTemplateVersion, latestConfigRevision, isConfigured, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<AvailableSolutionTemplateVersion>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<AvailableSolutionTemplateVersion>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(AvailableSolutionTemplateVersion)} does not support writing '{options.Format}' format.");
            }
        }

        AvailableSolutionTemplateVersion IPersistableModel<AvailableSolutionTemplateVersion>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<AvailableSolutionTemplateVersion>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeAvailableSolutionTemplateVersion(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(AvailableSolutionTemplateVersion)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<AvailableSolutionTemplateVersion>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/AzureResourceManagerCommonTypesExtendedLocation.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The complex type of the extended location. </summary>
    public partial class AzureResourceManagerCommonTypesExtendedLocation
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="AzureResourceManagerCommonTypesExtendedLocation"/>. </summary>
        /// <param name="name"> The name of the extended location. </param>
        /// <param name="extendedLocationType"> The type of the extended location. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        public AzureResourceManagerCommonTypesExtendedLocation(string name, ExtendedLocationType extendedLocationType)
        {
            Argument.AssertNotNull(name, nameof(name));

            Name = name;
            ExtendedLocationType = extendedLocationType;
        }

        /// <summary> Initializes a new instance of <see cref="AzureResourceManagerCommonTypesExtendedLocation"/>. </summary>
        /// <param name="name"> The name of the extended location. </param>
        /// <param name="extendedLocationType"> The type of the extended location. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal AzureResourceManagerCommonTypesExtendedLocation(string name, ExtendedLocationType extendedLocationType, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Name = name;
            ExtendedLocationType = extendedLocationType;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="AzureResourceManagerCommonTypesExtendedLocation"/> for deserialization. </summary>
        internal AzureResourceManagerCommonTypesExtendedLocation()
        {
        }

        /// <summary> The name of the extended location. </summary>
        public string Name { get; set; }
        /// <summary> The type of the extended location. </summary>
        public ExtendedLocationType ExtendedLocationType { get; set; }
    }
}



================================================
FILE: Generated/Models/AzureResourceManagerCommonTypesExtendedLocation.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class AzureResourceManagerCommonTypesExtendedLocation : IUtf8JsonSerializable, IJsonModel<AzureResourceManagerCommonTypesExtendedLocation>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<AzureResourceManagerCommonTypesExtendedLocation>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<AzureResourceManagerCommonTypesExtendedLocation>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<AzureResourceManagerCommonTypesExtendedLocation>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(AzureResourceManagerCommonTypesExtendedLocation)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("name"u8);
            writer.WriteStringValue(Name);
            writer.WritePropertyName("type"u8);
            writer.WriteStringValue(ExtendedLocationType.ToString());
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        AzureResourceManagerCommonTypesExtendedLocation IJsonModel<AzureResourceManagerCommonTypesExtendedLocation>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<AzureResourceManagerCommonTypesExtendedLocation>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(AzureResourceManagerCommonTypesExtendedLocation)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeAzureResourceManagerCommonTypesExtendedLocation(document.RootElement, options);
        }

        internal static AzureResourceManagerCommonTypesExtendedLocation DeserializeAzureResourceManagerCommonTypesExtendedLocation(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string name = default;
            ExtendedLocationType type = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ExtendedLocationType(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new AzureResourceManagerCommonTypesExtendedLocation(name, type, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<AzureResourceManagerCommonTypesExtendedLocation>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<AzureResourceManagerCommonTypesExtendedLocation>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(AzureResourceManagerCommonTypesExtendedLocation)} does not support writing '{options.Format}' format.");
            }
        }

        AzureResourceManagerCommonTypesExtendedLocation IPersistableModel<AzureResourceManagerCommonTypesExtendedLocation>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<AzureResourceManagerCommonTypesExtendedLocation>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeAzureResourceManagerCommonTypesExtendedLocation(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(AzureResourceManagerCommonTypesExtendedLocation)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<AzureResourceManagerCommonTypesExtendedLocation>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/AzureResourceManagerWorkloadOrchestrationContext.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System.ClientModel.Primitives;
using Azure.ResourceManager.Models;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    /// <summary>
    /// Context class which will be filled in by the System.ClientModel.SourceGeneration.
    /// For more information see 'https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/System.ClientModel/src/docs/ModelReaderWriterContext.md'
    /// </summary>
    [ModelReaderWriterBuildable(typeof(AvailableSolutionTemplateVersion))]
    [ModelReaderWriterBuildable(typeof(AzureResourceManagerCommonTypesExtendedLocation))]
    [ModelReaderWriterBuildable(typeof(BulkDeployTargetDetails))]
    [ModelReaderWriterBuildable(typeof(BulkPublishTargetDetails))]
    [ModelReaderWriterBuildable(typeof(BulkReviewTargetDetails))]
    [ModelReaderWriterBuildable(typeof(Capability))]
    [ModelReaderWriterBuildable(typeof(ComponentStatus))]
    [ModelReaderWriterBuildable(typeof(ConfigTemplateListResult))]
    [ModelReaderWriterBuildable(typeof(ConfigTemplateProperties))]
    [ModelReaderWriterBuildable(typeof(ConfigTemplateUpdateProperties))]
    [ModelReaderWriterBuildable(typeof(ConfigTemplateVersionListResult))]
    [ModelReaderWriterBuildable(typeof(ConfigTemplateVersionProperties))]
    [ModelReaderWriterBuildable(typeof(ConfigTemplateVersionWithUpdateType))]
    [ModelReaderWriterBuildable(typeof(ContextListResult))]
    [ModelReaderWriterBuildable(typeof(ContextProperties))]
    [ModelReaderWriterBuildable(typeof(ContextUpdateProperties))]
    [ModelReaderWriterBuildable(typeof(DeployJobStepStatistics))]
    [ModelReaderWriterBuildable(typeof(DeploymentStatus))]
    [ModelReaderWriterBuildable(typeof(DiagnosticListResult))]
    [ModelReaderWriterBuildable(typeof(DiagnosticProperties))]
    [ModelReaderWriterBuildable(typeof(DynamicSchemaListResult))]
    [ModelReaderWriterBuildable(typeof(DynamicSchemaProperties))]
    [ModelReaderWriterBuildable(typeof(DynamicSchemaVersionListResult))]
    [ModelReaderWriterBuildable(typeof(EdgeConfigTemplateData))]
    [ModelReaderWriterBuildable(typeof(EdgeConfigTemplatePatch))]
    [ModelReaderWriterBuildable(typeof(EdgeConfigTemplateResource))]
    [ModelReaderWriterBuildable(typeof(EdgeConfigTemplateVersionData))]
    [ModelReaderWriterBuildable(typeof(EdgeConfigTemplateVersionResource))]
    [ModelReaderWriterBuildable(typeof(EdgeContextData))]
    [ModelReaderWriterBuildable(typeof(EdgeContextPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeContextResource))]
    [ModelReaderWriterBuildable(typeof(EdgeDeploymentInstanceData))]
    [ModelReaderWriterBuildable(typeof(EdgeDeploymentInstanceHistoryData))]
    [ModelReaderWriterBuildable(typeof(EdgeDeploymentInstanceHistoryResource))]
    [ModelReaderWriterBuildable(typeof(EdgeDeploymentInstancePatch))]
    [ModelReaderWriterBuildable(typeof(EdgeDeploymentInstanceResource))]
    [ModelReaderWriterBuildable(typeof(EdgeDiagnosticData))]
    [ModelReaderWriterBuildable(typeof(EdgeDiagnosticPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeDiagnosticResource))]
    [ModelReaderWriterBuildable(typeof(EdgeDynamicSchemaData))]
    [ModelReaderWriterBuildable(typeof(EdgeDynamicSchemaPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeDynamicSchemaResource))]
    [ModelReaderWriterBuildable(typeof(EdgeDynamicSchemaVersionData))]
    [ModelReaderWriterBuildable(typeof(EdgeDynamicSchemaVersionPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeDynamicSchemaVersionResource))]
    [ModelReaderWriterBuildable(typeof(EdgeExecutionData))]
    [ModelReaderWriterBuildable(typeof(EdgeExecutionPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeExecutionResource))]
    [ModelReaderWriterBuildable(typeof(EdgeJobData))]
    [ModelReaderWriterBuildable(typeof(EdgeJobResource))]
    [ModelReaderWriterBuildable(typeof(EdgeSchemaData))]
    [ModelReaderWriterBuildable(typeof(EdgeSchemaPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeSchemaReferenceData))]
    [ModelReaderWriterBuildable(typeof(EdgeSchemaReferenceResource))]
    [ModelReaderWriterBuildable(typeof(EdgeSchemaResource))]
    [ModelReaderWriterBuildable(typeof(EdgeSchemaVersionData))]
    [ModelReaderWriterBuildable(typeof(EdgeSchemaVersionPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeSchemaVersionResource))]
    [ModelReaderWriterBuildable(typeof(EdgeSiteReferenceData))]
    [ModelReaderWriterBuildable(typeof(EdgeSiteReferencePatch))]
    [ModelReaderWriterBuildable(typeof(EdgeSiteReferenceResource))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionData))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionResource))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionTemplateData))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionTemplatePatch))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionTemplateResource))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionTemplateVersionData))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionTemplateVersionResource))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionVersionData))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionVersionPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeSolutionVersionResource))]
    [ModelReaderWriterBuildable(typeof(EdgeTargetData))]
    [ModelReaderWriterBuildable(typeof(EdgeTargetPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeTargetResource))]
    [ModelReaderWriterBuildable(typeof(EdgeWorkflowData))]
    [ModelReaderWriterBuildable(typeof(EdgeWorkflowPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeWorkflowResource))]
    [ModelReaderWriterBuildable(typeof(EdgeWorkflowVersionData))]
    [ModelReaderWriterBuildable(typeof(EdgeWorkflowVersionPatch))]
    [ModelReaderWriterBuildable(typeof(EdgeWorkflowVersionResource))]
    [ModelReaderWriterBuildable(typeof(ErrorAction))]
    [ModelReaderWriterBuildable(typeof(ExecutionListResult))]
    [ModelReaderWriterBuildable(typeof(ExecutionProperties))]
    [ModelReaderWriterBuildable(typeof(ExecutionPropertiesUpdate))]
    [ModelReaderWriterBuildable(typeof(ExecutionStatus))]
    [ModelReaderWriterBuildable(typeof(Hierarchy))]
    [ModelReaderWriterBuildable(typeof(InstanceHistoryListResult))]
    [ModelReaderWriterBuildable(typeof(InstanceHistoryProperties))]
    [ModelReaderWriterBuildable(typeof(InstanceListResult))]
    [ModelReaderWriterBuildable(typeof(InstanceProperties))]
    [ModelReaderWriterBuildable(typeof(InstancePropertiesUpdate))]
    [ModelReaderWriterBuildable(typeof(JobListResult))]
    [ModelReaderWriterBuildable(typeof(JobParameterBase))]
    [ModelReaderWriterBuildable(typeof(JobProperties))]
    [ModelReaderWriterBuildable(typeof(JobStep))]
    [ModelReaderWriterBuildable(typeof(JobStepStatisticsBase))]
    [ModelReaderWriterBuildable(typeof(PublishJobStepStatistics))]
    [ModelReaderWriterBuildable(typeof(ReconciliationPolicyProperties))]
    [ModelReaderWriterBuildable(typeof(ReconciliationPolicyPropertiesUpdate))]
    [ModelReaderWriterBuildable(typeof(ResolvedConfiguration))]
    [ModelReaderWriterBuildable(typeof(ResponseError))]
    [ModelReaderWriterBuildable(typeof(SchemaListResult))]
    [ModelReaderWriterBuildable(typeof(SchemaProperties))]
    [ModelReaderWriterBuildable(typeof(SchemaReferenceListResult))]
    [ModelReaderWriterBuildable(typeof(SchemaReferenceProperties))]
    [ModelReaderWriterBuildable(typeof(SchemaVersionListResult))]
    [ModelReaderWriterBuildable(typeof(SchemaVersionProperties))]
    [ModelReaderWriterBuildable(typeof(SchemaVersionPropertiesUpdate))]
    [ModelReaderWriterBuildable(typeof(SchemaVersionWithUpdateType))]
    [ModelReaderWriterBuildable(typeof(SiteReferenceListResult))]
    [ModelReaderWriterBuildable(typeof(SiteReferenceProperties))]
    [ModelReaderWriterBuildable(typeof(SiteReferencePropertiesUpdate))]
    [ModelReaderWriterBuildable(typeof(SolutionDependency))]
    [ModelReaderWriterBuildable(typeof(SolutionListResult))]
    [ModelReaderWriterBuildable(typeof(SolutionProperties))]
    [ModelReaderWriterBuildable(typeof(SolutionTemplateListResult))]
    [ModelReaderWriterBuildable(typeof(SolutionTemplateProperties))]
    [ModelReaderWriterBuildable(typeof(SolutionTemplateUpdateProperties))]
    [ModelReaderWriterBuildable(typeof(SolutionTemplateVersionListResult))]
    [ModelReaderWriterBuildable(typeof(SolutionTemplateVersionProperties))]
    [ModelReaderWriterBuildable(typeof(SolutionTemplateVersionWithUpdateType))]
    [ModelReaderWriterBuildable(typeof(SolutionVersionListResult))]
    [ModelReaderWriterBuildable(typeof(SolutionVersionProperties))]
    [ModelReaderWriterBuildable(typeof(SolutionVersionPropertiesUpdate))]
    [ModelReaderWriterBuildable(typeof(SolutionVersionSnapshot))]
    [ModelReaderWriterBuildable(typeof(StageMap))]
    [ModelReaderWriterBuildable(typeof(StageSpec))]
    [ModelReaderWriterBuildable(typeof(StageStatus))]
    [ModelReaderWriterBuildable(typeof(SystemData))]
    [ModelReaderWriterBuildable(typeof(TargetListResult))]
    [ModelReaderWriterBuildable(typeof(TargetProperties))]
    [ModelReaderWriterBuildable(typeof(TargetSnapshot))]
    [ModelReaderWriterBuildable(typeof(TargetStatus))]
    [ModelReaderWriterBuildable(typeof(TargetUpdateProperties))]
    [ModelReaderWriterBuildable(typeof(TaskSpec))]
    [ModelReaderWriterBuildable(typeof(UnknownJobParameterBase))]
    [ModelReaderWriterBuildable(typeof(UnknownJobStepStatisticsBase))]
    [ModelReaderWriterBuildable(typeof(WorkflowListResult))]
    [ModelReaderWriterBuildable(typeof(WorkflowProperties))]
    [ModelReaderWriterBuildable(typeof(WorkflowVersionListResult))]
    [ModelReaderWriterBuildable(typeof(WorkflowVersionProperties))]
    [ModelReaderWriterBuildable(typeof(WorkflowVersionPropertiesUpdate))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationBulkDeploySolutionContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationBulkPublishSolutionContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationBulkReviewSolutionContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationDeployJobContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationInstallSolutionContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationPublishJobContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationRemoveRevisionContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationRemoveVersionResult))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationSolutionDependencyContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationSolutionTemplateContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationSolutionVersionContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationTaskConfig))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationUninstallSolutionContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationUpdateExternalValidationStatusContent))]
    [ModelReaderWriterBuildable(typeof(WorkloadOrchestrationVersionContent))]
    public partial class AzureResourceManagerWorkloadOrchestrationContext : ModelReaderWriterContext
    {
    }
}



================================================
FILE: Generated/Models/BulkDeployTargetDetails.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Bulk deploy target details. </summary>
    public partial class BulkDeployTargetDetails
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="BulkDeployTargetDetails"/>. </summary>
        /// <param name="solutionVersionId"> ArmId of Target Solution Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionId"/> is null. </exception>
        public BulkDeployTargetDetails(ResourceIdentifier solutionVersionId)
        {
            Argument.AssertNotNull(solutionVersionId, nameof(solutionVersionId));

            SolutionVersionId = solutionVersionId;
        }

        /// <summary> Initializes a new instance of <see cref="BulkDeployTargetDetails"/>. </summary>
        /// <param name="solutionVersionId"> ArmId of Target Solution Version. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal BulkDeployTargetDetails(ResourceIdentifier solutionVersionId, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersionId = solutionVersionId;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="BulkDeployTargetDetails"/> for deserialization. </summary>
        internal BulkDeployTargetDetails()
        {
        }

        /// <summary> ArmId of Target Solution Version. </summary>
        public ResourceIdentifier SolutionVersionId { get; }
    }
}



================================================
FILE: Generated/Models/BulkDeployTargetDetails.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class BulkDeployTargetDetails : IUtf8JsonSerializable, IJsonModel<BulkDeployTargetDetails>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<BulkDeployTargetDetails>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<BulkDeployTargetDetails>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkDeployTargetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(BulkDeployTargetDetails)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionVersionId"u8);
            writer.WriteStringValue(SolutionVersionId);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        BulkDeployTargetDetails IJsonModel<BulkDeployTargetDetails>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkDeployTargetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(BulkDeployTargetDetails)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeBulkDeployTargetDetails(document.RootElement, options);
        }

        internal static BulkDeployTargetDetails DeserializeBulkDeployTargetDetails(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ResourceIdentifier solutionVersionId = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersionId"u8))
                {
                    solutionVersionId = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new BulkDeployTargetDetails(solutionVersionId, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<BulkDeployTargetDetails>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkDeployTargetDetails>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(BulkDeployTargetDetails)} does not support writing '{options.Format}' format.");
            }
        }

        BulkDeployTargetDetails IPersistableModel<BulkDeployTargetDetails>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkDeployTargetDetails>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeBulkDeployTargetDetails(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(BulkDeployTargetDetails)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<BulkDeployTargetDetails>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/BulkPublishTargetDetails.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Bulk publish target details. </summary>
    public partial class BulkPublishTargetDetails
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="BulkPublishTargetDetails"/>. </summary>
        /// <param name="targetId"> ArmId of Target. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetId"/> is null. </exception>
        public BulkPublishTargetDetails(ResourceIdentifier targetId)
        {
            Argument.AssertNotNull(targetId, nameof(targetId));

            TargetId = targetId;
        }

        /// <summary> Initializes a new instance of <see cref="BulkPublishTargetDetails"/>. </summary>
        /// <param name="targetId"> ArmId of Target. </param>
        /// <param name="solutionInstanceName"> Name of the solution instance. </param>
        /// <param name="solutionVersionId"> ArmId of Target Solution Version. </param>
        /// <param name="solutionConfiguration"> Configuration of solution. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal BulkPublishTargetDetails(ResourceIdentifier targetId, string solutionInstanceName, ResourceIdentifier solutionVersionId, string solutionConfiguration, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            TargetId = targetId;
            SolutionInstanceName = solutionInstanceName;
            SolutionVersionId = solutionVersionId;
            SolutionConfiguration = solutionConfiguration;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="BulkPublishTargetDetails"/> for deserialization. </summary>
        internal BulkPublishTargetDetails()
        {
        }

        /// <summary> ArmId of Target. </summary>
        public ResourceIdentifier TargetId { get; }
        /// <summary> Name of the solution instance. </summary>
        public string SolutionInstanceName { get; set; }
        /// <summary> ArmId of Target Solution Version. </summary>
        public ResourceIdentifier SolutionVersionId { get; set; }
        /// <summary> Configuration of solution. </summary>
        public string SolutionConfiguration { get; set; }
    }
}



================================================
FILE: Generated/Models/BulkPublishTargetDetails.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class BulkPublishTargetDetails : IUtf8JsonSerializable, IJsonModel<BulkPublishTargetDetails>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<BulkPublishTargetDetails>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<BulkPublishTargetDetails>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkPublishTargetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(BulkPublishTargetDetails)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("targetId"u8);
            writer.WriteStringValue(TargetId);
            if (Optional.IsDefined(SolutionInstanceName))
            {
                writer.WritePropertyName("solutionInstanceName"u8);
                writer.WriteStringValue(SolutionInstanceName);
            }
            if (Optional.IsDefined(SolutionVersionId))
            {
                writer.WritePropertyName("solutionVersionId"u8);
                writer.WriteStringValue(SolutionVersionId);
            }
            if (Optional.IsDefined(SolutionConfiguration))
            {
                writer.WritePropertyName("solutionConfiguration"u8);
                writer.WriteStringValue(SolutionConfiguration);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        BulkPublishTargetDetails IJsonModel<BulkPublishTargetDetails>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkPublishTargetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(BulkPublishTargetDetails)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeBulkPublishTargetDetails(document.RootElement, options);
        }

        internal static BulkPublishTargetDetails DeserializeBulkPublishTargetDetails(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ResourceIdentifier targetId = default;
            string solutionInstanceName = default;
            ResourceIdentifier solutionVersionId = default;
            string solutionConfiguration = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("targetId"u8))
                {
                    targetId = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("solutionInstanceName"u8))
                {
                    solutionInstanceName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionVersionId"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    solutionVersionId = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("solutionConfiguration"u8))
                {
                    solutionConfiguration = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new BulkPublishTargetDetails(targetId, solutionInstanceName, solutionVersionId, solutionConfiguration, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<BulkPublishTargetDetails>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkPublishTargetDetails>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(BulkPublishTargetDetails)} does not support writing '{options.Format}' format.");
            }
        }

        BulkPublishTargetDetails IPersistableModel<BulkPublishTargetDetails>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkPublishTargetDetails>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeBulkPublishTargetDetails(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(BulkPublishTargetDetails)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<BulkPublishTargetDetails>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/BulkReviewTargetDetails.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Bulk publish target details. </summary>
    public partial class BulkReviewTargetDetails
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="BulkReviewTargetDetails"/>. </summary>
        /// <param name="targetId"> ArmId of Target. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targetId"/> is null. </exception>
        public BulkReviewTargetDetails(ResourceIdentifier targetId)
        {
            Argument.AssertNotNull(targetId, nameof(targetId));

            TargetId = targetId;
        }

        /// <summary> Initializes a new instance of <see cref="BulkReviewTargetDetails"/>. </summary>
        /// <param name="targetId"> ArmId of Target. </param>
        /// <param name="solutionInstanceName"> Name of the solution instance. </param>
        /// <param name="solutionConfiguration"> Configuration of solution. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal BulkReviewTargetDetails(ResourceIdentifier targetId, string solutionInstanceName, string solutionConfiguration, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            TargetId = targetId;
            SolutionInstanceName = solutionInstanceName;
            SolutionConfiguration = solutionConfiguration;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="BulkReviewTargetDetails"/> for deserialization. </summary>
        internal BulkReviewTargetDetails()
        {
        }

        /// <summary> ArmId of Target. </summary>
        public ResourceIdentifier TargetId { get; }
        /// <summary> Name of the solution instance. </summary>
        public string SolutionInstanceName { get; set; }
        /// <summary> Configuration of solution. </summary>
        public string SolutionConfiguration { get; set; }
    }
}



================================================
FILE: Generated/Models/BulkReviewTargetDetails.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class BulkReviewTargetDetails : IUtf8JsonSerializable, IJsonModel<BulkReviewTargetDetails>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<BulkReviewTargetDetails>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<BulkReviewTargetDetails>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkReviewTargetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(BulkReviewTargetDetails)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("targetId"u8);
            writer.WriteStringValue(TargetId);
            if (Optional.IsDefined(SolutionInstanceName))
            {
                writer.WritePropertyName("solutionInstanceName"u8);
                writer.WriteStringValue(SolutionInstanceName);
            }
            if (Optional.IsDefined(SolutionConfiguration))
            {
                writer.WritePropertyName("solutionConfiguration"u8);
                writer.WriteStringValue(SolutionConfiguration);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        BulkReviewTargetDetails IJsonModel<BulkReviewTargetDetails>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkReviewTargetDetails>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(BulkReviewTargetDetails)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeBulkReviewTargetDetails(document.RootElement, options);
        }

        internal static BulkReviewTargetDetails DeserializeBulkReviewTargetDetails(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ResourceIdentifier targetId = default;
            string solutionInstanceName = default;
            string solutionConfiguration = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("targetId"u8))
                {
                    targetId = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("solutionInstanceName"u8))
                {
                    solutionInstanceName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionConfiguration"u8))
                {
                    solutionConfiguration = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new BulkReviewTargetDetails(targetId, solutionInstanceName, solutionConfiguration, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<BulkReviewTargetDetails>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkReviewTargetDetails>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(BulkReviewTargetDetails)} does not support writing '{options.Format}' format.");
            }
        }

        BulkReviewTargetDetails IPersistableModel<BulkReviewTargetDetails>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<BulkReviewTargetDetails>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeBulkReviewTargetDetails(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(BulkReviewTargetDetails)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<BulkReviewTargetDetails>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/Capability.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Capability, to match in Solution Templates and Targets. </summary>
    public partial class Capability
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="Capability"/>. </summary>
        /// <param name="name"> Name of Capability. </param>
        /// <param name="description"> Description of Capability. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> or <paramref name="description"/> is null. </exception>
        public Capability(string name, string description)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(description, nameof(description));

            Name = name;
            Description = description;
        }

        /// <summary> Initializes a new instance of <see cref="Capability"/>. </summary>
        /// <param name="name"> Name of Capability. </param>
        /// <param name="description"> Description of Capability. </param>
        /// <param name="state"> State of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal Capability(string name, string description, ResourceState? state, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Name = name;
            Description = description;
            State = state;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="Capability"/> for deserialization. </summary>
        internal Capability()
        {
        }

        /// <summary> Name of Capability. </summary>
        public string Name { get; set; }
        /// <summary> Description of Capability. </summary>
        public string Description { get; set; }
        /// <summary> State of resource. </summary>
        public ResourceState? State { get; set; }
    }
}



================================================
FILE: Generated/Models/Capability.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class Capability : IUtf8JsonSerializable, IJsonModel<Capability>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<Capability>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<Capability>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<Capability>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Capability)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("name"u8);
            writer.WriteStringValue(Name);
            writer.WritePropertyName("description"u8);
            writer.WriteStringValue(Description);
            if (Optional.IsDefined(State))
            {
                writer.WritePropertyName("state"u8);
                writer.WriteStringValue(State.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        Capability IJsonModel<Capability>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<Capability>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Capability)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeCapability(document.RootElement, options);
        }

        internal static Capability DeserializeCapability(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string name = default;
            string description = default;
            ResourceState? state = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("description"u8))
                {
                    description = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("state"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    state = new ResourceState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new Capability(name, description, state, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<Capability>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<Capability>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(Capability)} does not support writing '{options.Format}' format.");
            }
        }

        Capability IPersistableModel<Capability>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<Capability>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeCapability(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(Capability)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<Capability>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/CMStage.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Stages for Solution Version. </summary>
    public readonly partial struct CMStage : IEquatable<CMStage>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="CMStage"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public CMStage(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string ConfigurationValue = "Configuration";
        private const string PublishValue = "Publish";
        private const string DeploymentValue = "Deployment";
        private const string UninstallationValue = "Uninstallation";
        private const string ExternalValidationValue = "ExternalValidation";
        private const string StagingValue = "Staging";
        private const string UnstagingValue = "Unstaging";

        /// <summary> Configuration stage. </summary>
        public static CMStage Configuration { get; } = new CMStage(ConfigurationValue);
        /// <summary> Publish stage. </summary>
        public static CMStage Publish { get; } = new CMStage(PublishValue);
        /// <summary> Deployment stage. </summary>
        public static CMStage Deployment { get; } = new CMStage(DeploymentValue);
        /// <summary> Uninstallation stage. </summary>
        public static CMStage Uninstallation { get; } = new CMStage(UninstallationValue);
        /// <summary> External Validation stage. </summary>
        public static CMStage ExternalValidation { get; } = new CMStage(ExternalValidationValue);
        /// <summary> Staging stage. </summary>
        public static CMStage Staging { get; } = new CMStage(StagingValue);
        /// <summary> Unstaging stage. </summary>
        public static CMStage Unstaging { get; } = new CMStage(UnstagingValue);
        /// <summary> Determines if two <see cref="CMStage"/> values are the same. </summary>
        public static bool operator ==(CMStage left, CMStage right) => left.Equals(right);
        /// <summary> Determines if two <see cref="CMStage"/> values are not the same. </summary>
        public static bool operator !=(CMStage left, CMStage right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="CMStage"/>. </summary>
        public static implicit operator CMStage(string value) => new CMStage(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is CMStage other && Equals(other);
        /// <inheritdoc />
        public bool Equals(CMStage other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/ComponentStatus.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Component Status. </summary>
    public partial class ComponentStatus
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ComponentStatus"/>. </summary>
        internal ComponentStatus()
        {
        }

        /// <summary> Initializes a new instance of <see cref="ComponentStatus"/>. </summary>
        /// <param name="name"> Component name. </param>
        /// <param name="status"> Component status. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ComponentStatus(string name, string status, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Name = name;
            Status = status;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Component name. </summary>
        public string Name { get; }
        /// <summary> Component status. </summary>
        public string Status { get; }
    }
}



================================================
FILE: Generated/Models/ComponentStatus.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ComponentStatus : IUtf8JsonSerializable, IJsonModel<ComponentStatus>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ComponentStatus>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ComponentStatus>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ComponentStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ComponentStatus)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Name))
            {
                writer.WritePropertyName("name"u8);
                writer.WriteStringValue(Name);
            }
            if (Optional.IsDefined(Status))
            {
                writer.WritePropertyName("status"u8);
                writer.WriteStringValue(Status);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ComponentStatus IJsonModel<ComponentStatus>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ComponentStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ComponentStatus)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeComponentStatus(document.RootElement, options);
        }

        internal static ComponentStatus DeserializeComponentStatus(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string name = default;
            string status = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    status = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ComponentStatus(name, status, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ComponentStatus>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ComponentStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ComponentStatus)} does not support writing '{options.Format}' format.");
            }
        }

        ComponentStatus IPersistableModel<ComponentStatus>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ComponentStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeComponentStatus(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ComponentStatus)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ComponentStatus>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ConfigTemplateListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a ConfigTemplate list operation. </summary>
    internal partial class ConfigTemplateListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateListResult"/>. </summary>
        /// <param name="value"> The ConfigTemplate items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal ConfigTemplateListResult(IEnumerable<EdgeConfigTemplateData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateListResult"/>. </summary>
        /// <param name="value"> The ConfigTemplate items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ConfigTemplateListResult(IReadOnlyList<EdgeConfigTemplateData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateListResult"/> for deserialization. </summary>
        internal ConfigTemplateListResult()
        {
        }

        /// <summary> The ConfigTemplate items on this page. </summary>
        public IReadOnlyList<EdgeConfigTemplateData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/ConfigTemplateListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class ConfigTemplateListResult : IUtf8JsonSerializable, IJsonModel<ConfigTemplateListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ConfigTemplateListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ConfigTemplateListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ConfigTemplateListResult IJsonModel<ConfigTemplateListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeConfigTemplateListResult(document.RootElement, options);
        }

        internal static ConfigTemplateListResult DeserializeConfigTemplateListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeConfigTemplateData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeConfigTemplateData> array = new List<EdgeConfigTemplateData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeConfigTemplateData.DeserializeEdgeConfigTemplateData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ConfigTemplateListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ConfigTemplateListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateListResult)} does not support writing '{options.Format}' format.");
            }
        }

        ConfigTemplateListResult IPersistableModel<ConfigTemplateListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeConfigTemplateListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ConfigTemplateListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ConfigTemplateProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Config Template Properties. </summary>
    public partial class ConfigTemplateProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateProperties"/>. </summary>
        /// <param name="description"> Description of config template. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="description"/> is null. </exception>
        public ConfigTemplateProperties(string description)
        {
            Argument.AssertNotNull(description, nameof(description));

            Description = description;
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateProperties"/>. </summary>
        /// <param name="description"> Description of config template. </param>
        /// <param name="latestVersion"> Latest config template version. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ConfigTemplateProperties(string description, string latestVersion, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Description = description;
            LatestVersion = latestVersion;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateProperties"/> for deserialization. </summary>
        internal ConfigTemplateProperties()
        {
        }

        /// <summary> Description of config template. </summary>
        public string Description { get; set; }
        /// <summary> Latest config template version. </summary>
        public string LatestVersion { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/ConfigTemplateProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ConfigTemplateProperties : IUtf8JsonSerializable, IJsonModel<ConfigTemplateProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ConfigTemplateProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ConfigTemplateProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("description"u8);
            writer.WriteStringValue(Description);
            if (options.Format != "W" && Optional.IsDefined(LatestVersion))
            {
                writer.WritePropertyName("latestVersion"u8);
                writer.WriteStringValue(LatestVersion);
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ConfigTemplateProperties IJsonModel<ConfigTemplateProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeConfigTemplateProperties(document.RootElement, options);
        }

        internal static ConfigTemplateProperties DeserializeConfigTemplateProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string description = default;
            string latestVersion = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("description"u8))
                {
                    description = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("latestVersion"u8))
                {
                    latestVersion = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ConfigTemplateProperties(description, latestVersion, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ConfigTemplateProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateProperties)} does not support writing '{options.Format}' format.");
            }
        }

        ConfigTemplateProperties IPersistableModel<ConfigTemplateProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeConfigTemplateProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ConfigTemplateProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ConfigTemplateUpdateProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The updatable properties of the ConfigTemplate. </summary>
    internal partial class ConfigTemplateUpdateProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateUpdateProperties"/>. </summary>
        public ConfigTemplateUpdateProperties()
        {
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateUpdateProperties"/>. </summary>
        /// <param name="description"> Description of config template. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ConfigTemplateUpdateProperties(string description, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Description = description;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Description of config template. </summary>
        public string Description { get; set; }
    }
}



================================================
FILE: Generated/Models/ConfigTemplateUpdateProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class ConfigTemplateUpdateProperties : IUtf8JsonSerializable, IJsonModel<ConfigTemplateUpdateProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ConfigTemplateUpdateProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ConfigTemplateUpdateProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateUpdateProperties)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Description))
            {
                writer.WritePropertyName("description"u8);
                writer.WriteStringValue(Description);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ConfigTemplateUpdateProperties IJsonModel<ConfigTemplateUpdateProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateUpdateProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeConfigTemplateUpdateProperties(document.RootElement, options);
        }

        internal static ConfigTemplateUpdateProperties DeserializeConfigTemplateUpdateProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string description = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("description"u8))
                {
                    description = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ConfigTemplateUpdateProperties(description, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ConfigTemplateUpdateProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateUpdateProperties)} does not support writing '{options.Format}' format.");
            }
        }

        ConfigTemplateUpdateProperties IPersistableModel<ConfigTemplateUpdateProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeConfigTemplateUpdateProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateUpdateProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ConfigTemplateUpdateProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ConfigTemplateVersionListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a ConfigTemplateVersion list operation. </summary>
    internal partial class ConfigTemplateVersionListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateVersionListResult"/>. </summary>
        /// <param name="value"> The ConfigTemplateVersion items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal ConfigTemplateVersionListResult(IEnumerable<EdgeConfigTemplateVersionData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateVersionListResult"/>. </summary>
        /// <param name="value"> The ConfigTemplateVersion items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ConfigTemplateVersionListResult(IReadOnlyList<EdgeConfigTemplateVersionData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateVersionListResult"/> for deserialization. </summary>
        internal ConfigTemplateVersionListResult()
        {
        }

        /// <summary> The ConfigTemplateVersion items on this page. </summary>
        public IReadOnlyList<EdgeConfigTemplateVersionData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/ConfigTemplateVersionListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class ConfigTemplateVersionListResult : IUtf8JsonSerializable, IJsonModel<ConfigTemplateVersionListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ConfigTemplateVersionListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ConfigTemplateVersionListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateVersionListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ConfigTemplateVersionListResult IJsonModel<ConfigTemplateVersionListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateVersionListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeConfigTemplateVersionListResult(document.RootElement, options);
        }

        internal static ConfigTemplateVersionListResult DeserializeConfigTemplateVersionListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeConfigTemplateVersionData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeConfigTemplateVersionData> array = new List<EdgeConfigTemplateVersionData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeConfigTemplateVersionData.DeserializeEdgeConfigTemplateVersionData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ConfigTemplateVersionListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ConfigTemplateVersionListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateVersionListResult)} does not support writing '{options.Format}' format.");
            }
        }

        ConfigTemplateVersionListResult IPersistableModel<ConfigTemplateVersionListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeConfigTemplateVersionListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateVersionListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ConfigTemplateVersionListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ConfigTemplateVersionProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Config Template Version Properties. </summary>
    public partial class ConfigTemplateVersionProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateVersionProperties"/>. </summary>
        /// <param name="configurations"> Configuration values. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configurations"/> is null. </exception>
        public ConfigTemplateVersionProperties(string configurations)
        {
            Argument.AssertNotNull(configurations, nameof(configurations));

            Configurations = configurations;
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateVersionProperties"/>. </summary>
        /// <param name="configurations"> Configuration values. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ConfigTemplateVersionProperties(string configurations, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Configurations = configurations;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateVersionProperties"/> for deserialization. </summary>
        internal ConfigTemplateVersionProperties()
        {
        }

        /// <summary> Configuration values. </summary>
        public string Configurations { get; set; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/ConfigTemplateVersionProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ConfigTemplateVersionProperties : IUtf8JsonSerializable, IJsonModel<ConfigTemplateVersionProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ConfigTemplateVersionProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ConfigTemplateVersionProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateVersionProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("configurations"u8);
            writer.WriteStringValue(Configurations);
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ConfigTemplateVersionProperties IJsonModel<ConfigTemplateVersionProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateVersionProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeConfigTemplateVersionProperties(document.RootElement, options);
        }

        internal static ConfigTemplateVersionProperties DeserializeConfigTemplateVersionProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string configurations = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("configurations"u8))
                {
                    configurations = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ConfigTemplateVersionProperties(configurations, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ConfigTemplateVersionProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateVersionProperties)} does not support writing '{options.Format}' format.");
            }
        }

        ConfigTemplateVersionProperties IPersistableModel<ConfigTemplateVersionProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeConfigTemplateVersionProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateVersionProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ConfigTemplateVersionProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ConfigTemplateVersionWithUpdateType.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Config Template Version With Update Type. </summary>
    public partial class ConfigTemplateVersionWithUpdateType
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateVersionWithUpdateType"/>. </summary>
        /// <param name="configTemplateVersion"> Config Template Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configTemplateVersion"/> is null. </exception>
        public ConfigTemplateVersionWithUpdateType(EdgeConfigTemplateVersionData configTemplateVersion)
        {
            Argument.AssertNotNull(configTemplateVersion, nameof(configTemplateVersion));

            ConfigTemplateVersion = configTemplateVersion;
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateVersionWithUpdateType"/>. </summary>
        /// <param name="updateType"> Update type. </param>
        /// <param name="version"> Version to create. </param>
        /// <param name="configTemplateVersion"> Config Template Version. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ConfigTemplateVersionWithUpdateType(UpdateType? updateType, string version, EdgeConfigTemplateVersionData configTemplateVersion, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            UpdateType = updateType;
            Version = version;
            ConfigTemplateVersion = configTemplateVersion;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ConfigTemplateVersionWithUpdateType"/> for deserialization. </summary>
        internal ConfigTemplateVersionWithUpdateType()
        {
        }

        /// <summary> Update type. </summary>
        public UpdateType? UpdateType { get; set; }
        /// <summary> Version to create. </summary>
        public string Version { get; set; }
        /// <summary> Config Template Version. </summary>
        public EdgeConfigTemplateVersionData ConfigTemplateVersion { get; }
    }
}



================================================
FILE: Generated/Models/ConfigTemplateVersionWithUpdateType.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ConfigTemplateVersionWithUpdateType : IUtf8JsonSerializable, IJsonModel<ConfigTemplateVersionWithUpdateType>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ConfigTemplateVersionWithUpdateType>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ConfigTemplateVersionWithUpdateType>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateVersionWithUpdateType)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(UpdateType))
            {
                writer.WritePropertyName("updateType"u8);
                writer.WriteStringValue(UpdateType.Value.ToString());
            }
            if (Optional.IsDefined(Version))
            {
                writer.WritePropertyName("version"u8);
                writer.WriteStringValue(Version);
            }
            writer.WritePropertyName("configTemplateVersion"u8);
            writer.WriteObjectValue(ConfigTemplateVersion, options);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ConfigTemplateVersionWithUpdateType IJsonModel<ConfigTemplateVersionWithUpdateType>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ConfigTemplateVersionWithUpdateType)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeConfigTemplateVersionWithUpdateType(document.RootElement, options);
        }

        internal static ConfigTemplateVersionWithUpdateType DeserializeConfigTemplateVersionWithUpdateType(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            UpdateType? updateType = default;
            string version = default;
            EdgeConfigTemplateVersionData configTemplateVersion = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("updateType"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    updateType = new UpdateType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("version"u8))
                {
                    version = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("configTemplateVersion"u8))
                {
                    configTemplateVersion = EdgeConfigTemplateVersionData.DeserializeEdgeConfigTemplateVersionData(property.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ConfigTemplateVersionWithUpdateType(updateType, version, configTemplateVersion, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ConfigTemplateVersionWithUpdateType>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateVersionWithUpdateType)} does not support writing '{options.Format}' format.");
            }
        }

        ConfigTemplateVersionWithUpdateType IPersistableModel<ConfigTemplateVersionWithUpdateType>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ConfigTemplateVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeConfigTemplateVersionWithUpdateType(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ConfigTemplateVersionWithUpdateType)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ConfigTemplateVersionWithUpdateType>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ConfigurationModel.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Available configuration models. </summary>
    public readonly partial struct ConfigurationModel : IEquatable<ConfigurationModel>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="ConfigurationModel"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public ConfigurationModel(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string ApplicationValue = "Application";
        private const string CommonValue = "Common";

        /// <summary> Configuration model Application. </summary>
        public static ConfigurationModel Application { get; } = new ConfigurationModel(ApplicationValue);
        /// <summary> Configuration model Common. </summary>
        public static ConfigurationModel Common { get; } = new ConfigurationModel(CommonValue);
        /// <summary> Determines if two <see cref="ConfigurationModel"/> values are the same. </summary>
        public static bool operator ==(ConfigurationModel left, ConfigurationModel right) => left.Equals(right);
        /// <summary> Determines if two <see cref="ConfigurationModel"/> values are not the same. </summary>
        public static bool operator !=(ConfigurationModel left, ConfigurationModel right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="ConfigurationModel"/>. </summary>
        public static implicit operator ConfigurationModel(string value) => new ConfigurationModel(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is ConfigurationModel other && Equals(other);
        /// <inheritdoc />
        public bool Equals(ConfigurationModel other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/ConfigurationType.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Available configuration types. </summary>
    public readonly partial struct ConfigurationType : IEquatable<ConfigurationType>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="ConfigurationType"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public ConfigurationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string SharedValue = "Shared";
        private const string HierarchyValue = "Hierarchy";

        /// <summary> Configuration type Shared. </summary>
        public static ConfigurationType Shared { get; } = new ConfigurationType(SharedValue);
        /// <summary> Configuration type Hierarchy. </summary>
        public static ConfigurationType Hierarchy { get; } = new ConfigurationType(HierarchyValue);
        /// <summary> Determines if two <see cref="ConfigurationType"/> values are the same. </summary>
        public static bool operator ==(ConfigurationType left, ConfigurationType right) => left.Equals(right);
        /// <summary> Determines if two <see cref="ConfigurationType"/> values are not the same. </summary>
        public static bool operator !=(ConfigurationType left, ConfigurationType right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="ConfigurationType"/>. </summary>
        public static implicit operator ConfigurationType(string value) => new ConfigurationType(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is ConfigurationType other && Equals(other);
        /// <inheritdoc />
        public bool Equals(ConfigurationType other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/ContextListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a Context list operation. </summary>
    internal partial class ContextListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ContextListResult"/>. </summary>
        /// <param name="value"> The Context items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal ContextListResult(IEnumerable<EdgeContextData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="ContextListResult"/>. </summary>
        /// <param name="value"> The Context items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ContextListResult(IReadOnlyList<EdgeContextData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ContextListResult"/> for deserialization. </summary>
        internal ContextListResult()
        {
        }

        /// <summary> The Context items on this page. </summary>
        public IReadOnlyList<EdgeContextData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/ContextListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class ContextListResult : IUtf8JsonSerializable, IJsonModel<ContextListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ContextListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ContextListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ContextListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ContextListResult IJsonModel<ContextListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ContextListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeContextListResult(document.RootElement, options);
        }

        internal static ContextListResult DeserializeContextListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeContextData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeContextData> array = new List<EdgeContextData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeContextData.DeserializeEdgeContextData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ContextListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ContextListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ContextListResult)} does not support writing '{options.Format}' format.");
            }
        }

        ContextListResult IPersistableModel<ContextListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeContextListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ContextListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ContextListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ContextProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Context Properties. </summary>
    public partial class ContextProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ContextProperties"/>. </summary>
        /// <param name="capabilities"> List of Capabilities. </param>
        /// <param name="hierarchies"> List of Hierarchies. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="capabilities"/> or <paramref name="hierarchies"/> is null. </exception>
        public ContextProperties(IEnumerable<Capability> capabilities, IEnumerable<Hierarchy> hierarchies)
        {
            Argument.AssertNotNull(capabilities, nameof(capabilities));
            Argument.AssertNotNull(hierarchies, nameof(hierarchies));

            Capabilities = capabilities.ToList();
            Hierarchies = hierarchies.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="ContextProperties"/>. </summary>
        /// <param name="capabilities"> List of Capabilities. </param>
        /// <param name="hierarchies"> List of Hierarchies. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ContextProperties(IList<Capability> capabilities, IList<Hierarchy> hierarchies, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Capabilities = capabilities;
            Hierarchies = hierarchies;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ContextProperties"/> for deserialization. </summary>
        internal ContextProperties()
        {
        }

        /// <summary> List of Capabilities. </summary>
        public IList<Capability> Capabilities { get; }
        /// <summary> List of Hierarchies. </summary>
        public IList<Hierarchy> Hierarchies { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/ContextProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ContextProperties : IUtf8JsonSerializable, IJsonModel<ContextProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ContextProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ContextProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ContextProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("capabilities"u8);
            writer.WriteStartArray();
            foreach (var item in Capabilities)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            writer.WritePropertyName("hierarchies"u8);
            writer.WriteStartArray();
            foreach (var item in Hierarchies)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ContextProperties IJsonModel<ContextProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ContextProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeContextProperties(document.RootElement, options);
        }

        internal static ContextProperties DeserializeContextProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IList<Capability> capabilities = default;
            IList<Hierarchy> hierarchies = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("capabilities"u8))
                {
                    List<Capability> array = new List<Capability>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(Capability.DeserializeCapability(item, options));
                    }
                    capabilities = array;
                    continue;
                }
                if (property.NameEquals("hierarchies"u8))
                {
                    List<Hierarchy> array = new List<Hierarchy>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(Hierarchy.DeserializeHierarchy(item, options));
                    }
                    hierarchies = array;
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ContextProperties(capabilities, hierarchies, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ContextProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ContextProperties)} does not support writing '{options.Format}' format.");
            }
        }

        ContextProperties IPersistableModel<ContextProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeContextProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ContextProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ContextProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ContextUpdateProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The updatable properties of the Context. </summary>
    public partial class ContextUpdateProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ContextUpdateProperties"/>. </summary>
        public ContextUpdateProperties()
        {
            Capabilities = new ChangeTrackingList<Capability>();
            Hierarchies = new ChangeTrackingList<Hierarchy>();
        }

        /// <summary> Initializes a new instance of <see cref="ContextUpdateProperties"/>. </summary>
        /// <param name="capabilities"> List of Capabilities. </param>
        /// <param name="hierarchies"> List of Hierarchies. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ContextUpdateProperties(IList<Capability> capabilities, IList<Hierarchy> hierarchies, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Capabilities = capabilities;
            Hierarchies = hierarchies;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> List of Capabilities. </summary>
        public IList<Capability> Capabilities { get; }
        /// <summary> List of Hierarchies. </summary>
        public IList<Hierarchy> Hierarchies { get; }
    }
}



================================================
FILE: Generated/Models/ContextUpdateProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ContextUpdateProperties : IUtf8JsonSerializable, IJsonModel<ContextUpdateProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ContextUpdateProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ContextUpdateProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ContextUpdateProperties)} does not support writing '{format}' format.");
            }

            if (Optional.IsCollectionDefined(Capabilities))
            {
                writer.WritePropertyName("capabilities"u8);
                writer.WriteStartArray();
                foreach (var item in Capabilities)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (Optional.IsCollectionDefined(Hierarchies))
            {
                writer.WritePropertyName("hierarchies"u8);
                writer.WriteStartArray();
                foreach (var item in Hierarchies)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ContextUpdateProperties IJsonModel<ContextUpdateProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ContextUpdateProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeContextUpdateProperties(document.RootElement, options);
        }

        internal static ContextUpdateProperties DeserializeContextUpdateProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IList<Capability> capabilities = default;
            IList<Hierarchy> hierarchies = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("capabilities"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<Capability> array = new List<Capability>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(Capability.DeserializeCapability(item, options));
                    }
                    capabilities = array;
                    continue;
                }
                if (property.NameEquals("hierarchies"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<Hierarchy> array = new List<Hierarchy>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(Hierarchy.DeserializeHierarchy(item, options));
                    }
                    hierarchies = array;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ContextUpdateProperties(capabilities ?? new ChangeTrackingList<Capability>(), hierarchies ?? new ChangeTrackingList<Hierarchy>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ContextUpdateProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ContextUpdateProperties)} does not support writing '{options.Format}' format.");
            }
        }

        ContextUpdateProperties IPersistableModel<ContextUpdateProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ContextUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeContextUpdateProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ContextUpdateProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ContextUpdateProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/DeployJobStepStatistics.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Deploy statistics for a job step, including total, success, and failed counts. </summary>
    public partial class DeployJobStepStatistics : JobStepStatisticsBase
    {
        /// <summary> Initializes a new instance of <see cref="DeployJobStepStatistics"/>. </summary>
        public DeployJobStepStatistics()
        {
            StatisticsType = JobType.Deploy;
        }

        /// <summary> Initializes a new instance of <see cref="DeployJobStepStatistics"/>. </summary>
        /// <param name="statisticsType"> Statistics type discriminator value. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        /// <param name="totalCount"> Total count of items processed in this step. </param>
        /// <param name="successCount"> Count of successful items in this step. </param>
        /// <param name="failedCount"> Count of failed items in this step. </param>
        internal DeployJobStepStatistics(JobType statisticsType, IDictionary<string, BinaryData> serializedAdditionalRawData, int? totalCount, int? successCount, int? failedCount) : base(statisticsType, serializedAdditionalRawData)
        {
            TotalCount = totalCount;
            SuccessCount = successCount;
            FailedCount = failedCount;
            StatisticsType = statisticsType;
        }

        /// <summary> Total count of items processed in this step. </summary>
        public int? TotalCount { get; set; }
        /// <summary> Count of successful items in this step. </summary>
        public int? SuccessCount { get; set; }
        /// <summary> Count of failed items in this step. </summary>
        public int? FailedCount { get; set; }
    }
}



================================================
FILE: Generated/Models/DeployJobStepStatistics.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class DeployJobStepStatistics : IUtf8JsonSerializable, IJsonModel<DeployJobStepStatistics>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<DeployJobStepStatistics>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<DeployJobStepStatistics>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DeployJobStepStatistics>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DeployJobStepStatistics)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(TotalCount))
            {
                writer.WritePropertyName("totalCount"u8);
                writer.WriteNumberValue(TotalCount.Value);
            }
            if (Optional.IsDefined(SuccessCount))
            {
                writer.WritePropertyName("successCount"u8);
                writer.WriteNumberValue(SuccessCount.Value);
            }
            if (Optional.IsDefined(FailedCount))
            {
                writer.WritePropertyName("failedCount"u8);
                writer.WriteNumberValue(FailedCount.Value);
            }
        }

        DeployJobStepStatistics IJsonModel<DeployJobStepStatistics>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DeployJobStepStatistics>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DeployJobStepStatistics)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeDeployJobStepStatistics(document.RootElement, options);
        }

        internal static DeployJobStepStatistics DeserializeDeployJobStepStatistics(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            int? totalCount = default;
            int? successCount = default;
            int? failedCount = default;
            JobType statisticsType = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("totalCount"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    totalCount = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("successCount"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    successCount = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("failedCount"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    failedCount = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("statisticsType"u8))
                {
                    statisticsType = new JobType(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new DeployJobStepStatistics(statisticsType, serializedAdditionalRawData, totalCount, successCount, failedCount);
        }

        BinaryData IPersistableModel<DeployJobStepStatistics>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DeployJobStepStatistics>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(DeployJobStepStatistics)} does not support writing '{options.Format}' format.");
            }
        }

        DeployJobStepStatistics IPersistableModel<DeployJobStepStatistics>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DeployJobStepStatistics>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeDeployJobStepStatistics(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(DeployJobStepStatistics)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<DeployJobStepStatistics>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/DeploymentStatus.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Deployment Status. </summary>
    public partial class DeploymentStatus
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="DeploymentStatus"/>. </summary>
        internal DeploymentStatus()
        {
            TargetStatuses = new ChangeTrackingList<TargetStatus>();
        }

        /// <summary> Initializes a new instance of <see cref="DeploymentStatus"/>. </summary>
        /// <param name="lastModified"> The lastModified of the Status. </param>
        /// <param name="deployed"> Indicates if Instance is deployed. </param>
        /// <param name="expectedRunningJobId"> The expected running job id. </param>
        /// <param name="runningJobId"> The running job id. </param>
        /// <param name="status"> Deployment status. </param>
        /// <param name="statusDetails"> Status details. </param>
        /// <param name="generation"> Deployment Generation. </param>
        /// <param name="targetStatuses"> Target resource statuses. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal DeploymentStatus(DateTimeOffset? lastModified, int? deployed, int? expectedRunningJobId, int? runningJobId, string status, string statusDetails, int? generation, IReadOnlyList<TargetStatus> targetStatuses, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            LastModified = lastModified;
            Deployed = deployed;
            ExpectedRunningJobId = expectedRunningJobId;
            RunningJobId = runningJobId;
            Status = status;
            StatusDetails = statusDetails;
            Generation = generation;
            TargetStatuses = targetStatuses;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The lastModified of the Status. </summary>
        public DateTimeOffset? LastModified { get; }
        /// <summary> Indicates if Instance is deployed. </summary>
        public int? Deployed { get; }
        /// <summary> The expected running job id. </summary>
        public int? ExpectedRunningJobId { get; }
        /// <summary> The running job id. </summary>
        public int? RunningJobId { get; }
        /// <summary> Deployment status. </summary>
        public string Status { get; }
        /// <summary> Status details. </summary>
        public string StatusDetails { get; }
        /// <summary> Deployment Generation. </summary>
        public int? Generation { get; }
        /// <summary> Target resource statuses. </summary>
        public IReadOnlyList<TargetStatus> TargetStatuses { get; }
    }
}



================================================
FILE: Generated/Models/DeploymentStatus.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class DeploymentStatus : IUtf8JsonSerializable, IJsonModel<DeploymentStatus>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<DeploymentStatus>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<DeploymentStatus>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DeploymentStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DeploymentStatus)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(LastModified))
            {
                writer.WritePropertyName("lastModified"u8);
                writer.WriteStringValue(LastModified.Value, "O");
            }
            if (Optional.IsDefined(Deployed))
            {
                writer.WritePropertyName("deployed"u8);
                writer.WriteNumberValue(Deployed.Value);
            }
            if (Optional.IsDefined(ExpectedRunningJobId))
            {
                writer.WritePropertyName("expectedRunningJobId"u8);
                writer.WriteNumberValue(ExpectedRunningJobId.Value);
            }
            if (Optional.IsDefined(RunningJobId))
            {
                writer.WritePropertyName("runningJobId"u8);
                writer.WriteNumberValue(RunningJobId.Value);
            }
            if (Optional.IsDefined(Status))
            {
                writer.WritePropertyName("status"u8);
                writer.WriteStringValue(Status);
            }
            if (Optional.IsDefined(StatusDetails))
            {
                writer.WritePropertyName("statusDetails"u8);
                writer.WriteStringValue(StatusDetails);
            }
            if (Optional.IsDefined(Generation))
            {
                writer.WritePropertyName("generation"u8);
                writer.WriteNumberValue(Generation.Value);
            }
            if (Optional.IsCollectionDefined(TargetStatuses))
            {
                writer.WritePropertyName("targetStatuses"u8);
                writer.WriteStartArray();
                foreach (var item in TargetStatuses)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        DeploymentStatus IJsonModel<DeploymentStatus>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DeploymentStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DeploymentStatus)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeDeploymentStatus(document.RootElement, options);
        }

        internal static DeploymentStatus DeserializeDeploymentStatus(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            DateTimeOffset? lastModified = default;
            int? deployed = default;
            int? expectedRunningJobId = default;
            int? runningJobId = default;
            string status = default;
            string statusDetails = default;
            int? generation = default;
            IReadOnlyList<TargetStatus> targetStatuses = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("lastModified"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    lastModified = property.Value.GetDateTimeOffset("O");
                    continue;
                }
                if (property.NameEquals("deployed"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    deployed = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("expectedRunningJobId"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    expectedRunningJobId = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("runningJobId"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    runningJobId = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    status = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("statusDetails"u8))
                {
                    statusDetails = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("generation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    generation = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("targetStatuses"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<TargetStatus> array = new List<TargetStatus>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(TargetStatus.DeserializeTargetStatus(item, options));
                    }
                    targetStatuses = array;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new DeploymentStatus(
                lastModified,
                deployed,
                expectedRunningJobId,
                runningJobId,
                status,
                statusDetails,
                generation,
                targetStatuses ?? new ChangeTrackingList<TargetStatus>(),
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<DeploymentStatus>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DeploymentStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(DeploymentStatus)} does not support writing '{options.Format}' format.");
            }
        }

        DeploymentStatus IPersistableModel<DeploymentStatus>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DeploymentStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeDeploymentStatus(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(DeploymentStatus)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<DeploymentStatus>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/DiagnosticListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a Diagnostic list operation. </summary>
    internal partial class DiagnosticListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="DiagnosticListResult"/>. </summary>
        /// <param name="value"> The Diagnostic items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal DiagnosticListResult(IEnumerable<EdgeDiagnosticData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="DiagnosticListResult"/>. </summary>
        /// <param name="value"> The Diagnostic items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal DiagnosticListResult(IReadOnlyList<EdgeDiagnosticData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="DiagnosticListResult"/> for deserialization. </summary>
        internal DiagnosticListResult()
        {
        }

        /// <summary> The Diagnostic items on this page. </summary>
        public IReadOnlyList<EdgeDiagnosticData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/DiagnosticListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class DiagnosticListResult : IUtf8JsonSerializable, IJsonModel<DiagnosticListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<DiagnosticListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<DiagnosticListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DiagnosticListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DiagnosticListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        DiagnosticListResult IJsonModel<DiagnosticListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DiagnosticListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DiagnosticListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeDiagnosticListResult(document.RootElement, options);
        }

        internal static DiagnosticListResult DeserializeDiagnosticListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeDiagnosticData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeDiagnosticData> array = new List<EdgeDiagnosticData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeDiagnosticData.DeserializeEdgeDiagnosticData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new DiagnosticListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<DiagnosticListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DiagnosticListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(DiagnosticListResult)} does not support writing '{options.Format}' format.");
            }
        }

        DiagnosticListResult IPersistableModel<DiagnosticListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DiagnosticListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeDiagnosticListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(DiagnosticListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<DiagnosticListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/DiagnosticProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The properties of a Diagnostic resource. </summary>
    internal partial class DiagnosticProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="DiagnosticProperties"/>. </summary>
        public DiagnosticProperties()
        {
        }

        /// <summary> Initializes a new instance of <see cref="DiagnosticProperties"/>. </summary>
        /// <param name="provisioningState"> The status of the last operation. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal DiagnosticProperties(ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The status of the last operation. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/DiagnosticProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class DiagnosticProperties : IUtf8JsonSerializable, IJsonModel<DiagnosticProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<DiagnosticProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<DiagnosticProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DiagnosticProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DiagnosticProperties)} does not support writing '{format}' format.");
            }

            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        DiagnosticProperties IJsonModel<DiagnosticProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DiagnosticProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DiagnosticProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeDiagnosticProperties(document.RootElement, options);
        }

        internal static DiagnosticProperties DeserializeDiagnosticProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new DiagnosticProperties(provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<DiagnosticProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DiagnosticProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(DiagnosticProperties)} does not support writing '{options.Format}' format.");
            }
        }

        DiagnosticProperties IPersistableModel<DiagnosticProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DiagnosticProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeDiagnosticProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(DiagnosticProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<DiagnosticProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/DynamicSchemaListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a DynamicSchema list operation. </summary>
    internal partial class DynamicSchemaListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="DynamicSchemaListResult"/>. </summary>
        /// <param name="value"> The DynamicSchema items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal DynamicSchemaListResult(IEnumerable<EdgeDynamicSchemaData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="DynamicSchemaListResult"/>. </summary>
        /// <param name="value"> The DynamicSchema items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal DynamicSchemaListResult(IReadOnlyList<EdgeDynamicSchemaData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="DynamicSchemaListResult"/> for deserialization. </summary>
        internal DynamicSchemaListResult()
        {
        }

        /// <summary> The DynamicSchema items on this page. </summary>
        public IReadOnlyList<EdgeDynamicSchemaData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/DynamicSchemaListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class DynamicSchemaListResult : IUtf8JsonSerializable, IJsonModel<DynamicSchemaListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<DynamicSchemaListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<DynamicSchemaListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DynamicSchemaListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        DynamicSchemaListResult IJsonModel<DynamicSchemaListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DynamicSchemaListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeDynamicSchemaListResult(document.RootElement, options);
        }

        internal static DynamicSchemaListResult DeserializeDynamicSchemaListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeDynamicSchemaData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeDynamicSchemaData> array = new List<EdgeDynamicSchemaData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeDynamicSchemaData.DeserializeEdgeDynamicSchemaData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new DynamicSchemaListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<DynamicSchemaListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(DynamicSchemaListResult)} does not support writing '{options.Format}' format.");
            }
        }

        DynamicSchemaListResult IPersistableModel<DynamicSchemaListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeDynamicSchemaListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(DynamicSchemaListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<DynamicSchemaListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/DynamicSchemaProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> DynamicSchema Properties. </summary>
    public partial class DynamicSchemaProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="DynamicSchemaProperties"/>. </summary>
        public DynamicSchemaProperties()
        {
        }

        /// <summary> Initializes a new instance of <see cref="DynamicSchemaProperties"/>. </summary>
        /// <param name="displayName"> Display name of the dynamic schema. </param>
        /// <param name="configurationType"> Type of configuration. </param>
        /// <param name="configurationModel"> Type of configuration model. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal DynamicSchemaProperties(string displayName, ConfigurationType? configurationType, ConfigurationModel? configurationModel, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            DisplayName = displayName;
            ConfigurationType = configurationType;
            ConfigurationModel = configurationModel;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Display name of the dynamic schema. </summary>
        public string DisplayName { get; }
        /// <summary> Type of configuration. </summary>
        public ConfigurationType? ConfigurationType { get; }
        /// <summary> Type of configuration model. </summary>
        public ConfigurationModel? ConfigurationModel { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/DynamicSchemaProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class DynamicSchemaProperties : IUtf8JsonSerializable, IJsonModel<DynamicSchemaProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<DynamicSchemaProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<DynamicSchemaProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DynamicSchemaProperties)} does not support writing '{format}' format.");
            }

            if (options.Format != "W" && Optional.IsDefined(DisplayName))
            {
                writer.WritePropertyName("displayName"u8);
                writer.WriteStringValue(DisplayName);
            }
            if (options.Format != "W" && Optional.IsDefined(ConfigurationType))
            {
                writer.WritePropertyName("configurationType"u8);
                writer.WriteStringValue(ConfigurationType.Value.ToString());
            }
            if (options.Format != "W" && Optional.IsDefined(ConfigurationModel))
            {
                writer.WritePropertyName("configurationModel"u8);
                writer.WriteStringValue(ConfigurationModel.Value.ToString());
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        DynamicSchemaProperties IJsonModel<DynamicSchemaProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DynamicSchemaProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeDynamicSchemaProperties(document.RootElement, options);
        }

        internal static DynamicSchemaProperties DeserializeDynamicSchemaProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string displayName = default;
            ConfigurationType? configurationType = default;
            ConfigurationModel? configurationModel = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("displayName"u8))
                {
                    displayName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("configurationType"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    configurationType = new ConfigurationType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("configurationModel"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    configurationModel = new ConfigurationModel(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new DynamicSchemaProperties(displayName, configurationType, configurationModel, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<DynamicSchemaProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(DynamicSchemaProperties)} does not support writing '{options.Format}' format.");
            }
        }

        DynamicSchemaProperties IPersistableModel<DynamicSchemaProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeDynamicSchemaProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(DynamicSchemaProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<DynamicSchemaProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/DynamicSchemaVersionListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a DynamicSchemaVersion list operation. </summary>
    internal partial class DynamicSchemaVersionListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="DynamicSchemaVersionListResult"/>. </summary>
        /// <param name="value"> The DynamicSchemaVersion items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal DynamicSchemaVersionListResult(IEnumerable<EdgeDynamicSchemaVersionData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="DynamicSchemaVersionListResult"/>. </summary>
        /// <param name="value"> The DynamicSchemaVersion items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal DynamicSchemaVersionListResult(IReadOnlyList<EdgeDynamicSchemaVersionData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="DynamicSchemaVersionListResult"/> for deserialization. </summary>
        internal DynamicSchemaVersionListResult()
        {
        }

        /// <summary> The DynamicSchemaVersion items on this page. </summary>
        public IReadOnlyList<EdgeDynamicSchemaVersionData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/DynamicSchemaVersionListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class DynamicSchemaVersionListResult : IUtf8JsonSerializable, IJsonModel<DynamicSchemaVersionListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<DynamicSchemaVersionListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<DynamicSchemaVersionListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DynamicSchemaVersionListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        DynamicSchemaVersionListResult IJsonModel<DynamicSchemaVersionListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(DynamicSchemaVersionListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeDynamicSchemaVersionListResult(document.RootElement, options);
        }

        internal static DynamicSchemaVersionListResult DeserializeDynamicSchemaVersionListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeDynamicSchemaVersionData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeDynamicSchemaVersionData> array = new List<EdgeDynamicSchemaVersionData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeDynamicSchemaVersionData.DeserializeEdgeDynamicSchemaVersionData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new DynamicSchemaVersionListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<DynamicSchemaVersionListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(DynamicSchemaVersionListResult)} does not support writing '{options.Format}' format.");
            }
        }

        DynamicSchemaVersionListResult IPersistableModel<DynamicSchemaVersionListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<DynamicSchemaVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeDynamicSchemaVersionListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(DynamicSchemaVersionListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<DynamicSchemaVersionListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeConfigTemplatePatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The type used for update operations of the ConfigTemplate. </summary>
    public partial class EdgeConfigTemplatePatch
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeConfigTemplatePatch"/>. </summary>
        public EdgeConfigTemplatePatch()
        {
            Tags = new ChangeTrackingDictionary<string, string>();
        }

        /// <summary> Initializes a new instance of <see cref="EdgeConfigTemplatePatch"/>. </summary>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeConfigTemplatePatch(IDictionary<string, string> tags, ConfigTemplateUpdateProperties properties, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Tags = tags;
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Resource tags. </summary>
        public IDictionary<string, string> Tags { get; }
        /// <summary> The resource-specific properties for this resource. </summary>
        internal ConfigTemplateUpdateProperties Properties { get; set; }
        /// <summary> Description of config template. </summary>
        public string ConfigTemplateUpdateDescription
        {
            get => Properties is null ? default : Properties.Description;
            set
            {
                if (Properties is null)
                    Properties = new ConfigTemplateUpdateProperties();
                Properties.Description = value;
            }
        }
    }
}



================================================
FILE: Generated/Models/EdgeConfigTemplatePatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeConfigTemplatePatch : IUtf8JsonSerializable, IJsonModel<EdgeConfigTemplatePatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeConfigTemplatePatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeConfigTemplatePatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplatePatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeConfigTemplatePatch)} does not support writing '{format}' format.");
            }

            if (Optional.IsCollectionDefined(Tags))
            {
                writer.WritePropertyName("tags"u8);
                writer.WriteStartObject();
                foreach (var item in Tags)
                {
                    writer.WritePropertyName(item.Key);
                    writer.WriteStringValue(item.Value);
                }
                writer.WriteEndObject();
            }
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        EdgeConfigTemplatePatch IJsonModel<EdgeConfigTemplatePatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplatePatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeConfigTemplatePatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeConfigTemplatePatch(document.RootElement, options);
        }

        internal static EdgeConfigTemplatePatch DeserializeEdgeConfigTemplatePatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IDictionary<string, string> tags = default;
            ConfigTemplateUpdateProperties properties = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = ConfigTemplateUpdateProperties.DeserializeConfigTemplateUpdateProperties(property.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeConfigTemplatePatch(tags ?? new ChangeTrackingDictionary<string, string>(), properties, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeConfigTemplatePatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplatePatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeConfigTemplatePatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeConfigTemplatePatch IPersistableModel<EdgeConfigTemplatePatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeConfigTemplatePatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeConfigTemplatePatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeConfigTemplatePatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeConfigTemplatePatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeContextPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The type used for update operations of the Context. </summary>
    public partial class EdgeContextPatch
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeContextPatch"/>. </summary>
        public EdgeContextPatch()
        {
            Tags = new ChangeTrackingDictionary<string, string>();
        }

        /// <summary> Initializes a new instance of <see cref="EdgeContextPatch"/>. </summary>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeContextPatch(IDictionary<string, string> tags, ContextUpdateProperties properties, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Tags = tags;
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Resource tags. </summary>
        public IDictionary<string, string> Tags { get; }
        /// <summary> The resource-specific properties for this resource. </summary>
        public ContextUpdateProperties Properties { get; set; }
    }
}



================================================
FILE: Generated/Models/EdgeContextPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeContextPatch : IUtf8JsonSerializable, IJsonModel<EdgeContextPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeContextPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeContextPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeContextPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeContextPatch)} does not support writing '{format}' format.");
            }

            if (Optional.IsCollectionDefined(Tags))
            {
                writer.WritePropertyName("tags"u8);
                writer.WriteStartObject();
                foreach (var item in Tags)
                {
                    writer.WritePropertyName(item.Key);
                    writer.WriteStringValue(item.Value);
                }
                writer.WriteEndObject();
            }
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        EdgeContextPatch IJsonModel<EdgeContextPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeContextPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeContextPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeContextPatch(document.RootElement, options);
        }

        internal static EdgeContextPatch DeserializeEdgeContextPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IDictionary<string, string> tags = default;
            ContextUpdateProperties properties = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = ContextUpdateProperties.DeserializeContextUpdateProperties(property.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeContextPatch(tags ?? new ChangeTrackingDictionary<string, string>(), properties, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeContextPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeContextPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeContextPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeContextPatch IPersistableModel<EdgeContextPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeContextPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeContextPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeContextPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeContextPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeDeploymentInstancePatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Instance Resource. Represents a deployment object. </summary>
    public partial class EdgeDeploymentInstancePatch : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeDeploymentInstancePatch"/>. </summary>
        public EdgeDeploymentInstancePatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDeploymentInstancePatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeDeploymentInstancePatch(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, InstancePropertiesUpdate properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public InstancePropertiesUpdate Properties { get; set; }
    }
}



================================================
FILE: Generated/Models/EdgeDeploymentInstancePatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeDeploymentInstancePatch : IUtf8JsonSerializable, IJsonModel<EdgeDeploymentInstancePatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeDeploymentInstancePatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeDeploymentInstancePatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstancePatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDeploymentInstancePatch)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeDeploymentInstancePatch IJsonModel<EdgeDeploymentInstancePatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstancePatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDeploymentInstancePatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeDeploymentInstancePatch(document.RootElement, options);
        }

        internal static EdgeDeploymentInstancePatch DeserializeEdgeDeploymentInstancePatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            InstancePropertiesUpdate properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = InstancePropertiesUpdate.DeserializeInstancePropertiesUpdate(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeDeploymentInstancePatch(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeDeploymentInstancePatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstancePatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeDeploymentInstancePatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeDeploymentInstancePatch IPersistableModel<EdgeDeploymentInstancePatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDeploymentInstancePatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeDeploymentInstancePatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeDeploymentInstancePatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeDeploymentInstancePatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeDiagnosticPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The type used for update operations of the Diagnostic. </summary>
    public partial class EdgeDiagnosticPatch
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeDiagnosticPatch"/>. </summary>
        public EdgeDiagnosticPatch()
        {
            Tags = new ChangeTrackingDictionary<string, string>();
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDiagnosticPatch"/>. </summary>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeDiagnosticPatch(BinaryData properties, IDictionary<string, string> tags, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Properties = properties;
            Tags = tags;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary>
        /// The resource-specific properties for this resource.
        /// <para>
        /// To assign an object to this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public BinaryData Properties { get; set; }
        /// <summary> Resource tags. </summary>
        public IDictionary<string, string> Tags { get; }
    }
}



================================================
FILE: Generated/Models/EdgeDiagnosticPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeDiagnosticPatch : IUtf8JsonSerializable, IJsonModel<EdgeDiagnosticPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeDiagnosticPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeDiagnosticPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDiagnosticPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDiagnosticPatch)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(Properties);
#else
                using (JsonDocument document = JsonDocument.Parse(Properties, ModelSerializationExtensions.JsonDocumentOptions))
                {
                    JsonSerializer.Serialize(writer, document.RootElement);
                }
#endif
            }
            if (Optional.IsCollectionDefined(Tags))
            {
                writer.WritePropertyName("tags"u8);
                writer.WriteStartObject();
                foreach (var item in Tags)
                {
                    writer.WritePropertyName(item.Key);
                    writer.WriteStringValue(item.Value);
                }
                writer.WriteEndObject();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        EdgeDiagnosticPatch IJsonModel<EdgeDiagnosticPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDiagnosticPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDiagnosticPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeDiagnosticPatch(document.RootElement, options);
        }

        internal static EdgeDiagnosticPatch DeserializeEdgeDiagnosticPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            BinaryData properties = default;
            IDictionary<string, string> tags = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = BinaryData.FromString(property.Value.GetRawText());
                    continue;
                }
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeDiagnosticPatch(properties, tags ?? new ChangeTrackingDictionary<string, string>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeDiagnosticPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDiagnosticPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeDiagnosticPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeDiagnosticPatch IPersistableModel<EdgeDiagnosticPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDiagnosticPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeDiagnosticPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeDiagnosticPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeDiagnosticPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeDynamicSchemaPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> DynamicSchema Resource. </summary>
    public partial class EdgeDynamicSchemaPatch : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeDynamicSchemaPatch"/>. </summary>
        public EdgeDynamicSchemaPatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDynamicSchemaPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeDynamicSchemaPatch(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, DynamicSchemaProperties properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public DynamicSchemaProperties Properties { get; set; }
    }
}



================================================
FILE: Generated/Models/EdgeDynamicSchemaPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeDynamicSchemaPatch : IUtf8JsonSerializable, IJsonModel<EdgeDynamicSchemaPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeDynamicSchemaPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeDynamicSchemaPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDynamicSchemaPatch)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeDynamicSchemaPatch IJsonModel<EdgeDynamicSchemaPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDynamicSchemaPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeDynamicSchemaPatch(document.RootElement, options);
        }

        internal static EdgeDynamicSchemaPatch DeserializeEdgeDynamicSchemaPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            DynamicSchemaProperties properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = DynamicSchemaProperties.DeserializeDynamicSchemaProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeDynamicSchemaPatch(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeDynamicSchemaPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeDynamicSchemaPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeDynamicSchemaPatch IPersistableModel<EdgeDynamicSchemaPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeDynamicSchemaPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeDynamicSchemaPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeDynamicSchemaPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeDynamicSchemaVersionPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Dynamic Schema Version Resource. </summary>
    public partial class EdgeDynamicSchemaVersionPatch : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeDynamicSchemaVersionPatch"/>. </summary>
        public EdgeDynamicSchemaVersionPatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeDynamicSchemaVersionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeDynamicSchemaVersionPatch(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SchemaVersionPropertiesUpdate properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        internal SchemaVersionPropertiesUpdate Properties { get; set; }
        /// <summary> Value of schema version. </summary>
        public string SchemaVersionPropertiesUpdateValue
        {
            get => Properties is null ? default : Properties.Value;
            set
            {
                if (Properties is null)
                    Properties = new SchemaVersionPropertiesUpdate();
                Properties.Value = value;
            }
        }
    }
}



================================================
FILE: Generated/Models/EdgeDynamicSchemaVersionPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeDynamicSchemaVersionPatch : IUtf8JsonSerializable, IJsonModel<EdgeDynamicSchemaVersionPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeDynamicSchemaVersionPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeDynamicSchemaVersionPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaVersionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDynamicSchemaVersionPatch)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeDynamicSchemaVersionPatch IJsonModel<EdgeDynamicSchemaVersionPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaVersionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeDynamicSchemaVersionPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeDynamicSchemaVersionPatch(document.RootElement, options);
        }

        internal static EdgeDynamicSchemaVersionPatch DeserializeEdgeDynamicSchemaVersionPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SchemaVersionPropertiesUpdate properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SchemaVersionPropertiesUpdate.DeserializeSchemaVersionPropertiesUpdate(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeDynamicSchemaVersionPatch(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeDynamicSchemaVersionPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaVersionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeDynamicSchemaVersionPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeDynamicSchemaVersionPatch IPersistableModel<EdgeDynamicSchemaVersionPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeDynamicSchemaVersionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeDynamicSchemaVersionPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeDynamicSchemaVersionPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeDynamicSchemaVersionPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeExecutionPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Execution Resource. </summary>
    public partial class EdgeExecutionPatch : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeExecutionPatch"/>. </summary>
        public EdgeExecutionPatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeExecutionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeExecutionPatch(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, ExecutionPropertiesUpdate properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public ExecutionPropertiesUpdate Properties { get; set; }
    }
}



================================================
FILE: Generated/Models/EdgeExecutionPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeExecutionPatch : IUtf8JsonSerializable, IJsonModel<EdgeExecutionPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeExecutionPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeExecutionPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeExecutionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeExecutionPatch)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeExecutionPatch IJsonModel<EdgeExecutionPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeExecutionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeExecutionPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeExecutionPatch(document.RootElement, options);
        }

        internal static EdgeExecutionPatch DeserializeEdgeExecutionPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ExecutionPropertiesUpdate properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = ExecutionPropertiesUpdate.DeserializeExecutionPropertiesUpdate(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeExecutionPatch(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeExecutionPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeExecutionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeExecutionPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeExecutionPatch IPersistableModel<EdgeExecutionPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeExecutionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeExecutionPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeExecutionPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeExecutionPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeSchemaPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The type used for update operations of the Schema. </summary>
    public partial class EdgeSchemaPatch
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaPatch"/>. </summary>
        public EdgeSchemaPatch()
        {
            Tags = new ChangeTrackingDictionary<string, string>();
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaPatch"/>. </summary>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSchemaPatch(BinaryData properties, IDictionary<string, string> tags, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Properties = properties;
            Tags = tags;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary>
        /// The resource-specific properties for this resource.
        /// <para>
        /// To assign an object to this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public BinaryData Properties { get; set; }
        /// <summary> Resource tags. </summary>
        public IDictionary<string, string> Tags { get; }
    }
}



================================================
FILE: Generated/Models/EdgeSchemaPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeSchemaPatch : IUtf8JsonSerializable, IJsonModel<EdgeSchemaPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSchemaPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSchemaPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaPatch)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(Properties);
#else
                using (JsonDocument document = JsonDocument.Parse(Properties, ModelSerializationExtensions.JsonDocumentOptions))
                {
                    JsonSerializer.Serialize(writer, document.RootElement);
                }
#endif
            }
            if (Optional.IsCollectionDefined(Tags))
            {
                writer.WritePropertyName("tags"u8);
                writer.WriteStartObject();
                foreach (var item in Tags)
                {
                    writer.WritePropertyName(item.Key);
                    writer.WriteStringValue(item.Value);
                }
                writer.WriteEndObject();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        EdgeSchemaPatch IJsonModel<EdgeSchemaPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSchemaPatch(document.RootElement, options);
        }

        internal static EdgeSchemaPatch DeserializeEdgeSchemaPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            BinaryData properties = default;
            IDictionary<string, string> tags = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = BinaryData.FromString(property.Value.GetRawText());
                    continue;
                }
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSchemaPatch(properties, tags ?? new ChangeTrackingDictionary<string, string>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSchemaPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSchemaPatch IPersistableModel<EdgeSchemaPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSchemaPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSchemaPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeSchemaVersionPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Schema Version Resource. </summary>
    public partial class EdgeSchemaVersionPatch : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaVersionPatch"/>. </summary>
        public EdgeSchemaVersionPatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSchemaVersionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSchemaVersionPatch(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SchemaVersionPropertiesUpdate properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        internal SchemaVersionPropertiesUpdate Properties { get; set; }
        /// <summary> Value of schema version. </summary>
        public string SchemaVersionPropertiesUpdateValue
        {
            get => Properties is null ? default : Properties.Value;
            set
            {
                if (Properties is null)
                    Properties = new SchemaVersionPropertiesUpdate();
                Properties.Value = value;
            }
        }
    }
}



================================================
FILE: Generated/Models/EdgeSchemaVersionPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeSchemaVersionPatch : IUtf8JsonSerializable, IJsonModel<EdgeSchemaVersionPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSchemaVersionPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSchemaVersionPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaVersionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaVersionPatch)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeSchemaVersionPatch IJsonModel<EdgeSchemaVersionPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaVersionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSchemaVersionPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSchemaVersionPatch(document.RootElement, options);
        }

        internal static EdgeSchemaVersionPatch DeserializeEdgeSchemaVersionPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SchemaVersionPropertiesUpdate properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SchemaVersionPropertiesUpdate.DeserializeSchemaVersionPropertiesUpdate(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSchemaVersionPatch(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSchemaVersionPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaVersionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaVersionPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSchemaVersionPatch IPersistableModel<EdgeSchemaVersionPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSchemaVersionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSchemaVersionPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSchemaVersionPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSchemaVersionPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeSiteReferencePatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Site Reference Resource. </summary>
    public partial class EdgeSiteReferencePatch : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSiteReferencePatch"/>. </summary>
        public EdgeSiteReferencePatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSiteReferencePatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSiteReferencePatch(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SiteReferencePropertiesUpdate properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        internal SiteReferencePropertiesUpdate Properties { get; set; }
        /// <summary> Azure Resource ID for Site. </summary>
        public string SiteId
        {
            get => Properties is null ? default : Properties.SiteId;
            set
            {
                if (Properties is null)
                    Properties = new SiteReferencePropertiesUpdate();
                Properties.SiteId = value;
            }
        }
    }
}



================================================
FILE: Generated/Models/EdgeSiteReferencePatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeSiteReferencePatch : IUtf8JsonSerializable, IJsonModel<EdgeSiteReferencePatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSiteReferencePatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSiteReferencePatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSiteReferencePatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSiteReferencePatch)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeSiteReferencePatch IJsonModel<EdgeSiteReferencePatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSiteReferencePatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSiteReferencePatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSiteReferencePatch(document.RootElement, options);
        }

        internal static EdgeSiteReferencePatch DeserializeEdgeSiteReferencePatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SiteReferencePropertiesUpdate properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SiteReferencePropertiesUpdate.DeserializeSiteReferencePropertiesUpdate(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSiteReferencePatch(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSiteReferencePatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSiteReferencePatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSiteReferencePatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSiteReferencePatch IPersistableModel<EdgeSiteReferencePatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSiteReferencePatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSiteReferencePatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSiteReferencePatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSiteReferencePatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeSolutionPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The type used for update operations of the Solution. </summary>
    public partial class EdgeSolutionPatch
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionPatch"/>. </summary>
        public EdgeSolutionPatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionPatch"/>. </summary>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSolutionPatch(BinaryData properties, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary>
        /// The resource-specific properties for this resource.
        /// <para>
        /// To assign an object to this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public BinaryData Properties { get; set; }
    }
}



================================================
FILE: Generated/Models/EdgeSolutionPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeSolutionPatch : IUtf8JsonSerializable, IJsonModel<EdgeSolutionPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSolutionPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSolutionPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionPatch)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(Properties);
#else
                using (JsonDocument document = JsonDocument.Parse(Properties, ModelSerializationExtensions.JsonDocumentOptions))
                {
                    JsonSerializer.Serialize(writer, document.RootElement);
                }
#endif
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        EdgeSolutionPatch IJsonModel<EdgeSolutionPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSolutionPatch(document.RootElement, options);
        }

        internal static EdgeSolutionPatch DeserializeEdgeSolutionPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            BinaryData properties = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = BinaryData.FromString(property.Value.GetRawText());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSolutionPatch(properties, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSolutionPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSolutionPatch IPersistableModel<EdgeSolutionPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSolutionPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSolutionPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeSolutionTemplatePatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The type used for update operations of the SolutionTemplate. </summary>
    public partial class EdgeSolutionTemplatePatch
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionTemplatePatch"/>. </summary>
        public EdgeSolutionTemplatePatch()
        {
            Tags = new ChangeTrackingDictionary<string, string>();
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionTemplatePatch"/>. </summary>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSolutionTemplatePatch(IDictionary<string, string> tags, SolutionTemplateUpdateProperties properties, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Tags = tags;
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Resource tags. </summary>
        public IDictionary<string, string> Tags { get; }
        /// <summary> The resource-specific properties for this resource. </summary>
        public SolutionTemplateUpdateProperties Properties { get; set; }
    }
}



================================================
FILE: Generated/Models/EdgeSolutionTemplatePatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeSolutionTemplatePatch : IUtf8JsonSerializable, IJsonModel<EdgeSolutionTemplatePatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSolutionTemplatePatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSolutionTemplatePatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplatePatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionTemplatePatch)} does not support writing '{format}' format.");
            }

            if (Optional.IsCollectionDefined(Tags))
            {
                writer.WritePropertyName("tags"u8);
                writer.WriteStartObject();
                foreach (var item in Tags)
                {
                    writer.WritePropertyName(item.Key);
                    writer.WriteStringValue(item.Value);
                }
                writer.WriteEndObject();
            }
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        EdgeSolutionTemplatePatch IJsonModel<EdgeSolutionTemplatePatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplatePatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionTemplatePatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSolutionTemplatePatch(document.RootElement, options);
        }

        internal static EdgeSolutionTemplatePatch DeserializeEdgeSolutionTemplatePatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IDictionary<string, string> tags = default;
            SolutionTemplateUpdateProperties properties = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SolutionTemplateUpdateProperties.DeserializeSolutionTemplateUpdateProperties(property.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSolutionTemplatePatch(tags ?? new ChangeTrackingDictionary<string, string>(), properties, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSolutionTemplatePatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplatePatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionTemplatePatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSolutionTemplatePatch IPersistableModel<EdgeSolutionTemplatePatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionTemplatePatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSolutionTemplatePatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionTemplatePatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSolutionTemplatePatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeSolutionVersionPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Version Resource. It has the resolved configuration along with edge specification. </summary>
    public partial class EdgeSolutionVersionPatch : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionVersionPatch"/>. </summary>
        public EdgeSolutionVersionPatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeSolutionVersionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeSolutionVersionPatch(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, SolutionVersionPropertiesUpdate properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        internal SolutionVersionPropertiesUpdate Properties { get; set; }
        /// <summary>
        /// App components spec
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> SolutionVersionPropertiesUpdateSpecification
        {
            get
            {
                if (Properties is null)
                    Properties = new SolutionVersionPropertiesUpdate();
                return Properties.Specification;
            }
        }
    }
}



================================================
FILE: Generated/Models/EdgeSolutionVersionPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeSolutionVersionPatch : IUtf8JsonSerializable, IJsonModel<EdgeSolutionVersionPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeSolutionVersionPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeSolutionVersionPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionVersionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionVersionPatch)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeSolutionVersionPatch IJsonModel<EdgeSolutionVersionPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionVersionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeSolutionVersionPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeSolutionVersionPatch(document.RootElement, options);
        }

        internal static EdgeSolutionVersionPatch DeserializeEdgeSolutionVersionPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SolutionVersionPropertiesUpdate properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = SolutionVersionPropertiesUpdate.DeserializeSolutionVersionPropertiesUpdate(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeSolutionVersionPatch(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeSolutionVersionPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionVersionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionVersionPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeSolutionVersionPatch IPersistableModel<EdgeSolutionVersionPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeSolutionVersionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeSolutionVersionPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeSolutionVersionPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeSolutionVersionPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeTargetPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The type used for update operations of the Target. </summary>
    public partial class EdgeTargetPatch
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeTargetPatch"/>. </summary>
        public EdgeTargetPatch()
        {
            Tags = new ChangeTrackingDictionary<string, string>();
        }

        /// <summary> Initializes a new instance of <see cref="EdgeTargetPatch"/>. </summary>
        /// <param name="tags"> Resource tags. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeTargetPatch(IDictionary<string, string> tags, TargetUpdateProperties properties, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Tags = tags;
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Resource tags. </summary>
        public IDictionary<string, string> Tags { get; }
        /// <summary> The resource-specific properties for this resource. </summary>
        public TargetUpdateProperties Properties { get; set; }
    }
}



================================================
FILE: Generated/Models/EdgeTargetPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeTargetPatch : IUtf8JsonSerializable, IJsonModel<EdgeTargetPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeTargetPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeTargetPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeTargetPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeTargetPatch)} does not support writing '{format}' format.");
            }

            if (Optional.IsCollectionDefined(Tags))
            {
                writer.WritePropertyName("tags"u8);
                writer.WriteStartObject();
                foreach (var item in Tags)
                {
                    writer.WritePropertyName(item.Key);
                    writer.WriteStringValue(item.Value);
                }
                writer.WriteEndObject();
            }
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        EdgeTargetPatch IJsonModel<EdgeTargetPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeTargetPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeTargetPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeTargetPatch(document.RootElement, options);
        }

        internal static EdgeTargetPatch DeserializeEdgeTargetPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IDictionary<string, string> tags = default;
            TargetUpdateProperties properties = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("tags"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, string> dictionary = new Dictionary<string, string>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        dictionary.Add(property0.Name, property0.Value.GetString());
                    }
                    tags = dictionary;
                    continue;
                }
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = TargetUpdateProperties.DeserializeTargetUpdateProperties(property.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeTargetPatch(tags ?? new ChangeTrackingDictionary<string, string>(), properties, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeTargetPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeTargetPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeTargetPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeTargetPatch IPersistableModel<EdgeTargetPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeTargetPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeTargetPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeTargetPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeTargetPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeWorkflowPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Workflow Resource. </summary>
    public partial class EdgeWorkflowPatch : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeWorkflowPatch"/>. </summary>
        public EdgeWorkflowPatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeWorkflowPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeWorkflowPatch(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, WorkflowProperties properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public WorkflowProperties Properties { get; set; }
    }
}



================================================
FILE: Generated/Models/EdgeWorkflowPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeWorkflowPatch : IUtf8JsonSerializable, IJsonModel<EdgeWorkflowPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeWorkflowPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeWorkflowPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeWorkflowPatch)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeWorkflowPatch IJsonModel<EdgeWorkflowPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeWorkflowPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeWorkflowPatch(document.RootElement, options);
        }

        internal static EdgeWorkflowPatch DeserializeEdgeWorkflowPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            WorkflowProperties properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = WorkflowProperties.DeserializeWorkflowProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeWorkflowPatch(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeWorkflowPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeWorkflowPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeWorkflowPatch IPersistableModel<EdgeWorkflowPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeWorkflowPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeWorkflowPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeWorkflowPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/EdgeWorkflowVersionPatch.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Workflow Version Resource. </summary>
    public partial class EdgeWorkflowVersionPatch : ResourceData
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="EdgeWorkflowVersionPatch"/>. </summary>
        public EdgeWorkflowVersionPatch()
        {
        }

        /// <summary> Initializes a new instance of <see cref="EdgeWorkflowVersionPatch"/>. </summary>
        /// <param name="id"> The id. </param>
        /// <param name="name"> The name. </param>
        /// <param name="resourceType"> The resourceType. </param>
        /// <param name="systemData"> The systemData. </param>
        /// <param name="properties"> The resource-specific properties for this resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal EdgeWorkflowVersionPatch(ResourceIdentifier id, string name, ResourceType resourceType, SystemData systemData, WorkflowVersionPropertiesUpdate properties, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(id, name, resourceType, systemData)
        {
            Properties = properties;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The resource-specific properties for this resource. </summary>
        public WorkflowVersionPropertiesUpdate Properties { get; set; }
    }
}



================================================
FILE: Generated/Models/EdgeWorkflowVersionPatch.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;
using Azure.ResourceManager.Models;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class EdgeWorkflowVersionPatch : IUtf8JsonSerializable, IJsonModel<EdgeWorkflowVersionPatch>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<EdgeWorkflowVersionPatch>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<EdgeWorkflowVersionPatch>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowVersionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeWorkflowVersionPatch)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Properties))
            {
                writer.WritePropertyName("properties"u8);
                writer.WriteObjectValue(Properties, options);
            }
        }

        EdgeWorkflowVersionPatch IJsonModel<EdgeWorkflowVersionPatch>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowVersionPatch>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(EdgeWorkflowVersionPatch)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeEdgeWorkflowVersionPatch(document.RootElement, options);
        }

        internal static EdgeWorkflowVersionPatch DeserializeEdgeWorkflowVersionPatch(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            WorkflowVersionPropertiesUpdate properties = default;
            ResourceIdentifier id = default;
            string name = default;
            ResourceType type = default;
            SystemData systemData = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("properties"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    properties = WorkflowVersionPropertiesUpdate.DeserializeWorkflowVersionPropertiesUpdate(property.Value, options);
                    continue;
                }
                if (property.NameEquals("id"u8))
                {
                    id = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("type"u8))
                {
                    type = new ResourceType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("systemData"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    systemData = ModelReaderWriter.Read<SystemData>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), ModelSerializationExtensions.WireOptions, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new EdgeWorkflowVersionPatch(
                id,
                name,
                type,
                systemData,
                properties,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<EdgeWorkflowVersionPatch>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowVersionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(EdgeWorkflowVersionPatch)} does not support writing '{options.Format}' format.");
            }
        }

        EdgeWorkflowVersionPatch IPersistableModel<EdgeWorkflowVersionPatch>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<EdgeWorkflowVersionPatch>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeEdgeWorkflowVersionPatch(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(EdgeWorkflowVersionPatch)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<EdgeWorkflowVersionPatch>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ErrorAction.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Error Action Properties. </summary>
    public partial class ErrorAction
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ErrorAction"/>. </summary>
        public ErrorAction()
        {
        }

        /// <summary> Initializes a new instance of <see cref="ErrorAction"/>. </summary>
        /// <param name="mode"> Error action mode. </param>
        /// <param name="maxToleratedFailures"> Max tolerated failures. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ErrorAction(ErrorActionMode? mode, int? maxToleratedFailures, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Mode = mode;
            MaxToleratedFailures = maxToleratedFailures;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Error action mode. </summary>
        public ErrorActionMode? Mode { get; set; }
        /// <summary> Max tolerated failures. </summary>
        public int? MaxToleratedFailures { get; set; }
    }
}



================================================
FILE: Generated/Models/ErrorAction.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ErrorAction : IUtf8JsonSerializable, IJsonModel<ErrorAction>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ErrorAction>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ErrorAction>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ErrorAction>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ErrorAction)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Mode))
            {
                writer.WritePropertyName("mode"u8);
                writer.WriteStringValue(Mode.Value.ToString());
            }
            if (Optional.IsDefined(MaxToleratedFailures))
            {
                writer.WritePropertyName("maxToleratedFailures"u8);
                writer.WriteNumberValue(MaxToleratedFailures.Value);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ErrorAction IJsonModel<ErrorAction>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ErrorAction>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ErrorAction)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeErrorAction(document.RootElement, options);
        }

        internal static ErrorAction DeserializeErrorAction(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ErrorActionMode? mode = default;
            int? maxToleratedFailures = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("mode"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    mode = new ErrorActionMode(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("maxToleratedFailures"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    maxToleratedFailures = property.Value.GetInt32();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ErrorAction(mode, maxToleratedFailures, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ErrorAction>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ErrorAction>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ErrorAction)} does not support writing '{options.Format}' format.");
            }
        }

        ErrorAction IPersistableModel<ErrorAction>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ErrorAction>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeErrorAction(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ErrorAction)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ErrorAction>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ErrorActionMode.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Error action mode. </summary>
    public readonly partial struct ErrorActionMode : IEquatable<ErrorActionMode>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="ErrorActionMode"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public ErrorActionMode(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string StopOnAnyFailureValue = "stopOnAnyFailure";
        private const string StopOnNFailuresValue = "stopOnNFailures";
        private const string SilentlyContinueValue = "silentlyContinue";

        /// <summary> Stop on any failure. </summary>
        public static ErrorActionMode StopOnAnyFailure { get; } = new ErrorActionMode(StopOnAnyFailureValue);
        /// <summary> Stop after N cumulative failures. </summary>
        public static ErrorActionMode StopOnNFailures { get; } = new ErrorActionMode(StopOnNFailuresValue);
        /// <summary> Continue silently despite errors. </summary>
        public static ErrorActionMode SilentlyContinue { get; } = new ErrorActionMode(SilentlyContinueValue);
        /// <summary> Determines if two <see cref="ErrorActionMode"/> values are the same. </summary>
        public static bool operator ==(ErrorActionMode left, ErrorActionMode right) => left.Equals(right);
        /// <summary> Determines if two <see cref="ErrorActionMode"/> values are not the same. </summary>
        public static bool operator !=(ErrorActionMode left, ErrorActionMode right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="ErrorActionMode"/>. </summary>
        public static implicit operator ErrorActionMode(string value) => new ErrorActionMode(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is ErrorActionMode other && Equals(other);
        /// <inheritdoc />
        public bool Equals(ErrorActionMode other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/ExecutionListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a Execution list operation. </summary>
    internal partial class ExecutionListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ExecutionListResult"/>. </summary>
        /// <param name="value"> The Execution items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal ExecutionListResult(IEnumerable<EdgeExecutionData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="ExecutionListResult"/>. </summary>
        /// <param name="value"> The Execution items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ExecutionListResult(IReadOnlyList<EdgeExecutionData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ExecutionListResult"/> for deserialization. </summary>
        internal ExecutionListResult()
        {
        }

        /// <summary> The Execution items on this page. </summary>
        public IReadOnlyList<EdgeExecutionData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/ExecutionListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class ExecutionListResult : IUtf8JsonSerializable, IJsonModel<ExecutionListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ExecutionListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ExecutionListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ExecutionListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ExecutionListResult IJsonModel<ExecutionListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ExecutionListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeExecutionListResult(document.RootElement, options);
        }

        internal static ExecutionListResult DeserializeExecutionListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeExecutionData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeExecutionData> array = new List<EdgeExecutionData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeExecutionData.DeserializeEdgeExecutionData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ExecutionListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ExecutionListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ExecutionListResult)} does not support writing '{options.Format}' format.");
            }
        }

        ExecutionListResult IPersistableModel<ExecutionListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeExecutionListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ExecutionListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ExecutionListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ExecutionProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Execution Properties. </summary>
    public partial class ExecutionProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ExecutionProperties"/>. </summary>
        /// <param name="workflowVersionId"> Workflow version of execution. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="workflowVersionId"/> is null. </exception>
        public ExecutionProperties(string workflowVersionId)
        {
            Argument.AssertNotNull(workflowVersionId, nameof(workflowVersionId));

            WorkflowVersionId = workflowVersionId;
            Specification = new ChangeTrackingDictionary<string, BinaryData>();
        }

        /// <summary> Initializes a new instance of <see cref="ExecutionProperties"/>. </summary>
        /// <param name="workflowVersionId"> Workflow version of execution. </param>
        /// <param name="specification"> Execution specification. </param>
        /// <param name="status"> Status of Execution. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ExecutionProperties(string workflowVersionId, IDictionary<string, BinaryData> specification, ExecutionStatus status, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            WorkflowVersionId = workflowVersionId;
            Specification = specification;
            Status = status;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ExecutionProperties"/> for deserialization. </summary>
        internal ExecutionProperties()
        {
        }

        /// <summary> Workflow version of execution. </summary>
        public string WorkflowVersionId { get; set; }
        /// <summary>
        /// Execution specification
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> Specification { get; }
        /// <summary> Status of Execution. </summary>
        public ExecutionStatus Status { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/ExecutionProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ExecutionProperties : IUtf8JsonSerializable, IJsonModel<ExecutionProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ExecutionProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ExecutionProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ExecutionProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("workflowVersionId"u8);
            writer.WriteStringValue(WorkflowVersionId);
            if (Optional.IsCollectionDefined(Specification))
            {
                writer.WritePropertyName("specification"u8);
                writer.WriteStartObject();
                foreach (var item in Specification)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (options.Format != "W" && Optional.IsDefined(Status))
            {
                writer.WritePropertyName("status"u8);
                writer.WriteObjectValue(Status, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ExecutionProperties IJsonModel<ExecutionProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ExecutionProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeExecutionProperties(document.RootElement, options);
        }

        internal static ExecutionProperties DeserializeExecutionProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string workflowVersionId = default;
            IDictionary<string, BinaryData> specification = default;
            ExecutionStatus status = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("workflowVersionId"u8))
                {
                    workflowVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("specification"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    status = ExecutionStatus.DeserializeExecutionStatus(property.Value, options);
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ExecutionProperties(workflowVersionId, specification ?? new ChangeTrackingDictionary<string, BinaryData>(), status, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ExecutionProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ExecutionProperties)} does not support writing '{options.Format}' format.");
            }
        }

        ExecutionProperties IPersistableModel<ExecutionProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeExecutionProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ExecutionProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ExecutionProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ExecutionPropertiesUpdate.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Execution Properties. </summary>
    public partial class ExecutionPropertiesUpdate
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ExecutionPropertiesUpdate"/>. </summary>
        public ExecutionPropertiesUpdate()
        {
            Specification = new ChangeTrackingDictionary<string, BinaryData>();
        }

        /// <summary> Initializes a new instance of <see cref="ExecutionPropertiesUpdate"/>. </summary>
        /// <param name="workflowVersionId"> Workflow version of execution. </param>
        /// <param name="specification"> Execution specification. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ExecutionPropertiesUpdate(string workflowVersionId, IDictionary<string, BinaryData> specification, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            WorkflowVersionId = workflowVersionId;
            Specification = specification;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Workflow version of execution. </summary>
        public string WorkflowVersionId { get; set; }
        /// <summary>
        /// Execution specification
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> Specification { get; }
    }
}



================================================
FILE: Generated/Models/ExecutionPropertiesUpdate.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ExecutionPropertiesUpdate : IUtf8JsonSerializable, IJsonModel<ExecutionPropertiesUpdate>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ExecutionPropertiesUpdate>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ExecutionPropertiesUpdate>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ExecutionPropertiesUpdate)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(WorkflowVersionId))
            {
                writer.WritePropertyName("workflowVersionId"u8);
                writer.WriteStringValue(WorkflowVersionId);
            }
            if (Optional.IsCollectionDefined(Specification))
            {
                writer.WritePropertyName("specification"u8);
                writer.WriteStartObject();
                foreach (var item in Specification)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ExecutionPropertiesUpdate IJsonModel<ExecutionPropertiesUpdate>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ExecutionPropertiesUpdate)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeExecutionPropertiesUpdate(document.RootElement, options);
        }

        internal static ExecutionPropertiesUpdate DeserializeExecutionPropertiesUpdate(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string workflowVersionId = default;
            IDictionary<string, BinaryData> specification = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("workflowVersionId"u8))
                {
                    workflowVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("specification"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ExecutionPropertiesUpdate(workflowVersionId, specification ?? new ChangeTrackingDictionary<string, BinaryData>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ExecutionPropertiesUpdate>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ExecutionPropertiesUpdate)} does not support writing '{options.Format}' format.");
            }
        }

        ExecutionPropertiesUpdate IPersistableModel<ExecutionPropertiesUpdate>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeExecutionPropertiesUpdate(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ExecutionPropertiesUpdate)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ExecutionPropertiesUpdate>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ExecutionStatus.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Execution Status. </summary>
    public partial class ExecutionStatus
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ExecutionStatus"/>. </summary>
        internal ExecutionStatus()
        {
            StageHistory = new ChangeTrackingList<StageStatus>();
        }

        /// <summary> Initializes a new instance of <see cref="ExecutionStatus"/>. </summary>
        /// <param name="updateOn"> The lastModified timestamp of the Status. </param>
        /// <param name="status"> Deployment status. </param>
        /// <param name="statusMessage"> status details. </param>
        /// <param name="stageHistory"> target resource statuses. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ExecutionStatus(DateTimeOffset? updateOn, int? status, string statusMessage, IReadOnlyList<StageStatus> stageHistory, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            UpdateOn = updateOn;
            Status = status;
            StatusMessage = statusMessage;
            StageHistory = stageHistory;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The lastModified timestamp of the Status. </summary>
        public DateTimeOffset? UpdateOn { get; }
        /// <summary> Deployment status. </summary>
        public int? Status { get; }
        /// <summary> status details. </summary>
        public string StatusMessage { get; }
        /// <summary> target resource statuses. </summary>
        public IReadOnlyList<StageStatus> StageHistory { get; }
    }
}



================================================
FILE: Generated/Models/ExecutionStatus.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ExecutionStatus : IUtf8JsonSerializable, IJsonModel<ExecutionStatus>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ExecutionStatus>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ExecutionStatus>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ExecutionStatus)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(UpdateOn))
            {
                writer.WritePropertyName("updateTime"u8);
                writer.WriteStringValue(UpdateOn.Value, "O");
            }
            if (Optional.IsDefined(Status))
            {
                writer.WritePropertyName("status"u8);
                writer.WriteNumberValue(Status.Value);
            }
            if (Optional.IsDefined(StatusMessage))
            {
                writer.WritePropertyName("statusMessage"u8);
                writer.WriteStringValue(StatusMessage);
            }
            if (Optional.IsCollectionDefined(StageHistory))
            {
                writer.WritePropertyName("stageHistory"u8);
                writer.WriteStartArray();
                foreach (var item in StageHistory)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ExecutionStatus IJsonModel<ExecutionStatus>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ExecutionStatus)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeExecutionStatus(document.RootElement, options);
        }

        internal static ExecutionStatus DeserializeExecutionStatus(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            DateTimeOffset? updateTime = default;
            int? status = default;
            string statusMessage = default;
            IReadOnlyList<StageStatus> stageHistory = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("updateTime"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    updateTime = property.Value.GetDateTimeOffset("O");
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    status = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("statusMessage"u8))
                {
                    statusMessage = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("stageHistory"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<StageStatus> array = new List<StageStatus>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(StageStatus.DeserializeStageStatus(item, options));
                    }
                    stageHistory = array;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ExecutionStatus(updateTime, status, statusMessage, stageHistory ?? new ChangeTrackingList<StageStatus>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ExecutionStatus>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ExecutionStatus)} does not support writing '{options.Format}' format.");
            }
        }

        ExecutionStatus IPersistableModel<ExecutionStatus>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ExecutionStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeExecutionStatus(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ExecutionStatus)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ExecutionStatus>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ExtendedLocationType.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The supported ExtendedLocation types. </summary>
    public readonly partial struct ExtendedLocationType : IEquatable<ExtendedLocationType>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="ExtendedLocationType"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public ExtendedLocationType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string EdgeZoneValue = "EdgeZone";
        private const string CustomLocationValue = "CustomLocation";

        /// <summary> Azure Edge Zones location type. </summary>
        public static ExtendedLocationType EdgeZone { get; } = new ExtendedLocationType(EdgeZoneValue);
        /// <summary> Azure Custom Locations type. </summary>
        public static ExtendedLocationType CustomLocation { get; } = new ExtendedLocationType(CustomLocationValue);
        /// <summary> Determines if two <see cref="ExtendedLocationType"/> values are the same. </summary>
        public static bool operator ==(ExtendedLocationType left, ExtendedLocationType right) => left.Equals(right);
        /// <summary> Determines if two <see cref="ExtendedLocationType"/> values are not the same. </summary>
        public static bool operator !=(ExtendedLocationType left, ExtendedLocationType right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="ExtendedLocationType"/>. </summary>
        public static implicit operator ExtendedLocationType(string value) => new ExtendedLocationType(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is ExtendedLocationType other && Equals(other);
        /// <inheritdoc />
        public bool Equals(ExtendedLocationType other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/Hierarchy.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Hierarchy, to tag Sites / Hierarchy Provider nodes with what they represent. </summary>
    public partial class Hierarchy
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="Hierarchy"/>. </summary>
        /// <param name="name"> Name of Hierarchy. </param>
        /// <param name="description"> Description of Hierarchy. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> or <paramref name="description"/> is null. </exception>
        public Hierarchy(string name, string description)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(description, nameof(description));

            Name = name;
            Description = description;
        }

        /// <summary> Initializes a new instance of <see cref="Hierarchy"/>. </summary>
        /// <param name="name"> Name of Hierarchy. </param>
        /// <param name="description"> Description of Hierarchy. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal Hierarchy(string name, string description, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Name = name;
            Description = description;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="Hierarchy"/> for deserialization. </summary>
        internal Hierarchy()
        {
        }

        /// <summary> Name of Hierarchy. </summary>
        public string Name { get; set; }
        /// <summary> Description of Hierarchy. </summary>
        public string Description { get; set; }
    }
}



================================================
FILE: Generated/Models/Hierarchy.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class Hierarchy : IUtf8JsonSerializable, IJsonModel<Hierarchy>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<Hierarchy>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<Hierarchy>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<Hierarchy>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Hierarchy)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("name"u8);
            writer.WriteStringValue(Name);
            writer.WritePropertyName("description"u8);
            writer.WriteStringValue(Description);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        Hierarchy IJsonModel<Hierarchy>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<Hierarchy>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(Hierarchy)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeHierarchy(document.RootElement, options);
        }

        internal static Hierarchy DeserializeHierarchy(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string name = default;
            string description = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("description"u8))
                {
                    description = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new Hierarchy(name, description, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<Hierarchy>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<Hierarchy>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(Hierarchy)} does not support writing '{options.Format}' format.");
            }
        }

        Hierarchy IPersistableModel<Hierarchy>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<Hierarchy>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeHierarchy(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(Hierarchy)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<Hierarchy>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/InstanceHistoryListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a InstanceHistory list operation. </summary>
    internal partial class InstanceHistoryListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="InstanceHistoryListResult"/>. </summary>
        /// <param name="value"> The InstanceHistory items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal InstanceHistoryListResult(IEnumerable<EdgeDeploymentInstanceHistoryData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="InstanceHistoryListResult"/>. </summary>
        /// <param name="value"> The InstanceHistory items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal InstanceHistoryListResult(IReadOnlyList<EdgeDeploymentInstanceHistoryData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="InstanceHistoryListResult"/> for deserialization. </summary>
        internal InstanceHistoryListResult()
        {
        }

        /// <summary> The InstanceHistory items on this page. </summary>
        public IReadOnlyList<EdgeDeploymentInstanceHistoryData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/InstanceHistoryListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class InstanceHistoryListResult : IUtf8JsonSerializable, IJsonModel<InstanceHistoryListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<InstanceHistoryListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<InstanceHistoryListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceHistoryListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstanceHistoryListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        InstanceHistoryListResult IJsonModel<InstanceHistoryListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceHistoryListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstanceHistoryListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeInstanceHistoryListResult(document.RootElement, options);
        }

        internal static InstanceHistoryListResult DeserializeInstanceHistoryListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeDeploymentInstanceHistoryData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeDeploymentInstanceHistoryData> array = new List<EdgeDeploymentInstanceHistoryData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeDeploymentInstanceHistoryData.DeserializeEdgeDeploymentInstanceHistoryData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new InstanceHistoryListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<InstanceHistoryListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceHistoryListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(InstanceHistoryListResult)} does not support writing '{options.Format}' format.");
            }
        }

        InstanceHistoryListResult IPersistableModel<InstanceHistoryListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceHistoryListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeInstanceHistoryListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(InstanceHistoryListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<InstanceHistoryListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/InstanceHistoryProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Instance History Properties. </summary>
    public partial class InstanceHistoryProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="InstanceHistoryProperties"/>. </summary>
        /// <param name="solutionVersion"> Solution version of instance. </param>
        /// <param name="target"> Target of instance. </param>
        public InstanceHistoryProperties(SolutionVersionSnapshot solutionVersion, TargetSnapshot target)
        {
            SolutionVersion = solutionVersion;
            Target = target;
        }

        /// <summary> Initializes a new instance of <see cref="InstanceHistoryProperties"/>. </summary>
        /// <param name="solutionVersion"> Solution version of instance. </param>
        /// <param name="target"> Target of instance. </param>
        /// <param name="solutionScope"> Scope of instance. </param>
        /// <param name="activeState"> State of instance. </param>
        /// <param name="reconciliationPolicy"> Reconciliation policy of instance. </param>
        /// <param name="status"> Deployment Status of instance. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal InstanceHistoryProperties(SolutionVersionSnapshot solutionVersion, TargetSnapshot target, string solutionScope, ActiveState? activeState, ReconciliationPolicyProperties reconciliationPolicy, DeploymentStatus status, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersion = solutionVersion;
            Target = target;
            SolutionScope = solutionScope;
            ActiveState = activeState;
            ReconciliationPolicy = reconciliationPolicy;
            Status = status;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="InstanceHistoryProperties"/> for deserialization. </summary>
        internal InstanceHistoryProperties()
        {
        }

        /// <summary> Solution version of instance. </summary>
        public SolutionVersionSnapshot SolutionVersion { get; }
        /// <summary> Target of instance. </summary>
        public TargetSnapshot Target { get; }
        /// <summary> Scope of instance. </summary>
        public string SolutionScope { get; }
        /// <summary> State of instance. </summary>
        public ActiveState? ActiveState { get; set; }
        /// <summary> Reconciliation policy of instance. </summary>
        public ReconciliationPolicyProperties ReconciliationPolicy { get; }
        /// <summary> Deployment Status of instance. </summary>
        public DeploymentStatus Status { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/InstanceHistoryProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class InstanceHistoryProperties : IUtf8JsonSerializable, IJsonModel<InstanceHistoryProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<InstanceHistoryProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<InstanceHistoryProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceHistoryProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstanceHistoryProperties)} does not support writing '{format}' format.");
            }

            if (options.Format != "W")
            {
                writer.WritePropertyName("solutionVersion"u8);
                writer.WriteObjectValue(SolutionVersion, options);
            }
            if (options.Format != "W")
            {
                writer.WritePropertyName("target"u8);
                writer.WriteObjectValue(Target, options);
            }
            if (options.Format != "W" && Optional.IsDefined(SolutionScope))
            {
                writer.WritePropertyName("solutionScope"u8);
                writer.WriteStringValue(SolutionScope);
            }
            if (Optional.IsDefined(ActiveState))
            {
                writer.WritePropertyName("activeState"u8);
                writer.WriteStringValue(ActiveState.Value.ToString());
            }
            if (options.Format != "W" && Optional.IsDefined(ReconciliationPolicy))
            {
                writer.WritePropertyName("reconciliationPolicy"u8);
                writer.WriteObjectValue(ReconciliationPolicy, options);
            }
            if (options.Format != "W" && Optional.IsDefined(Status))
            {
                writer.WritePropertyName("status"u8);
                writer.WriteObjectValue(Status, options);
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        InstanceHistoryProperties IJsonModel<InstanceHistoryProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceHistoryProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstanceHistoryProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeInstanceHistoryProperties(document.RootElement, options);
        }

        internal static InstanceHistoryProperties DeserializeInstanceHistoryProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            SolutionVersionSnapshot solutionVersion = default;
            TargetSnapshot target = default;
            string solutionScope = default;
            ActiveState? activeState = default;
            ReconciliationPolicyProperties reconciliationPolicy = default;
            DeploymentStatus status = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersion"u8))
                {
                    solutionVersion = SolutionVersionSnapshot.DeserializeSolutionVersionSnapshot(property.Value, options);
                    continue;
                }
                if (property.NameEquals("target"u8))
                {
                    target = TargetSnapshot.DeserializeTargetSnapshot(property.Value, options);
                    continue;
                }
                if (property.NameEquals("solutionScope"u8))
                {
                    solutionScope = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("activeState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    activeState = new ActiveState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("reconciliationPolicy"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    reconciliationPolicy = ReconciliationPolicyProperties.DeserializeReconciliationPolicyProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    status = DeploymentStatus.DeserializeDeploymentStatus(property.Value, options);
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new InstanceHistoryProperties(
                solutionVersion,
                target,
                solutionScope,
                activeState,
                reconciliationPolicy,
                status,
                provisioningState,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<InstanceHistoryProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceHistoryProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(InstanceHistoryProperties)} does not support writing '{options.Format}' format.");
            }
        }

        InstanceHistoryProperties IPersistableModel<InstanceHistoryProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceHistoryProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeInstanceHistoryProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(InstanceHistoryProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<InstanceHistoryProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/InstanceListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a Instance list operation. </summary>
    internal partial class InstanceListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="InstanceListResult"/>. </summary>
        /// <param name="value"> The Instance items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal InstanceListResult(IEnumerable<EdgeDeploymentInstanceData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="InstanceListResult"/>. </summary>
        /// <param name="value"> The Instance items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal InstanceListResult(IReadOnlyList<EdgeDeploymentInstanceData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="InstanceListResult"/> for deserialization. </summary>
        internal InstanceListResult()
        {
        }

        /// <summary> The Instance items on this page. </summary>
        public IReadOnlyList<EdgeDeploymentInstanceData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/InstanceListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class InstanceListResult : IUtf8JsonSerializable, IJsonModel<InstanceListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<InstanceListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<InstanceListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstanceListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        InstanceListResult IJsonModel<InstanceListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstanceListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeInstanceListResult(document.RootElement, options);
        }

        internal static InstanceListResult DeserializeInstanceListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeDeploymentInstanceData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeDeploymentInstanceData> array = new List<EdgeDeploymentInstanceData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeDeploymentInstanceData.DeserializeEdgeDeploymentInstanceData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new InstanceListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<InstanceListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(InstanceListResult)} does not support writing '{options.Format}' format.");
            }
        }

        InstanceListResult IPersistableModel<InstanceListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeInstanceListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(InstanceListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<InstanceListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/InstanceProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Instance Properties. </summary>
    public partial class InstanceProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="InstanceProperties"/>. </summary>
        /// <param name="solutionVersionId"> Solution version of instance. </param>
        /// <param name="targetId"> Target of instance. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionId"/> or <paramref name="targetId"/> is null. </exception>
        public InstanceProperties(string solutionVersionId, string targetId)
        {
            Argument.AssertNotNull(solutionVersionId, nameof(solutionVersionId));
            Argument.AssertNotNull(targetId, nameof(targetId));

            SolutionVersionId = solutionVersionId;
            TargetId = targetId;
        }

        /// <summary> Initializes a new instance of <see cref="InstanceProperties"/>. </summary>
        /// <param name="solutionVersionId"> Solution version of instance. </param>
        /// <param name="targetId"> Target of instance. </param>
        /// <param name="activeState"> State of instance. </param>
        /// <param name="reconciliationPolicy"> Reconciliation policy of instance. </param>
        /// <param name="solutionScope"> Scope of instance. </param>
        /// <param name="status"> Status of instance. </param>
        /// <param name="deploymentTimestampEpoch"> Deployment timestamp of instance. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal InstanceProperties(string solutionVersionId, string targetId, ActiveState? activeState, ReconciliationPolicyProperties reconciliationPolicy, string solutionScope, DeploymentStatus status, long? deploymentTimestampEpoch, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersionId = solutionVersionId;
            TargetId = targetId;
            ActiveState = activeState;
            ReconciliationPolicy = reconciliationPolicy;
            SolutionScope = solutionScope;
            Status = status;
            DeploymentTimestampEpoch = deploymentTimestampEpoch;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="InstanceProperties"/> for deserialization. </summary>
        internal InstanceProperties()
        {
        }

        /// <summary> Solution version of instance. </summary>
        public string SolutionVersionId { get; set; }
        /// <summary> Target of instance. </summary>
        public string TargetId { get; set; }
        /// <summary> State of instance. </summary>
        public ActiveState? ActiveState { get; set; }
        /// <summary> Reconciliation policy of instance. </summary>
        public ReconciliationPolicyProperties ReconciliationPolicy { get; set; }
        /// <summary> Scope of instance. </summary>
        public string SolutionScope { get; set; }
        /// <summary> Status of instance. </summary>
        public DeploymentStatus Status { get; }
        /// <summary> Deployment timestamp of instance. </summary>
        public long? DeploymentTimestampEpoch { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/InstanceProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class InstanceProperties : IUtf8JsonSerializable, IJsonModel<InstanceProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<InstanceProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<InstanceProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstanceProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionVersionId"u8);
            writer.WriteStringValue(SolutionVersionId);
            writer.WritePropertyName("targetId"u8);
            writer.WriteStringValue(TargetId);
            if (Optional.IsDefined(ActiveState))
            {
                writer.WritePropertyName("activeState"u8);
                writer.WriteStringValue(ActiveState.Value.ToString());
            }
            if (Optional.IsDefined(ReconciliationPolicy))
            {
                writer.WritePropertyName("reconciliationPolicy"u8);
                writer.WriteObjectValue(ReconciliationPolicy, options);
            }
            if (Optional.IsDefined(SolutionScope))
            {
                writer.WritePropertyName("solutionScope"u8);
                writer.WriteStringValue(SolutionScope);
            }
            if (options.Format != "W" && Optional.IsDefined(Status))
            {
                writer.WritePropertyName("status"u8);
                writer.WriteObjectValue(Status, options);
            }
            if (options.Format != "W" && Optional.IsDefined(DeploymentTimestampEpoch))
            {
                writer.WritePropertyName("deploymentTimestampEpoch"u8);
                writer.WriteNumberValue(DeploymentTimestampEpoch.Value);
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        InstanceProperties IJsonModel<InstanceProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstanceProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeInstanceProperties(document.RootElement, options);
        }

        internal static InstanceProperties DeserializeInstanceProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionVersionId = default;
            string targetId = default;
            ActiveState? activeState = default;
            ReconciliationPolicyProperties reconciliationPolicy = default;
            string solutionScope = default;
            DeploymentStatus status = default;
            long? deploymentTimestampEpoch = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersionId"u8))
                {
                    solutionVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("targetId"u8))
                {
                    targetId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("activeState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    activeState = new ActiveState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("reconciliationPolicy"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    reconciliationPolicy = ReconciliationPolicyProperties.DeserializeReconciliationPolicyProperties(property.Value, options);
                    continue;
                }
                if (property.NameEquals("solutionScope"u8))
                {
                    solutionScope = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    status = DeploymentStatus.DeserializeDeploymentStatus(property.Value, options);
                    continue;
                }
                if (property.NameEquals("deploymentTimestampEpoch"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    deploymentTimestampEpoch = property.Value.GetInt64();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new InstanceProperties(
                solutionVersionId,
                targetId,
                activeState,
                reconciliationPolicy,
                solutionScope,
                status,
                deploymentTimestampEpoch,
                provisioningState,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<InstanceProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(InstanceProperties)} does not support writing '{options.Format}' format.");
            }
        }

        InstanceProperties IPersistableModel<InstanceProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstanceProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeInstanceProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(InstanceProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<InstanceProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/InstancePropertiesUpdate.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Instance Properties. </summary>
    public partial class InstancePropertiesUpdate
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="InstancePropertiesUpdate"/>. </summary>
        public InstancePropertiesUpdate()
        {
        }

        /// <summary> Initializes a new instance of <see cref="InstancePropertiesUpdate"/>. </summary>
        /// <param name="solutionVersionId"> Solution version of instance. </param>
        /// <param name="targetId"> Target of instance. </param>
        /// <param name="activeState"> State of instance. </param>
        /// <param name="reconciliationPolicy"> Reconciliation policy of instance. </param>
        /// <param name="solutionScope"> Scope of instance. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal InstancePropertiesUpdate(string solutionVersionId, string targetId, ActiveState? activeState, ReconciliationPolicyPropertiesUpdate reconciliationPolicy, string solutionScope, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersionId = solutionVersionId;
            TargetId = targetId;
            ActiveState = activeState;
            ReconciliationPolicy = reconciliationPolicy;
            SolutionScope = solutionScope;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Solution version of instance. </summary>
        public string SolutionVersionId { get; set; }
        /// <summary> Target of instance. </summary>
        public string TargetId { get; set; }
        /// <summary> State of instance. </summary>
        public ActiveState? ActiveState { get; set; }
        /// <summary> Reconciliation policy of instance. </summary>
        public ReconciliationPolicyPropertiesUpdate ReconciliationPolicy { get; set; }
        /// <summary> Scope of instance. </summary>
        public string SolutionScope { get; set; }
    }
}



================================================
FILE: Generated/Models/InstancePropertiesUpdate.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class InstancePropertiesUpdate : IUtf8JsonSerializable, IJsonModel<InstancePropertiesUpdate>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<InstancePropertiesUpdate>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<InstancePropertiesUpdate>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstancePropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstancePropertiesUpdate)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(SolutionVersionId))
            {
                writer.WritePropertyName("solutionVersionId"u8);
                writer.WriteStringValue(SolutionVersionId);
            }
            if (Optional.IsDefined(TargetId))
            {
                writer.WritePropertyName("targetId"u8);
                writer.WriteStringValue(TargetId);
            }
            if (Optional.IsDefined(ActiveState))
            {
                writer.WritePropertyName("activeState"u8);
                writer.WriteStringValue(ActiveState.Value.ToString());
            }
            if (Optional.IsDefined(ReconciliationPolicy))
            {
                writer.WritePropertyName("reconciliationPolicy"u8);
                writer.WriteObjectValue(ReconciliationPolicy, options);
            }
            if (Optional.IsDefined(SolutionScope))
            {
                writer.WritePropertyName("solutionScope"u8);
                writer.WriteStringValue(SolutionScope);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        InstancePropertiesUpdate IJsonModel<InstancePropertiesUpdate>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstancePropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(InstancePropertiesUpdate)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeInstancePropertiesUpdate(document.RootElement, options);
        }

        internal static InstancePropertiesUpdate DeserializeInstancePropertiesUpdate(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionVersionId = default;
            string targetId = default;
            ActiveState? activeState = default;
            ReconciliationPolicyPropertiesUpdate reconciliationPolicy = default;
            string solutionScope = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersionId"u8))
                {
                    solutionVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("targetId"u8))
                {
                    targetId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("activeState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    activeState = new ActiveState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("reconciliationPolicy"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    reconciliationPolicy = ReconciliationPolicyPropertiesUpdate.DeserializeReconciliationPolicyPropertiesUpdate(property.Value, options);
                    continue;
                }
                if (property.NameEquals("solutionScope"u8))
                {
                    solutionScope = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new InstancePropertiesUpdate(
                solutionVersionId,
                targetId,
                activeState,
                reconciliationPolicy,
                solutionScope,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<InstancePropertiesUpdate>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstancePropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(InstancePropertiesUpdate)} does not support writing '{options.Format}' format.");
            }
        }

        InstancePropertiesUpdate IPersistableModel<InstancePropertiesUpdate>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<InstancePropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeInstancePropertiesUpdate(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(InstancePropertiesUpdate)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<InstancePropertiesUpdate>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/JobListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a Job list operation. </summary>
    internal partial class JobListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="JobListResult"/>. </summary>
        /// <param name="value"> The Job items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal JobListResult(IEnumerable<EdgeJobData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="JobListResult"/>. </summary>
        /// <param name="value"> The Job items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal JobListResult(IReadOnlyList<EdgeJobData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="JobListResult"/> for deserialization. </summary>
        internal JobListResult()
        {
        }

        /// <summary> The Job items on this page. </summary>
        public IReadOnlyList<EdgeJobData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/JobListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class JobListResult : IUtf8JsonSerializable, IJsonModel<JobListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<JobListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<JobListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        JobListResult IJsonModel<JobListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeJobListResult(document.RootElement, options);
        }

        internal static JobListResult DeserializeJobListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeJobData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeJobData> array = new List<EdgeJobData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeJobData.DeserializeEdgeJobData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new JobListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<JobListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(JobListResult)} does not support writing '{options.Format}' format.");
            }
        }

        JobListResult IPersistableModel<JobListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeJobListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(JobListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<JobListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/JobParameterBase.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary>
    /// Base Job Parameter
    /// Please note <see cref="JobParameterBase"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
    /// The available derived classes include <see cref="WorkloadOrchestrationDeployJobContent"/> and <see cref="WorkloadOrchestrationPublishJobContent"/>.
    /// </summary>
    public abstract partial class JobParameterBase
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private protected IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="JobParameterBase"/>. </summary>
        protected JobParameterBase()
        {
        }

        /// <summary> Initializes a new instance of <see cref="JobParameterBase"/>. </summary>
        /// <param name="jobType"> Job type discriminator value. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal JobParameterBase(JobType jobType, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            JobType = jobType;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Job type discriminator value. </summary>
        internal JobType JobType { get; set; }
    }
}



================================================
FILE: Generated/Models/JobParameterBase.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    [PersistableModelProxy(typeof(UnknownJobParameterBase))]
    public partial class JobParameterBase : IUtf8JsonSerializable, IJsonModel<JobParameterBase>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<JobParameterBase>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<JobParameterBase>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobParameterBase>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobParameterBase)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("jobType"u8);
            writer.WriteStringValue(JobType.ToString());
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        JobParameterBase IJsonModel<JobParameterBase>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobParameterBase>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobParameterBase)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeJobParameterBase(document.RootElement, options);
        }

        internal static JobParameterBase DeserializeJobParameterBase(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            if (element.TryGetProperty("jobType", out JsonElement discriminator))
            {
                switch (discriminator.GetString())
                {
                    case "deploy": return WorkloadOrchestrationDeployJobContent.DeserializeWorkloadOrchestrationDeployJobContent(element, options);
                    case "publish": return WorkloadOrchestrationPublishJobContent.DeserializeWorkloadOrchestrationPublishJobContent(element, options);
                }
            }
            return UnknownJobParameterBase.DeserializeUnknownJobParameterBase(element, options);
        }

        BinaryData IPersistableModel<JobParameterBase>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobParameterBase>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(JobParameterBase)} does not support writing '{options.Format}' format.");
            }
        }

        JobParameterBase IPersistableModel<JobParameterBase>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobParameterBase>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeJobParameterBase(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(JobParameterBase)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<JobParameterBase>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/JobProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Properties of a Job resource, including type, status, parameters, steps, and error details. </summary>
    public partial class JobProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="JobProperties"/>. </summary>
        /// <param name="jobType"> The type of job. </param>
        /// <param name="status"> Status of the job. </param>
        public JobProperties(JobType jobType, JobStatus status)
        {
            JobType = jobType;
            Status = status;
            Steps = new ChangeTrackingList<JobStep>();
        }

        /// <summary> Initializes a new instance of <see cref="JobProperties"/>. </summary>
        /// <param name="jobType"> The type of job. </param>
        /// <param name="startOn"> Start time of the job (ISO8601). </param>
        /// <param name="endOn"> End time of the job (ISO8601). </param>
        /// <param name="status"> Status of the job. </param>
        /// <param name="jobParameter">
        /// Parameters for the job.
        /// Please note <see cref="JobParameterBase"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="WorkloadOrchestrationDeployJobContent"/> and <see cref="WorkloadOrchestrationPublishJobContent"/>.
        /// </param>
        /// <param name="correlationId"> Correlation ID for tracking. </param>
        /// <param name="steps"> Steps and substatuses for the job. </param>
        /// <param name="triggeredBy"> The OID or identity that triggered the job. </param>
        /// <param name="provisioningState"> Provisioning state of the resource. </param>
        /// <param name="errorDetails"> Error Details if any failure is there. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal JobProperties(JobType jobType, DateTimeOffset? startOn, DateTimeOffset? endOn, JobStatus status, JobParameterBase jobParameter, string correlationId, IList<JobStep> steps, string triggeredBy, ProvisioningState? provisioningState, ResponseError errorDetails, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            JobType = jobType;
            StartOn = startOn;
            EndOn = endOn;
            Status = status;
            JobParameter = jobParameter;
            CorrelationId = correlationId;
            Steps = steps;
            TriggeredBy = triggeredBy;
            ProvisioningState = provisioningState;
            ErrorDetails = errorDetails;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="JobProperties"/> for deserialization. </summary>
        internal JobProperties()
        {
        }

        /// <summary> The type of job. </summary>
        public JobType JobType { get; set; }
        /// <summary> Start time of the job (ISO8601). </summary>
        public DateTimeOffset? StartOn { get; set; }
        /// <summary> End time of the job (ISO8601). </summary>
        public DateTimeOffset? EndOn { get; set; }
        /// <summary> Status of the job. </summary>
        public JobStatus Status { get; }
        /// <summary>
        /// Parameters for the job.
        /// Please note <see cref="JobParameterBase"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="WorkloadOrchestrationDeployJobContent"/> and <see cref="WorkloadOrchestrationPublishJobContent"/>.
        /// </summary>
        public JobParameterBase JobParameter { get; set; }
        /// <summary> Correlation ID for tracking. </summary>
        public string CorrelationId { get; set; }
        /// <summary> Steps and substatuses for the job. </summary>
        public IList<JobStep> Steps { get; }
        /// <summary> The OID or identity that triggered the job. </summary>
        public string TriggeredBy { get; set; }
        /// <summary> Provisioning state of the resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
        /// <summary> Error Details if any failure is there. </summary>
        public ResponseError ErrorDetails { get; }
    }
}



================================================
FILE: Generated/Models/JobProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class JobProperties : IUtf8JsonSerializable, IJsonModel<JobProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<JobProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<JobProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("jobType"u8);
            writer.WriteStringValue(JobType.ToString());
            if (Optional.IsDefined(StartOn))
            {
                writer.WritePropertyName("startTime"u8);
                writer.WriteStringValue(StartOn.Value, "O");
            }
            if (Optional.IsDefined(EndOn))
            {
                writer.WritePropertyName("endTime"u8);
                writer.WriteStringValue(EndOn.Value, "O");
            }
            if (options.Format != "W")
            {
                writer.WritePropertyName("status"u8);
                writer.WriteStringValue(Status.ToString());
            }
            if (Optional.IsDefined(JobParameter))
            {
                writer.WritePropertyName("jobParameter"u8);
                writer.WriteObjectValue(JobParameter, options);
            }
            if (Optional.IsDefined(CorrelationId))
            {
                writer.WritePropertyName("correlationId"u8);
                writer.WriteStringValue(CorrelationId);
            }
            if (Optional.IsCollectionDefined(Steps))
            {
                writer.WritePropertyName("steps"u8);
                writer.WriteStartArray();
                foreach (var item in Steps)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (Optional.IsDefined(TriggeredBy))
            {
                writer.WritePropertyName("triggeredBy"u8);
                writer.WriteStringValue(TriggeredBy);
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && Optional.IsDefined(ErrorDetails))
            {
                writer.WritePropertyName("errorDetails"u8);
                ((IJsonModel<ResponseError>)ErrorDetails).Write(writer, options);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        JobProperties IJsonModel<JobProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeJobProperties(document.RootElement, options);
        }

        internal static JobProperties DeserializeJobProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            JobType jobType = default;
            DateTimeOffset? startTime = default;
            DateTimeOffset? endTime = default;
            JobStatus status = default;
            JobParameterBase jobParameter = default;
            string correlationId = default;
            IList<JobStep> steps = default;
            string triggeredBy = default;
            ProvisioningState? provisioningState = default;
            ResponseError errorDetails = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("jobType"u8))
                {
                    jobType = new JobType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("startTime"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    startTime = property.Value.GetDateTimeOffset("O");
                    continue;
                }
                if (property.NameEquals("endTime"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    endTime = property.Value.GetDateTimeOffset("O");
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    status = new JobStatus(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("jobParameter"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    jobParameter = JobParameterBase.DeserializeJobParameterBase(property.Value, options);
                    continue;
                }
                if (property.NameEquals("correlationId"u8))
                {
                    correlationId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("steps"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<JobStep> array = new List<JobStep>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(JobStep.DeserializeJobStep(item, options));
                    }
                    steps = array;
                    continue;
                }
                if (property.NameEquals("triggeredBy"u8))
                {
                    triggeredBy = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("errorDetails"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    errorDetails = ModelReaderWriter.Read<ResponseError>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new JobProperties(
                jobType,
                startTime,
                endTime,
                status,
                jobParameter,
                correlationId,
                steps ?? new ChangeTrackingList<JobStep>(),
                triggeredBy,
                provisioningState,
                errorDetails,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<JobProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(JobProperties)} does not support writing '{options.Format}' format.");
            }
        }

        JobProperties IPersistableModel<JobProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeJobProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(JobProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<JobProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/JobStatus.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Status of a job or job step. </summary>
    public readonly partial struct JobStatus : IEquatable<JobStatus>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="JobStatus"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public JobStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string NotStartedValue = "NotStarted";
        private const string InProgressValue = "InProgress";
        private const string SucceededValue = "Succeeded";
        private const string FailedValue = "Failed";

        /// <summary> The job or step is not started. </summary>
        public static JobStatus NotStarted { get; } = new JobStatus(NotStartedValue);
        /// <summary> The job or step is in progress. </summary>
        public static JobStatus InProgress { get; } = new JobStatus(InProgressValue);
        /// <summary> The job or step succeeded. </summary>
        public static JobStatus Succeeded { get; } = new JobStatus(SucceededValue);
        /// <summary> The job or step failed. </summary>
        public static JobStatus Failed { get; } = new JobStatus(FailedValue);
        /// <summary> Determines if two <see cref="JobStatus"/> values are the same. </summary>
        public static bool operator ==(JobStatus left, JobStatus right) => left.Equals(right);
        /// <summary> Determines if two <see cref="JobStatus"/> values are not the same. </summary>
        public static bool operator !=(JobStatus left, JobStatus right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="JobStatus"/>. </summary>
        public static implicit operator JobStatus(string value) => new JobStatus(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is JobStatus other && Equals(other);
        /// <inheritdoc />
        public bool Equals(JobStatus other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/JobStep.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Job Step. </summary>
    public partial class JobStep
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="JobStep"/>. </summary>
        /// <param name="name"> Name of the step. </param>
        /// <param name="status"> Status of the step. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        public JobStep(string name, JobStatus status)
        {
            Argument.AssertNotNull(name, nameof(name));

            Name = name;
            Status = status;
            Steps = new ChangeTrackingList<JobStep>();
        }

        /// <summary> Initializes a new instance of <see cref="JobStep"/>. </summary>
        /// <param name="name"> Name of the step. </param>
        /// <param name="status"> Status of the step. </param>
        /// <param name="startOn"> Start time of the step (ISO8601). </param>
        /// <param name="endOn"> End time of the step (ISO8601). </param>
        /// <param name="message"> Message for the step. </param>
        /// <param name="statistics">
        /// Statistics for the step
        /// Please note <see cref="JobStepStatisticsBase"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="DeployJobStepStatistics"/> and <see cref="PublishJobStepStatistics"/>.
        /// </param>
        /// <param name="steps"> Nested substeps for this step. </param>
        /// <param name="errorDetails"> Error Details if any failure is there. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal JobStep(string name, JobStatus status, DateTimeOffset? startOn, DateTimeOffset? endOn, string message, JobStepStatisticsBase statistics, IList<JobStep> steps, ResponseError errorDetails, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Name = name;
            Status = status;
            StartOn = startOn;
            EndOn = endOn;
            Message = message;
            Statistics = statistics;
            Steps = steps;
            ErrorDetails = errorDetails;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="JobStep"/> for deserialization. </summary>
        internal JobStep()
        {
        }

        /// <summary> Name of the step. </summary>
        public string Name { get; set; }
        /// <summary> Status of the step. </summary>
        public JobStatus Status { get; }
        /// <summary> Start time of the step (ISO8601). </summary>
        public DateTimeOffset? StartOn { get; set; }
        /// <summary> End time of the step (ISO8601). </summary>
        public DateTimeOffset? EndOn { get; set; }
        /// <summary> Message for the step. </summary>
        public string Message { get; set; }
        /// <summary>
        /// Statistics for the step
        /// Please note <see cref="JobStepStatisticsBase"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="DeployJobStepStatistics"/> and <see cref="PublishJobStepStatistics"/>.
        /// </summary>
        public JobStepStatisticsBase Statistics { get; set; }
        /// <summary> Nested substeps for this step. </summary>
        public IList<JobStep> Steps { get; }
        /// <summary> Error Details if any failure is there. </summary>
        public ResponseError ErrorDetails { get; }
    }
}



================================================
FILE: Generated/Models/JobStep.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class JobStep : IUtf8JsonSerializable, IJsonModel<JobStep>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<JobStep>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<JobStep>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStep>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobStep)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("name"u8);
            writer.WriteStringValue(Name);
            if (options.Format != "W")
            {
                writer.WritePropertyName("status"u8);
                writer.WriteStringValue(Status.ToString());
            }
            if (Optional.IsDefined(StartOn))
            {
                writer.WritePropertyName("startTime"u8);
                writer.WriteStringValue(StartOn.Value, "O");
            }
            if (Optional.IsDefined(EndOn))
            {
                writer.WritePropertyName("endTime"u8);
                writer.WriteStringValue(EndOn.Value, "O");
            }
            if (Optional.IsDefined(Message))
            {
                writer.WritePropertyName("message"u8);
                writer.WriteStringValue(Message);
            }
            if (Optional.IsDefined(Statistics))
            {
                writer.WritePropertyName("statistics"u8);
                writer.WriteObjectValue(Statistics, options);
            }
            if (Optional.IsCollectionDefined(Steps))
            {
                writer.WritePropertyName("steps"u8);
                writer.WriteStartArray();
                foreach (var item in Steps)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && Optional.IsDefined(ErrorDetails))
            {
                writer.WritePropertyName("errorDetails"u8);
                ((IJsonModel<ResponseError>)ErrorDetails).Write(writer, options);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        JobStep IJsonModel<JobStep>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStep>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobStep)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeJobStep(document.RootElement, options);
        }

        internal static JobStep DeserializeJobStep(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string name = default;
            JobStatus status = default;
            DateTimeOffset? startTime = default;
            DateTimeOffset? endTime = default;
            string message = default;
            JobStepStatisticsBase statistics = default;
            IList<JobStep> steps = default;
            ResponseError errorDetails = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    status = new JobStatus(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("startTime"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    startTime = property.Value.GetDateTimeOffset("O");
                    continue;
                }
                if (property.NameEquals("endTime"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    endTime = property.Value.GetDateTimeOffset("O");
                    continue;
                }
                if (property.NameEquals("message"u8))
                {
                    message = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("statistics"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    statistics = JobStepStatisticsBase.DeserializeJobStepStatisticsBase(property.Value, options);
                    continue;
                }
                if (property.NameEquals("steps"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<JobStep> array = new List<JobStep>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(DeserializeJobStep(item, options));
                    }
                    steps = array;
                    continue;
                }
                if (property.NameEquals("errorDetails"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    errorDetails = ModelReaderWriter.Read<ResponseError>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new JobStep(
                name,
                status,
                startTime,
                endTime,
                message,
                statistics,
                steps ?? new ChangeTrackingList<JobStep>(),
                errorDetails,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<JobStep>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStep>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(JobStep)} does not support writing '{options.Format}' format.");
            }
        }

        JobStep IPersistableModel<JobStep>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStep>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeJobStep(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(JobStep)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<JobStep>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/JobStepStatisticsBase.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary>
    /// Base Job Step Statistics
    /// Please note <see cref="JobStepStatisticsBase"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
    /// The available derived classes include <see cref="DeployJobStepStatistics"/> and <see cref="PublishJobStepStatistics"/>.
    /// </summary>
    public abstract partial class JobStepStatisticsBase
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private protected IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="JobStepStatisticsBase"/>. </summary>
        protected JobStepStatisticsBase()
        {
        }

        /// <summary> Initializes a new instance of <see cref="JobStepStatisticsBase"/>. </summary>
        /// <param name="statisticsType"> Statistics type discriminator value. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal JobStepStatisticsBase(JobType statisticsType, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            StatisticsType = statisticsType;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Statistics type discriminator value. </summary>
        internal JobType StatisticsType { get; set; }
    }
}



================================================
FILE: Generated/Models/JobStepStatisticsBase.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    [PersistableModelProxy(typeof(UnknownJobStepStatisticsBase))]
    public partial class JobStepStatisticsBase : IUtf8JsonSerializable, IJsonModel<JobStepStatisticsBase>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<JobStepStatisticsBase>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<JobStepStatisticsBase>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStepStatisticsBase>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobStepStatisticsBase)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("statisticsType"u8);
            writer.WriteStringValue(StatisticsType.ToString());
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        JobStepStatisticsBase IJsonModel<JobStepStatisticsBase>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStepStatisticsBase>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobStepStatisticsBase)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeJobStepStatisticsBase(document.RootElement, options);
        }

        internal static JobStepStatisticsBase DeserializeJobStepStatisticsBase(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            if (element.TryGetProperty("statisticsType", out JsonElement discriminator))
            {
                switch (discriminator.GetString())
                {
                    case "deploy": return DeployJobStepStatistics.DeserializeDeployJobStepStatistics(element, options);
                    case "publish": return PublishJobStepStatistics.DeserializePublishJobStepStatistics(element, options);
                }
            }
            return UnknownJobStepStatisticsBase.DeserializeUnknownJobStepStatisticsBase(element, options);
        }

        BinaryData IPersistableModel<JobStepStatisticsBase>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStepStatisticsBase>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(JobStepStatisticsBase)} does not support writing '{options.Format}' format.");
            }
        }

        JobStepStatisticsBase IPersistableModel<JobStepStatisticsBase>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStepStatisticsBase>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeJobStepStatisticsBase(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(JobStepStatisticsBase)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<JobStepStatisticsBase>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/JobType.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> JobType for the job. Supports extensibility via string values. </summary>
    public readonly partial struct JobType : IEquatable<JobType>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="JobType"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public JobType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string DeployValue = "deploy";
        private const string PublishValue = "publish";
        private const string StagingValue = "staging";
        private const string ExternalValidationValue = "externalValidation";

        /// <summary> A deployment job. </summary>
        public static JobType Deploy { get; } = new JobType(DeployValue);
        /// <summary> A publish job. </summary>
        public static JobType Publish { get; } = new JobType(PublishValue);
        /// <summary> A staging job. </summary>
        public static JobType Staging { get; } = new JobType(StagingValue);
        /// <summary> A validation job. </summary>
        public static JobType ExternalValidation { get; } = new JobType(ExternalValidationValue);
        /// <summary> Determines if two <see cref="JobType"/> values are the same. </summary>
        public static bool operator ==(JobType left, JobType right) => left.Equals(right);
        /// <summary> Determines if two <see cref="JobType"/> values are not the same. </summary>
        public static bool operator !=(JobType left, JobType right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="JobType"/>. </summary>
        public static implicit operator JobType(string value) => new JobType(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is JobType other && Equals(other);
        /// <inheritdoc />
        public bool Equals(JobType other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/OrchestratorType.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Available Orchestrator types. </summary>
    public readonly partial struct OrchestratorType : IEquatable<OrchestratorType>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="OrchestratorType"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public OrchestratorType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string TOValue = "TO";

        /// <summary> Default type. </summary>
        public static OrchestratorType TO { get; } = new OrchestratorType(TOValue);
        /// <summary> Determines if two <see cref="OrchestratorType"/> values are the same. </summary>
        public static bool operator ==(OrchestratorType left, OrchestratorType right) => left.Equals(right);
        /// <summary> Determines if two <see cref="OrchestratorType"/> values are not the same. </summary>
        public static bool operator !=(OrchestratorType left, OrchestratorType right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="OrchestratorType"/>. </summary>
        public static implicit operator OrchestratorType(string value) => new OrchestratorType(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is OrchestratorType other && Equals(other);
        /// <inheritdoc />
        public bool Equals(OrchestratorType other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/ProvisioningState.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Provisioning state of resource. </summary>
    public readonly partial struct ProvisioningState : IEquatable<ProvisioningState>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="ProvisioningState"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public ProvisioningState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string SucceededValue = "Succeeded";
        private const string FailedValue = "Failed";
        private const string CanceledValue = "Canceled";
        private const string InitializedValue = "Initialized";
        private const string InprogressValue = "InProgress";
        private const string DeletingValue = "Deleting";

        /// <summary> Resource has been created. </summary>
        public static ProvisioningState Succeeded { get; } = new ProvisioningState(SucceededValue);
        /// <summary> Resource creation failed. </summary>
        public static ProvisioningState Failed { get; } = new ProvisioningState(FailedValue);
        /// <summary> Resource creation was canceled. </summary>
        public static ProvisioningState Canceled { get; } = new ProvisioningState(CanceledValue);
        /// <summary> Resource Provisioning is initialized. </summary>
        public static ProvisioningState Initialized { get; } = new ProvisioningState(InitializedValue);
        /// <summary> Resource Provisioning is in progress. </summary>
        public static ProvisioningState Inprogress { get; } = new ProvisioningState(InprogressValue);
        /// <summary> Resource Provisioning is deleting. </summary>
        public static ProvisioningState Deleting { get; } = new ProvisioningState(DeletingValue);
        /// <summary> Determines if two <see cref="ProvisioningState"/> values are the same. </summary>
        public static bool operator ==(ProvisioningState left, ProvisioningState right) => left.Equals(right);
        /// <summary> Determines if two <see cref="ProvisioningState"/> values are not the same. </summary>
        public static bool operator !=(ProvisioningState left, ProvisioningState right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="ProvisioningState"/>. </summary>
        public static implicit operator ProvisioningState(string value) => new ProvisioningState(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is ProvisioningState other && Equals(other);
        /// <inheritdoc />
        public bool Equals(ProvisioningState other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/PublishJobStepStatistics.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Publish statistics for a job step, including total, success, and failed counts. </summary>
    public partial class PublishJobStepStatistics : JobStepStatisticsBase
    {
        /// <summary> Initializes a new instance of <see cref="PublishJobStepStatistics"/>. </summary>
        public PublishJobStepStatistics()
        {
            StatisticsType = JobType.Publish;
        }

        /// <summary> Initializes a new instance of <see cref="PublishJobStepStatistics"/>. </summary>
        /// <param name="statisticsType"> Statistics type discriminator value. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        /// <param name="totalCount"> Total count of items processed in this step. </param>
        /// <param name="successCount"> Count of successful items in this step. </param>
        /// <param name="failedCount"> Count of failed items in this step. </param>
        internal PublishJobStepStatistics(JobType statisticsType, IDictionary<string, BinaryData> serializedAdditionalRawData, int? totalCount, int? successCount, int? failedCount) : base(statisticsType, serializedAdditionalRawData)
        {
            TotalCount = totalCount;
            SuccessCount = successCount;
            FailedCount = failedCount;
            StatisticsType = statisticsType;
        }

        /// <summary> Total count of items processed in this step. </summary>
        public int? TotalCount { get; set; }
        /// <summary> Count of successful items in this step. </summary>
        public int? SuccessCount { get; set; }
        /// <summary> Count of failed items in this step. </summary>
        public int? FailedCount { get; set; }
    }
}



================================================
FILE: Generated/Models/PublishJobStepStatistics.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class PublishJobStepStatistics : IUtf8JsonSerializable, IJsonModel<PublishJobStepStatistics>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<PublishJobStepStatistics>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<PublishJobStepStatistics>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<PublishJobStepStatistics>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(PublishJobStepStatistics)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(TotalCount))
            {
                writer.WritePropertyName("totalCount"u8);
                writer.WriteNumberValue(TotalCount.Value);
            }
            if (Optional.IsDefined(SuccessCount))
            {
                writer.WritePropertyName("successCount"u8);
                writer.WriteNumberValue(SuccessCount.Value);
            }
            if (Optional.IsDefined(FailedCount))
            {
                writer.WritePropertyName("failedCount"u8);
                writer.WriteNumberValue(FailedCount.Value);
            }
        }

        PublishJobStepStatistics IJsonModel<PublishJobStepStatistics>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<PublishJobStepStatistics>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(PublishJobStepStatistics)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializePublishJobStepStatistics(document.RootElement, options);
        }

        internal static PublishJobStepStatistics DeserializePublishJobStepStatistics(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            int? totalCount = default;
            int? successCount = default;
            int? failedCount = default;
            JobType statisticsType = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("totalCount"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    totalCount = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("successCount"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    successCount = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("failedCount"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    failedCount = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("statisticsType"u8))
                {
                    statisticsType = new JobType(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new PublishJobStepStatistics(statisticsType, serializedAdditionalRawData, totalCount, successCount, failedCount);
        }

        BinaryData IPersistableModel<PublishJobStepStatistics>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<PublishJobStepStatistics>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(PublishJobStepStatistics)} does not support writing '{options.Format}' format.");
            }
        }

        PublishJobStepStatistics IPersistableModel<PublishJobStepStatistics>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<PublishJobStepStatistics>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializePublishJobStepStatistics(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(PublishJobStepStatistics)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<PublishJobStepStatistics>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ReconciliationPolicyProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Defines a ReconciliationPolicy. </summary>
    public partial class ReconciliationPolicyProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ReconciliationPolicyProperties"/>. </summary>
        /// <param name="state"> The state of the ReconciliationPolicy. </param>
        /// <param name="interval"> Policy interval. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="interval"/> is null. </exception>
        public ReconciliationPolicyProperties(ReconciliationState state, string interval)
        {
            Argument.AssertNotNull(interval, nameof(interval));

            State = state;
            Interval = interval;
        }

        /// <summary> Initializes a new instance of <see cref="ReconciliationPolicyProperties"/>. </summary>
        /// <param name="state"> The state of the ReconciliationPolicy. </param>
        /// <param name="interval"> Policy interval. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ReconciliationPolicyProperties(ReconciliationState state, string interval, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            State = state;
            Interval = interval;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ReconciliationPolicyProperties"/> for deserialization. </summary>
        internal ReconciliationPolicyProperties()
        {
        }

        /// <summary> The state of the ReconciliationPolicy. </summary>
        public ReconciliationState State { get; set; }
        /// <summary> Policy interval. </summary>
        public string Interval { get; set; }
    }
}



================================================
FILE: Generated/Models/ReconciliationPolicyProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ReconciliationPolicyProperties : IUtf8JsonSerializable, IJsonModel<ReconciliationPolicyProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ReconciliationPolicyProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ReconciliationPolicyProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ReconciliationPolicyProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ReconciliationPolicyProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("state"u8);
            writer.WriteStringValue(State.ToString());
            writer.WritePropertyName("interval"u8);
            writer.WriteStringValue(Interval);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ReconciliationPolicyProperties IJsonModel<ReconciliationPolicyProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ReconciliationPolicyProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ReconciliationPolicyProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeReconciliationPolicyProperties(document.RootElement, options);
        }

        internal static ReconciliationPolicyProperties DeserializeReconciliationPolicyProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ReconciliationState state = default;
            string interval = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("state"u8))
                {
                    state = new ReconciliationState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("interval"u8))
                {
                    interval = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ReconciliationPolicyProperties(state, interval, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ReconciliationPolicyProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ReconciliationPolicyProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ReconciliationPolicyProperties)} does not support writing '{options.Format}' format.");
            }
        }

        ReconciliationPolicyProperties IPersistableModel<ReconciliationPolicyProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ReconciliationPolicyProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeReconciliationPolicyProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ReconciliationPolicyProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ReconciliationPolicyProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ReconciliationPolicyPropertiesUpdate.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Defines a ReconciliationPolicy. </summary>
    public partial class ReconciliationPolicyPropertiesUpdate
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ReconciliationPolicyPropertiesUpdate"/>. </summary>
        public ReconciliationPolicyPropertiesUpdate()
        {
        }

        /// <summary> Initializes a new instance of <see cref="ReconciliationPolicyPropertiesUpdate"/>. </summary>
        /// <param name="state"> The state of the ReconciliationPolicy. </param>
        /// <param name="interval"> Policy interval. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ReconciliationPolicyPropertiesUpdate(ReconciliationState? state, string interval, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            State = state;
            Interval = interval;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> The state of the ReconciliationPolicy. </summary>
        public ReconciliationState? State { get; set; }
        /// <summary> Policy interval. </summary>
        public string Interval { get; set; }
    }
}



================================================
FILE: Generated/Models/ReconciliationPolicyPropertiesUpdate.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ReconciliationPolicyPropertiesUpdate : IUtf8JsonSerializable, IJsonModel<ReconciliationPolicyPropertiesUpdate>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ReconciliationPolicyPropertiesUpdate>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ReconciliationPolicyPropertiesUpdate>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ReconciliationPolicyPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ReconciliationPolicyPropertiesUpdate)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(State))
            {
                writer.WritePropertyName("state"u8);
                writer.WriteStringValue(State.Value.ToString());
            }
            if (Optional.IsDefined(Interval))
            {
                writer.WritePropertyName("interval"u8);
                writer.WriteStringValue(Interval);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ReconciliationPolicyPropertiesUpdate IJsonModel<ReconciliationPolicyPropertiesUpdate>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ReconciliationPolicyPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ReconciliationPolicyPropertiesUpdate)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeReconciliationPolicyPropertiesUpdate(document.RootElement, options);
        }

        internal static ReconciliationPolicyPropertiesUpdate DeserializeReconciliationPolicyPropertiesUpdate(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ReconciliationState? state = default;
            string interval = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("state"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    state = new ReconciliationState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("interval"u8))
                {
                    interval = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ReconciliationPolicyPropertiesUpdate(state, interval, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ReconciliationPolicyPropertiesUpdate>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ReconciliationPolicyPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ReconciliationPolicyPropertiesUpdate)} does not support writing '{options.Format}' format.");
            }
        }

        ReconciliationPolicyPropertiesUpdate IPersistableModel<ReconciliationPolicyPropertiesUpdate>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ReconciliationPolicyPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeReconciliationPolicyPropertiesUpdate(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ReconciliationPolicyPropertiesUpdate)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ReconciliationPolicyPropertiesUpdate>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ReconciliationState.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Defines a state of the reconciliation policy. </summary>
    public readonly partial struct ReconciliationState : IEquatable<ReconciliationState>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="ReconciliationState"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public ReconciliationState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string InactiveValue = "inactive";
        private const string ActiveValue = "active";

        /// <summary> Reconciliation is inactive. </summary>
        public static ReconciliationState Inactive { get; } = new ReconciliationState(InactiveValue);
        /// <summary> Reconciliation is active. </summary>
        public static ReconciliationState Active { get; } = new ReconciliationState(ActiveValue);
        /// <summary> Determines if two <see cref="ReconciliationState"/> values are the same. </summary>
        public static bool operator ==(ReconciliationState left, ReconciliationState right) => left.Equals(right);
        /// <summary> Determines if two <see cref="ReconciliationState"/> values are not the same. </summary>
        public static bool operator !=(ReconciliationState left, ReconciliationState right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="ReconciliationState"/>. </summary>
        public static implicit operator ReconciliationState(string value) => new ReconciliationState(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is ReconciliationState other && Equals(other);
        /// <inheritdoc />
        public bool Equals(ReconciliationState other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/ResolvedConfiguration.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Resolved Configuration. </summary>
    public partial class ResolvedConfiguration
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="ResolvedConfiguration"/>. </summary>
        /// <param name="configuration"> Resolved Configuration as string. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configuration"/> is null. </exception>
        internal ResolvedConfiguration(string configuration)
        {
            Argument.AssertNotNull(configuration, nameof(configuration));

            Configuration = configuration;
        }

        /// <summary> Initializes a new instance of <see cref="ResolvedConfiguration"/>. </summary>
        /// <param name="configuration"> Resolved Configuration as string. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal ResolvedConfiguration(string configuration, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Configuration = configuration;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="ResolvedConfiguration"/> for deserialization. </summary>
        internal ResolvedConfiguration()
        {
        }

        /// <summary> Resolved Configuration as string. </summary>
        public string Configuration { get; }
    }
}



================================================
FILE: Generated/Models/ResolvedConfiguration.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class ResolvedConfiguration : IUtf8JsonSerializable, IJsonModel<ResolvedConfiguration>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<ResolvedConfiguration>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<ResolvedConfiguration>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ResolvedConfiguration>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ResolvedConfiguration)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("configuration"u8);
            writer.WriteStringValue(Configuration);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        ResolvedConfiguration IJsonModel<ResolvedConfiguration>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ResolvedConfiguration>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(ResolvedConfiguration)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeResolvedConfiguration(document.RootElement, options);
        }

        internal static ResolvedConfiguration DeserializeResolvedConfiguration(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string configuration = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("configuration"u8))
                {
                    configuration = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new ResolvedConfiguration(configuration, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<ResolvedConfiguration>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ResolvedConfiguration>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(ResolvedConfiguration)} does not support writing '{options.Format}' format.");
            }
        }

        ResolvedConfiguration IPersistableModel<ResolvedConfiguration>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<ResolvedConfiguration>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeResolvedConfiguration(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(ResolvedConfiguration)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<ResolvedConfiguration>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/ResourceState.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Resource Type State. </summary>
    public readonly partial struct ResourceState : IEquatable<ResourceState>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="ResourceState"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public ResourceState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string ActiveValue = "active";
        private const string InactiveValue = "inactive";

        /// <summary> Resource is active. </summary>
        public static ResourceState Active { get; } = new ResourceState(ActiveValue);
        /// <summary> Resource is inactive. </summary>
        public static ResourceState Inactive { get; } = new ResourceState(InactiveValue);
        /// <summary> Determines if two <see cref="ResourceState"/> values are the same. </summary>
        public static bool operator ==(ResourceState left, ResourceState right) => left.Equals(right);
        /// <summary> Determines if two <see cref="ResourceState"/> values are not the same. </summary>
        public static bool operator !=(ResourceState left, ResourceState right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="ResourceState"/>. </summary>
        public static implicit operator ResourceState(string value) => new ResourceState(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is ResourceState other && Equals(other);
        /// <inheritdoc />
        public bool Equals(ResourceState other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/SchemaListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a Schema list operation. </summary>
    internal partial class SchemaListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SchemaListResult"/>. </summary>
        /// <param name="value"> The Schema items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal SchemaListResult(IEnumerable<EdgeSchemaData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="SchemaListResult"/>. </summary>
        /// <param name="value"> The Schema items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SchemaListResult(IReadOnlyList<EdgeSchemaData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SchemaListResult"/> for deserialization. </summary>
        internal SchemaListResult()
        {
        }

        /// <summary> The Schema items on this page. </summary>
        public IReadOnlyList<EdgeSchemaData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/SchemaListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SchemaListResult : IUtf8JsonSerializable, IJsonModel<SchemaListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SchemaListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SchemaListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SchemaListResult IJsonModel<SchemaListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSchemaListResult(document.RootElement, options);
        }

        internal static SchemaListResult DeserializeSchemaListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeSchemaData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeSchemaData> array = new List<EdgeSchemaData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeSchemaData.DeserializeEdgeSchemaData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SchemaListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SchemaListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SchemaListResult)} does not support writing '{options.Format}' format.");
            }
        }

        SchemaListResult IPersistableModel<SchemaListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSchemaListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SchemaListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SchemaListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SchemaProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Schema Properties. </summary>
    public partial class SchemaProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SchemaProperties"/>. </summary>
        public SchemaProperties()
        {
        }

        /// <summary> Initializes a new instance of <see cref="SchemaProperties"/>. </summary>
        /// <param name="currentVersion"> Current Version of schema. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SchemaProperties(string currentVersion, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            CurrentVersion = currentVersion;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Current Version of schema. </summary>
        public string CurrentVersion { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/SchemaProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SchemaProperties : IUtf8JsonSerializable, IJsonModel<SchemaProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SchemaProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SchemaProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaProperties)} does not support writing '{format}' format.");
            }

            if (options.Format != "W" && Optional.IsDefined(CurrentVersion))
            {
                writer.WritePropertyName("currentVersion"u8);
                writer.WriteStringValue(CurrentVersion);
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SchemaProperties IJsonModel<SchemaProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSchemaProperties(document.RootElement, options);
        }

        internal static SchemaProperties DeserializeSchemaProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string currentVersion = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("currentVersion"u8))
                {
                    currentVersion = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SchemaProperties(currentVersion, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SchemaProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SchemaProperties)} does not support writing '{options.Format}' format.");
            }
        }

        SchemaProperties IPersistableModel<SchemaProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSchemaProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SchemaProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SchemaProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SchemaReferenceListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a SchemaReference list operation. </summary>
    internal partial class SchemaReferenceListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SchemaReferenceListResult"/>. </summary>
        /// <param name="value"> The SchemaReference items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal SchemaReferenceListResult(IEnumerable<EdgeSchemaReferenceData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="SchemaReferenceListResult"/>. </summary>
        /// <param name="value"> The SchemaReference items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SchemaReferenceListResult(IReadOnlyList<EdgeSchemaReferenceData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SchemaReferenceListResult"/> for deserialization. </summary>
        internal SchemaReferenceListResult()
        {
        }

        /// <summary> The SchemaReference items on this page. </summary>
        public IReadOnlyList<EdgeSchemaReferenceData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/SchemaReferenceListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SchemaReferenceListResult : IUtf8JsonSerializable, IJsonModel<SchemaReferenceListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SchemaReferenceListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SchemaReferenceListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaReferenceListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaReferenceListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SchemaReferenceListResult IJsonModel<SchemaReferenceListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaReferenceListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaReferenceListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSchemaReferenceListResult(document.RootElement, options);
        }

        internal static SchemaReferenceListResult DeserializeSchemaReferenceListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeSchemaReferenceData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeSchemaReferenceData> array = new List<EdgeSchemaReferenceData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeSchemaReferenceData.DeserializeEdgeSchemaReferenceData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SchemaReferenceListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SchemaReferenceListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaReferenceListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SchemaReferenceListResult)} does not support writing '{options.Format}' format.");
            }
        }

        SchemaReferenceListResult IPersistableModel<SchemaReferenceListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaReferenceListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSchemaReferenceListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SchemaReferenceListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SchemaReferenceListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SchemaReferenceProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Schema Reference Properties. </summary>
    public partial class SchemaReferenceProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SchemaReferenceProperties"/>. </summary>
        /// <param name="schemaId"> Schema Id of schema reference. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaId"/> is null. </exception>
        public SchemaReferenceProperties(string schemaId)
        {
            Argument.AssertNotNull(schemaId, nameof(schemaId));

            SchemaId = schemaId;
        }

        /// <summary> Initializes a new instance of <see cref="SchemaReferenceProperties"/>. </summary>
        /// <param name="schemaId"> Schema Id of schema reference. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SchemaReferenceProperties(string schemaId, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SchemaId = schemaId;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SchemaReferenceProperties"/> for deserialization. </summary>
        internal SchemaReferenceProperties()
        {
        }

        /// <summary> Schema Id of schema reference. </summary>
        public string SchemaId { get; set; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/SchemaReferenceProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SchemaReferenceProperties : IUtf8JsonSerializable, IJsonModel<SchemaReferenceProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SchemaReferenceProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SchemaReferenceProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaReferenceProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaReferenceProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("schemaId"u8);
            writer.WriteStringValue(SchemaId);
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SchemaReferenceProperties IJsonModel<SchemaReferenceProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaReferenceProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaReferenceProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSchemaReferenceProperties(document.RootElement, options);
        }

        internal static SchemaReferenceProperties DeserializeSchemaReferenceProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string schemaId = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("schemaId"u8))
                {
                    schemaId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SchemaReferenceProperties(schemaId, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SchemaReferenceProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaReferenceProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SchemaReferenceProperties)} does not support writing '{options.Format}' format.");
            }
        }

        SchemaReferenceProperties IPersistableModel<SchemaReferenceProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaReferenceProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSchemaReferenceProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SchemaReferenceProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SchemaReferenceProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SchemaVersionListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a SchemaVersion list operation. </summary>
    internal partial class SchemaVersionListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SchemaVersionListResult"/>. </summary>
        /// <param name="value"> The SchemaVersion items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal SchemaVersionListResult(IEnumerable<EdgeSchemaVersionData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="SchemaVersionListResult"/>. </summary>
        /// <param name="value"> The SchemaVersion items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SchemaVersionListResult(IReadOnlyList<EdgeSchemaVersionData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SchemaVersionListResult"/> for deserialization. </summary>
        internal SchemaVersionListResult()
        {
        }

        /// <summary> The SchemaVersion items on this page. </summary>
        public IReadOnlyList<EdgeSchemaVersionData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/SchemaVersionListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SchemaVersionListResult : IUtf8JsonSerializable, IJsonModel<SchemaVersionListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SchemaVersionListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SchemaVersionListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaVersionListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SchemaVersionListResult IJsonModel<SchemaVersionListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaVersionListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSchemaVersionListResult(document.RootElement, options);
        }

        internal static SchemaVersionListResult DeserializeSchemaVersionListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeSchemaVersionData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeSchemaVersionData> array = new List<EdgeSchemaVersionData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeSchemaVersionData.DeserializeEdgeSchemaVersionData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SchemaVersionListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SchemaVersionListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SchemaVersionListResult)} does not support writing '{options.Format}' format.");
            }
        }

        SchemaVersionListResult IPersistableModel<SchemaVersionListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSchemaVersionListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SchemaVersionListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SchemaVersionListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SchemaVersionProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Schema Version Properties. </summary>
    public partial class SchemaVersionProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SchemaVersionProperties"/>. </summary>
        /// <param name="value"> Value of schema version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public SchemaVersionProperties(string value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value;
        }

        /// <summary> Initializes a new instance of <see cref="SchemaVersionProperties"/>. </summary>
        /// <param name="value"> Value of schema version. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SchemaVersionProperties(string value, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SchemaVersionProperties"/> for deserialization. </summary>
        internal SchemaVersionProperties()
        {
        }

        /// <summary> Value of schema version. </summary>
        public string Value { get; set; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/SchemaVersionProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SchemaVersionProperties : IUtf8JsonSerializable, IJsonModel<SchemaVersionProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SchemaVersionProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SchemaVersionProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaVersionProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStringValue(Value);
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SchemaVersionProperties IJsonModel<SchemaVersionProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaVersionProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSchemaVersionProperties(document.RootElement, options);
        }

        internal static SchemaVersionProperties DeserializeSchemaVersionProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string value = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    value = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SchemaVersionProperties(value, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SchemaVersionProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SchemaVersionProperties)} does not support writing '{options.Format}' format.");
            }
        }

        SchemaVersionProperties IPersistableModel<SchemaVersionProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSchemaVersionProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SchemaVersionProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SchemaVersionProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SchemaVersionPropertiesUpdate.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Schema Version Properties. </summary>
    internal partial class SchemaVersionPropertiesUpdate
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SchemaVersionPropertiesUpdate"/>. </summary>
        public SchemaVersionPropertiesUpdate()
        {
        }

        /// <summary> Initializes a new instance of <see cref="SchemaVersionPropertiesUpdate"/>. </summary>
        /// <param name="value"> Value of schema version. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SchemaVersionPropertiesUpdate(string value, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Value of schema version. </summary>
        public string Value { get; set; }
    }
}



================================================
FILE: Generated/Models/SchemaVersionPropertiesUpdate.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SchemaVersionPropertiesUpdate : IUtf8JsonSerializable, IJsonModel<SchemaVersionPropertiesUpdate>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SchemaVersionPropertiesUpdate>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SchemaVersionPropertiesUpdate>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaVersionPropertiesUpdate)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Value))
            {
                writer.WritePropertyName("value"u8);
                writer.WriteStringValue(Value);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SchemaVersionPropertiesUpdate IJsonModel<SchemaVersionPropertiesUpdate>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaVersionPropertiesUpdate)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSchemaVersionPropertiesUpdate(document.RootElement, options);
        }

        internal static SchemaVersionPropertiesUpdate DeserializeSchemaVersionPropertiesUpdate(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string value = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    value = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SchemaVersionPropertiesUpdate(value, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SchemaVersionPropertiesUpdate>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SchemaVersionPropertiesUpdate)} does not support writing '{options.Format}' format.");
            }
        }

        SchemaVersionPropertiesUpdate IPersistableModel<SchemaVersionPropertiesUpdate>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSchemaVersionPropertiesUpdate(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SchemaVersionPropertiesUpdate)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SchemaVersionPropertiesUpdate>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SchemaVersionWithUpdateType.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Schema Version With Update Type. </summary>
    public partial class SchemaVersionWithUpdateType
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SchemaVersionWithUpdateType"/>. </summary>
        /// <param name="schemaVersion"> Schema Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="schemaVersion"/> is null. </exception>
        public SchemaVersionWithUpdateType(EdgeSchemaVersionData schemaVersion)
        {
            Argument.AssertNotNull(schemaVersion, nameof(schemaVersion));

            SchemaVersion = schemaVersion;
        }

        /// <summary> Initializes a new instance of <see cref="SchemaVersionWithUpdateType"/>. </summary>
        /// <param name="updateType"> Update type. </param>
        /// <param name="version"> Version to create. </param>
        /// <param name="schemaVersion"> Schema Version. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SchemaVersionWithUpdateType(UpdateType? updateType, string version, EdgeSchemaVersionData schemaVersion, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            UpdateType = updateType;
            Version = version;
            SchemaVersion = schemaVersion;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SchemaVersionWithUpdateType"/> for deserialization. </summary>
        internal SchemaVersionWithUpdateType()
        {
        }

        /// <summary> Update type. </summary>
        public UpdateType? UpdateType { get; set; }
        /// <summary> Version to create. </summary>
        public string Version { get; set; }
        /// <summary> Schema Version. </summary>
        public EdgeSchemaVersionData SchemaVersion { get; }
    }
}



================================================
FILE: Generated/Models/SchemaVersionWithUpdateType.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SchemaVersionWithUpdateType : IUtf8JsonSerializable, IJsonModel<SchemaVersionWithUpdateType>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SchemaVersionWithUpdateType>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SchemaVersionWithUpdateType>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaVersionWithUpdateType)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(UpdateType))
            {
                writer.WritePropertyName("updateType"u8);
                writer.WriteStringValue(UpdateType.Value.ToString());
            }
            if (Optional.IsDefined(Version))
            {
                writer.WritePropertyName("version"u8);
                writer.WriteStringValue(Version);
            }
            writer.WritePropertyName("schemaVersion"u8);
            writer.WriteObjectValue(SchemaVersion, options);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SchemaVersionWithUpdateType IJsonModel<SchemaVersionWithUpdateType>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SchemaVersionWithUpdateType)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSchemaVersionWithUpdateType(document.RootElement, options);
        }

        internal static SchemaVersionWithUpdateType DeserializeSchemaVersionWithUpdateType(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            UpdateType? updateType = default;
            string version = default;
            EdgeSchemaVersionData schemaVersion = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("updateType"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    updateType = new UpdateType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("version"u8))
                {
                    version = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("schemaVersion"u8))
                {
                    schemaVersion = EdgeSchemaVersionData.DeserializeEdgeSchemaVersionData(property.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SchemaVersionWithUpdateType(updateType, version, schemaVersion, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SchemaVersionWithUpdateType>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SchemaVersionWithUpdateType)} does not support writing '{options.Format}' format.");
            }
        }

        SchemaVersionWithUpdateType IPersistableModel<SchemaVersionWithUpdateType>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SchemaVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSchemaVersionWithUpdateType(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SchemaVersionWithUpdateType)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SchemaVersionWithUpdateType>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SiteReferenceListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a SiteReference list operation. </summary>
    internal partial class SiteReferenceListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SiteReferenceListResult"/>. </summary>
        /// <param name="value"> The SiteReference items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal SiteReferenceListResult(IEnumerable<EdgeSiteReferenceData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="SiteReferenceListResult"/>. </summary>
        /// <param name="value"> The SiteReference items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SiteReferenceListResult(IReadOnlyList<EdgeSiteReferenceData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SiteReferenceListResult"/> for deserialization. </summary>
        internal SiteReferenceListResult()
        {
        }

        /// <summary> The SiteReference items on this page. </summary>
        public IReadOnlyList<EdgeSiteReferenceData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/SiteReferenceListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SiteReferenceListResult : IUtf8JsonSerializable, IJsonModel<SiteReferenceListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SiteReferenceListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SiteReferenceListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferenceListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SiteReferenceListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SiteReferenceListResult IJsonModel<SiteReferenceListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferenceListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SiteReferenceListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSiteReferenceListResult(document.RootElement, options);
        }

        internal static SiteReferenceListResult DeserializeSiteReferenceListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeSiteReferenceData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeSiteReferenceData> array = new List<EdgeSiteReferenceData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeSiteReferenceData.DeserializeEdgeSiteReferenceData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SiteReferenceListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SiteReferenceListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferenceListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SiteReferenceListResult)} does not support writing '{options.Format}' format.");
            }
        }

        SiteReferenceListResult IPersistableModel<SiteReferenceListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferenceListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSiteReferenceListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SiteReferenceListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SiteReferenceListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SiteReferenceProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Site Reference Properties. </summary>
    public partial class SiteReferenceProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SiteReferenceProperties"/>. </summary>
        /// <param name="siteId"> Azure Resource ID for Site. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="siteId"/> is null. </exception>
        public SiteReferenceProperties(string siteId)
        {
            Argument.AssertNotNull(siteId, nameof(siteId));

            SiteId = siteId;
        }

        /// <summary> Initializes a new instance of <see cref="SiteReferenceProperties"/>. </summary>
        /// <param name="siteId"> Azure Resource ID for Site. </param>
        /// <param name="provisioningState"> Provisioning State. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SiteReferenceProperties(string siteId, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SiteId = siteId;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SiteReferenceProperties"/> for deserialization. </summary>
        internal SiteReferenceProperties()
        {
        }

        /// <summary> Azure Resource ID for Site. </summary>
        public string SiteId { get; set; }
        /// <summary> Provisioning State. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/SiteReferenceProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SiteReferenceProperties : IUtf8JsonSerializable, IJsonModel<SiteReferenceProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SiteReferenceProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SiteReferenceProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferenceProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SiteReferenceProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("siteId"u8);
            writer.WriteStringValue(SiteId);
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SiteReferenceProperties IJsonModel<SiteReferenceProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferenceProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SiteReferenceProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSiteReferenceProperties(document.RootElement, options);
        }

        internal static SiteReferenceProperties DeserializeSiteReferenceProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string siteId = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("siteId"u8))
                {
                    siteId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SiteReferenceProperties(siteId, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SiteReferenceProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferenceProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SiteReferenceProperties)} does not support writing '{options.Format}' format.");
            }
        }

        SiteReferenceProperties IPersistableModel<SiteReferenceProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferenceProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSiteReferenceProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SiteReferenceProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SiteReferenceProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SiteReferencePropertiesUpdate.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Site Reference Properties. </summary>
    internal partial class SiteReferencePropertiesUpdate
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SiteReferencePropertiesUpdate"/>. </summary>
        public SiteReferencePropertiesUpdate()
        {
        }

        /// <summary> Initializes a new instance of <see cref="SiteReferencePropertiesUpdate"/>. </summary>
        /// <param name="siteId"> Azure Resource ID for Site. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SiteReferencePropertiesUpdate(string siteId, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SiteId = siteId;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Azure Resource ID for Site. </summary>
        public string SiteId { get; set; }
    }
}



================================================
FILE: Generated/Models/SiteReferencePropertiesUpdate.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SiteReferencePropertiesUpdate : IUtf8JsonSerializable, IJsonModel<SiteReferencePropertiesUpdate>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SiteReferencePropertiesUpdate>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SiteReferencePropertiesUpdate>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferencePropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SiteReferencePropertiesUpdate)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(SiteId))
            {
                writer.WritePropertyName("siteId"u8);
                writer.WriteStringValue(SiteId);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SiteReferencePropertiesUpdate IJsonModel<SiteReferencePropertiesUpdate>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferencePropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SiteReferencePropertiesUpdate)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSiteReferencePropertiesUpdate(document.RootElement, options);
        }

        internal static SiteReferencePropertiesUpdate DeserializeSiteReferencePropertiesUpdate(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string siteId = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("siteId"u8))
                {
                    siteId = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SiteReferencePropertiesUpdate(siteId, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SiteReferencePropertiesUpdate>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferencePropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SiteReferencePropertiesUpdate)} does not support writing '{options.Format}' format.");
            }
        }

        SiteReferencePropertiesUpdate IPersistableModel<SiteReferencePropertiesUpdate>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SiteReferencePropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSiteReferencePropertiesUpdate(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SiteReferencePropertiesUpdate)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SiteReferencePropertiesUpdate>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionDependency.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Dependency Context. </summary>
    public partial class SolutionDependency
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionDependency"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version Id. </param>
        /// <param name="solutionTemplateVersionId"> Solution Template Version Id. </param>
        /// <param name="targetId"> Target Id. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionId"/>, <paramref name="solutionTemplateVersionId"/> or <paramref name="targetId"/> is null. </exception>
        internal SolutionDependency(string solutionVersionId, string solutionTemplateVersionId, string targetId)
        {
            Argument.AssertNotNull(solutionVersionId, nameof(solutionVersionId));
            Argument.AssertNotNull(solutionTemplateVersionId, nameof(solutionTemplateVersionId));
            Argument.AssertNotNull(targetId, nameof(targetId));

            SolutionVersionId = solutionVersionId;
            SolutionTemplateVersionId = solutionTemplateVersionId;
            TargetId = targetId;
            Dependencies = new ChangeTrackingList<SolutionDependency>();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionDependency"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version Id. </param>
        /// <param name="solutionInstanceName"> Solution Instance Name. </param>
        /// <param name="solutionTemplateVersionId"> Solution Template Version Id. </param>
        /// <param name="targetId"> Target Id. </param>
        /// <param name="dependencies"> Solution dependencies. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionDependency(string solutionVersionId, string solutionInstanceName, string solutionTemplateVersionId, string targetId, IReadOnlyList<SolutionDependency> dependencies, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersionId = solutionVersionId;
            SolutionInstanceName = solutionInstanceName;
            SolutionTemplateVersionId = solutionTemplateVersionId;
            TargetId = targetId;
            Dependencies = dependencies;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionDependency"/> for deserialization. </summary>
        internal SolutionDependency()
        {
        }

        /// <summary> Solution Version Id. </summary>
        public string SolutionVersionId { get; }
        /// <summary> Solution Instance Name. </summary>
        public string SolutionInstanceName { get; }
        /// <summary> Solution Template Version Id. </summary>
        public string SolutionTemplateVersionId { get; }
        /// <summary> Target Id. </summary>
        public string TargetId { get; }
        /// <summary> Solution dependencies. </summary>
        public IReadOnlyList<SolutionDependency> Dependencies { get; }
    }
}



================================================
FILE: Generated/Models/SolutionDependency.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SolutionDependency : IUtf8JsonSerializable, IJsonModel<SolutionDependency>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionDependency>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionDependency>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionDependency>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionDependency)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionVersionId"u8);
            writer.WriteStringValue(SolutionVersionId);
            if (Optional.IsDefined(SolutionInstanceName))
            {
                writer.WritePropertyName("solutionInstanceName"u8);
                writer.WriteStringValue(SolutionInstanceName);
            }
            writer.WritePropertyName("solutionTemplateVersionId"u8);
            writer.WriteStringValue(SolutionTemplateVersionId);
            writer.WritePropertyName("targetId"u8);
            writer.WriteStringValue(TargetId);
            if (Optional.IsCollectionDefined(Dependencies))
            {
                writer.WritePropertyName("dependencies"u8);
                writer.WriteStartArray();
                foreach (var item in Dependencies)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionDependency IJsonModel<SolutionDependency>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionDependency>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionDependency)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionDependency(document.RootElement, options);
        }

        internal static SolutionDependency DeserializeSolutionDependency(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionVersionId = default;
            string solutionInstanceName = default;
            string solutionTemplateVersionId = default;
            string targetId = default;
            IReadOnlyList<SolutionDependency> dependencies = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersionId"u8))
                {
                    solutionVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionInstanceName"u8))
                {
                    solutionInstanceName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionTemplateVersionId"u8))
                {
                    solutionTemplateVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("targetId"u8))
                {
                    targetId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("dependencies"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<SolutionDependency> array = new List<SolutionDependency>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(DeserializeSolutionDependency(item, options));
                    }
                    dependencies = array;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionDependency(
                solutionVersionId,
                solutionInstanceName,
                solutionTemplateVersionId,
                targetId,
                dependencies ?? new ChangeTrackingList<SolutionDependency>(),
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionDependency>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionDependency>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionDependency)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionDependency IPersistableModel<SolutionDependency>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionDependency>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionDependency(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionDependency)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionDependency>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a Solution list operation. </summary>
    internal partial class SolutionListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionListResult"/>. </summary>
        /// <param name="value"> The Solution items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal SolutionListResult(IEnumerable<EdgeSolutionData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionListResult"/>. </summary>
        /// <param name="value"> The Solution items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionListResult(IReadOnlyList<EdgeSolutionData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionListResult"/> for deserialization. </summary>
        internal SolutionListResult()
        {
        }

        /// <summary> The Solution items on this page. </summary>
        public IReadOnlyList<EdgeSolutionData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/SolutionListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SolutionListResult : IUtf8JsonSerializable, IJsonModel<SolutionListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionListResult IJsonModel<SolutionListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionListResult(document.RootElement, options);
        }

        internal static SolutionListResult DeserializeSolutionListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeSolutionData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeSolutionData> array = new List<EdgeSolutionData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeSolutionData.DeserializeEdgeSolutionData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionListResult)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionListResult IPersistableModel<SolutionListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Properties. </summary>
    public partial class SolutionProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionProperties"/>. </summary>
        public SolutionProperties()
        {
            AvailableSolutionTemplateVersions = new ChangeTrackingList<AvailableSolutionTemplateVersion>();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionProperties"/>. </summary>
        /// <param name="solutionTemplateId"> Solution template Id. </param>
        /// <param name="displayName"> Display name of the solution. </param>
        /// <param name="availableSolutionTemplateVersions"> List of latest revisions for available solution template versions. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionProperties(string solutionTemplateId, string displayName, IReadOnlyList<AvailableSolutionTemplateVersion> availableSolutionTemplateVersions, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionTemplateId = solutionTemplateId;
            DisplayName = displayName;
            AvailableSolutionTemplateVersions = availableSolutionTemplateVersions;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Solution template Id. </summary>
        public string SolutionTemplateId { get; }
        /// <summary> Display name of the solution. </summary>
        public string DisplayName { get; }
        /// <summary> List of latest revisions for available solution template versions. </summary>
        public IReadOnlyList<AvailableSolutionTemplateVersion> AvailableSolutionTemplateVersions { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/SolutionProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SolutionProperties : IUtf8JsonSerializable, IJsonModel<SolutionProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionProperties)} does not support writing '{format}' format.");
            }

            if (options.Format != "W" && Optional.IsDefined(SolutionTemplateId))
            {
                writer.WritePropertyName("solutionTemplateId"u8);
                writer.WriteStringValue(SolutionTemplateId);
            }
            if (options.Format != "W" && Optional.IsDefined(DisplayName))
            {
                writer.WritePropertyName("displayName"u8);
                writer.WriteStringValue(DisplayName);
            }
            if (options.Format != "W" && Optional.IsCollectionDefined(AvailableSolutionTemplateVersions))
            {
                writer.WritePropertyName("availableSolutionTemplateVersions"u8);
                writer.WriteStartArray();
                foreach (var item in AvailableSolutionTemplateVersions)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionProperties IJsonModel<SolutionProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionProperties(document.RootElement, options);
        }

        internal static SolutionProperties DeserializeSolutionProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionTemplateId = default;
            string displayName = default;
            IReadOnlyList<AvailableSolutionTemplateVersion> availableSolutionTemplateVersions = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionTemplateId"u8))
                {
                    solutionTemplateId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("displayName"u8))
                {
                    displayName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("availableSolutionTemplateVersions"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<AvailableSolutionTemplateVersion> array = new List<AvailableSolutionTemplateVersion>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(AvailableSolutionTemplateVersion.DeserializeAvailableSolutionTemplateVersion(item, options));
                    }
                    availableSolutionTemplateVersions = array;
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionProperties(solutionTemplateId, displayName, availableSolutionTemplateVersions ?? new ChangeTrackingList<AvailableSolutionTemplateVersion>(), provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionProperties)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionProperties IPersistableModel<SolutionProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionTemplateListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a SolutionTemplate list operation. </summary>
    internal partial class SolutionTemplateListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateListResult"/>. </summary>
        /// <param name="value"> The SolutionTemplate items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal SolutionTemplateListResult(IEnumerable<EdgeSolutionTemplateData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateListResult"/>. </summary>
        /// <param name="value"> The SolutionTemplate items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionTemplateListResult(IReadOnlyList<EdgeSolutionTemplateData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateListResult"/> for deserialization. </summary>
        internal SolutionTemplateListResult()
        {
        }

        /// <summary> The SolutionTemplate items on this page. </summary>
        public IReadOnlyList<EdgeSolutionTemplateData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/SolutionTemplateListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SolutionTemplateListResult : IUtf8JsonSerializable, IJsonModel<SolutionTemplateListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionTemplateListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionTemplateListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionTemplateListResult IJsonModel<SolutionTemplateListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionTemplateListResult(document.RootElement, options);
        }

        internal static SolutionTemplateListResult DeserializeSolutionTemplateListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeSolutionTemplateData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeSolutionTemplateData> array = new List<EdgeSolutionTemplateData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeSolutionTemplateData.DeserializeEdgeSolutionTemplateData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionTemplateListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionTemplateListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateListResult)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionTemplateListResult IPersistableModel<SolutionTemplateListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionTemplateListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionTemplateListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionTemplateProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Template Properties. </summary>
    public partial class SolutionTemplateProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateProperties"/>. </summary>
        /// <param name="description"> Description of Solution template. </param>
        /// <param name="capabilities"> List of capabilities. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="description"/> or <paramref name="capabilities"/> is null. </exception>
        public SolutionTemplateProperties(string description, IEnumerable<string> capabilities)
        {
            Argument.AssertNotNull(description, nameof(description));
            Argument.AssertNotNull(capabilities, nameof(capabilities));

            Description = description;
            Capabilities = capabilities.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateProperties"/>. </summary>
        /// <param name="uniqueIdentifier"> A unique identifier for the solution template, generated by the system. </param>
        /// <param name="description"> Description of Solution template. </param>
        /// <param name="capabilities"> List of capabilities. </param>
        /// <param name="latestVersion"> Latest solution template version. </param>
        /// <param name="state"> State of resource. </param>
        /// <param name="enableExternalValidation"> Flag to enable external validation. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionTemplateProperties(string uniqueIdentifier, string description, IList<string> capabilities, string latestVersion, ResourceState? state, bool? enableExternalValidation, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            UniqueIdentifier = uniqueIdentifier;
            Description = description;
            Capabilities = capabilities;
            LatestVersion = latestVersion;
            State = state;
            EnableExternalValidation = enableExternalValidation;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateProperties"/> for deserialization. </summary>
        internal SolutionTemplateProperties()
        {
        }

        /// <summary> A unique identifier for the solution template, generated by the system. </summary>
        public string UniqueIdentifier { get; }
        /// <summary> Description of Solution template. </summary>
        public string Description { get; set; }
        /// <summary> List of capabilities. </summary>
        public IList<string> Capabilities { get; }
        /// <summary> Latest solution template version. </summary>
        public string LatestVersion { get; }
        /// <summary> State of resource. </summary>
        public ResourceState? State { get; set; }
        /// <summary> Flag to enable external validation. </summary>
        public bool? EnableExternalValidation { get; set; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/SolutionTemplateProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SolutionTemplateProperties : IUtf8JsonSerializable, IJsonModel<SolutionTemplateProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionTemplateProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionTemplateProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateProperties)} does not support writing '{format}' format.");
            }

            if (options.Format != "W" && Optional.IsDefined(UniqueIdentifier))
            {
                writer.WritePropertyName("uniqueIdentifier"u8);
                writer.WriteStringValue(UniqueIdentifier);
            }
            writer.WritePropertyName("description"u8);
            writer.WriteStringValue(Description);
            writer.WritePropertyName("capabilities"u8);
            writer.WriteStartArray();
            foreach (var item in Capabilities)
            {
                writer.WriteStringValue(item);
            }
            writer.WriteEndArray();
            if (options.Format != "W" && Optional.IsDefined(LatestVersion))
            {
                writer.WritePropertyName("latestVersion"u8);
                writer.WriteStringValue(LatestVersion);
            }
            if (Optional.IsDefined(State))
            {
                writer.WritePropertyName("state"u8);
                writer.WriteStringValue(State.Value.ToString());
            }
            if (Optional.IsDefined(EnableExternalValidation))
            {
                writer.WritePropertyName("enableExternalValidation"u8);
                writer.WriteBooleanValue(EnableExternalValidation.Value);
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionTemplateProperties IJsonModel<SolutionTemplateProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionTemplateProperties(document.RootElement, options);
        }

        internal static SolutionTemplateProperties DeserializeSolutionTemplateProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string uniqueIdentifier = default;
            string description = default;
            IList<string> capabilities = default;
            string latestVersion = default;
            ResourceState? state = default;
            bool? enableExternalValidation = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("uniqueIdentifier"u8))
                {
                    uniqueIdentifier = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("description"u8))
                {
                    description = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("capabilities"u8))
                {
                    List<string> array = new List<string>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(item.GetString());
                    }
                    capabilities = array;
                    continue;
                }
                if (property.NameEquals("latestVersion"u8))
                {
                    latestVersion = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("state"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    state = new ResourceState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("enableExternalValidation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    enableExternalValidation = property.Value.GetBoolean();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionTemplateProperties(
                uniqueIdentifier,
                description,
                capabilities,
                latestVersion,
                state,
                enableExternalValidation,
                provisioningState,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionTemplateProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateProperties)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionTemplateProperties IPersistableModel<SolutionTemplateProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionTemplateProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionTemplateProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionTemplateUpdateProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The updatable properties of the SolutionTemplate. </summary>
    public partial class SolutionTemplateUpdateProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateUpdateProperties"/>. </summary>
        public SolutionTemplateUpdateProperties()
        {
            Capabilities = new ChangeTrackingList<string>();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateUpdateProperties"/>. </summary>
        /// <param name="description"> Description of Solution template. </param>
        /// <param name="capabilities"> List of capabilities. </param>
        /// <param name="state"> State of resource. </param>
        /// <param name="enableExternalValidation"> Flag to enable external validation. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionTemplateUpdateProperties(string description, IList<string> capabilities, ResourceState? state, bool? enableExternalValidation, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Description = description;
            Capabilities = capabilities;
            State = state;
            EnableExternalValidation = enableExternalValidation;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Description of Solution template. </summary>
        public string Description { get; set; }
        /// <summary> List of capabilities. </summary>
        public IList<string> Capabilities { get; }
        /// <summary> State of resource. </summary>
        public ResourceState? State { get; set; }
        /// <summary> Flag to enable external validation. </summary>
        public bool? EnableExternalValidation { get; set; }
    }
}



================================================
FILE: Generated/Models/SolutionTemplateUpdateProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SolutionTemplateUpdateProperties : IUtf8JsonSerializable, IJsonModel<SolutionTemplateUpdateProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionTemplateUpdateProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionTemplateUpdateProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateUpdateProperties)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Description))
            {
                writer.WritePropertyName("description"u8);
                writer.WriteStringValue(Description);
            }
            if (Optional.IsCollectionDefined(Capabilities))
            {
                writer.WritePropertyName("capabilities"u8);
                writer.WriteStartArray();
                foreach (var item in Capabilities)
                {
                    writer.WriteStringValue(item);
                }
                writer.WriteEndArray();
            }
            if (Optional.IsDefined(State))
            {
                writer.WritePropertyName("state"u8);
                writer.WriteStringValue(State.Value.ToString());
            }
            if (Optional.IsDefined(EnableExternalValidation))
            {
                writer.WritePropertyName("enableExternalValidation"u8);
                writer.WriteBooleanValue(EnableExternalValidation.Value);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionTemplateUpdateProperties IJsonModel<SolutionTemplateUpdateProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateUpdateProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionTemplateUpdateProperties(document.RootElement, options);
        }

        internal static SolutionTemplateUpdateProperties DeserializeSolutionTemplateUpdateProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string description = default;
            IList<string> capabilities = default;
            ResourceState? state = default;
            bool? enableExternalValidation = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("description"u8))
                {
                    description = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("capabilities"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<string> array = new List<string>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(item.GetString());
                    }
                    capabilities = array;
                    continue;
                }
                if (property.NameEquals("state"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    state = new ResourceState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("enableExternalValidation"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    enableExternalValidation = property.Value.GetBoolean();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionTemplateUpdateProperties(description, capabilities ?? new ChangeTrackingList<string>(), state, enableExternalValidation, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionTemplateUpdateProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateUpdateProperties)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionTemplateUpdateProperties IPersistableModel<SolutionTemplateUpdateProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionTemplateUpdateProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateUpdateProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionTemplateUpdateProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionTemplateVersionListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a SolutionTemplateVersion list operation. </summary>
    internal partial class SolutionTemplateVersionListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateVersionListResult"/>. </summary>
        /// <param name="value"> The SolutionTemplateVersion items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal SolutionTemplateVersionListResult(IEnumerable<EdgeSolutionTemplateVersionData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateVersionListResult"/>. </summary>
        /// <param name="value"> The SolutionTemplateVersion items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionTemplateVersionListResult(IReadOnlyList<EdgeSolutionTemplateVersionData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateVersionListResult"/> for deserialization. </summary>
        internal SolutionTemplateVersionListResult()
        {
        }

        /// <summary> The SolutionTemplateVersion items on this page. </summary>
        public IReadOnlyList<EdgeSolutionTemplateVersionData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/SolutionTemplateVersionListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SolutionTemplateVersionListResult : IUtf8JsonSerializable, IJsonModel<SolutionTemplateVersionListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionTemplateVersionListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionTemplateVersionListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateVersionListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionTemplateVersionListResult IJsonModel<SolutionTemplateVersionListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateVersionListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionTemplateVersionListResult(document.RootElement, options);
        }

        internal static SolutionTemplateVersionListResult DeserializeSolutionTemplateVersionListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeSolutionTemplateVersionData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeSolutionTemplateVersionData> array = new List<EdgeSolutionTemplateVersionData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeSolutionTemplateVersionData.DeserializeEdgeSolutionTemplateVersionData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionTemplateVersionListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionTemplateVersionListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateVersionListResult)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionTemplateVersionListResult IPersistableModel<SolutionTemplateVersionListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionTemplateVersionListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateVersionListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionTemplateVersionListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionTemplateVersionProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Template Version Properties. </summary>
    public partial class SolutionTemplateVersionProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateVersionProperties"/>. </summary>
        /// <param name="configurations"> Config expressions for this solution version. </param>
        /// <param name="specification"> App components spec. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="configurations"/> or <paramref name="specification"/> is null. </exception>
        public SolutionTemplateVersionProperties(string configurations, IDictionary<string, BinaryData> specification)
        {
            Argument.AssertNotNull(configurations, nameof(configurations));
            Argument.AssertNotNull(specification, nameof(specification));

            Configurations = configurations;
            Specification = specification;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateVersionProperties"/>. </summary>
        /// <param name="configurations"> Config expressions for this solution version. </param>
        /// <param name="specification"> App components spec. </param>
        /// <param name="orchestratorType"> Orchestrator type. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionTemplateVersionProperties(string configurations, IDictionary<string, BinaryData> specification, OrchestratorType? orchestratorType, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Configurations = configurations;
            Specification = specification;
            OrchestratorType = orchestratorType;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateVersionProperties"/> for deserialization. </summary>
        internal SolutionTemplateVersionProperties()
        {
        }

        /// <summary> Config expressions for this solution version. </summary>
        public string Configurations { get; set; }
        /// <summary>
        /// App components spec
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> Specification { get; }
        /// <summary> Orchestrator type. </summary>
        public OrchestratorType? OrchestratorType { get; set; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/SolutionTemplateVersionProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SolutionTemplateVersionProperties : IUtf8JsonSerializable, IJsonModel<SolutionTemplateVersionProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionTemplateVersionProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionTemplateVersionProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateVersionProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("configurations"u8);
            writer.WriteStringValue(Configurations);
            writer.WritePropertyName("specification"u8);
            writer.WriteStartObject();
            foreach (var item in Specification)
            {
                writer.WritePropertyName(item.Key);
                if (item.Value == null)
                {
                    writer.WriteNullValue();
                    continue;
                }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                {
                    JsonSerializer.Serialize(writer, document.RootElement);
                }
#endif
            }
            writer.WriteEndObject();
            if (Optional.IsDefined(OrchestratorType))
            {
                writer.WritePropertyName("orchestratorType"u8);
                writer.WriteStringValue(OrchestratorType.Value.ToString());
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionTemplateVersionProperties IJsonModel<SolutionTemplateVersionProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateVersionProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionTemplateVersionProperties(document.RootElement, options);
        }

        internal static SolutionTemplateVersionProperties DeserializeSolutionTemplateVersionProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string configurations = default;
            IDictionary<string, BinaryData> specification = default;
            OrchestratorType? orchestratorType = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("configurations"u8))
                {
                    configurations = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("specification"u8))
                {
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (property.NameEquals("orchestratorType"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    orchestratorType = new OrchestratorType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionTemplateVersionProperties(configurations, specification, orchestratorType, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionTemplateVersionProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateVersionProperties)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionTemplateVersionProperties IPersistableModel<SolutionTemplateVersionProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionTemplateVersionProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateVersionProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionTemplateVersionProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionTemplateVersionWithUpdateType.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Template Version With Update Type. </summary>
    public partial class SolutionTemplateVersionWithUpdateType
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateVersionWithUpdateType"/>. </summary>
        /// <param name="solutionTemplateVersion"> Solution Template Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersion"/> is null. </exception>
        public SolutionTemplateVersionWithUpdateType(EdgeSolutionTemplateVersionData solutionTemplateVersion)
        {
            Argument.AssertNotNull(solutionTemplateVersion, nameof(solutionTemplateVersion));

            SolutionTemplateVersion = solutionTemplateVersion;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateVersionWithUpdateType"/>. </summary>
        /// <param name="updateType"> Update type. </param>
        /// <param name="version"> Version to create. </param>
        /// <param name="solutionTemplateVersion"> Solution Template Version. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionTemplateVersionWithUpdateType(UpdateType? updateType, string version, EdgeSolutionTemplateVersionData solutionTemplateVersion, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            UpdateType = updateType;
            Version = version;
            SolutionTemplateVersion = solutionTemplateVersion;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionTemplateVersionWithUpdateType"/> for deserialization. </summary>
        internal SolutionTemplateVersionWithUpdateType()
        {
        }

        /// <summary> Update type. </summary>
        public UpdateType? UpdateType { get; set; }
        /// <summary> Version to create. </summary>
        public string Version { get; set; }
        /// <summary> Solution Template Version. </summary>
        public EdgeSolutionTemplateVersionData SolutionTemplateVersion { get; }
    }
}



================================================
FILE: Generated/Models/SolutionTemplateVersionWithUpdateType.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SolutionTemplateVersionWithUpdateType : IUtf8JsonSerializable, IJsonModel<SolutionTemplateVersionWithUpdateType>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionTemplateVersionWithUpdateType>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionTemplateVersionWithUpdateType>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateVersionWithUpdateType)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(UpdateType))
            {
                writer.WritePropertyName("updateType"u8);
                writer.WriteStringValue(UpdateType.Value.ToString());
            }
            if (Optional.IsDefined(Version))
            {
                writer.WritePropertyName("version"u8);
                writer.WriteStringValue(Version);
            }
            writer.WritePropertyName("solutionTemplateVersion"u8);
            writer.WriteObjectValue(SolutionTemplateVersion, options);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionTemplateVersionWithUpdateType IJsonModel<SolutionTemplateVersionWithUpdateType>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionTemplateVersionWithUpdateType)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionTemplateVersionWithUpdateType(document.RootElement, options);
        }

        internal static SolutionTemplateVersionWithUpdateType DeserializeSolutionTemplateVersionWithUpdateType(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            UpdateType? updateType = default;
            string version = default;
            EdgeSolutionTemplateVersionData solutionTemplateVersion = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("updateType"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    updateType = new UpdateType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("version"u8))
                {
                    version = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionTemplateVersion"u8))
                {
                    solutionTemplateVersion = EdgeSolutionTemplateVersionData.DeserializeEdgeSolutionTemplateVersionData(property.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionTemplateVersionWithUpdateType(updateType, version, solutionTemplateVersion, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionTemplateVersionWithUpdateType>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateVersionWithUpdateType)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionTemplateVersionWithUpdateType IPersistableModel<SolutionTemplateVersionWithUpdateType>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionTemplateVersionWithUpdateType>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionTemplateVersionWithUpdateType(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionTemplateVersionWithUpdateType)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionTemplateVersionWithUpdateType>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionVersionListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a SolutionVersion list operation. </summary>
    internal partial class SolutionVersionListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionVersionListResult"/>. </summary>
        /// <param name="value"> The SolutionVersion items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal SolutionVersionListResult(IEnumerable<EdgeSolutionVersionData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionVersionListResult"/>. </summary>
        /// <param name="value"> The SolutionVersion items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionVersionListResult(IReadOnlyList<EdgeSolutionVersionData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionVersionListResult"/> for deserialization. </summary>
        internal SolutionVersionListResult()
        {
        }

        /// <summary> The SolutionVersion items on this page. </summary>
        public IReadOnlyList<EdgeSolutionVersionData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/SolutionVersionListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SolutionVersionListResult : IUtf8JsonSerializable, IJsonModel<SolutionVersionListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionVersionListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionVersionListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionVersionListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionVersionListResult IJsonModel<SolutionVersionListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionVersionListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionVersionListResult(document.RootElement, options);
        }

        internal static SolutionVersionListResult DeserializeSolutionVersionListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeSolutionVersionData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeSolutionVersionData> array = new List<EdgeSolutionVersionData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeSolutionVersionData.DeserializeEdgeSolutionVersionData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionVersionListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionVersionListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionVersionListResult)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionVersionListResult IPersistableModel<SolutionVersionListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionVersionListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionVersionListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionVersionListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionVersionProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Version Properties. </summary>
    public partial class SolutionVersionProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionVersionProperties"/>. </summary>
        /// <param name="specification"> App components spec. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="specification"/> is null. </exception>
        public SolutionVersionProperties(IDictionary<string, BinaryData> specification)
        {
            Argument.AssertNotNull(specification, nameof(specification));

            Specification = specification;
            Stages = new ChangeTrackingList<StageMap>();
            SolutionDependencies = new ChangeTrackingList<SolutionDependency>();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionVersionProperties"/>. </summary>
        /// <param name="solutionTemplateVersionId"> Solution Template Version Id. </param>
        /// <param name="revision"> Revision number of resolved config for this solution version. </param>
        /// <param name="targetDisplayName"> Name of applicable target's display name. </param>
        /// <param name="configuration"> Resolved configuration values. </param>
        /// <param name="targetLevelConfiguration"> Configuration on the line level across all solution template versions. </param>
        /// <param name="specification"> App components spec. </param>
        /// <param name="reviewId"> Review id of resolved config for this solution version. </param>
        /// <param name="externalValidationId"> External validation id. </param>
        /// <param name="state"> State of solution instance. </param>
        /// <param name="currentStage"> Current Stage of revision. </param>
        /// <param name="stages"> Stages of revision. </param>
        /// <param name="solutionInstanceName"> Solution instance name. </param>
        /// <param name="solutionDependencies"> Solution Dependency Context. </param>
        /// <param name="errorDetails"> Error Details if any failure is there. </param>
        /// <param name="latestActionTrackingUri"> The URI for tracking the latest action performed on this solution version. </param>
        /// <param name="lastestActionTriggeredBy"> Object Id of user who triggered the latest action on this solution version. </param>
        /// <param name="actionType"> The type of the latest action performed on this solution version. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionVersionProperties(string solutionTemplateVersionId, int? revision, string targetDisplayName, string configuration, string targetLevelConfiguration, IDictionary<string, BinaryData> specification, string reviewId, string externalValidationId, State? state, StageMap currentStage, IReadOnlyList<StageMap> stages, string solutionInstanceName, IReadOnlyList<SolutionDependency> solutionDependencies, ResponseError errorDetails, Uri latestActionTrackingUri, string lastestActionTriggeredBy, JobType? actionType, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionTemplateVersionId = solutionTemplateVersionId;
            Revision = revision;
            TargetDisplayName = targetDisplayName;
            Configuration = configuration;
            TargetLevelConfiguration = targetLevelConfiguration;
            Specification = specification;
            ReviewId = reviewId;
            ExternalValidationId = externalValidationId;
            State = state;
            CurrentStage = currentStage;
            Stages = stages;
            SolutionInstanceName = solutionInstanceName;
            SolutionDependencies = solutionDependencies;
            ErrorDetails = errorDetails;
            LatestActionTrackingUri = latestActionTrackingUri;
            LastestActionTriggeredBy = lastestActionTriggeredBy;
            ActionType = actionType;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="SolutionVersionProperties"/> for deserialization. </summary>
        internal SolutionVersionProperties()
        {
        }

        /// <summary> Solution Template Version Id. </summary>
        public string SolutionTemplateVersionId { get; }
        /// <summary> Revision number of resolved config for this solution version. </summary>
        public int? Revision { get; }
        /// <summary> Name of applicable target's display name. </summary>
        public string TargetDisplayName { get; }
        /// <summary> Resolved configuration values. </summary>
        public string Configuration { get; }
        /// <summary> Configuration on the line level across all solution template versions. </summary>
        public string TargetLevelConfiguration { get; }
        /// <summary>
        /// App components spec
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> Specification { get; }
        /// <summary> Review id of resolved config for this solution version. </summary>
        public string ReviewId { get; }
        /// <summary> External validation id. </summary>
        public string ExternalValidationId { get; }
        /// <summary> State of solution instance. </summary>
        public State? State { get; }
        /// <summary> Current Stage of revision. </summary>
        public StageMap CurrentStage { get; }
        /// <summary> Stages of revision. </summary>
        public IReadOnlyList<StageMap> Stages { get; }
        /// <summary> Solution instance name. </summary>
        public string SolutionInstanceName { get; }
        /// <summary> Solution Dependency Context. </summary>
        public IReadOnlyList<SolutionDependency> SolutionDependencies { get; }
        /// <summary> Error Details if any failure is there. </summary>
        public ResponseError ErrorDetails { get; }
        /// <summary> The URI for tracking the latest action performed on this solution version. </summary>
        public Uri LatestActionTrackingUri { get; }
        /// <summary> Object Id of user who triggered the latest action on this solution version. </summary>
        public string LastestActionTriggeredBy { get; }
        /// <summary> The type of the latest action performed on this solution version. </summary>
        public JobType? ActionType { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/SolutionVersionProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SolutionVersionProperties : IUtf8JsonSerializable, IJsonModel<SolutionVersionProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionVersionProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionVersionProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionVersionProperties)} does not support writing '{format}' format.");
            }

            if (options.Format != "W" && Optional.IsDefined(SolutionTemplateVersionId))
            {
                writer.WritePropertyName("solutionTemplateVersionId"u8);
                writer.WriteStringValue(SolutionTemplateVersionId);
            }
            if (options.Format != "W" && Optional.IsDefined(Revision))
            {
                writer.WritePropertyName("revision"u8);
                writer.WriteNumberValue(Revision.Value);
            }
            if (options.Format != "W" && Optional.IsDefined(TargetDisplayName))
            {
                writer.WritePropertyName("targetDisplayName"u8);
                writer.WriteStringValue(TargetDisplayName);
            }
            if (options.Format != "W" && Optional.IsDefined(Configuration))
            {
                writer.WritePropertyName("configuration"u8);
                writer.WriteStringValue(Configuration);
            }
            if (options.Format != "W" && Optional.IsDefined(TargetLevelConfiguration))
            {
                writer.WritePropertyName("targetLevelConfiguration"u8);
                writer.WriteStringValue(TargetLevelConfiguration);
            }
            writer.WritePropertyName("specification"u8);
            writer.WriteStartObject();
            foreach (var item in Specification)
            {
                writer.WritePropertyName(item.Key);
                if (item.Value == null)
                {
                    writer.WriteNullValue();
                    continue;
                }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                {
                    JsonSerializer.Serialize(writer, document.RootElement);
                }
#endif
            }
            writer.WriteEndObject();
            if (options.Format != "W" && Optional.IsDefined(ReviewId))
            {
                writer.WritePropertyName("reviewId"u8);
                writer.WriteStringValue(ReviewId);
            }
            if (options.Format != "W" && Optional.IsDefined(ExternalValidationId))
            {
                writer.WritePropertyName("externalValidationId"u8);
                writer.WriteStringValue(ExternalValidationId);
            }
            if (options.Format != "W" && Optional.IsDefined(State))
            {
                writer.WritePropertyName("state"u8);
                writer.WriteStringValue(State.Value.ToString());
            }
            if (options.Format != "W" && Optional.IsDefined(CurrentStage))
            {
                writer.WritePropertyName("currentStage"u8);
                writer.WriteObjectValue(CurrentStage, options);
            }
            if (options.Format != "W" && Optional.IsCollectionDefined(Stages))
            {
                writer.WritePropertyName("stages"u8);
                writer.WriteStartArray();
                foreach (var item in Stages)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && Optional.IsDefined(SolutionInstanceName))
            {
                writer.WritePropertyName("solutionInstanceName"u8);
                writer.WriteStringValue(SolutionInstanceName);
            }
            if (options.Format != "W" && Optional.IsCollectionDefined(SolutionDependencies))
            {
                writer.WritePropertyName("solutionDependencies"u8);
                writer.WriteStartArray();
                foreach (var item in SolutionDependencies)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && Optional.IsDefined(ErrorDetails))
            {
                writer.WritePropertyName("errorDetails"u8);
                ((IJsonModel<ResponseError>)ErrorDetails).Write(writer, options);
            }
            if (options.Format != "W" && Optional.IsDefined(LatestActionTrackingUri))
            {
                writer.WritePropertyName("latestActionTrackingUri"u8);
                writer.WriteStringValue(LatestActionTrackingUri.AbsoluteUri);
            }
            if (options.Format != "W" && Optional.IsDefined(LastestActionTriggeredBy))
            {
                writer.WritePropertyName("lastestActionTriggeredBy"u8);
                writer.WriteStringValue(LastestActionTriggeredBy);
            }
            if (options.Format != "W" && Optional.IsDefined(ActionType))
            {
                writer.WritePropertyName("actionType"u8);
                writer.WriteStringValue(ActionType.Value.ToString());
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionVersionProperties IJsonModel<SolutionVersionProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionVersionProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionVersionProperties(document.RootElement, options);
        }

        internal static SolutionVersionProperties DeserializeSolutionVersionProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionTemplateVersionId = default;
            int? revision = default;
            string targetDisplayName = default;
            string configuration = default;
            string targetLevelConfiguration = default;
            IDictionary<string, BinaryData> specification = default;
            string reviewId = default;
            string externalValidationId = default;
            State? state = default;
            StageMap currentStage = default;
            IReadOnlyList<StageMap> stages = default;
            string solutionInstanceName = default;
            IReadOnlyList<SolutionDependency> solutionDependencies = default;
            ResponseError errorDetails = default;
            Uri latestActionTrackingUri = default;
            string lastestActionTriggeredBy = default;
            JobType? actionType = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionTemplateVersionId"u8))
                {
                    solutionTemplateVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("revision"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    revision = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("targetDisplayName"u8))
                {
                    targetDisplayName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("configuration"u8))
                {
                    configuration = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("targetLevelConfiguration"u8))
                {
                    targetLevelConfiguration = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("specification"u8))
                {
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (property.NameEquals("reviewId"u8))
                {
                    reviewId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("externalValidationId"u8))
                {
                    externalValidationId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("state"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    state = new State(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("currentStage"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    currentStage = StageMap.DeserializeStageMap(property.Value, options);
                    continue;
                }
                if (property.NameEquals("stages"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<StageMap> array = new List<StageMap>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(StageMap.DeserializeStageMap(item, options));
                    }
                    stages = array;
                    continue;
                }
                if (property.NameEquals("solutionInstanceName"u8))
                {
                    solutionInstanceName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionDependencies"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<SolutionDependency> array = new List<SolutionDependency>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(SolutionDependency.DeserializeSolutionDependency(item, options));
                    }
                    solutionDependencies = array;
                    continue;
                }
                if (property.NameEquals("errorDetails"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    errorDetails = ModelReaderWriter.Read<ResponseError>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (property.NameEquals("latestActionTrackingUri"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    latestActionTrackingUri = new Uri(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("lastestActionTriggeredBy"u8))
                {
                    lastestActionTriggeredBy = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("actionType"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    actionType = new JobType(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionVersionProperties(
                solutionTemplateVersionId,
                revision,
                targetDisplayName,
                configuration,
                targetLevelConfiguration,
                specification,
                reviewId,
                externalValidationId,
                state,
                currentStage,
                stages ?? new ChangeTrackingList<StageMap>(),
                solutionInstanceName,
                solutionDependencies ?? new ChangeTrackingList<SolutionDependency>(),
                errorDetails,
                latestActionTrackingUri,
                lastestActionTriggeredBy,
                actionType,
                provisioningState,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionVersionProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionVersionProperties)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionVersionProperties IPersistableModel<SolutionVersionProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionVersionProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionVersionProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionVersionProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionVersionPropertiesUpdate.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Version Properties. </summary>
    internal partial class SolutionVersionPropertiesUpdate
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionVersionPropertiesUpdate"/>. </summary>
        public SolutionVersionPropertiesUpdate()
        {
            Specification = new ChangeTrackingDictionary<string, BinaryData>();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionVersionPropertiesUpdate"/>. </summary>
        /// <param name="specification"> App components spec. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionVersionPropertiesUpdate(IDictionary<string, BinaryData> specification, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Specification = specification;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary>
        /// App components spec
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> Specification { get; }
    }
}



================================================
FILE: Generated/Models/SolutionVersionPropertiesUpdate.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class SolutionVersionPropertiesUpdate : IUtf8JsonSerializable, IJsonModel<SolutionVersionPropertiesUpdate>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionVersionPropertiesUpdate>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionVersionPropertiesUpdate>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionVersionPropertiesUpdate)} does not support writing '{format}' format.");
            }

            if (Optional.IsCollectionDefined(Specification))
            {
                writer.WritePropertyName("specification"u8);
                writer.WriteStartObject();
                foreach (var item in Specification)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionVersionPropertiesUpdate IJsonModel<SolutionVersionPropertiesUpdate>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionVersionPropertiesUpdate)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionVersionPropertiesUpdate(document.RootElement, options);
        }

        internal static SolutionVersionPropertiesUpdate DeserializeSolutionVersionPropertiesUpdate(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IDictionary<string, BinaryData> specification = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("specification"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionVersionPropertiesUpdate(specification ?? new ChangeTrackingDictionary<string, BinaryData>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionVersionPropertiesUpdate>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionVersionPropertiesUpdate)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionVersionPropertiesUpdate IPersistableModel<SolutionVersionPropertiesUpdate>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionVersionPropertiesUpdate(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionVersionPropertiesUpdate)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionVersionPropertiesUpdate>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/SolutionVersionSnapshot.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Version Snapshot. </summary>
    public partial class SolutionVersionSnapshot
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="SolutionVersionSnapshot"/>. </summary>
        internal SolutionVersionSnapshot()
        {
            Specification = new ChangeTrackingDictionary<string, BinaryData>();
        }

        /// <summary> Initializes a new instance of <see cref="SolutionVersionSnapshot"/>. </summary>
        /// <param name="solutionVersionId"> Solution version of instance. </param>
        /// <param name="specification"> App components spec. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal SolutionVersionSnapshot(ResourceIdentifier solutionVersionId, IReadOnlyDictionary<string, BinaryData> specification, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersionId = solutionVersionId;
            Specification = specification;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Solution version of instance. </summary>
        public ResourceIdentifier SolutionVersionId { get; }
        /// <summary>
        /// App components spec
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IReadOnlyDictionary<string, BinaryData> Specification { get; }
    }
}



================================================
FILE: Generated/Models/SolutionVersionSnapshot.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class SolutionVersionSnapshot : IUtf8JsonSerializable, IJsonModel<SolutionVersionSnapshot>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<SolutionVersionSnapshot>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<SolutionVersionSnapshot>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionSnapshot>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionVersionSnapshot)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(SolutionVersionId))
            {
                writer.WritePropertyName("solutionVersionId"u8);
                writer.WriteStringValue(SolutionVersionId);
            }
            if (Optional.IsCollectionDefined(Specification))
            {
                writer.WritePropertyName("specification"u8);
                writer.WriteStartObject();
                foreach (var item in Specification)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        SolutionVersionSnapshot IJsonModel<SolutionVersionSnapshot>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionSnapshot>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(SolutionVersionSnapshot)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeSolutionVersionSnapshot(document.RootElement, options);
        }

        internal static SolutionVersionSnapshot DeserializeSolutionVersionSnapshot(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ResourceIdentifier solutionVersionId = default;
            IReadOnlyDictionary<string, BinaryData> specification = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersionId"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    solutionVersionId = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("specification"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new SolutionVersionSnapshot(solutionVersionId, specification ?? new ChangeTrackingDictionary<string, BinaryData>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<SolutionVersionSnapshot>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionSnapshot>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(SolutionVersionSnapshot)} does not support writing '{options.Format}' format.");
            }
        }

        SolutionVersionSnapshot IPersistableModel<SolutionVersionSnapshot>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<SolutionVersionSnapshot>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeSolutionVersionSnapshot(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(SolutionVersionSnapshot)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<SolutionVersionSnapshot>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/StageMap.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Stage Map for Solution Version. </summary>
    public partial class StageMap
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="StageMap"/>. </summary>
        /// <param name="displayState"> Display State. </param>
        /// <param name="stage"> Stage name. </param>
        /// <param name="status"> Stage status. </param>
        internal StageMap(string displayState, CMStage stage, StateCategory status)
        {
            DisplayState = displayState;
            Stage = stage;
            Status = status;
            ChildStages = new ChangeTrackingList<StageMap>();
        }

        /// <summary> Initializes a new instance of <see cref="StageMap"/>. </summary>
        /// <param name="displayState"> Display State. </param>
        /// <param name="stage"> Stage name. </param>
        /// <param name="status"> Stage status. </param>
        /// <param name="startOn"> Stage start time. </param>
        /// <param name="endOn"> Stage end time. </param>
        /// <param name="childStages"> Child stages which represents more granular level stage status if any. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal StageMap(string displayState, CMStage stage, StateCategory status, DateTimeOffset? startOn, DateTimeOffset? endOn, IReadOnlyList<StageMap> childStages, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            DisplayState = displayState;
            Stage = stage;
            Status = status;
            StartOn = startOn;
            EndOn = endOn;
            ChildStages = childStages;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="StageMap"/> for deserialization. </summary>
        internal StageMap()
        {
        }

        /// <summary> Display State. </summary>
        public string DisplayState { get; }
        /// <summary> Stage name. </summary>
        public CMStage Stage { get; }
        /// <summary> Stage status. </summary>
        public StateCategory Status { get; }
        /// <summary> Stage start time. </summary>
        public DateTimeOffset? StartOn { get; }
        /// <summary> Stage end time. </summary>
        public DateTimeOffset? EndOn { get; }
        /// <summary> Child stages which represents more granular level stage status if any. </summary>
        public IReadOnlyList<StageMap> ChildStages { get; }
    }
}



================================================
FILE: Generated/Models/StageMap.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class StageMap : IUtf8JsonSerializable, IJsonModel<StageMap>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<StageMap>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<StageMap>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageMap>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(StageMap)} does not support writing '{format}' format.");
            }

            if (options.Format != "W")
            {
                writer.WritePropertyName("displayState"u8);
                writer.WriteStringValue(DisplayState);
            }
            if (options.Format != "W")
            {
                writer.WritePropertyName("stage"u8);
                writer.WriteStringValue(Stage.ToString());
            }
            if (options.Format != "W")
            {
                writer.WritePropertyName("status"u8);
                writer.WriteStringValue(Status.ToString());
            }
            if (options.Format != "W" && Optional.IsDefined(StartOn))
            {
                writer.WritePropertyName("startTime"u8);
                writer.WriteStringValue(StartOn.Value, "O");
            }
            if (options.Format != "W" && Optional.IsDefined(EndOn))
            {
                writer.WritePropertyName("endTime"u8);
                writer.WriteStringValue(EndOn.Value, "O");
            }
            if (options.Format != "W" && Optional.IsCollectionDefined(ChildStages))
            {
                writer.WritePropertyName("childStages"u8);
                writer.WriteStartArray();
                foreach (var item in ChildStages)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        StageMap IJsonModel<StageMap>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageMap>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(StageMap)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeStageMap(document.RootElement, options);
        }

        internal static StageMap DeserializeStageMap(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string displayState = default;
            CMStage stage = default;
            StateCategory status = default;
            DateTimeOffset? startTime = default;
            DateTimeOffset? endTime = default;
            IReadOnlyList<StageMap> childStages = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("displayState"u8))
                {
                    displayState = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("stage"u8))
                {
                    stage = new CMStage(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    status = new StateCategory(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("startTime"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    startTime = property.Value.GetDateTimeOffset("O");
                    continue;
                }
                if (property.NameEquals("endTime"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    endTime = property.Value.GetDateTimeOffset("O");
                    continue;
                }
                if (property.NameEquals("childStages"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<StageMap> array = new List<StageMap>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(DeserializeStageMap(item, options));
                    }
                    childStages = array;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new StageMap(
                displayState,
                stage,
                status,
                startTime,
                endTime,
                childStages ?? new ChangeTrackingList<StageMap>(),
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<StageMap>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageMap>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(StageMap)} does not support writing '{options.Format}' format.");
            }
        }

        StageMap IPersistableModel<StageMap>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageMap>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeStageMap(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(StageMap)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<StageMap>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/StageSpec.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Stage Properties. </summary>
    public partial class StageSpec
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="StageSpec"/>. </summary>
        /// <param name="name"> Name of Stage. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        public StageSpec(string name)
        {
            Argument.AssertNotNull(name, nameof(name));

            Name = name;
            Specification = new ChangeTrackingDictionary<string, BinaryData>();
            Tasks = new ChangeTrackingList<TaskSpec>();
        }

        /// <summary> Initializes a new instance of <see cref="StageSpec"/>. </summary>
        /// <param name="name"> Name of Stage. </param>
        /// <param name="specification"> Stage specification. </param>
        /// <param name="tasks"> List of tasks in the stage. </param>
        /// <param name="taskOption"> Task option for the stage. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal StageSpec(string name, IDictionary<string, BinaryData> specification, IList<TaskSpec> tasks, WorkloadOrchestrationTaskConfig taskOption, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Name = name;
            Specification = specification;
            Tasks = tasks;
            TaskOption = taskOption;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="StageSpec"/> for deserialization. </summary>
        internal StageSpec()
        {
        }

        /// <summary> Name of Stage. </summary>
        public string Name { get; set; }
        /// <summary>
        /// Stage specification
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> Specification { get; }
        /// <summary> List of tasks in the stage. </summary>
        public IList<TaskSpec> Tasks { get; }
        /// <summary> Task option for the stage. </summary>
        public WorkloadOrchestrationTaskConfig TaskOption { get; set; }
    }
}



================================================
FILE: Generated/Models/StageSpec.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class StageSpec : IUtf8JsonSerializable, IJsonModel<StageSpec>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<StageSpec>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<StageSpec>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageSpec>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(StageSpec)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("name"u8);
            writer.WriteStringValue(Name);
            if (Optional.IsCollectionDefined(Specification))
            {
                writer.WritePropertyName("specification"u8);
                writer.WriteStartObject();
                foreach (var item in Specification)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (Optional.IsCollectionDefined(Tasks))
            {
                writer.WritePropertyName("tasks"u8);
                writer.WriteStartArray();
                foreach (var item in Tasks)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (Optional.IsDefined(TaskOption))
            {
                writer.WritePropertyName("taskOption"u8);
                writer.WriteObjectValue(TaskOption, options);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        StageSpec IJsonModel<StageSpec>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageSpec>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(StageSpec)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeStageSpec(document.RootElement, options);
        }

        internal static StageSpec DeserializeStageSpec(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string name = default;
            IDictionary<string, BinaryData> specification = default;
            IList<TaskSpec> tasks = default;
            WorkloadOrchestrationTaskConfig taskOption = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("specification"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (property.NameEquals("tasks"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<TaskSpec> array = new List<TaskSpec>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(TaskSpec.DeserializeTaskSpec(item, options));
                    }
                    tasks = array;
                    continue;
                }
                if (property.NameEquals("taskOption"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    taskOption = WorkloadOrchestrationTaskConfig.DeserializeWorkloadOrchestrationTaskConfig(property.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new StageSpec(name, specification ?? new ChangeTrackingDictionary<string, BinaryData>(), tasks ?? new ChangeTrackingList<TaskSpec>(), taskOption, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<StageSpec>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageSpec>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(StageSpec)} does not support writing '{options.Format}' format.");
            }
        }

        StageSpec IPersistableModel<StageSpec>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageSpec>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeStageSpec(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(StageSpec)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<StageSpec>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/StageStatus.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Result of Stage execution. </summary>
    public partial class StageStatus
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="StageStatus"/>. </summary>
        internal StageStatus()
        {
            Inputs = new ChangeTrackingDictionary<string, BinaryData>();
            Outputs = new ChangeTrackingDictionary<string, BinaryData>();
        }

        /// <summary> Initializes a new instance of <see cref="StageStatus"/>. </summary>
        /// <param name="status"> Deployment status. </param>
        /// <param name="statusMessage"> Status message. </param>
        /// <param name="stage"> Current stage. </param>
        /// <param name="nextstage"> Next stage. </param>
        /// <param name="errorMessage"> Error message. </param>
        /// <param name="isActive"> whether this stage is active or inactive. </param>
        /// <param name="inputs"> The inputs of the StageHistory, Inputs holds a key-value map of user-defined parameters for the initial stage. </param>
        /// <param name="outputs"> The outputs of the StageHistory, it is different as the different input stages. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal StageStatus(int? status, string statusMessage, string stage, string nextstage, string errorMessage, ActiveState? isActive, IReadOnlyDictionary<string, BinaryData> inputs, IReadOnlyDictionary<string, BinaryData> outputs, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Status = status;
            StatusMessage = statusMessage;
            Stage = stage;
            Nextstage = nextstage;
            ErrorMessage = errorMessage;
            IsActive = isActive;
            Inputs = inputs;
            Outputs = outputs;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Deployment status. </summary>
        public int? Status { get; }
        /// <summary> Status message. </summary>
        public string StatusMessage { get; }
        /// <summary> Current stage. </summary>
        public string Stage { get; }
        /// <summary> Next stage. </summary>
        public string Nextstage { get; }
        /// <summary> Error message. </summary>
        public string ErrorMessage { get; }
        /// <summary> whether this stage is active or inactive. </summary>
        public ActiveState? IsActive { get; }
        /// <summary>
        /// The inputs of the StageHistory, Inputs holds a key-value map of user-defined parameters for the initial stage
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IReadOnlyDictionary<string, BinaryData> Inputs { get; }
        /// <summary>
        /// The outputs of the StageHistory, it is different as the different input stages.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IReadOnlyDictionary<string, BinaryData> Outputs { get; }
    }
}



================================================
FILE: Generated/Models/StageStatus.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class StageStatus : IUtf8JsonSerializable, IJsonModel<StageStatus>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<StageStatus>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<StageStatus>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(StageStatus)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Status))
            {
                writer.WritePropertyName("status"u8);
                writer.WriteNumberValue(Status.Value);
            }
            if (Optional.IsDefined(StatusMessage))
            {
                writer.WritePropertyName("statusMessage"u8);
                writer.WriteStringValue(StatusMessage);
            }
            if (Optional.IsDefined(Stage))
            {
                writer.WritePropertyName("stage"u8);
                writer.WriteStringValue(Stage);
            }
            if (Optional.IsDefined(Nextstage))
            {
                writer.WritePropertyName("nextstage"u8);
                writer.WriteStringValue(Nextstage);
            }
            if (Optional.IsDefined(ErrorMessage))
            {
                writer.WritePropertyName("errorMessage"u8);
                writer.WriteStringValue(ErrorMessage);
            }
            if (Optional.IsDefined(IsActive))
            {
                writer.WritePropertyName("isActive"u8);
                writer.WriteStringValue(IsActive.Value.ToString());
            }
            if (Optional.IsCollectionDefined(Inputs))
            {
                writer.WritePropertyName("inputs"u8);
                writer.WriteStartObject();
                foreach (var item in Inputs)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (Optional.IsCollectionDefined(Outputs))
            {
                writer.WritePropertyName("outputs"u8);
                writer.WriteStartObject();
                foreach (var item in Outputs)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        StageStatus IJsonModel<StageStatus>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(StageStatus)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeStageStatus(document.RootElement, options);
        }

        internal static StageStatus DeserializeStageStatus(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            int? status = default;
            string statusMessage = default;
            string stage = default;
            string nextstage = default;
            string errorMessage = default;
            ActiveState? isActive = default;
            IReadOnlyDictionary<string, BinaryData> inputs = default;
            IReadOnlyDictionary<string, BinaryData> outputs = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("status"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    status = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("statusMessage"u8))
                {
                    statusMessage = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("stage"u8))
                {
                    stage = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("nextstage"u8))
                {
                    nextstage = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("errorMessage"u8))
                {
                    errorMessage = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("isActive"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    isActive = new ActiveState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("inputs"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    inputs = dictionary;
                    continue;
                }
                if (property.NameEquals("outputs"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    outputs = dictionary;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new StageStatus(
                status,
                statusMessage,
                stage,
                nextstage,
                errorMessage,
                isActive,
                inputs ?? new ChangeTrackingDictionary<string, BinaryData>(),
                outputs ?? new ChangeTrackingDictionary<string, BinaryData>(),
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<StageStatus>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(StageStatus)} does not support writing '{options.Format}' format.");
            }
        }

        StageStatus IPersistableModel<StageStatus>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<StageStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeStageStatus(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(StageStatus)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<StageStatus>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/State.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Instance State. </summary>
    public readonly partial struct State : IEquatable<State>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="State"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public State(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string InReviewValue = "InReview";
        private const string UpgradeInReviewValue = "UpgradeInReview";
        private const string ReadyToDeployValue = "ReadyToDeploy";
        private const string ReadyToUpgradeValue = "ReadyToUpgrade";
        private const string DeployingValue = "Deploying";
        private const string DeployedValue = "Deployed";
        private const string FailedValue = "Failed";
        private const string UndeployedValue = "Undeployed";
        private const string PendingExternalValidationValue = "PendingExternalValidation";
        private const string ExternalValidationFailedValue = "ExternalValidationFailed";
        private const string StagingValue = "Staging";
        private const string NotApplicableValue = "NotApplicable";

        /// <summary> Solution Instance is in review. </summary>
        public static State InReview { get; } = new State(InReviewValue);
        /// <summary> Solution Instance upgrade is in review. </summary>
        public static State UpgradeInReview { get; } = new State(UpgradeInReviewValue);
        /// <summary> Solution Instance is ready to deploy. </summary>
        public static State ReadyToDeploy { get; } = new State(ReadyToDeployValue);
        /// <summary> Solution Instance is ready to upgrade. </summary>
        public static State ReadyToUpgrade { get; } = new State(ReadyToUpgradeValue);
        /// <summary> Solution Instance is deploying. </summary>
        public static State Deploying { get; } = new State(DeployingValue);
        /// <summary> Solution Instance is deployed. </summary>
        public static State Deployed { get; } = new State(DeployedValue);
        /// <summary> Solution Instance failed to deploy. </summary>
        public static State Failed { get; } = new State(FailedValue);
        /// <summary> Solution Instance is undeployed. </summary>
        public static State Undeployed { get; } = new State(UndeployedValue);
        /// <summary> Solution Instance is pending external validation. </summary>
        public static State PendingExternalValidation { get; } = new State(PendingExternalValidationValue);
        /// <summary> Solution Instance failed external validation. </summary>
        public static State ExternalValidationFailed { get; } = new State(ExternalValidationFailedValue);
        /// <summary> Solution Instance is staging the images. </summary>
        public static State Staging { get; } = new State(StagingValue);
        /// <summary> State is not applicable. </summary>
        public static State NotApplicable { get; } = new State(NotApplicableValue);
        /// <summary> Determines if two <see cref="State"/> values are the same. </summary>
        public static bool operator ==(State left, State right) => left.Equals(right);
        /// <summary> Determines if two <see cref="State"/> values are not the same. </summary>
        public static bool operator !=(State left, State right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="State"/>. </summary>
        public static implicit operator State(string value) => new State(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is State other && Equals(other);
        /// <inheritdoc />
        public bool Equals(State other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/StateCategory.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> State Category for Solution Version. </summary>
    public readonly partial struct StateCategory : IEquatable<StateCategory>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="StateCategory"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public StateCategory(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string PendingValue = "Pending";
        private const string InProgressValue = "InProgress";
        private const string CompletedValue = "Completed";
        private const string FailedValue = "Failed";
        private const string NoneValue = "None";

        /// <summary> Pending state [Non-Terminal]. </summary>
        public static StateCategory Pending { get; } = new StateCategory(PendingValue);
        /// <summary> InProgress state [Non-Terminal]. </summary>
        public static StateCategory InProgress { get; } = new StateCategory(InProgressValue);
        /// <summary> Completed state [Terminal]. </summary>
        public static StateCategory Completed { get; } = new StateCategory(CompletedValue);
        /// <summary> Failed state [Terminal]. </summary>
        public static StateCategory Failed { get; } = new StateCategory(FailedValue);
        /// <summary> None state [Terminal]. </summary>
        public static StateCategory None { get; } = new StateCategory(NoneValue);
        /// <summary> Determines if two <see cref="StateCategory"/> values are the same. </summary>
        public static bool operator ==(StateCategory left, StateCategory right) => left.Equals(right);
        /// <summary> Determines if two <see cref="StateCategory"/> values are not the same. </summary>
        public static bool operator !=(StateCategory left, StateCategory right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="StateCategory"/>. </summary>
        public static implicit operator StateCategory(string value) => new StateCategory(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is StateCategory other && Equals(other);
        /// <inheritdoc />
        public bool Equals(StateCategory other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/TargetListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a Target list operation. </summary>
    internal partial class TargetListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="TargetListResult"/>. </summary>
        /// <param name="value"> The Target items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal TargetListResult(IEnumerable<EdgeTargetData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="TargetListResult"/>. </summary>
        /// <param name="value"> The Target items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal TargetListResult(IReadOnlyList<EdgeTargetData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="TargetListResult"/> for deserialization. </summary>
        internal TargetListResult()
        {
        }

        /// <summary> The Target items on this page. </summary>
        public IReadOnlyList<EdgeTargetData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/TargetListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class TargetListResult : IUtf8JsonSerializable, IJsonModel<TargetListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<TargetListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<TargetListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        TargetListResult IJsonModel<TargetListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeTargetListResult(document.RootElement, options);
        }

        internal static TargetListResult DeserializeTargetListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeTargetData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeTargetData> array = new List<EdgeTargetData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeTargetData.DeserializeEdgeTargetData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new TargetListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<TargetListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(TargetListResult)} does not support writing '{options.Format}' format.");
            }
        }

        TargetListResult IPersistableModel<TargetListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeTargetListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(TargetListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<TargetListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/TargetProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Target Properties. </summary>
    public partial class TargetProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="TargetProperties"/>. </summary>
        /// <param name="description"> Description of target. </param>
        /// <param name="displayName"> Display name of target. </param>
        /// <param name="contextId"> ArmId of Context. </param>
        /// <param name="targetSpecification"> target spec. </param>
        /// <param name="capabilities"> List of capabilities. </param>
        /// <param name="hierarchyLevel"> Hierarchy Level. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="description"/>, <paramref name="displayName"/>, <paramref name="contextId"/>, <paramref name="targetSpecification"/>, <paramref name="capabilities"/> or <paramref name="hierarchyLevel"/> is null. </exception>
        public TargetProperties(string description, string displayName, ResourceIdentifier contextId, IDictionary<string, BinaryData> targetSpecification, IEnumerable<string> capabilities, string hierarchyLevel)
        {
            Argument.AssertNotNull(description, nameof(description));
            Argument.AssertNotNull(displayName, nameof(displayName));
            Argument.AssertNotNull(contextId, nameof(contextId));
            Argument.AssertNotNull(targetSpecification, nameof(targetSpecification));
            Argument.AssertNotNull(capabilities, nameof(capabilities));
            Argument.AssertNotNull(hierarchyLevel, nameof(hierarchyLevel));

            Description = description;
            DisplayName = displayName;
            ContextId = contextId;
            TargetSpecification = targetSpecification;
            Capabilities = capabilities.ToList();
            HierarchyLevel = hierarchyLevel;
        }

        /// <summary> Initializes a new instance of <see cref="TargetProperties"/>. </summary>
        /// <param name="description"> Description of target. </param>
        /// <param name="displayName"> Display name of target. </param>
        /// <param name="contextId"> ArmId of Context. </param>
        /// <param name="targetSpecification"> target spec. </param>
        /// <param name="capabilities"> List of capabilities. </param>
        /// <param name="hierarchyLevel"> Hierarchy Level. </param>
        /// <param name="status"> Status of target. </param>
        /// <param name="solutionScope"> Scope of the target resource. </param>
        /// <param name="state"> State of resource. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal TargetProperties(string description, string displayName, ResourceIdentifier contextId, IDictionary<string, BinaryData> targetSpecification, IList<string> capabilities, string hierarchyLevel, DeploymentStatus status, string solutionScope, ResourceState? state, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Description = description;
            DisplayName = displayName;
            ContextId = contextId;
            TargetSpecification = targetSpecification;
            Capabilities = capabilities;
            HierarchyLevel = hierarchyLevel;
            Status = status;
            SolutionScope = solutionScope;
            State = state;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="TargetProperties"/> for deserialization. </summary>
        internal TargetProperties()
        {
        }

        /// <summary> Description of target. </summary>
        public string Description { get; set; }
        /// <summary> Display name of target. </summary>
        public string DisplayName { get; set; }
        /// <summary> ArmId of Context. </summary>
        public ResourceIdentifier ContextId { get; set; }
        /// <summary>
        /// target spec
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> TargetSpecification { get; }
        /// <summary> List of capabilities. </summary>
        public IList<string> Capabilities { get; }
        /// <summary> Hierarchy Level. </summary>
        public string HierarchyLevel { get; set; }
        /// <summary> Status of target. </summary>
        public DeploymentStatus Status { get; }
        /// <summary> Scope of the target resource. </summary>
        public string SolutionScope { get; set; }
        /// <summary> State of resource. </summary>
        public ResourceState? State { get; set; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/TargetProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class TargetProperties : IUtf8JsonSerializable, IJsonModel<TargetProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<TargetProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<TargetProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetProperties)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("description"u8);
            writer.WriteStringValue(Description);
            writer.WritePropertyName("displayName"u8);
            writer.WriteStringValue(DisplayName);
            writer.WritePropertyName("contextId"u8);
            writer.WriteStringValue(ContextId);
            writer.WritePropertyName("targetSpecification"u8);
            writer.WriteStartObject();
            foreach (var item in TargetSpecification)
            {
                writer.WritePropertyName(item.Key);
                if (item.Value == null)
                {
                    writer.WriteNullValue();
                    continue;
                }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                {
                    JsonSerializer.Serialize(writer, document.RootElement);
                }
#endif
            }
            writer.WriteEndObject();
            writer.WritePropertyName("capabilities"u8);
            writer.WriteStartArray();
            foreach (var item in Capabilities)
            {
                writer.WriteStringValue(item);
            }
            writer.WriteEndArray();
            writer.WritePropertyName("hierarchyLevel"u8);
            writer.WriteStringValue(HierarchyLevel);
            if (options.Format != "W" && Optional.IsDefined(Status))
            {
                writer.WritePropertyName("status"u8);
                writer.WriteObjectValue(Status, options);
            }
            if (Optional.IsDefined(SolutionScope))
            {
                writer.WritePropertyName("solutionScope"u8);
                writer.WriteStringValue(SolutionScope);
            }
            if (Optional.IsDefined(State))
            {
                writer.WritePropertyName("state"u8);
                writer.WriteStringValue(State.Value.ToString());
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        TargetProperties IJsonModel<TargetProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeTargetProperties(document.RootElement, options);
        }

        internal static TargetProperties DeserializeTargetProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string description = default;
            string displayName = default;
            ResourceIdentifier contextId = default;
            IDictionary<string, BinaryData> targetSpecification = default;
            IList<string> capabilities = default;
            string hierarchyLevel = default;
            DeploymentStatus status = default;
            string solutionScope = default;
            ResourceState? state = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("description"u8))
                {
                    description = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("displayName"u8))
                {
                    displayName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("contextId"u8))
                {
                    contextId = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("targetSpecification"u8))
                {
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    targetSpecification = dictionary;
                    continue;
                }
                if (property.NameEquals("capabilities"u8))
                {
                    List<string> array = new List<string>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(item.GetString());
                    }
                    capabilities = array;
                    continue;
                }
                if (property.NameEquals("hierarchyLevel"u8))
                {
                    hierarchyLevel = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    status = DeploymentStatus.DeserializeDeploymentStatus(property.Value, options);
                    continue;
                }
                if (property.NameEquals("solutionScope"u8))
                {
                    solutionScope = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("state"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    state = new ResourceState(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new TargetProperties(
                description,
                displayName,
                contextId,
                targetSpecification,
                capabilities,
                hierarchyLevel,
                status,
                solutionScope,
                state,
                provisioningState,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<TargetProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(TargetProperties)} does not support writing '{options.Format}' format.");
            }
        }

        TargetProperties IPersistableModel<TargetProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeTargetProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(TargetProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<TargetProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/TargetSnapshot.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Target Snapshot. </summary>
    public partial class TargetSnapshot
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="TargetSnapshot"/>. </summary>
        internal TargetSnapshot()
        {
            TargetSpecification = new ChangeTrackingDictionary<string, BinaryData>();
        }

        /// <summary> Initializes a new instance of <see cref="TargetSnapshot"/>. </summary>
        /// <param name="targetId"> Target of instance. </param>
        /// <param name="targetSpecification"> target spec. </param>
        /// <param name="solutionScope"> Scope of the target resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal TargetSnapshot(ResourceIdentifier targetId, IReadOnlyDictionary<string, BinaryData> targetSpecification, string solutionScope, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            TargetId = targetId;
            TargetSpecification = targetSpecification;
            SolutionScope = solutionScope;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Target of instance. </summary>
        public ResourceIdentifier TargetId { get; }
        /// <summary>
        /// target spec
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IReadOnlyDictionary<string, BinaryData> TargetSpecification { get; }
        /// <summary> Scope of the target resource. </summary>
        public string SolutionScope { get; }
    }
}



================================================
FILE: Generated/Models/TargetSnapshot.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class TargetSnapshot : IUtf8JsonSerializable, IJsonModel<TargetSnapshot>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<TargetSnapshot>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<TargetSnapshot>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetSnapshot>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetSnapshot)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(TargetId))
            {
                writer.WritePropertyName("targetId"u8);
                writer.WriteStringValue(TargetId);
            }
            if (Optional.IsCollectionDefined(TargetSpecification))
            {
                writer.WritePropertyName("targetSpecification"u8);
                writer.WriteStartObject();
                foreach (var item in TargetSpecification)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (Optional.IsDefined(SolutionScope))
            {
                writer.WritePropertyName("solutionScope"u8);
                writer.WriteStringValue(SolutionScope);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        TargetSnapshot IJsonModel<TargetSnapshot>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetSnapshot>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetSnapshot)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeTargetSnapshot(document.RootElement, options);
        }

        internal static TargetSnapshot DeserializeTargetSnapshot(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            ResourceIdentifier targetId = default;
            IReadOnlyDictionary<string, BinaryData> targetSpecification = default;
            string solutionScope = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("targetId"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    targetId = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("targetSpecification"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    targetSpecification = dictionary;
                    continue;
                }
                if (property.NameEquals("solutionScope"u8))
                {
                    solutionScope = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new TargetSnapshot(targetId, targetSpecification ?? new ChangeTrackingDictionary<string, BinaryData>(), solutionScope, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<TargetSnapshot>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetSnapshot>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(TargetSnapshot)} does not support writing '{options.Format}' format.");
            }
        }

        TargetSnapshot IPersistableModel<TargetSnapshot>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetSnapshot>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeTargetSnapshot(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(TargetSnapshot)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<TargetSnapshot>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/TargetStatus.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Target Status. </summary>
    public partial class TargetStatus
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="TargetStatus"/>. </summary>
        internal TargetStatus()
        {
            ComponentStatuses = new ChangeTrackingList<ComponentStatus>();
        }

        /// <summary> Initializes a new instance of <see cref="TargetStatus"/>. </summary>
        /// <param name="name"> Target name. </param>
        /// <param name="status"> Target status. </param>
        /// <param name="componentStatuses"> Component statuses. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal TargetStatus(string name, string status, IReadOnlyList<ComponentStatus> componentStatuses, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Name = name;
            Status = status;
            ComponentStatuses = componentStatuses;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Target name. </summary>
        public string Name { get; }
        /// <summary> Target status. </summary>
        public string Status { get; }
        /// <summary> Component statuses. </summary>
        public IReadOnlyList<ComponentStatus> ComponentStatuses { get; }
    }
}



================================================
FILE: Generated/Models/TargetStatus.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class TargetStatus : IUtf8JsonSerializable, IJsonModel<TargetStatus>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<TargetStatus>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<TargetStatus>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetStatus)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Name))
            {
                writer.WritePropertyName("name"u8);
                writer.WriteStringValue(Name);
            }
            if (Optional.IsDefined(Status))
            {
                writer.WritePropertyName("status"u8);
                writer.WriteStringValue(Status);
            }
            if (Optional.IsCollectionDefined(ComponentStatuses))
            {
                writer.WritePropertyName("componentStatuses"u8);
                writer.WriteStartArray();
                foreach (var item in ComponentStatuses)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        TargetStatus IJsonModel<TargetStatus>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetStatus>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetStatus)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeTargetStatus(document.RootElement, options);
        }

        internal static TargetStatus DeserializeTargetStatus(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string name = default;
            string status = default;
            IReadOnlyList<ComponentStatus> componentStatuses = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("status"u8))
                {
                    status = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("componentStatuses"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<ComponentStatus> array = new List<ComponentStatus>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(ComponentStatus.DeserializeComponentStatus(item, options));
                    }
                    componentStatuses = array;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new TargetStatus(name, status, componentStatuses ?? new ChangeTrackingList<ComponentStatus>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<TargetStatus>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(TargetStatus)} does not support writing '{options.Format}' format.");
            }
        }

        TargetStatus IPersistableModel<TargetStatus>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetStatus>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeTargetStatus(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(TargetStatus)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<TargetStatus>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/TargetUpdateProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The updatable properties of the Target. </summary>
    public partial class TargetUpdateProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="TargetUpdateProperties"/>. </summary>
        public TargetUpdateProperties()
        {
            TargetSpecification = new ChangeTrackingDictionary<string, BinaryData>();
            Capabilities = new ChangeTrackingList<string>();
        }

        /// <summary> Initializes a new instance of <see cref="TargetUpdateProperties"/>. </summary>
        /// <param name="description"> Description of target. </param>
        /// <param name="displayName"> Display name of target. </param>
        /// <param name="contextId"> ArmId of Context. </param>
        /// <param name="targetSpecification"> target spec. </param>
        /// <param name="capabilities"> List of capabilities. </param>
        /// <param name="hierarchyLevel"> Hierarchy Level. </param>
        /// <param name="solutionScope"> Scope of the target resource. </param>
        /// <param name="state"> State of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal TargetUpdateProperties(string description, string displayName, ResourceIdentifier contextId, IDictionary<string, BinaryData> targetSpecification, IList<string> capabilities, string hierarchyLevel, string solutionScope, ResourceState? state, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Description = description;
            DisplayName = displayName;
            ContextId = contextId;
            TargetSpecification = targetSpecification;
            Capabilities = capabilities;
            HierarchyLevel = hierarchyLevel;
            SolutionScope = solutionScope;
            State = state;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Description of target. </summary>
        public string Description { get; set; }
        /// <summary> Display name of target. </summary>
        public string DisplayName { get; set; }
        /// <summary> ArmId of Context. </summary>
        public ResourceIdentifier ContextId { get; set; }
        /// <summary>
        /// target spec
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> TargetSpecification { get; }
        /// <summary> List of capabilities. </summary>
        public IList<string> Capabilities { get; }
        /// <summary> Hierarchy Level. </summary>
        public string HierarchyLevel { get; set; }
        /// <summary> Scope of the target resource. </summary>
        public string SolutionScope { get; set; }
        /// <summary> State of resource. </summary>
        public ResourceState? State { get; set; }
    }
}



================================================
FILE: Generated/Models/TargetUpdateProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class TargetUpdateProperties : IUtf8JsonSerializable, IJsonModel<TargetUpdateProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<TargetUpdateProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<TargetUpdateProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetUpdateProperties)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Description))
            {
                writer.WritePropertyName("description"u8);
                writer.WriteStringValue(Description);
            }
            if (Optional.IsDefined(DisplayName))
            {
                writer.WritePropertyName("displayName"u8);
                writer.WriteStringValue(DisplayName);
            }
            if (Optional.IsDefined(ContextId))
            {
                writer.WritePropertyName("contextId"u8);
                writer.WriteStringValue(ContextId);
            }
            if (Optional.IsCollectionDefined(TargetSpecification))
            {
                writer.WritePropertyName("targetSpecification"u8);
                writer.WriteStartObject();
                foreach (var item in TargetSpecification)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (Optional.IsCollectionDefined(Capabilities))
            {
                writer.WritePropertyName("capabilities"u8);
                writer.WriteStartArray();
                foreach (var item in Capabilities)
                {
                    writer.WriteStringValue(item);
                }
                writer.WriteEndArray();
            }
            if (Optional.IsDefined(HierarchyLevel))
            {
                writer.WritePropertyName("hierarchyLevel"u8);
                writer.WriteStringValue(HierarchyLevel);
            }
            if (Optional.IsDefined(SolutionScope))
            {
                writer.WritePropertyName("solutionScope"u8);
                writer.WriteStringValue(SolutionScope);
            }
            if (Optional.IsDefined(State))
            {
                writer.WritePropertyName("state"u8);
                writer.WriteStringValue(State.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        TargetUpdateProperties IJsonModel<TargetUpdateProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TargetUpdateProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeTargetUpdateProperties(document.RootElement, options);
        }

        internal static TargetUpdateProperties DeserializeTargetUpdateProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string description = default;
            string displayName = default;
            ResourceIdentifier contextId = default;
            IDictionary<string, BinaryData> targetSpecification = default;
            IList<string> capabilities = default;
            string hierarchyLevel = default;
            string solutionScope = default;
            ResourceState? state = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("description"u8))
                {
                    description = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("displayName"u8))
                {
                    displayName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("contextId"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    contextId = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("targetSpecification"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    targetSpecification = dictionary;
                    continue;
                }
                if (property.NameEquals("capabilities"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<string> array = new List<string>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(item.GetString());
                    }
                    capabilities = array;
                    continue;
                }
                if (property.NameEquals("hierarchyLevel"u8))
                {
                    hierarchyLevel = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionScope"u8))
                {
                    solutionScope = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("state"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    state = new ResourceState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new TargetUpdateProperties(
                description,
                displayName,
                contextId,
                targetSpecification ?? new ChangeTrackingDictionary<string, BinaryData>(),
                capabilities ?? new ChangeTrackingList<string>(),
                hierarchyLevel,
                solutionScope,
                state,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<TargetUpdateProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(TargetUpdateProperties)} does not support writing '{options.Format}' format.");
            }
        }

        TargetUpdateProperties IPersistableModel<TargetUpdateProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TargetUpdateProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeTargetUpdateProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(TargetUpdateProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<TargetUpdateProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/TaskSpec.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Task Spec. </summary>
    public partial class TaskSpec
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="TaskSpec"/>. </summary>
        /// <param name="name"> Name of Task. </param>
        /// <param name="specification"> Task specification. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> or <paramref name="specification"/> is null. </exception>
        public TaskSpec(string name, IDictionary<string, BinaryData> specification)
        {
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(specification, nameof(specification));

            Name = name;
            Specification = specification;
        }

        /// <summary> Initializes a new instance of <see cref="TaskSpec"/>. </summary>
        /// <param name="name"> Name of Task. </param>
        /// <param name="targetId"> Target ARM id. </param>
        /// <param name="specification"> Task specification. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal TaskSpec(string name, ResourceIdentifier targetId, IDictionary<string, BinaryData> specification, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Name = name;
            TargetId = targetId;
            Specification = specification;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="TaskSpec"/> for deserialization. </summary>
        internal TaskSpec()
        {
        }

        /// <summary> Name of Task. </summary>
        public string Name { get; set; }
        /// <summary> Target ARM id. </summary>
        public ResourceIdentifier TargetId { get; set; }
        /// <summary>
        /// Task specification
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> Specification { get; }
    }
}



================================================
FILE: Generated/Models/TaskSpec.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class TaskSpec : IUtf8JsonSerializable, IJsonModel<TaskSpec>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<TaskSpec>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<TaskSpec>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TaskSpec>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TaskSpec)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("name"u8);
            writer.WriteStringValue(Name);
            if (Optional.IsDefined(TargetId))
            {
                writer.WritePropertyName("targetId"u8);
                writer.WriteStringValue(TargetId);
            }
            writer.WritePropertyName("specification"u8);
            writer.WriteStartObject();
            foreach (var item in Specification)
            {
                writer.WritePropertyName(item.Key);
                if (item.Value == null)
                {
                    writer.WriteNullValue();
                    continue;
                }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                {
                    JsonSerializer.Serialize(writer, document.RootElement);
                }
#endif
            }
            writer.WriteEndObject();
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        TaskSpec IJsonModel<TaskSpec>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TaskSpec>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(TaskSpec)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeTaskSpec(document.RootElement, options);
        }

        internal static TaskSpec DeserializeTaskSpec(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string name = default;
            ResourceIdentifier targetId = default;
            IDictionary<string, BinaryData> specification = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("name"u8))
                {
                    name = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("targetId"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    targetId = new ResourceIdentifier(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("specification"u8))
                {
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new TaskSpec(name, targetId, specification, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<TaskSpec>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TaskSpec>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(TaskSpec)} does not support writing '{options.Format}' format.");
            }
        }

        TaskSpec IPersistableModel<TaskSpec>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<TaskSpec>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeTaskSpec(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(TaskSpec)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<TaskSpec>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/UnknownJobParameterBase.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Unknown version of JobParameterBase. </summary>
    internal partial class UnknownJobParameterBase : JobParameterBase
    {
        /// <summary> Initializes a new instance of <see cref="UnknownJobParameterBase"/>. </summary>
        /// <param name="jobType"> Job type discriminator value. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal UnknownJobParameterBase(JobType jobType, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(jobType, serializedAdditionalRawData)
        {
            JobType = jobType;
        }

        /// <summary> Initializes a new instance of <see cref="UnknownJobParameterBase"/> for deserialization. </summary>
        internal UnknownJobParameterBase()
        {
        }
    }
}



================================================
FILE: Generated/Models/UnknownJobParameterBase.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class UnknownJobParameterBase : IUtf8JsonSerializable, IJsonModel<JobParameterBase>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<JobParameterBase>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<JobParameterBase>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobParameterBase>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobParameterBase)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
        }

        JobParameterBase IJsonModel<JobParameterBase>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobParameterBase>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobParameterBase)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeJobParameterBase(document.RootElement, options);
        }

        internal static UnknownJobParameterBase DeserializeUnknownJobParameterBase(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            JobType jobType = "Unknown";
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("jobType"u8))
                {
                    jobType = new JobType(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new UnknownJobParameterBase(jobType, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<JobParameterBase>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobParameterBase>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(JobParameterBase)} does not support writing '{options.Format}' format.");
            }
        }

        JobParameterBase IPersistableModel<JobParameterBase>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobParameterBase>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeJobParameterBase(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(JobParameterBase)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<JobParameterBase>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/UnknownJobStepStatisticsBase.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Unknown version of JobStepStatisticsBase. </summary>
    internal partial class UnknownJobStepStatisticsBase : JobStepStatisticsBase
    {
        /// <summary> Initializes a new instance of <see cref="UnknownJobStepStatisticsBase"/>. </summary>
        /// <param name="statisticsType"> Statistics type discriminator value. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal UnknownJobStepStatisticsBase(JobType statisticsType, IDictionary<string, BinaryData> serializedAdditionalRawData) : base(statisticsType, serializedAdditionalRawData)
        {
            StatisticsType = statisticsType;
        }

        /// <summary> Initializes a new instance of <see cref="UnknownJobStepStatisticsBase"/> for deserialization. </summary>
        internal UnknownJobStepStatisticsBase()
        {
        }
    }
}



================================================
FILE: Generated/Models/UnknownJobStepStatisticsBase.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class UnknownJobStepStatisticsBase : IUtf8JsonSerializable, IJsonModel<JobStepStatisticsBase>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<JobStepStatisticsBase>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<JobStepStatisticsBase>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStepStatisticsBase>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobStepStatisticsBase)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
        }

        JobStepStatisticsBase IJsonModel<JobStepStatisticsBase>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStepStatisticsBase>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(JobStepStatisticsBase)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeJobStepStatisticsBase(document.RootElement, options);
        }

        internal static UnknownJobStepStatisticsBase DeserializeUnknownJobStepStatisticsBase(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            JobType statisticsType = "Unknown";
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("statisticsType"u8))
                {
                    statisticsType = new JobType(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new UnknownJobStepStatisticsBase(statisticsType, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<JobStepStatisticsBase>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStepStatisticsBase>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(JobStepStatisticsBase)} does not support writing '{options.Format}' format.");
            }
        }

        JobStepStatisticsBase IPersistableModel<JobStepStatisticsBase>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<JobStepStatisticsBase>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeJobStepStatisticsBase(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(JobStepStatisticsBase)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<JobStepStatisticsBase>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/UpdateType.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Denotes which part of the version number will be updated. </summary>
    public readonly partial struct UpdateType : IEquatable<UpdateType>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="UpdateType"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public UpdateType(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string MajorValue = "Major";
        private const string MinorValue = "Minor";
        private const string PatchValue = "Patch";

        /// <summary> Major version. </summary>
        public static UpdateType Major { get; } = new UpdateType(MajorValue);
        /// <summary> Minor version. </summary>
        public static UpdateType Minor { get; } = new UpdateType(MinorValue);
        /// <summary> Patch version. </summary>
        public static UpdateType Patch { get; } = new UpdateType(PatchValue);
        /// <summary> Determines if two <see cref="UpdateType"/> values are the same. </summary>
        public static bool operator ==(UpdateType left, UpdateType right) => left.Equals(right);
        /// <summary> Determines if two <see cref="UpdateType"/> values are not the same. </summary>
        public static bool operator !=(UpdateType left, UpdateType right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="UpdateType"/>. </summary>
        public static implicit operator UpdateType(string value) => new UpdateType(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is UpdateType other && Equals(other);
        /// <inheritdoc />
        public bool Equals(UpdateType other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/ValidationStatus.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Instance Validation Status. </summary>
    public readonly partial struct ValidationStatus : IEquatable<ValidationStatus>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="ValidationStatus"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public ValidationStatus(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string ValidValue = "Valid";
        private const string InvalidValue = "Invalid";

        /// <summary> Solution Instance is valid. </summary>
        public static ValidationStatus Valid { get; } = new ValidationStatus(ValidValue);
        /// <summary> Solution Instance is invalid. </summary>
        public static ValidationStatus Invalid { get; } = new ValidationStatus(InvalidValue);
        /// <summary> Determines if two <see cref="ValidationStatus"/> values are the same. </summary>
        public static bool operator ==(ValidationStatus left, ValidationStatus right) => left.Equals(right);
        /// <summary> Determines if two <see cref="ValidationStatus"/> values are not the same. </summary>
        public static bool operator !=(ValidationStatus left, ValidationStatus right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="ValidationStatus"/>. </summary>
        public static implicit operator ValidationStatus(string value) => new ValidationStatus(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is ValidationStatus other && Equals(other);
        /// <inheritdoc />
        public bool Equals(ValidationStatus other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}



================================================
FILE: Generated/Models/WorkflowListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a Workflow list operation. </summary>
    internal partial class WorkflowListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkflowListResult"/>. </summary>
        /// <param name="value"> The Workflow items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal WorkflowListResult(IEnumerable<EdgeWorkflowData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="WorkflowListResult"/>. </summary>
        /// <param name="value"> The Workflow items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkflowListResult(IReadOnlyList<EdgeWorkflowData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkflowListResult"/> for deserialization. </summary>
        internal WorkflowListResult()
        {
        }

        /// <summary> The Workflow items on this page. </summary>
        public IReadOnlyList<EdgeWorkflowData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/WorkflowListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class WorkflowListResult : IUtf8JsonSerializable, IJsonModel<WorkflowListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkflowListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkflowListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkflowListResult IJsonModel<WorkflowListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkflowListResult(document.RootElement, options);
        }

        internal static WorkflowListResult DeserializeWorkflowListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeWorkflowData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeWorkflowData> array = new List<EdgeWorkflowData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeWorkflowData.DeserializeEdgeWorkflowData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkflowListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkflowListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkflowListResult)} does not support writing '{options.Format}' format.");
            }
        }

        WorkflowListResult IPersistableModel<WorkflowListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkflowListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkflowListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkflowListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkflowProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Workflow Properties. </summary>
    public partial class WorkflowProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkflowProperties"/>. </summary>
        public WorkflowProperties()
        {
        }

        /// <summary> Initializes a new instance of <see cref="WorkflowProperties"/>. </summary>
        /// <param name="workflowTemplateId"> Workflow template Id. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkflowProperties(string workflowTemplateId, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            WorkflowTemplateId = workflowTemplateId;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Workflow template Id. </summary>
        public string WorkflowTemplateId { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/WorkflowProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkflowProperties : IUtf8JsonSerializable, IJsonModel<WorkflowProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkflowProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkflowProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowProperties)} does not support writing '{format}' format.");
            }

            if (options.Format != "W" && Optional.IsDefined(WorkflowTemplateId))
            {
                writer.WritePropertyName("workflowTemplateId"u8);
                writer.WriteStringValue(WorkflowTemplateId);
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkflowProperties IJsonModel<WorkflowProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkflowProperties(document.RootElement, options);
        }

        internal static WorkflowProperties DeserializeWorkflowProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string workflowTemplateId = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("workflowTemplateId"u8))
                {
                    workflowTemplateId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkflowProperties(workflowTemplateId, provisioningState, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkflowProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkflowProperties)} does not support writing '{options.Format}' format.");
            }
        }

        WorkflowProperties IPersistableModel<WorkflowProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkflowProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkflowProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkflowProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkflowVersionListResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> The response of a WorkflowVersion list operation. </summary>
    internal partial class WorkflowVersionListResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkflowVersionListResult"/>. </summary>
        /// <param name="value"> The WorkflowVersion items on this page. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        internal WorkflowVersionListResult(IEnumerable<EdgeWorkflowVersionData> value)
        {
            Argument.AssertNotNull(value, nameof(value));

            Value = value.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="WorkflowVersionListResult"/>. </summary>
        /// <param name="value"> The WorkflowVersion items on this page. </param>
        /// <param name="nextLink"> The link to the next page of items. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkflowVersionListResult(IReadOnlyList<EdgeWorkflowVersionData> value, Uri nextLink, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Value = value;
            NextLink = nextLink;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkflowVersionListResult"/> for deserialization. </summary>
        internal WorkflowVersionListResult()
        {
        }

        /// <summary> The WorkflowVersion items on this page. </summary>
        public IReadOnlyList<EdgeWorkflowVersionData> Value { get; }
        /// <summary> The link to the next page of items. </summary>
        public Uri NextLink { get; }
    }
}



================================================
FILE: Generated/Models/WorkflowVersionListResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    internal partial class WorkflowVersionListResult : IUtf8JsonSerializable, IJsonModel<WorkflowVersionListResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkflowVersionListResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkflowVersionListResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowVersionListResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("value"u8);
            writer.WriteStartArray();
            foreach (var item in Value)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(NextLink))
            {
                writer.WritePropertyName("nextLink"u8);
                writer.WriteStringValue(NextLink.AbsoluteUri);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkflowVersionListResult IJsonModel<WorkflowVersionListResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionListResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowVersionListResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkflowVersionListResult(document.RootElement, options);
        }

        internal static WorkflowVersionListResult DeserializeWorkflowVersionListResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IReadOnlyList<EdgeWorkflowVersionData> value = default;
            Uri nextLink = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("value"u8))
                {
                    List<EdgeWorkflowVersionData> array = new List<EdgeWorkflowVersionData>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(EdgeWorkflowVersionData.DeserializeEdgeWorkflowVersionData(item, options));
                    }
                    value = array;
                    continue;
                }
                if (property.NameEquals("nextLink"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    nextLink = new Uri(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkflowVersionListResult(value, nextLink, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkflowVersionListResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkflowVersionListResult)} does not support writing '{options.Format}' format.");
            }
        }

        WorkflowVersionListResult IPersistableModel<WorkflowVersionListResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionListResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkflowVersionListResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkflowVersionListResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkflowVersionListResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkflowVersionProperties.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Workflow Version Properties. </summary>
    public partial class WorkflowVersionProperties
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkflowVersionProperties"/>. </summary>
        /// <param name="stageSpec"> A list of stage specs. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="stageSpec"/> is null. </exception>
        public WorkflowVersionProperties(IEnumerable<StageSpec> stageSpec)
        {
            Argument.AssertNotNull(stageSpec, nameof(stageSpec));

            StageSpec = stageSpec.ToList();
            Specification = new ChangeTrackingDictionary<string, BinaryData>();
        }

        /// <summary> Initializes a new instance of <see cref="WorkflowVersionProperties"/>. </summary>
        /// <param name="revision"> Revision number of resolved config for this workflow version. </param>
        /// <param name="configuration"> Resolved configuration values. </param>
        /// <param name="stageSpec"> A list of stage specs. </param>
        /// <param name="reviewId"> Review id of resolved config for this workflow version. </param>
        /// <param name="state"> State of workflow version. </param>
        /// <param name="specification"> Execution specification. </param>
        /// <param name="provisioningState"> Provisioning state of resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkflowVersionProperties(int? revision, string configuration, IList<StageSpec> stageSpec, string reviewId, State? state, IDictionary<string, BinaryData> specification, ProvisioningState? provisioningState, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Revision = revision;
            Configuration = configuration;
            StageSpec = stageSpec;
            ReviewId = reviewId;
            State = state;
            Specification = specification;
            ProvisioningState = provisioningState;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkflowVersionProperties"/> for deserialization. </summary>
        internal WorkflowVersionProperties()
        {
        }

        /// <summary> Revision number of resolved config for this workflow version. </summary>
        public int? Revision { get; }
        /// <summary> Resolved configuration values. </summary>
        public string Configuration { get; }
        /// <summary> A list of stage specs. </summary>
        public IList<StageSpec> StageSpec { get; }
        /// <summary> Review id of resolved config for this workflow version. </summary>
        public string ReviewId { get; }
        /// <summary> State of workflow version. </summary>
        public State? State { get; }
        /// <summary>
        /// Execution specification
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> Specification { get; }
        /// <summary> Provisioning state of resource. </summary>
        public ProvisioningState? ProvisioningState { get; }
    }
}



================================================
FILE: Generated/Models/WorkflowVersionProperties.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkflowVersionProperties : IUtf8JsonSerializable, IJsonModel<WorkflowVersionProperties>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkflowVersionProperties>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkflowVersionProperties>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowVersionProperties)} does not support writing '{format}' format.");
            }

            if (options.Format != "W" && Optional.IsDefined(Revision))
            {
                writer.WritePropertyName("revision"u8);
                writer.WriteNumberValue(Revision.Value);
            }
            if (options.Format != "W" && Optional.IsDefined(Configuration))
            {
                writer.WritePropertyName("configuration"u8);
                writer.WriteStringValue(Configuration);
            }
            writer.WritePropertyName("stageSpec"u8);
            writer.WriteStartArray();
            foreach (var item in StageSpec)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (options.Format != "W" && Optional.IsDefined(ReviewId))
            {
                writer.WritePropertyName("reviewId"u8);
                writer.WriteStringValue(ReviewId);
            }
            if (options.Format != "W" && Optional.IsDefined(State))
            {
                writer.WritePropertyName("state"u8);
                writer.WriteStringValue(State.Value.ToString());
            }
            if (Optional.IsCollectionDefined(Specification))
            {
                writer.WritePropertyName("specification"u8);
                writer.WriteStartObject();
                foreach (var item in Specification)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (options.Format != "W" && Optional.IsDefined(ProvisioningState))
            {
                writer.WritePropertyName("provisioningState"u8);
                writer.WriteStringValue(ProvisioningState.Value.ToString());
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkflowVersionProperties IJsonModel<WorkflowVersionProperties>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionProperties>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowVersionProperties)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkflowVersionProperties(document.RootElement, options);
        }

        internal static WorkflowVersionProperties DeserializeWorkflowVersionProperties(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            int? revision = default;
            string configuration = default;
            IList<StageSpec> stageSpec = default;
            string reviewId = default;
            State? state = default;
            IDictionary<string, BinaryData> specification = default;
            ProvisioningState? provisioningState = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("revision"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    revision = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("configuration"u8))
                {
                    configuration = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("stageSpec"u8))
                {
                    List<StageSpec> array = new List<StageSpec>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(Models.StageSpec.DeserializeStageSpec(item, options));
                    }
                    stageSpec = array;
                    continue;
                }
                if (property.NameEquals("reviewId"u8))
                {
                    reviewId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("state"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    state = new State(property.Value.GetString());
                    continue;
                }
                if (property.NameEquals("specification"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (property.NameEquals("provisioningState"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    provisioningState = new ProvisioningState(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkflowVersionProperties(
                revision,
                configuration,
                stageSpec,
                reviewId,
                state,
                specification ?? new ChangeTrackingDictionary<string, BinaryData>(),
                provisioningState,
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkflowVersionProperties>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkflowVersionProperties)} does not support writing '{options.Format}' format.");
            }
        }

        WorkflowVersionProperties IPersistableModel<WorkflowVersionProperties>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionProperties>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkflowVersionProperties(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkflowVersionProperties)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkflowVersionProperties>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkflowVersionPropertiesUpdate.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Workflow Version Properties. </summary>
    public partial class WorkflowVersionPropertiesUpdate
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkflowVersionPropertiesUpdate"/>. </summary>
        public WorkflowVersionPropertiesUpdate()
        {
            StageSpec = new ChangeTrackingList<StageSpec>();
            Specification = new ChangeTrackingDictionary<string, BinaryData>();
        }

        /// <summary> Initializes a new instance of <see cref="WorkflowVersionPropertiesUpdate"/>. </summary>
        /// <param name="stageSpec"> A list of stage specs. </param>
        /// <param name="specification"> Execution specification. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkflowVersionPropertiesUpdate(IList<StageSpec> stageSpec, IDictionary<string, BinaryData> specification, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            StageSpec = stageSpec;
            Specification = specification;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> A list of stage specs. </summary>
        public IList<StageSpec> StageSpec { get; }
        /// <summary>
        /// Execution specification
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        public IDictionary<string, BinaryData> Specification { get; }
    }
}



================================================
FILE: Generated/Models/WorkflowVersionPropertiesUpdate.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkflowVersionPropertiesUpdate : IUtf8JsonSerializable, IJsonModel<WorkflowVersionPropertiesUpdate>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkflowVersionPropertiesUpdate>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkflowVersionPropertiesUpdate>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowVersionPropertiesUpdate)} does not support writing '{format}' format.");
            }

            if (Optional.IsCollectionDefined(StageSpec))
            {
                writer.WritePropertyName("stageSpec"u8);
                writer.WriteStartArray();
                foreach (var item in StageSpec)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (Optional.IsCollectionDefined(Specification))
            {
                writer.WritePropertyName("specification"u8);
                writer.WriteStartObject();
                foreach (var item in Specification)
                {
                    writer.WritePropertyName(item.Key);
                    if (item.Value == null)
                    {
                        writer.WriteNullValue();
                        continue;
                    }
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
                writer.WriteEndObject();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkflowVersionPropertiesUpdate IJsonModel<WorkflowVersionPropertiesUpdate>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkflowVersionPropertiesUpdate)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkflowVersionPropertiesUpdate(document.RootElement, options);
        }

        internal static WorkflowVersionPropertiesUpdate DeserializeWorkflowVersionPropertiesUpdate(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IList<StageSpec> stageSpec = default;
            IDictionary<string, BinaryData> specification = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("stageSpec"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<StageSpec> array = new List<StageSpec>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(Models.StageSpec.DeserializeStageSpec(item, options));
                    }
                    stageSpec = array;
                    continue;
                }
                if (property.NameEquals("specification"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    Dictionary<string, BinaryData> dictionary = new Dictionary<string, BinaryData>();
                    foreach (var property0 in property.Value.EnumerateObject())
                    {
                        if (property0.Value.ValueKind == JsonValueKind.Null)
                        {
                            dictionary.Add(property0.Name, null);
                        }
                        else
                        {
                            dictionary.Add(property0.Name, BinaryData.FromString(property0.Value.GetRawText()));
                        }
                    }
                    specification = dictionary;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkflowVersionPropertiesUpdate(stageSpec ?? new ChangeTrackingList<StageSpec>(), specification ?? new ChangeTrackingDictionary<string, BinaryData>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkflowVersionPropertiesUpdate>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkflowVersionPropertiesUpdate)} does not support writing '{options.Format}' format.");
            }
        }

        WorkflowVersionPropertiesUpdate IPersistableModel<WorkflowVersionPropertiesUpdate>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkflowVersionPropertiesUpdate>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkflowVersionPropertiesUpdate(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkflowVersionPropertiesUpdate)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkflowVersionPropertiesUpdate>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationBulkDeploySolutionContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Bulk deploy solution parameter. </summary>
    public partial class WorkloadOrchestrationBulkDeploySolutionContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationBulkDeploySolutionContent"/>. </summary>
        /// <param name="targets"> Targets to which solution needs to be deployed. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targets"/> is null. </exception>
        public WorkloadOrchestrationBulkDeploySolutionContent(IEnumerable<BulkDeployTargetDetails> targets)
        {
            Argument.AssertNotNull(targets, nameof(targets));

            Targets = targets.ToList();
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationBulkDeploySolutionContent"/>. </summary>
        /// <param name="targets"> Targets to which solution needs to be deployed. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationBulkDeploySolutionContent(IList<BulkDeployTargetDetails> targets, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Targets = targets;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationBulkDeploySolutionContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationBulkDeploySolutionContent()
        {
        }

        /// <summary> Targets to which solution needs to be deployed. </summary>
        public IList<BulkDeployTargetDetails> Targets { get; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationBulkDeploySolutionContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationBulkDeploySolutionContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationBulkDeploySolutionContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationBulkDeploySolutionContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationBulkDeploySolutionContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkDeploySolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkDeploySolutionContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("targets"u8);
            writer.WriteStartArray();
            foreach (var item in Targets)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationBulkDeploySolutionContent IJsonModel<WorkloadOrchestrationBulkDeploySolutionContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkDeploySolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkDeploySolutionContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationBulkDeploySolutionContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationBulkDeploySolutionContent DeserializeWorkloadOrchestrationBulkDeploySolutionContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IList<BulkDeployTargetDetails> targets = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("targets"u8))
                {
                    List<BulkDeployTargetDetails> array = new List<BulkDeployTargetDetails>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(BulkDeployTargetDetails.DeserializeBulkDeployTargetDetails(item, options));
                    }
                    targets = array;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationBulkDeploySolutionContent(targets, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationBulkDeploySolutionContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkDeploySolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkDeploySolutionContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationBulkDeploySolutionContent IPersistableModel<WorkloadOrchestrationBulkDeploySolutionContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkDeploySolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationBulkDeploySolutionContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkDeploySolutionContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationBulkDeploySolutionContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationBulkPublishSolutionContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Bulk publish solution parameter. </summary>
    public partial class WorkloadOrchestrationBulkPublishSolutionContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationBulkPublishSolutionContent"/>. </summary>
        /// <param name="targets"> Targets to which solution needs to be published. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targets"/> is null. </exception>
        public WorkloadOrchestrationBulkPublishSolutionContent(IEnumerable<BulkPublishTargetDetails> targets)
        {
            Argument.AssertNotNull(targets, nameof(targets));

            Targets = targets.ToList();
            SolutionDependencies = new ChangeTrackingList<WorkloadOrchestrationSolutionDependencyContent>();
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationBulkPublishSolutionContent"/>. </summary>
        /// <param name="targets"> Targets to which solution needs to be published. </param>
        /// <param name="solutionInstanceName"> Name of the solution instance. </param>
        /// <param name="solutionDependencies"> Solution dependencies. </param>
        /// <param name="solutionConfiguration"> Configuration of solution. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationBulkPublishSolutionContent(IList<BulkPublishTargetDetails> targets, string solutionInstanceName, IList<WorkloadOrchestrationSolutionDependencyContent> solutionDependencies, string solutionConfiguration, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Targets = targets;
            SolutionInstanceName = solutionInstanceName;
            SolutionDependencies = solutionDependencies;
            SolutionConfiguration = solutionConfiguration;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationBulkPublishSolutionContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationBulkPublishSolutionContent()
        {
        }

        /// <summary> Targets to which solution needs to be published. </summary>
        public IList<BulkPublishTargetDetails> Targets { get; }
        /// <summary> Name of the solution instance. </summary>
        public string SolutionInstanceName { get; set; }
        /// <summary> Solution dependencies. </summary>
        public IList<WorkloadOrchestrationSolutionDependencyContent> SolutionDependencies { get; }
        /// <summary> Configuration of solution. </summary>
        public string SolutionConfiguration { get; set; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationBulkPublishSolutionContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationBulkPublishSolutionContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationBulkPublishSolutionContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationBulkPublishSolutionContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationBulkPublishSolutionContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkPublishSolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkPublishSolutionContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("targets"u8);
            writer.WriteStartArray();
            foreach (var item in Targets)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(SolutionInstanceName))
            {
                writer.WritePropertyName("solutionInstanceName"u8);
                writer.WriteStringValue(SolutionInstanceName);
            }
            if (Optional.IsCollectionDefined(SolutionDependencies))
            {
                writer.WritePropertyName("solutionDependencies"u8);
                writer.WriteStartArray();
                foreach (var item in SolutionDependencies)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (Optional.IsDefined(SolutionConfiguration))
            {
                writer.WritePropertyName("solutionConfiguration"u8);
                writer.WriteStringValue(SolutionConfiguration);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationBulkPublishSolutionContent IJsonModel<WorkloadOrchestrationBulkPublishSolutionContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkPublishSolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkPublishSolutionContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationBulkPublishSolutionContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationBulkPublishSolutionContent DeserializeWorkloadOrchestrationBulkPublishSolutionContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IList<BulkPublishTargetDetails> targets = default;
            string solutionInstanceName = default;
            IList<WorkloadOrchestrationSolutionDependencyContent> solutionDependencies = default;
            string solutionConfiguration = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("targets"u8))
                {
                    List<BulkPublishTargetDetails> array = new List<BulkPublishTargetDetails>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(BulkPublishTargetDetails.DeserializeBulkPublishTargetDetails(item, options));
                    }
                    targets = array;
                    continue;
                }
                if (property.NameEquals("solutionInstanceName"u8))
                {
                    solutionInstanceName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionDependencies"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<WorkloadOrchestrationSolutionDependencyContent> array = new List<WorkloadOrchestrationSolutionDependencyContent>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(WorkloadOrchestrationSolutionDependencyContent.DeserializeWorkloadOrchestrationSolutionDependencyContent(item, options));
                    }
                    solutionDependencies = array;
                    continue;
                }
                if (property.NameEquals("solutionConfiguration"u8))
                {
                    solutionConfiguration = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationBulkPublishSolutionContent(targets, solutionInstanceName, solutionDependencies ?? new ChangeTrackingList<WorkloadOrchestrationSolutionDependencyContent>(), solutionConfiguration, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationBulkPublishSolutionContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkPublishSolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkPublishSolutionContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationBulkPublishSolutionContent IPersistableModel<WorkloadOrchestrationBulkPublishSolutionContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkPublishSolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationBulkPublishSolutionContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkPublishSolutionContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationBulkPublishSolutionContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationBulkReviewSolutionContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Bulk publish solution parameter. </summary>
    public partial class WorkloadOrchestrationBulkReviewSolutionContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationBulkReviewSolutionContent"/>. </summary>
        /// <param name="targets"> Targets to which solution needs to be published. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="targets"/> is null. </exception>
        public WorkloadOrchestrationBulkReviewSolutionContent(IEnumerable<BulkReviewTargetDetails> targets)
        {
            Argument.AssertNotNull(targets, nameof(targets));

            Targets = targets.ToList();
            SolutionDependencies = new ChangeTrackingList<WorkloadOrchestrationSolutionDependencyContent>();
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationBulkReviewSolutionContent"/>. </summary>
        /// <param name="targets"> Targets to which solution needs to be published. </param>
        /// <param name="solutionInstanceName"> Name of the solution instance. </param>
        /// <param name="solutionDependencies"> Solution dependencies. </param>
        /// <param name="solutionConfiguration"> Configuration of solution. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationBulkReviewSolutionContent(IList<BulkReviewTargetDetails> targets, string solutionInstanceName, IList<WorkloadOrchestrationSolutionDependencyContent> solutionDependencies, string solutionConfiguration, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Targets = targets;
            SolutionInstanceName = solutionInstanceName;
            SolutionDependencies = solutionDependencies;
            SolutionConfiguration = solutionConfiguration;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationBulkReviewSolutionContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationBulkReviewSolutionContent()
        {
        }

        /// <summary> Targets to which solution needs to be published. </summary>
        public IList<BulkReviewTargetDetails> Targets { get; }
        /// <summary> Name of the solution instance. </summary>
        public string SolutionInstanceName { get; set; }
        /// <summary> Solution dependencies. </summary>
        public IList<WorkloadOrchestrationSolutionDependencyContent> SolutionDependencies { get; }
        /// <summary> Configuration of solution. </summary>
        public string SolutionConfiguration { get; set; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationBulkReviewSolutionContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationBulkReviewSolutionContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationBulkReviewSolutionContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationBulkReviewSolutionContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationBulkReviewSolutionContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkReviewSolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkReviewSolutionContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("targets"u8);
            writer.WriteStartArray();
            foreach (var item in Targets)
            {
                writer.WriteObjectValue(item, options);
            }
            writer.WriteEndArray();
            if (Optional.IsDefined(SolutionInstanceName))
            {
                writer.WritePropertyName("solutionInstanceName"u8);
                writer.WriteStringValue(SolutionInstanceName);
            }
            if (Optional.IsCollectionDefined(SolutionDependencies))
            {
                writer.WritePropertyName("solutionDependencies"u8);
                writer.WriteStartArray();
                foreach (var item in SolutionDependencies)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (Optional.IsDefined(SolutionConfiguration))
            {
                writer.WritePropertyName("solutionConfiguration"u8);
                writer.WriteStringValue(SolutionConfiguration);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationBulkReviewSolutionContent IJsonModel<WorkloadOrchestrationBulkReviewSolutionContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkReviewSolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkReviewSolutionContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationBulkReviewSolutionContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationBulkReviewSolutionContent DeserializeWorkloadOrchestrationBulkReviewSolutionContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            IList<BulkReviewTargetDetails> targets = default;
            string solutionInstanceName = default;
            IList<WorkloadOrchestrationSolutionDependencyContent> solutionDependencies = default;
            string solutionConfiguration = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("targets"u8))
                {
                    List<BulkReviewTargetDetails> array = new List<BulkReviewTargetDetails>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(BulkReviewTargetDetails.DeserializeBulkReviewTargetDetails(item, options));
                    }
                    targets = array;
                    continue;
                }
                if (property.NameEquals("solutionInstanceName"u8))
                {
                    solutionInstanceName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionDependencies"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<WorkloadOrchestrationSolutionDependencyContent> array = new List<WorkloadOrchestrationSolutionDependencyContent>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(WorkloadOrchestrationSolutionDependencyContent.DeserializeWorkloadOrchestrationSolutionDependencyContent(item, options));
                    }
                    solutionDependencies = array;
                    continue;
                }
                if (property.NameEquals("solutionConfiguration"u8))
                {
                    solutionConfiguration = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationBulkReviewSolutionContent(targets, solutionInstanceName, solutionDependencies ?? new ChangeTrackingList<WorkloadOrchestrationSolutionDependencyContent>(), solutionConfiguration, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationBulkReviewSolutionContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkReviewSolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkReviewSolutionContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationBulkReviewSolutionContent IPersistableModel<WorkloadOrchestrationBulkReviewSolutionContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationBulkReviewSolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationBulkReviewSolutionContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationBulkReviewSolutionContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationBulkReviewSolutionContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationDeployJobContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Parameters for a deployment job. </summary>
    public partial class WorkloadOrchestrationDeployJobContent : JobParameterBase
    {
        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationDeployJobContent"/>. </summary>
        public WorkloadOrchestrationDeployJobContent()
        {
            JobType = JobType.Deploy;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationDeployJobContent"/>. </summary>
        /// <param name="jobType"> Job type discriminator value. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        /// <param name="parameter"> Install Solution Parameter. </param>
        internal WorkloadOrchestrationDeployJobContent(JobType jobType, IDictionary<string, BinaryData> serializedAdditionalRawData, WorkloadOrchestrationInstallSolutionContent parameter) : base(jobType, serializedAdditionalRawData)
        {
            Parameter = parameter;
            JobType = jobType;
        }

        /// <summary> Install Solution Parameter. </summary>
        internal WorkloadOrchestrationInstallSolutionContent Parameter { get; set; }
        /// <summary> Solution Version ARM Id. </summary>
        public string ParameterSolutionVersionId
        {
            get => Parameter is null ? default : Parameter.SolutionVersionId;
            set => Parameter = new WorkloadOrchestrationInstallSolutionContent(value);
        }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationDeployJobContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationDeployJobContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationDeployJobContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationDeployJobContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationDeployJobContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationDeployJobContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationDeployJobContent)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Parameter))
            {
                writer.WritePropertyName("parameter"u8);
                writer.WriteObjectValue(Parameter, options);
            }
        }

        WorkloadOrchestrationDeployJobContent IJsonModel<WorkloadOrchestrationDeployJobContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationDeployJobContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationDeployJobContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationDeployJobContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationDeployJobContent DeserializeWorkloadOrchestrationDeployJobContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            WorkloadOrchestrationInstallSolutionContent parameter = default;
            JobType jobType = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("parameter"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    parameter = WorkloadOrchestrationInstallSolutionContent.DeserializeWorkloadOrchestrationInstallSolutionContent(property.Value, options);
                    continue;
                }
                if (property.NameEquals("jobType"u8))
                {
                    jobType = new JobType(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationDeployJobContent(jobType, serializedAdditionalRawData, parameter);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationDeployJobContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationDeployJobContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationDeployJobContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationDeployJobContent IPersistableModel<WorkloadOrchestrationDeployJobContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationDeployJobContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationDeployJobContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationDeployJobContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationDeployJobContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationInstallSolutionContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Install Solution Parameter. </summary>
    public partial class WorkloadOrchestrationInstallSolutionContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationInstallSolutionContent"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version ARM Id. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionId"/> is null. </exception>
        public WorkloadOrchestrationInstallSolutionContent(string solutionVersionId)
        {
            Argument.AssertNotNull(solutionVersionId, nameof(solutionVersionId));

            SolutionVersionId = solutionVersionId;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationInstallSolutionContent"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version ARM Id. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationInstallSolutionContent(string solutionVersionId, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersionId = solutionVersionId;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationInstallSolutionContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationInstallSolutionContent()
        {
        }

        /// <summary> Solution Version ARM Id. </summary>
        public string SolutionVersionId { get; set; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationInstallSolutionContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationInstallSolutionContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationInstallSolutionContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationInstallSolutionContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationInstallSolutionContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationInstallSolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationInstallSolutionContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionVersionId"u8);
            writer.WriteStringValue(SolutionVersionId);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationInstallSolutionContent IJsonModel<WorkloadOrchestrationInstallSolutionContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationInstallSolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationInstallSolutionContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationInstallSolutionContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationInstallSolutionContent DeserializeWorkloadOrchestrationInstallSolutionContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionVersionId = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersionId"u8))
                {
                    solutionVersionId = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationInstallSolutionContent(solutionVersionId, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationInstallSolutionContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationInstallSolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationInstallSolutionContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationInstallSolutionContent IPersistableModel<WorkloadOrchestrationInstallSolutionContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationInstallSolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationInstallSolutionContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationInstallSolutionContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationInstallSolutionContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationPublishJobContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Parameters for a publish job. </summary>
    public partial class WorkloadOrchestrationPublishJobContent : JobParameterBase
    {
        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationPublishJobContent"/>. </summary>
        public WorkloadOrchestrationPublishJobContent()
        {
            JobType = JobType.Publish;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationPublishJobContent"/>. </summary>
        /// <param name="jobType"> Job type discriminator value. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        /// <param name="parameter"> Solution Version Parameter. </param>
        internal WorkloadOrchestrationPublishJobContent(JobType jobType, IDictionary<string, BinaryData> serializedAdditionalRawData, WorkloadOrchestrationSolutionVersionContent parameter) : base(jobType, serializedAdditionalRawData)
        {
            Parameter = parameter;
            JobType = jobType;
        }

        /// <summary> Solution Version Parameter. </summary>
        internal WorkloadOrchestrationSolutionVersionContent Parameter { get; set; }
        /// <summary> Solution Version ARM Id. </summary>
        public string ParameterSolutionVersionId
        {
            get => Parameter is null ? default : Parameter.SolutionVersionId;
            set => Parameter = new WorkloadOrchestrationSolutionVersionContent(value);
        }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationPublishJobContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationPublishJobContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationPublishJobContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationPublishJobContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationPublishJobContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected override void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationPublishJobContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationPublishJobContent)} does not support writing '{format}' format.");
            }

            base.JsonModelWriteCore(writer, options);
            if (Optional.IsDefined(Parameter))
            {
                writer.WritePropertyName("parameter"u8);
                writer.WriteObjectValue(Parameter, options);
            }
        }

        WorkloadOrchestrationPublishJobContent IJsonModel<WorkloadOrchestrationPublishJobContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationPublishJobContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationPublishJobContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationPublishJobContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationPublishJobContent DeserializeWorkloadOrchestrationPublishJobContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            WorkloadOrchestrationSolutionVersionContent parameter = default;
            JobType jobType = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("parameter"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    parameter = WorkloadOrchestrationSolutionVersionContent.DeserializeWorkloadOrchestrationSolutionVersionContent(property.Value, options);
                    continue;
                }
                if (property.NameEquals("jobType"u8))
                {
                    jobType = new JobType(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationPublishJobContent(jobType, serializedAdditionalRawData, parameter);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationPublishJobContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationPublishJobContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationPublishJobContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationPublishJobContent IPersistableModel<WorkloadOrchestrationPublishJobContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationPublishJobContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationPublishJobContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationPublishJobContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationPublishJobContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationRemoveRevisionContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Install Solution Parameter. </summary>
    public partial class WorkloadOrchestrationRemoveRevisionContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationRemoveRevisionContent"/>. </summary>
        /// <param name="solutionTemplateId"> Solution Template ARM Id. </param>
        /// <param name="solutionVersion"> Solution Version Name. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateId"/> or <paramref name="solutionVersion"/> is null. </exception>
        public WorkloadOrchestrationRemoveRevisionContent(string solutionTemplateId, string solutionVersion)
        {
            Argument.AssertNotNull(solutionTemplateId, nameof(solutionTemplateId));
            Argument.AssertNotNull(solutionVersion, nameof(solutionVersion));

            SolutionTemplateId = solutionTemplateId;
            SolutionVersion = solutionVersion;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationRemoveRevisionContent"/>. </summary>
        /// <param name="solutionTemplateId"> Solution Template ARM Id. </param>
        /// <param name="solutionVersion"> Solution Version Name. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationRemoveRevisionContent(string solutionTemplateId, string solutionVersion, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionTemplateId = solutionTemplateId;
            SolutionVersion = solutionVersion;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationRemoveRevisionContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationRemoveRevisionContent()
        {
        }

        /// <summary> Solution Template ARM Id. </summary>
        public string SolutionTemplateId { get; }
        /// <summary> Solution Version Name. </summary>
        public string SolutionVersion { get; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationRemoveRevisionContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationRemoveRevisionContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationRemoveRevisionContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationRemoveRevisionContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationRemoveRevisionContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationRemoveRevisionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationRemoveRevisionContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionTemplateId"u8);
            writer.WriteStringValue(SolutionTemplateId);
            writer.WritePropertyName("solutionVersion"u8);
            writer.WriteStringValue(SolutionVersion);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationRemoveRevisionContent IJsonModel<WorkloadOrchestrationRemoveRevisionContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationRemoveRevisionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationRemoveRevisionContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationRemoveRevisionContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationRemoveRevisionContent DeserializeWorkloadOrchestrationRemoveRevisionContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionTemplateId = default;
            string solutionVersion = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionTemplateId"u8))
                {
                    solutionTemplateId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionVersion"u8))
                {
                    solutionVersion = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationRemoveRevisionContent(solutionTemplateId, solutionVersion, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationRemoveRevisionContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationRemoveRevisionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationRemoveRevisionContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationRemoveRevisionContent IPersistableModel<WorkloadOrchestrationRemoveRevisionContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationRemoveRevisionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationRemoveRevisionContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationRemoveRevisionContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationRemoveRevisionContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationRemoveVersionResult.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Remove Version response. </summary>
    public partial class WorkloadOrchestrationRemoveVersionResult
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationRemoveVersionResult"/>. </summary>
        /// <param name="status"> Status for remove version response. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="status"/> is null. </exception>
        internal WorkloadOrchestrationRemoveVersionResult(string status)
        {
            Argument.AssertNotNull(status, nameof(status));

            Status = status;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationRemoveVersionResult"/>. </summary>
        /// <param name="status"> Status for remove version response. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationRemoveVersionResult(string status, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Status = status;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationRemoveVersionResult"/> for deserialization. </summary>
        internal WorkloadOrchestrationRemoveVersionResult()
        {
        }

        /// <summary> Status for remove version response. </summary>
        public string Status { get; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationRemoveVersionResult.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationRemoveVersionResult : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationRemoveVersionResult>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationRemoveVersionResult>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationRemoveVersionResult>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationRemoveVersionResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationRemoveVersionResult)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("status"u8);
            writer.WriteStringValue(Status);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationRemoveVersionResult IJsonModel<WorkloadOrchestrationRemoveVersionResult>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationRemoveVersionResult>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationRemoveVersionResult)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationRemoveVersionResult(document.RootElement, options);
        }

        internal static WorkloadOrchestrationRemoveVersionResult DeserializeWorkloadOrchestrationRemoveVersionResult(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string status = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("status"u8))
                {
                    status = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationRemoveVersionResult(status, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationRemoveVersionResult>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationRemoveVersionResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationRemoveVersionResult)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationRemoveVersionResult IPersistableModel<WorkloadOrchestrationRemoveVersionResult>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationRemoveVersionResult>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationRemoveVersionResult(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationRemoveVersionResult)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationRemoveVersionResult>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationSolutionDependencyContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Dependency Context. </summary>
    public partial class WorkloadOrchestrationSolutionDependencyContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationSolutionDependencyContent"/>. </summary>
        public WorkloadOrchestrationSolutionDependencyContent()
        {
            Dependencies = new ChangeTrackingList<WorkloadOrchestrationSolutionDependencyContent>();
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationSolutionDependencyContent"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version Id. </param>
        /// <param name="solutionTemplateId"> Solution Template Id. </param>
        /// <param name="solutionTemplateVersion"> Solution Template Version. </param>
        /// <param name="solutionInstanceName"> Solution Instance Name. </param>
        /// <param name="targetId"> Target Id. </param>
        /// <param name="dependencies"> Solution dependencies. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationSolutionDependencyContent(string solutionVersionId, string solutionTemplateId, string solutionTemplateVersion, string solutionInstanceName, string targetId, IList<WorkloadOrchestrationSolutionDependencyContent> dependencies, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersionId = solutionVersionId;
            SolutionTemplateId = solutionTemplateId;
            SolutionTemplateVersion = solutionTemplateVersion;
            SolutionInstanceName = solutionInstanceName;
            TargetId = targetId;
            Dependencies = dependencies;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Solution Version Id. </summary>
        public string SolutionVersionId { get; set; }
        /// <summary> Solution Template Id. </summary>
        public string SolutionTemplateId { get; set; }
        /// <summary> Solution Template Version. </summary>
        public string SolutionTemplateVersion { get; set; }
        /// <summary> Solution Instance Name. </summary>
        public string SolutionInstanceName { get; set; }
        /// <summary> Target Id. </summary>
        public string TargetId { get; set; }
        /// <summary> Solution dependencies. </summary>
        public IList<WorkloadOrchestrationSolutionDependencyContent> Dependencies { get; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationSolutionDependencyContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationSolutionDependencyContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationSolutionDependencyContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationSolutionDependencyContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationSolutionDependencyContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionDependencyContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionDependencyContent)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(SolutionVersionId))
            {
                writer.WritePropertyName("solutionVersionId"u8);
                writer.WriteStringValue(SolutionVersionId);
            }
            if (Optional.IsDefined(SolutionTemplateId))
            {
                writer.WritePropertyName("solutionTemplateId"u8);
                writer.WriteStringValue(SolutionTemplateId);
            }
            if (Optional.IsDefined(SolutionTemplateVersion))
            {
                writer.WritePropertyName("solutionTemplateVersion"u8);
                writer.WriteStringValue(SolutionTemplateVersion);
            }
            if (Optional.IsDefined(SolutionInstanceName))
            {
                writer.WritePropertyName("solutionInstanceName"u8);
                writer.WriteStringValue(SolutionInstanceName);
            }
            if (Optional.IsDefined(TargetId))
            {
                writer.WritePropertyName("targetId"u8);
                writer.WriteStringValue(TargetId);
            }
            if (Optional.IsCollectionDefined(Dependencies))
            {
                writer.WritePropertyName("dependencies"u8);
                writer.WriteStartArray();
                foreach (var item in Dependencies)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationSolutionDependencyContent IJsonModel<WorkloadOrchestrationSolutionDependencyContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionDependencyContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionDependencyContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationSolutionDependencyContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationSolutionDependencyContent DeserializeWorkloadOrchestrationSolutionDependencyContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionVersionId = default;
            string solutionTemplateId = default;
            string solutionTemplateVersion = default;
            string solutionInstanceName = default;
            string targetId = default;
            IList<WorkloadOrchestrationSolutionDependencyContent> dependencies = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersionId"u8))
                {
                    solutionVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionTemplateId"u8))
                {
                    solutionTemplateId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionTemplateVersion"u8))
                {
                    solutionTemplateVersion = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionInstanceName"u8))
                {
                    solutionInstanceName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("targetId"u8))
                {
                    targetId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("dependencies"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<WorkloadOrchestrationSolutionDependencyContent> array = new List<WorkloadOrchestrationSolutionDependencyContent>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(DeserializeWorkloadOrchestrationSolutionDependencyContent(item, options));
                    }
                    dependencies = array;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationSolutionDependencyContent(
                solutionVersionId,
                solutionTemplateId,
                solutionTemplateVersion,
                solutionInstanceName,
                targetId,
                dependencies ?? new ChangeTrackingList<WorkloadOrchestrationSolutionDependencyContent>(),
                serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationSolutionDependencyContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionDependencyContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionDependencyContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationSolutionDependencyContent IPersistableModel<WorkloadOrchestrationSolutionDependencyContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionDependencyContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationSolutionDependencyContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionDependencyContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationSolutionDependencyContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationSolutionTemplateContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Template Parameter. </summary>
    public partial class WorkloadOrchestrationSolutionTemplateContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationSolutionTemplateContent"/>. </summary>
        /// <param name="solutionTemplateVersionId"> Solution Template Version ARM Id. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateVersionId"/> is null. </exception>
        public WorkloadOrchestrationSolutionTemplateContent(string solutionTemplateVersionId)
        {
            Argument.AssertNotNull(solutionTemplateVersionId, nameof(solutionTemplateVersionId));

            SolutionTemplateVersionId = solutionTemplateVersionId;
            SolutionDependencies = new ChangeTrackingList<WorkloadOrchestrationSolutionDependencyContent>();
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationSolutionTemplateContent"/>. </summary>
        /// <param name="solutionTemplateVersionId"> Solution Template Version ARM Id. </param>
        /// <param name="solutionInstanceName"> Solution Instance Name. </param>
        /// <param name="solutionDependencies"> Solution Dependencies. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationSolutionTemplateContent(string solutionTemplateVersionId, string solutionInstanceName, IList<WorkloadOrchestrationSolutionDependencyContent> solutionDependencies, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionTemplateVersionId = solutionTemplateVersionId;
            SolutionInstanceName = solutionInstanceName;
            SolutionDependencies = solutionDependencies;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationSolutionTemplateContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationSolutionTemplateContent()
        {
        }

        /// <summary> Solution Template Version ARM Id. </summary>
        public string SolutionTemplateVersionId { get; }
        /// <summary> Solution Instance Name. </summary>
        public string SolutionInstanceName { get; set; }
        /// <summary> Solution Dependencies. </summary>
        public IList<WorkloadOrchestrationSolutionDependencyContent> SolutionDependencies { get; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationSolutionTemplateContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationSolutionTemplateContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationSolutionTemplateContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationSolutionTemplateContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationSolutionTemplateContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionTemplateContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionTemplateContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionTemplateVersionId"u8);
            writer.WriteStringValue(SolutionTemplateVersionId);
            if (Optional.IsDefined(SolutionInstanceName))
            {
                writer.WritePropertyName("solutionInstanceName"u8);
                writer.WriteStringValue(SolutionInstanceName);
            }
            if (Optional.IsCollectionDefined(SolutionDependencies))
            {
                writer.WritePropertyName("solutionDependencies"u8);
                writer.WriteStartArray();
                foreach (var item in SolutionDependencies)
                {
                    writer.WriteObjectValue(item, options);
                }
                writer.WriteEndArray();
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationSolutionTemplateContent IJsonModel<WorkloadOrchestrationSolutionTemplateContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionTemplateContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionTemplateContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationSolutionTemplateContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationSolutionTemplateContent DeserializeWorkloadOrchestrationSolutionTemplateContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionTemplateVersionId = default;
            string solutionInstanceName = default;
            IList<WorkloadOrchestrationSolutionDependencyContent> solutionDependencies = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionTemplateVersionId"u8))
                {
                    solutionTemplateVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionInstanceName"u8))
                {
                    solutionInstanceName = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionDependencies"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    List<WorkloadOrchestrationSolutionDependencyContent> array = new List<WorkloadOrchestrationSolutionDependencyContent>();
                    foreach (var item in property.Value.EnumerateArray())
                    {
                        array.Add(WorkloadOrchestrationSolutionDependencyContent.DeserializeWorkloadOrchestrationSolutionDependencyContent(item, options));
                    }
                    solutionDependencies = array;
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationSolutionTemplateContent(solutionTemplateVersionId, solutionInstanceName, solutionDependencies ?? new ChangeTrackingList<WorkloadOrchestrationSolutionDependencyContent>(), serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationSolutionTemplateContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionTemplateContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionTemplateContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationSolutionTemplateContent IPersistableModel<WorkloadOrchestrationSolutionTemplateContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionTemplateContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationSolutionTemplateContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionTemplateContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationSolutionTemplateContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationSolutionVersionContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Solution Version Parameter. </summary>
    public partial class WorkloadOrchestrationSolutionVersionContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationSolutionVersionContent"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version ARM Id. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionId"/> is null. </exception>
        public WorkloadOrchestrationSolutionVersionContent(string solutionVersionId)
        {
            Argument.AssertNotNull(solutionVersionId, nameof(solutionVersionId));

            SolutionVersionId = solutionVersionId;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationSolutionVersionContent"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version ARM Id. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationSolutionVersionContent(string solutionVersionId, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersionId = solutionVersionId;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationSolutionVersionContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationSolutionVersionContent()
        {
        }

        /// <summary> Solution Version ARM Id. </summary>
        public string SolutionVersionId { get; set; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationSolutionVersionContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationSolutionVersionContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationSolutionVersionContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationSolutionVersionContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationSolutionVersionContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionVersionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionVersionContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionVersionId"u8);
            writer.WriteStringValue(SolutionVersionId);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationSolutionVersionContent IJsonModel<WorkloadOrchestrationSolutionVersionContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionVersionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionVersionContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationSolutionVersionContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationSolutionVersionContent DeserializeWorkloadOrchestrationSolutionVersionContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionVersionId = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersionId"u8))
                {
                    solutionVersionId = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationSolutionVersionContent(solutionVersionId, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationSolutionVersionContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionVersionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionVersionContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationSolutionVersionContent IPersistableModel<WorkloadOrchestrationSolutionVersionContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationSolutionVersionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationSolutionVersionContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationSolutionVersionContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationSolutionVersionContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationTaskConfig.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Task Option Properties. </summary>
    public partial class WorkloadOrchestrationTaskConfig
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationTaskConfig"/>. </summary>
        public WorkloadOrchestrationTaskConfig()
        {
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationTaskConfig"/>. </summary>
        /// <param name="concurrency"> Parallel worker numbers of the tasks. </param>
        /// <param name="errorAction"> Error action for the tasks. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationTaskConfig(int? concurrency, ErrorAction errorAction, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Concurrency = concurrency;
            ErrorAction = errorAction;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Parallel worker numbers of the tasks. </summary>
        public int? Concurrency { get; set; }
        /// <summary> Error action for the tasks. </summary>
        public ErrorAction ErrorAction { get; set; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationTaskConfig.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationTaskConfig : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationTaskConfig>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationTaskConfig>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationTaskConfig>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationTaskConfig>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationTaskConfig)} does not support writing '{format}' format.");
            }

            if (Optional.IsDefined(Concurrency))
            {
                writer.WritePropertyName("concurrency"u8);
                writer.WriteNumberValue(Concurrency.Value);
            }
            if (Optional.IsDefined(ErrorAction))
            {
                writer.WritePropertyName("errorAction"u8);
                writer.WriteObjectValue(ErrorAction, options);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationTaskConfig IJsonModel<WorkloadOrchestrationTaskConfig>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationTaskConfig>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationTaskConfig)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationTaskConfig(document.RootElement, options);
        }

        internal static WorkloadOrchestrationTaskConfig DeserializeWorkloadOrchestrationTaskConfig(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            int? concurrency = default;
            ErrorAction errorAction = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("concurrency"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    concurrency = property.Value.GetInt32();
                    continue;
                }
                if (property.NameEquals("errorAction"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    errorAction = ErrorAction.DeserializeErrorAction(property.Value, options);
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationTaskConfig(concurrency, errorAction, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationTaskConfig>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationTaskConfig>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationTaskConfig)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationTaskConfig IPersistableModel<WorkloadOrchestrationTaskConfig>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationTaskConfig>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationTaskConfig(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationTaskConfig)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationTaskConfig>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationUninstallSolutionContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Uninstall Solution Parameter. </summary>
    public partial class WorkloadOrchestrationUninstallSolutionContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationUninstallSolutionContent"/>. </summary>
        /// <param name="solutionTemplateId"> Solution Template ARM Id. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionTemplateId"/> is null. </exception>
        public WorkloadOrchestrationUninstallSolutionContent(string solutionTemplateId)
        {
            Argument.AssertNotNull(solutionTemplateId, nameof(solutionTemplateId));

            SolutionTemplateId = solutionTemplateId;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationUninstallSolutionContent"/>. </summary>
        /// <param name="solutionTemplateId"> Solution Template ARM Id. </param>
        /// <param name="solutionInstanceName"> Solution Instance Name. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationUninstallSolutionContent(string solutionTemplateId, string solutionInstanceName, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionTemplateId = solutionTemplateId;
            SolutionInstanceName = solutionInstanceName;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationUninstallSolutionContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationUninstallSolutionContent()
        {
        }

        /// <summary> Solution Template ARM Id. </summary>
        public string SolutionTemplateId { get; }
        /// <summary> Solution Instance Name. </summary>
        public string SolutionInstanceName { get; set; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationUninstallSolutionContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationUninstallSolutionContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationUninstallSolutionContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationUninstallSolutionContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationUninstallSolutionContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationUninstallSolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationUninstallSolutionContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionTemplateId"u8);
            writer.WriteStringValue(SolutionTemplateId);
            if (Optional.IsDefined(SolutionInstanceName))
            {
                writer.WritePropertyName("solutionInstanceName"u8);
                writer.WriteStringValue(SolutionInstanceName);
            }
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationUninstallSolutionContent IJsonModel<WorkloadOrchestrationUninstallSolutionContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationUninstallSolutionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationUninstallSolutionContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationUninstallSolutionContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationUninstallSolutionContent DeserializeWorkloadOrchestrationUninstallSolutionContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionTemplateId = default;
            string solutionInstanceName = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionTemplateId"u8))
                {
                    solutionTemplateId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("solutionInstanceName"u8))
                {
                    solutionInstanceName = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationUninstallSolutionContent(solutionTemplateId, solutionInstanceName, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationUninstallSolutionContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationUninstallSolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationUninstallSolutionContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationUninstallSolutionContent IPersistableModel<WorkloadOrchestrationUninstallSolutionContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationUninstallSolutionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationUninstallSolutionContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationUninstallSolutionContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationUninstallSolutionContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationUpdateExternalValidationStatusContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Update External Validation Status Parameter. </summary>
    public partial class WorkloadOrchestrationUpdateExternalValidationStatusContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationUpdateExternalValidationStatusContent"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version Id. </param>
        /// <param name="externalValidationId"> External validation id. </param>
        /// <param name="validationStatus"> Validation Status of external validation. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="solutionVersionId"/> or <paramref name="externalValidationId"/> is null. </exception>
        public WorkloadOrchestrationUpdateExternalValidationStatusContent(string solutionVersionId, string externalValidationId, ValidationStatus validationStatus)
        {
            Argument.AssertNotNull(solutionVersionId, nameof(solutionVersionId));
            Argument.AssertNotNull(externalValidationId, nameof(externalValidationId));

            SolutionVersionId = solutionVersionId;
            ExternalValidationId = externalValidationId;
            ValidationStatus = validationStatus;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationUpdateExternalValidationStatusContent"/>. </summary>
        /// <param name="solutionVersionId"> Solution Version Id. </param>
        /// <param name="errorDetails"> Error Details if any failure is there. </param>
        /// <param name="externalValidationId"> External validation id. </param>
        /// <param name="validationStatus"> Validation Status of external validation. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationUpdateExternalValidationStatusContent(string solutionVersionId, ResponseError errorDetails, string externalValidationId, ValidationStatus validationStatus, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            SolutionVersionId = solutionVersionId;
            ErrorDetails = errorDetails;
            ExternalValidationId = externalValidationId;
            ValidationStatus = validationStatus;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationUpdateExternalValidationStatusContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationUpdateExternalValidationStatusContent()
        {
        }

        /// <summary> Solution Version Id. </summary>
        public string SolutionVersionId { get; }
        /// <summary> Error Details if any failure is there. </summary>
        public ResponseError ErrorDetails { get; set; }
        /// <summary> External validation id. </summary>
        public string ExternalValidationId { get; }
        /// <summary> Validation Status of external validation. </summary>
        public ValidationStatus ValidationStatus { get; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationUpdateExternalValidationStatusContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationUpdateExternalValidationStatusContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationUpdateExternalValidationStatusContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("solutionVersionId"u8);
            writer.WriteStringValue(SolutionVersionId);
            if (Optional.IsDefined(ErrorDetails))
            {
                writer.WritePropertyName("errorDetails"u8);
                ((IJsonModel<ResponseError>)ErrorDetails).Write(writer, options);
            }
            writer.WritePropertyName("externalValidationId"u8);
            writer.WriteStringValue(ExternalValidationId);
            writer.WritePropertyName("validationStatus"u8);
            writer.WriteStringValue(ValidationStatus.ToString());
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationUpdateExternalValidationStatusContent IJsonModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationUpdateExternalValidationStatusContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationUpdateExternalValidationStatusContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationUpdateExternalValidationStatusContent DeserializeWorkloadOrchestrationUpdateExternalValidationStatusContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string solutionVersionId = default;
            ResponseError errorDetails = default;
            string externalValidationId = default;
            ValidationStatus validationStatus = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("solutionVersionId"u8))
                {
                    solutionVersionId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("errorDetails"u8))
                {
                    if (property.Value.ValueKind == JsonValueKind.Null)
                    {
                        continue;
                    }
                    errorDetails = ModelReaderWriter.Read<ResponseError>(new BinaryData(Encoding.UTF8.GetBytes(property.Value.GetRawText())), options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                    continue;
                }
                if (property.NameEquals("externalValidationId"u8))
                {
                    externalValidationId = property.Value.GetString();
                    continue;
                }
                if (property.NameEquals("validationStatus"u8))
                {
                    validationStatus = new ValidationStatus(property.Value.GetString());
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationUpdateExternalValidationStatusContent(solutionVersionId, errorDetails, externalValidationId, validationStatus, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationUpdateExternalValidationStatusContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationUpdateExternalValidationStatusContent IPersistableModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationUpdateExternalValidationStatusContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationUpdateExternalValidationStatusContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationUpdateExternalValidationStatusContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationVersionContent.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    /// <summary> Version Parameter. </summary>
    public partial class WorkloadOrchestrationVersionContent
    {
        /// <summary>
        /// Keeps track of any properties unknown to the library.
        /// <para>
        /// To assign an object to the value of this property use <see cref="BinaryData.FromObjectAsJson{T}(T, System.Text.Json.JsonSerializerOptions?)"/>.
        /// </para>
        /// <para>
        /// To assign an already formatted json string to this property use <see cref="BinaryData.FromString(string)"/>.
        /// </para>
        /// <para>
        /// Examples:
        /// <list type="bullet">
        /// <item>
        /// <term>BinaryData.FromObjectAsJson("foo")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("\"foo\"")</term>
        /// <description>Creates a payload of "foo".</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromObjectAsJson(new { key = "value" })</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// <item>
        /// <term>BinaryData.FromString("{\"key\": \"value\"}")</term>
        /// <description>Creates a payload of { "key": "value" }.</description>
        /// </item>
        /// </list>
        /// </para>
        /// </summary>
        private IDictionary<string, BinaryData> _serializedAdditionalRawData;

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationVersionContent"/>. </summary>
        /// <param name="version"> Version of the Resource. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="version"/> is null. </exception>
        public WorkloadOrchestrationVersionContent(string version)
        {
            Argument.AssertNotNull(version, nameof(version));

            Version = version;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationVersionContent"/>. </summary>
        /// <param name="version"> Version of the Resource. </param>
        /// <param name="serializedAdditionalRawData"> Keeps track of any properties unknown to the library. </param>
        internal WorkloadOrchestrationVersionContent(string version, IDictionary<string, BinaryData> serializedAdditionalRawData)
        {
            Version = version;
            _serializedAdditionalRawData = serializedAdditionalRawData;
        }

        /// <summary> Initializes a new instance of <see cref="WorkloadOrchestrationVersionContent"/> for deserialization. </summary>
        internal WorkloadOrchestrationVersionContent()
        {
        }

        /// <summary> Version of the Resource. </summary>
        public string Version { get; }
    }
}



================================================
FILE: Generated/Models/WorkloadOrchestrationVersionContent.Serialization.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ClientModel.Primitives;
using System.Collections.Generic;
using System.Text.Json;
using Azure.Core;

namespace Azure.ResourceManager.WorkloadOrchestration.Models
{
    public partial class WorkloadOrchestrationVersionContent : IUtf8JsonSerializable, IJsonModel<WorkloadOrchestrationVersionContent>
    {
        void IUtf8JsonSerializable.Write(Utf8JsonWriter writer) => ((IJsonModel<WorkloadOrchestrationVersionContent>)this).Write(writer, ModelSerializationExtensions.WireOptions);

        void IJsonModel<WorkloadOrchestrationVersionContent>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            writer.WriteStartObject();
            JsonModelWriteCore(writer, options);
            writer.WriteEndObject();
        }

        /// <param name="writer"> The JSON writer. </param>
        /// <param name="options"> The client options for reading and writing models. </param>
        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationVersionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationVersionContent)} does not support writing '{format}' format.");
            }

            writer.WritePropertyName("version"u8);
            writer.WriteStringValue(Version);
            if (options.Format != "W" && _serializedAdditionalRawData != null)
            {
                foreach (var item in _serializedAdditionalRawData)
                {
                    writer.WritePropertyName(item.Key);
#if NET6_0_OR_GREATER
				writer.WriteRawValue(item.Value);
#else
                    using (JsonDocument document = JsonDocument.Parse(item.Value, ModelSerializationExtensions.JsonDocumentOptions))
                    {
                        JsonSerializer.Serialize(writer, document.RootElement);
                    }
#endif
                }
            }
        }

        WorkloadOrchestrationVersionContent IJsonModel<WorkloadOrchestrationVersionContent>.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationVersionContent>)this).GetFormatFromOptions(options) : options.Format;
            if (format != "J")
            {
                throw new FormatException($"The model {nameof(WorkloadOrchestrationVersionContent)} does not support reading '{format}' format.");
            }

            using JsonDocument document = JsonDocument.ParseValue(ref reader);
            return DeserializeWorkloadOrchestrationVersionContent(document.RootElement, options);
        }

        internal static WorkloadOrchestrationVersionContent DeserializeWorkloadOrchestrationVersionContent(JsonElement element, ModelReaderWriterOptions options = null)
        {
            options ??= ModelSerializationExtensions.WireOptions;

            if (element.ValueKind == JsonValueKind.Null)
            {
                return null;
            }
            string version = default;
            IDictionary<string, BinaryData> serializedAdditionalRawData = default;
            Dictionary<string, BinaryData> rawDataDictionary = new Dictionary<string, BinaryData>();
            foreach (var property in element.EnumerateObject())
            {
                if (property.NameEquals("version"u8))
                {
                    version = property.Value.GetString();
                    continue;
                }
                if (options.Format != "W")
                {
                    rawDataDictionary.Add(property.Name, BinaryData.FromString(property.Value.GetRawText()));
                }
            }
            serializedAdditionalRawData = rawDataDictionary;
            return new WorkloadOrchestrationVersionContent(version, serializedAdditionalRawData);
        }

        BinaryData IPersistableModel<WorkloadOrchestrationVersionContent>.Write(ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationVersionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    return ModelReaderWriter.Write(this, options, AzureResourceManagerWorkloadOrchestrationContext.Default);
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationVersionContent)} does not support writing '{options.Format}' format.");
            }
        }

        WorkloadOrchestrationVersionContent IPersistableModel<WorkloadOrchestrationVersionContent>.Create(BinaryData data, ModelReaderWriterOptions options)
        {
            var format = options.Format == "W" ? ((IPersistableModel<WorkloadOrchestrationVersionContent>)this).GetFormatFromOptions(options) : options.Format;

            switch (format)
            {
                case "J":
                    {
                        using JsonDocument document = JsonDocument.Parse(data, ModelSerializationExtensions.JsonDocumentOptions);
                        return DeserializeWorkloadOrchestrationVersionContent(document.RootElement, options);
                    }
                default:
                    throw new FormatException($"The model {nameof(WorkloadOrchestrationVersionContent)} does not support reading '{options.Format}' format.");
            }
        }

        string IPersistableModel<WorkloadOrchestrationVersionContent>.GetFormatFromOptions(ModelReaderWriterOptions options) => "J";
    }
}



================================================
FILE: Generated/RestOperations/ConfigTemplatesRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class ConfigTemplatesRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of ConfigTemplatesRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public ConfigTemplatesRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySubscriptionRequestUri(string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionRequest(string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ConfigTemplateListResult>> ListBySubscriptionAsync(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ConfigTemplateListResult.DeserializeConfigTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ConfigTemplateListResult> ListBySubscription(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ConfigTemplateListResult.DeserializeConfigTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupRequestUri(string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupRequest(string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ConfigTemplateListResult>> ListByResourceGroupAsync(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ConfigTemplateListResult.DeserializeConfigTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ConfigTemplateListResult> ListByResourceGroup(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ConfigTemplateListResult.DeserializeConfigTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string configTemplateName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string configTemplateName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Config Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeConfigTemplateData>> GetAsync(string subscriptionId, string resourceGroupName, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, configTemplateName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeConfigTemplateData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeConfigTemplateData.DeserializeEdgeConfigTemplateData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeConfigTemplateData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Config Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeConfigTemplateData> Get(string subscriptionId, string resourceGroupName, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, configTemplateName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeConfigTemplateData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeConfigTemplateData.DeserializeEdgeConfigTemplateData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeConfigTemplateData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string configTemplateName, EdgeConfigTemplateData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string configTemplateName, EdgeConfigTemplateData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Config Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string configTemplateName, EdgeConfigTemplateData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, configTemplateName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Config Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string configTemplateName, EdgeConfigTemplateData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, configTemplateName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string configTemplateName, EdgeConfigTemplatePatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string configTemplateName, EdgeConfigTemplatePatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update a Config Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeConfigTemplateData>> UpdateAsync(string subscriptionId, string resourceGroupName, string configTemplateName, EdgeConfigTemplatePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, configTemplateName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeConfigTemplateData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeConfigTemplateData.DeserializeEdgeConfigTemplateData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update a Config Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeConfigTemplateData> Update(string subscriptionId, string resourceGroupName, string configTemplateName, EdgeConfigTemplatePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, configTemplateName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeConfigTemplateData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeConfigTemplateData.DeserializeEdgeConfigTemplateData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string configTemplateName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string configTemplateName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Config Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, configTemplateName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Config Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, configTemplateName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateVersionRequestUri(string subscriptionId, string resourceGroupName, string configTemplateName, ConfigTemplateVersionWithUpdateType body)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendPath("/createVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateVersionRequest(string subscriptionId, string resourceGroupName, string configTemplateName, ConfigTemplateVersionWithUpdateType body)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendPath("/createVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(body, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Config Template Version Resource with the specified UpdateType. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateVersionAsync(string subscriptionId, string resourceGroupName, string configTemplateName, ConfigTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(body, nameof(body));

            using var message = CreateCreateVersionRequest(subscriptionId, resourceGroupName, configTemplateName, body);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Config Template Version Resource with the specified UpdateType. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateVersion(string subscriptionId, string resourceGroupName, string configTemplateName, ConfigTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(body, nameof(body));

            using var message = CreateCreateVersionRequest(subscriptionId, resourceGroupName, configTemplateName, body);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateRemoveVersionRequestUri(string subscriptionId, string resourceGroupName, string configTemplateName, WorkloadOrchestrationVersionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendPath("/removeVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateRemoveVersionRequest(string subscriptionId, string resourceGroupName, string configTemplateName, WorkloadOrchestrationVersionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendPath("/removeVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Remove Config Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<WorkloadOrchestrationRemoveVersionResult>> RemoveVersionAsync(string subscriptionId, string resourceGroupName, string configTemplateName, WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateRemoveVersionRequest(subscriptionId, resourceGroupName, configTemplateName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkloadOrchestrationRemoveVersionResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = WorkloadOrchestrationRemoveVersionResult.DeserializeWorkloadOrchestrationRemoveVersionResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Remove Config Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<WorkloadOrchestrationRemoveVersionResult> RemoveVersion(string subscriptionId, string resourceGroupName, string configTemplateName, WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateRemoveVersionRequest(subscriptionId, resourceGroupName, configTemplateName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkloadOrchestrationRemoveVersionResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = WorkloadOrchestrationRemoveVersionResult.DeserializeWorkloadOrchestrationRemoveVersionResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySubscriptionNextPageRequestUri(string nextLink, string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionNextPageRequest(string nextLink, string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ConfigTemplateListResult>> ListBySubscriptionNextPageAsync(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ConfigTemplateListResult.DeserializeConfigTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ConfigTemplateListResult> ListBySubscriptionNextPage(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ConfigTemplateListResult.DeserializeConfigTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ConfigTemplateListResult>> ListByResourceGroupNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ConfigTemplateListResult.DeserializeConfigTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ConfigTemplateListResult> ListByResourceGroupNextPage(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ConfigTemplateListResult.DeserializeConfigTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/ConfigTemplateVersionsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class ConfigTemplateVersionsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of ConfigTemplateVersionsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public ConfigTemplateVersionsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByConfigTemplateRequestUri(string subscriptionId, string resourceGroupName, string configTemplateName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByConfigTemplateRequest(string subscriptionId, string resourceGroupName, string configTemplateName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Config Template Version Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ConfigTemplateVersionListResult>> ListByConfigTemplateAsync(string subscriptionId, string resourceGroupName, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var message = CreateListByConfigTemplateRequest(subscriptionId, resourceGroupName, configTemplateName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ConfigTemplateVersionListResult.DeserializeConfigTemplateVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Config Template Version Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ConfigTemplateVersionListResult> ListByConfigTemplate(string subscriptionId, string resourceGroupName, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var message = CreateListByConfigTemplateRequest(subscriptionId, resourceGroupName, configTemplateName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ConfigTemplateVersionListResult.DeserializeConfigTemplateVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string configTemplateName, string configTemplateVersionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(configTemplateVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string configTemplateName, string configTemplateVersionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/configTemplates/", false);
            uri.AppendPath(configTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(configTemplateVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Config Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="configTemplateVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeConfigTemplateVersionData>> GetAsync(string subscriptionId, string resourceGroupName, string configTemplateName, string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNullOrEmpty(configTemplateVersionName, nameof(configTemplateVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, configTemplateName, configTemplateVersionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeConfigTemplateVersionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeConfigTemplateVersionData.DeserializeEdgeConfigTemplateVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeConfigTemplateVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Config Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="configTemplateVersionName"> The name of the ConfigTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="configTemplateVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="configTemplateName"/> or <paramref name="configTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeConfigTemplateVersionData> Get(string subscriptionId, string resourceGroupName, string configTemplateName, string configTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));
            Argument.AssertNotNullOrEmpty(configTemplateVersionName, nameof(configTemplateVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, configTemplateName, configTemplateVersionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeConfigTemplateVersionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeConfigTemplateVersionData.DeserializeEdgeConfigTemplateVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeConfigTemplateVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByConfigTemplateNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string configTemplateName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByConfigTemplateNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string configTemplateName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Config Template Version Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ConfigTemplateVersionListResult>> ListByConfigTemplateNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var message = CreateListByConfigTemplateNextPageRequest(nextLink, subscriptionId, resourceGroupName, configTemplateName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ConfigTemplateVersionListResult.DeserializeConfigTemplateVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Config Template Version Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="configTemplateName"> The name of the ConfigTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="configTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ConfigTemplateVersionListResult> ListByConfigTemplateNextPage(string nextLink, string subscriptionId, string resourceGroupName, string configTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(configTemplateName, nameof(configTemplateName));

            using var message = CreateListByConfigTemplateNextPageRequest(nextLink, subscriptionId, resourceGroupName, configTemplateName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ConfigTemplateVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ConfigTemplateVersionListResult.DeserializeConfigTemplateVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/ContextsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class ContextsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of ContextsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public ContextsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySubscriptionRequestUri(string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionRequest(string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ContextListResult>> ListBySubscriptionAsync(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ContextListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ContextListResult.DeserializeContextListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ContextListResult> ListBySubscription(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ContextListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ContextListResult.DeserializeContextListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupRequestUri(string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupRequest(string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ContextListResult>> ListByResourceGroupAsync(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ContextListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ContextListResult.DeserializeContextListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ContextListResult> ListByResourceGroup(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ContextListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ContextListResult.DeserializeContextListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string contextName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string contextName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get Context Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeContextData>> GetAsync(string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeContextData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeContextData.DeserializeEdgeContextData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeContextData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get Context Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeContextData> Get(string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeContextData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeContextData.DeserializeEdgeContextData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeContextData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, EdgeContextData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, EdgeContextData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update Context Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string contextName, EdgeContextData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update Context Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string contextName, EdgeContextData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, EdgeContextPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, EdgeContextPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update an Context Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string contextName, EdgeContextPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update an Context Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string contextName, EdgeContextPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string contextName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string contextName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete Context Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete Context Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySubscriptionNextPageRequestUri(string nextLink, string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionNextPageRequest(string nextLink, string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ContextListResult>> ListBySubscriptionNextPageAsync(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ContextListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ContextListResult.DeserializeContextListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ContextListResult> ListBySubscriptionNextPage(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ContextListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ContextListResult.DeserializeContextListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ContextListResult>> ListByResourceGroupNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ContextListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ContextListResult.DeserializeContextListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ContextListResult> ListByResourceGroupNextPage(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ContextListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ContextListResult.DeserializeContextListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/DiagnosticsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class DiagnosticsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of DiagnosticsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public DiagnosticsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySubscriptionRequestUri(string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionRequest(string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Lists Diagnostics resources within an Azure subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<DiagnosticListResult>> ListBySubscriptionAsync(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DiagnosticListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = DiagnosticListResult.DeserializeDiagnosticListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists Diagnostics resources within an Azure subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<DiagnosticListResult> ListBySubscription(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DiagnosticListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = DiagnosticListResult.DeserializeDiagnosticListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupRequestUri(string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupRequest(string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Returns a collection of Diagnostic resources within the resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<DiagnosticListResult>> ListByResourceGroupAsync(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DiagnosticListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = DiagnosticListResult.DeserializeDiagnosticListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Returns a collection of Diagnostic resources within the resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<DiagnosticListResult> ListByResourceGroup(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DiagnosticListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = DiagnosticListResult.DeserializeDiagnosticListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string diagnosticName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics/", false);
            uri.AppendPath(diagnosticName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string diagnosticName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics/", false);
            uri.AppendPath(diagnosticName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Returns details of specified Diagnostic resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeDiagnosticData>> GetAsync(string subscriptionId, string resourceGroupName, string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, diagnosticName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDiagnosticData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeDiagnosticData.DeserializeEdgeDiagnosticData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDiagnosticData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Returns details of specified Diagnostic resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeDiagnosticData> Get(string subscriptionId, string resourceGroupName, string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, diagnosticName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDiagnosticData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeDiagnosticData.DeserializeEdgeDiagnosticData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDiagnosticData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string diagnosticName, EdgeDiagnosticData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics/", false);
            uri.AppendPath(diagnosticName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string diagnosticName, EdgeDiagnosticData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics/", false);
            uri.AppendPath(diagnosticName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Creates new or updates existing Diagnostic resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="diagnosticName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string diagnosticName, EdgeDiagnosticData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, diagnosticName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Creates new or updates existing Diagnostic resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="diagnosticName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string diagnosticName, EdgeDiagnosticData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, diagnosticName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string diagnosticName, EdgeDiagnosticPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics/", false);
            uri.AppendPath(diagnosticName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string diagnosticName, EdgeDiagnosticPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics/", false);
            uri.AppendPath(diagnosticName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Updates existing Diagnostic resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="diagnosticName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string diagnosticName, EdgeDiagnosticPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, diagnosticName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Updates existing Diagnostic resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="diagnosticName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string diagnosticName, EdgeDiagnosticPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, diagnosticName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string diagnosticName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics/", false);
            uri.AppendPath(diagnosticName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string diagnosticName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/diagnostics/", false);
            uri.AppendPath(diagnosticName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Deletes specified Diagnostic resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, diagnosticName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Deletes specified Diagnostic resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="diagnosticName"> Name of Diagnostic. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="diagnosticName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string diagnosticName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(diagnosticName, nameof(diagnosticName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, diagnosticName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySubscriptionNextPageRequestUri(string nextLink, string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionNextPageRequest(string nextLink, string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Lists Diagnostics resources within an Azure subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<DiagnosticListResult>> ListBySubscriptionNextPageAsync(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DiagnosticListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = DiagnosticListResult.DeserializeDiagnosticListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Lists Diagnostics resources within an Azure subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<DiagnosticListResult> ListBySubscriptionNextPage(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DiagnosticListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = DiagnosticListResult.DeserializeDiagnosticListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Returns a collection of Diagnostic resources within the resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<DiagnosticListResult>> ListByResourceGroupNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DiagnosticListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = DiagnosticListResult.DeserializeDiagnosticListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Returns a collection of Diagnostic resources within the resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<DiagnosticListResult> ListByResourceGroupNextPage(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DiagnosticListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = DiagnosticListResult.DeserializeDiagnosticListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/DynamicSchemasRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class DynamicSchemasRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of DynamicSchemasRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public DynamicSchemasRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySchemaRequestUri(string subscriptionId, string resourceGroupName, string schemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySchemaRequest(string subscriptionId, string resourceGroupName, string schemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by Schema. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<DynamicSchemaListResult>> ListBySchemaAsync(string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateListBySchemaRequest(subscriptionId, resourceGroupName, schemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DynamicSchemaListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = DynamicSchemaListResult.DeserializeDynamicSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by Schema. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<DynamicSchemaListResult> ListBySchema(string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateListBySchemaRequest(subscriptionId, resourceGroupName, schemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DynamicSchemaListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = DynamicSchemaListResult.DeserializeDynamicSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a DynamicSchema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeDynamicSchemaData>> GetAsync(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDynamicSchemaData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeDynamicSchemaData.DeserializeEdgeDynamicSchemaData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDynamicSchemaData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a DynamicSchema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeDynamicSchemaData> Get(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDynamicSchemaData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeDynamicSchemaData.DeserializeEdgeDynamicSchemaData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDynamicSchemaData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, EdgeDynamicSchemaData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, EdgeDynamicSchemaData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a DynamicSchema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, EdgeDynamicSchemaData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a DynamicSchema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, EdgeDynamicSchemaData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, EdgeDynamicSchemaPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, EdgeDynamicSchemaPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update a DynamicSchema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeDynamicSchemaData>> UpdateAsync(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, EdgeDynamicSchemaPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDynamicSchemaData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeDynamicSchemaData.DeserializeEdgeDynamicSchemaData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update a DynamicSchema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeDynamicSchemaData> Update(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, EdgeDynamicSchemaPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDynamicSchemaData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeDynamicSchemaData.DeserializeEdgeDynamicSchemaData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a DynamicSchema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a DynamicSchema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySchemaNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string schemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySchemaNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string schemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by Schema. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<DynamicSchemaListResult>> ListBySchemaNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateListBySchemaNextPageRequest(nextLink, subscriptionId, resourceGroupName, schemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DynamicSchemaListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = DynamicSchemaListResult.DeserializeDynamicSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by Schema. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<DynamicSchemaListResult> ListBySchemaNextPage(string nextLink, string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateListBySchemaNextPageRequest(nextLink, subscriptionId, resourceGroupName, schemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DynamicSchemaListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = DynamicSchemaListResult.DeserializeDynamicSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/DynamicSchemaVersionsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class DynamicSchemaVersionsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of DynamicSchemaVersionsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public DynamicSchemaVersionsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByDynamicSchemaRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByDynamicSchemaRequest(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by Dynamic Schema. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<DynamicSchemaVersionListResult>> ListByDynamicSchemaAsync(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var message = CreateListByDynamicSchemaRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DynamicSchemaVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = DynamicSchemaVersionListResult.DeserializeDynamicSchemaVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by Dynamic Schema. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<DynamicSchemaVersionListResult> ListByDynamicSchema(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var message = CreateListByDynamicSchemaRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DynamicSchemaVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = DynamicSchemaVersionListResult.DeserializeDynamicSchemaVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(dynamicSchemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(dynamicSchemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Dynamic Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeDynamicSchemaVersionData>> GetAsync(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDynamicSchemaVersionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeDynamicSchemaVersionData.DeserializeEdgeDynamicSchemaVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDynamicSchemaVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Dynamic Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeDynamicSchemaVersionData> Get(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDynamicSchemaVersionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeDynamicSchemaVersionData.DeserializeEdgeDynamicSchemaVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDynamicSchemaVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(dynamicSchemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(dynamicSchemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Dynamic Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/>, <paramref name="dynamicSchemaVersionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Dynamic Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/>, <paramref name="dynamicSchemaVersionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(dynamicSchemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(dynamicSchemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update a Dynamic Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/>, <paramref name="dynamicSchemaVersionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeDynamicSchemaVersionData>> UpdateAsync(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDynamicSchemaVersionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeDynamicSchemaVersionData.DeserializeEdgeDynamicSchemaVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update a Dynamic Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/>, <paramref name="dynamicSchemaVersionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeDynamicSchemaVersionData> Update(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, EdgeDynamicSchemaVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDynamicSchemaVersionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeDynamicSchemaVersionData.DeserializeEdgeDynamicSchemaVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(dynamicSchemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/dynamicSchemas/", false);
            uri.AppendPath(dynamicSchemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(dynamicSchemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Dynamic Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Dynamic Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="dynamicSchemaVersionName"> The name of the DynamicSchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="dynamicSchemaName"/> or <paramref name="dynamicSchemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, string dynamicSchemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaVersionName, nameof(dynamicSchemaVersionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, schemaName, dynamicSchemaName, dynamicSchemaVersionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByDynamicSchemaNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByDynamicSchemaNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by Dynamic Schema. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<DynamicSchemaVersionListResult>> ListByDynamicSchemaNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var message = CreateListByDynamicSchemaNextPageRequest(nextLink, subscriptionId, resourceGroupName, schemaName, dynamicSchemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DynamicSchemaVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = DynamicSchemaVersionListResult.DeserializeDynamicSchemaVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by Dynamic Schema. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="dynamicSchemaName"> The name of the DynamicSchema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="dynamicSchemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<DynamicSchemaVersionListResult> ListByDynamicSchemaNextPage(string nextLink, string subscriptionId, string resourceGroupName, string schemaName, string dynamicSchemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(dynamicSchemaName, nameof(dynamicSchemaName));

            using var message = CreateListByDynamicSchemaNextPageRequest(nextLink, subscriptionId, resourceGroupName, schemaName, dynamicSchemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        DynamicSchemaVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = DynamicSchemaVersionListResult.DeserializeDynamicSchemaVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/ExecutionsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class ExecutionsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of ExecutionsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public ExecutionsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByWorkflowVersionRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByWorkflowVersionRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Execution Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ExecutionListResult>> ListByWorkflowVersionAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var message = CreateListByWorkflowVersionRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ExecutionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ExecutionListResult.DeserializeExecutionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Execution Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ExecutionListResult> ListByWorkflowVersion(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var message = CreateListByWorkflowVersionRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ExecutionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ExecutionListResult.DeserializeExecutionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions/", false);
            uri.AppendPath(executionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions/", false);
            uri.AppendPath(executionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get Execution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeExecutionData>> GetAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, executionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeExecutionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeExecutionData.DeserializeEdgeExecutionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeExecutionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get Execution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeExecutionData> Get(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, executionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeExecutionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeExecutionData.DeserializeEdgeExecutionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeExecutionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, EdgeExecutionData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions/", false);
            uri.AppendPath(executionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, EdgeExecutionData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions/", false);
            uri.AppendPath(executionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update Execution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/>, <paramref name="executionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, EdgeExecutionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, executionName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update Execution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/>, <paramref name="executionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, EdgeExecutionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, executionName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, EdgeExecutionPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions/", false);
            uri.AppendPath(executionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, EdgeExecutionPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions/", false);
            uri.AppendPath(executionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update an Execution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/>, <paramref name="executionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, EdgeExecutionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, executionName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update an Execution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/>, <paramref name="executionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, EdgeExecutionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, executionName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions/", false);
            uri.AppendPath(executionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendPath("/executions/", false);
            uri.AppendPath(executionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete Execution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, executionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete Execution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="executionName"> The name of the Execution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="executionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, string executionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNullOrEmpty(executionName, nameof(executionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, executionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByWorkflowVersionNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByWorkflowVersionNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Execution Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<ExecutionListResult>> ListByWorkflowVersionNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var message = CreateListByWorkflowVersionNextPageRequest(nextLink, subscriptionId, resourceGroupName, contextName, workflowName, versionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ExecutionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = ExecutionListResult.DeserializeExecutionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Execution Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<ExecutionListResult> ListByWorkflowVersionNextPage(string nextLink, string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var message = CreateListByWorkflowVersionNextPageRequest(nextLink, subscriptionId, resourceGroupName, contextName, workflowName, versionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ExecutionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = ExecutionListResult.DeserializeExecutionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/InstanceHistoriesRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class InstanceHistoriesRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of InstanceHistoriesRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public InstanceHistoriesRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByInstanceRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendPath("/histories", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByInstanceRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendPath("/histories", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List InstanceHistory Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<InstanceHistoryListResult>> ListByInstanceAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var message = CreateListByInstanceRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        InstanceHistoryListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = InstanceHistoryListResult.DeserializeInstanceHistoryListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List InstanceHistory Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<InstanceHistoryListResult> ListByInstance(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var message = CreateListByInstanceRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        InstanceHistoryListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = InstanceHistoryListResult.DeserializeInstanceHistoryListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, string instanceHistoryName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendPath("/histories/", false);
            uri.AppendPath(instanceHistoryName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, string instanceHistoryName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendPath("/histories/", false);
            uri.AppendPath(instanceHistoryName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get InstanceHistory Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="instanceName"/> or <paramref name="instanceHistoryName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="instanceName"/> or <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeDeploymentInstanceHistoryData>> GetAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));
            Argument.AssertNotNullOrEmpty(instanceHistoryName, nameof(instanceHistoryName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName, instanceHistoryName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDeploymentInstanceHistoryData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeDeploymentInstanceHistoryData.DeserializeEdgeDeploymentInstanceHistoryData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDeploymentInstanceHistoryData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get InstanceHistory Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="instanceHistoryName"> Name of the instance history. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="instanceName"/> or <paramref name="instanceHistoryName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="instanceName"/> or <paramref name="instanceHistoryName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeDeploymentInstanceHistoryData> Get(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, string instanceHistoryName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));
            Argument.AssertNotNullOrEmpty(instanceHistoryName, nameof(instanceHistoryName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName, instanceHistoryName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDeploymentInstanceHistoryData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeDeploymentInstanceHistoryData.DeserializeEdgeDeploymentInstanceHistoryData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDeploymentInstanceHistoryData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByInstanceNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByInstanceNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List InstanceHistory Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<InstanceHistoryListResult>> ListByInstanceNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var message = CreateListByInstanceNextPageRequest(nextLink, subscriptionId, resourceGroupName, targetName, solutionName, instanceName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        InstanceHistoryListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = InstanceHistoryListResult.DeserializeInstanceHistoryListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List InstanceHistory Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<InstanceHistoryListResult> ListByInstanceNextPage(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var message = CreateListByInstanceNextPageRequest(nextLink, subscriptionId, resourceGroupName, targetName, solutionName, instanceName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        InstanceHistoryListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = InstanceHistoryListResult.DeserializeInstanceHistoryListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/InstancesRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class InstancesRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of InstancesRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public InstancesRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySolutionRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySolutionRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Instance Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<InstanceListResult>> ListBySolutionAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateListBySolutionRequest(subscriptionId, resourceGroupName, targetName, solutionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        InstanceListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = InstanceListResult.DeserializeInstanceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Instance Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<InstanceListResult> ListBySolution(string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateListBySolutionRequest(subscriptionId, resourceGroupName, targetName, solutionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        InstanceListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = InstanceListResult.DeserializeInstanceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get Instance Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeDeploymentInstanceData>> GetAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDeploymentInstanceData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeDeploymentInstanceData.DeserializeEdgeDeploymentInstanceData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDeploymentInstanceData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get Instance Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeDeploymentInstanceData> Get(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeDeploymentInstanceData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeDeploymentInstanceData.DeserializeEdgeDeploymentInstanceData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeDeploymentInstanceData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, EdgeDeploymentInstanceData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, EdgeDeploymentInstanceData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update Instance Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="instanceName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, EdgeDeploymentInstanceData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update Instance Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="instanceName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, EdgeDeploymentInstanceData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, EdgeDeploymentInstancePatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, EdgeDeploymentInstancePatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Update an Instance Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="instanceName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, EdgeDeploymentInstancePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Update an Instance Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="instanceName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, EdgeDeploymentInstancePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/instances/", false);
            uri.AppendPath(instanceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete Instance Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete Instance Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="instanceName"> Name of the instance. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="instanceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string instanceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(instanceName, nameof(instanceName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, targetName, solutionName, instanceName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySolutionNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySolutionNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Instance Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<InstanceListResult>> ListBySolutionNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateListBySolutionNextPageRequest(nextLink, subscriptionId, resourceGroupName, targetName, solutionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        InstanceListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = InstanceListResult.DeserializeInstanceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Instance Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<InstanceListResult> ListBySolutionNextPage(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateListBySolutionNextPageRequest(nextLink, subscriptionId, resourceGroupName, targetName, solutionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        InstanceListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = InstanceListResult.DeserializeInstanceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/JobsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class JobsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of JobsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public JobsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByTargetRequestUri(string resourceUri)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(resourceUri, false);
            uri.AppendPath("/providers/Microsoft.Edge/jobs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByTargetRequest(string resourceUri)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(resourceUri, false);
            uri.AppendPath("/providers/Microsoft.Edge/jobs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Jobs by parent resource. </summary>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceUri"/> is null. </exception>
        public async Task<Response<JobListResult>> ListByTargetAsync(string resourceUri, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));

            using var message = CreateListByTargetRequest(resourceUri);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        JobListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = JobListResult.DeserializeJobListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Jobs by parent resource. </summary>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceUri"/> is null. </exception>
        public Response<JobListResult> ListByTarget(string resourceUri, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));

            using var message = CreateListByTargetRequest(resourceUri);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        JobListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = JobListResult.DeserializeJobListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string resourceUri, string jobName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(resourceUri, false);
            uri.AppendPath("/providers/Microsoft.Edge/jobs/", false);
            uri.AppendPath(jobName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string resourceUri, string jobName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(resourceUri, false);
            uri.AppendPath("/providers/Microsoft.Edge/jobs/", false);
            uri.AppendPath(jobName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Job resource. </summary>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceUri"/> or <paramref name="jobName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeJobData>> GetAsync(string resourceUri, string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            using var message = CreateGetRequest(resourceUri, jobName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeJobData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeJobData.DeserializeEdgeJobData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeJobData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Job resource. </summary>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="jobName"> The name of the Job. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceUri"/> or <paramref name="jobName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeJobData> Get(string resourceUri, string jobName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            using var message = CreateGetRequest(resourceUri, jobName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeJobData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeJobData.DeserializeEdgeJobData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeJobData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByTargetNextPageRequestUri(string nextLink, string resourceUri)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByTargetNextPageRequest(string nextLink, string resourceUri)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Jobs by parent resource. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="resourceUri"/> is null. </exception>
        public async Task<Response<JobListResult>> ListByTargetNextPageAsync(string nextLink, string resourceUri, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));

            using var message = CreateListByTargetNextPageRequest(nextLink, resourceUri);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        JobListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = JobListResult.DeserializeJobListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Jobs by parent resource. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="resourceUri"/> is null. </exception>
        public Response<JobListResult> ListByTargetNextPage(string nextLink, string resourceUri, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));

            using var message = CreateListByTargetNextPageRequest(nextLink, resourceUri);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        JobListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = JobListResult.DeserializeJobListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/SchemaReferencesRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class SchemaReferencesRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of SchemaReferencesRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public SchemaReferencesRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByResourceGroupRequestUri(string resourceUri)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(resourceUri, false);
            uri.AppendPath("/providers/Microsoft.Edge/schemaReferences", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupRequest(string resourceUri)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(resourceUri, false);
            uri.AppendPath("/providers/Microsoft.Edge/schemaReferences", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceUri"/> is null. </exception>
        public async Task<Response<SchemaReferenceListResult>> ListByResourceGroupAsync(string resourceUri, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));

            using var message = CreateListByResourceGroupRequest(resourceUri);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaReferenceListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SchemaReferenceListResult.DeserializeSchemaReferenceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceUri"/> is null. </exception>
        public Response<SchemaReferenceListResult> ListByResourceGroup(string resourceUri, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));

            using var message = CreateListByResourceGroupRequest(resourceUri);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaReferenceListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SchemaReferenceListResult.DeserializeSchemaReferenceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string resourceUri, string schemaReferenceName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(resourceUri, false);
            uri.AppendPath("/providers/Microsoft.Edge/schemaReferences/", false);
            uri.AppendPath(schemaReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string resourceUri, string schemaReferenceName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/", false);
            uri.AppendPath(resourceUri, false);
            uri.AppendPath("/providers/Microsoft.Edge/schemaReferences/", false);
            uri.AppendPath(schemaReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Schema Reference Resource. </summary>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceUri"/> or <paramref name="schemaReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSchemaReferenceData>> GetAsync(string resourceUri, string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));
            Argument.AssertNotNullOrEmpty(schemaReferenceName, nameof(schemaReferenceName));

            using var message = CreateGetRequest(resourceUri, schemaReferenceName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaReferenceData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSchemaReferenceData.DeserializeEdgeSchemaReferenceData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSchemaReferenceData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Schema Reference Resource. </summary>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="schemaReferenceName"> The name of the SchemaReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceUri"/> or <paramref name="schemaReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="schemaReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSchemaReferenceData> Get(string resourceUri, string schemaReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));
            Argument.AssertNotNullOrEmpty(schemaReferenceName, nameof(schemaReferenceName));

            using var message = CreateGetRequest(resourceUri, schemaReferenceName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaReferenceData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSchemaReferenceData.DeserializeEdgeSchemaReferenceData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSchemaReferenceData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupNextPageRequestUri(string nextLink, string resourceUri)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupNextPageRequest(string nextLink, string resourceUri)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="resourceUri"/> is null. </exception>
        public async Task<Response<SchemaReferenceListResult>> ListByResourceGroupNextPageAsync(string nextLink, string resourceUri, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, resourceUri);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaReferenceListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SchemaReferenceListResult.DeserializeSchemaReferenceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="resourceUri"> The fully qualified Azure Resource manager identifier of the resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="resourceUri"/> is null. </exception>
        public Response<SchemaReferenceListResult> ListByResourceGroupNextPage(string nextLink, string resourceUri, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNull(resourceUri, nameof(resourceUri));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, resourceUri);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaReferenceListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SchemaReferenceListResult.DeserializeSchemaReferenceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/SchemasRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class SchemasRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of SchemasRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public SchemasRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySubscriptionRequestUri(string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionRequest(string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SchemaListResult>> ListBySubscriptionAsync(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SchemaListResult.DeserializeSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SchemaListResult> ListBySubscription(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SchemaListResult.DeserializeSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupRequestUri(string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupRequest(string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SchemaListResult>> ListByResourceGroupAsync(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SchemaListResult.DeserializeSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SchemaListResult> ListByResourceGroup(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SchemaListResult.DeserializeSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string schemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string schemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Schema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSchemaData>> GetAsync(string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, schemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSchemaData.DeserializeEdgeSchemaData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSchemaData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Schema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSchemaData> Get(string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, schemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSchemaData.DeserializeEdgeSchemaData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSchemaData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string schemaName, EdgeSchemaData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string schemaName, EdgeSchemaData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Schema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string schemaName, EdgeSchemaData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, schemaName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Schema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string schemaName, EdgeSchemaData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, schemaName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string schemaName, EdgeSchemaPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string schemaName, EdgeSchemaPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update a Schema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSchemaData>> UpdateAsync(string subscriptionId, string resourceGroupName, string schemaName, EdgeSchemaPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, schemaName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSchemaData.DeserializeEdgeSchemaData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update a Schema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSchemaData> Update(string subscriptionId, string resourceGroupName, string schemaName, EdgeSchemaPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, schemaName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSchemaData.DeserializeEdgeSchemaData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string schemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string schemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Schema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, schemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Schema Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, schemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateVersionRequestUri(string subscriptionId, string resourceGroupName, string schemaName, SchemaVersionWithUpdateType body)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/createVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateVersionRequest(string subscriptionId, string resourceGroupName, string schemaName, SchemaVersionWithUpdateType body)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/createVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(body, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateVersionAsync(string subscriptionId, string resourceGroupName, string schemaName, SchemaVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(body, nameof(body));

            using var message = CreateCreateVersionRequest(subscriptionId, resourceGroupName, schemaName, body);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateVersion(string subscriptionId, string resourceGroupName, string schemaName, SchemaVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(body, nameof(body));

            using var message = CreateCreateVersionRequest(subscriptionId, resourceGroupName, schemaName, body);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateRemoveVersionRequestUri(string subscriptionId, string resourceGroupName, string schemaName, WorkloadOrchestrationVersionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/removeVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateRemoveVersionRequest(string subscriptionId, string resourceGroupName, string schemaName, WorkloadOrchestrationVersionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/removeVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Remove Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<WorkloadOrchestrationRemoveVersionResult>> RemoveVersionAsync(string subscriptionId, string resourceGroupName, string schemaName, WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateRemoveVersionRequest(subscriptionId, resourceGroupName, schemaName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkloadOrchestrationRemoveVersionResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = WorkloadOrchestrationRemoveVersionResult.DeserializeWorkloadOrchestrationRemoveVersionResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Remove Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<WorkloadOrchestrationRemoveVersionResult> RemoveVersion(string subscriptionId, string resourceGroupName, string schemaName, WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateRemoveVersionRequest(subscriptionId, resourceGroupName, schemaName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkloadOrchestrationRemoveVersionResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = WorkloadOrchestrationRemoveVersionResult.DeserializeWorkloadOrchestrationRemoveVersionResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySubscriptionNextPageRequestUri(string nextLink, string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionNextPageRequest(string nextLink, string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SchemaListResult>> ListBySubscriptionNextPageAsync(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SchemaListResult.DeserializeSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SchemaListResult> ListBySubscriptionNextPage(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SchemaListResult.DeserializeSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SchemaListResult>> ListByResourceGroupNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SchemaListResult.DeserializeSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SchemaListResult> ListByResourceGroupNextPage(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SchemaListResult.DeserializeSchemaListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/SchemaVersionsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class SchemaVersionsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of SchemaVersionsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public SchemaVersionsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySchemaRequestUri(string subscriptionId, string resourceGroupName, string schemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySchemaRequest(string subscriptionId, string resourceGroupName, string schemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SchemaVersionListResult>> ListBySchemaAsync(string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateListBySchemaRequest(subscriptionId, resourceGroupName, schemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SchemaVersionListResult.DeserializeSchemaVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SchemaVersionListResult> ListBySchema(string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateListBySchemaRequest(subscriptionId, resourceGroupName, schemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SchemaVersionListResult.DeserializeSchemaVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(schemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(schemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSchemaVersionData>> GetAsync(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, schemaName, schemaVersionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaVersionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSchemaVersionData.DeserializeEdgeSchemaVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSchemaVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSchemaVersionData> Get(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, schemaName, schemaVersionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaVersionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSchemaVersionData.DeserializeEdgeSchemaVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSchemaVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, EdgeSchemaVersionData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(schemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, EdgeSchemaVersionData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(schemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="schemaVersionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, EdgeSchemaVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, schemaName, schemaVersionName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="schemaVersionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, EdgeSchemaVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, schemaName, schemaVersionName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, EdgeSchemaVersionPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(schemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, EdgeSchemaVersionPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(schemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="schemaVersionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSchemaVersionData>> UpdateAsync(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, EdgeSchemaVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, schemaName, schemaVersionName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaVersionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSchemaVersionData.DeserializeEdgeSchemaVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/>, <paramref name="schemaVersionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSchemaVersionData> Update(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, EdgeSchemaVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, schemaName, schemaVersionName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSchemaVersionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSchemaVersionData.DeserializeEdgeSchemaVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(schemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/schemas/", false);
            uri.AppendPath(schemaName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(schemaVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, schemaName, schemaVersionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Schema Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="schemaVersionName"> The name of the SchemaVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="schemaName"/> or <paramref name="schemaVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string schemaName, string schemaVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));
            Argument.AssertNotNullOrEmpty(schemaVersionName, nameof(schemaVersionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, schemaName, schemaVersionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySchemaNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string schemaName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySchemaNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string schemaName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SchemaVersionListResult>> ListBySchemaNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateListBySchemaNextPageRequest(nextLink, subscriptionId, resourceGroupName, schemaName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SchemaVersionListResult.DeserializeSchemaVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="schemaName"> The name of the Schema. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="schemaName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SchemaVersionListResult> ListBySchemaNextPage(string nextLink, string subscriptionId, string resourceGroupName, string schemaName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(schemaName, nameof(schemaName));

            using var message = CreateListBySchemaNextPageRequest(nextLink, subscriptionId, resourceGroupName, schemaName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SchemaVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SchemaVersionListResult.DeserializeSchemaVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/SiteReferencesRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class SiteReferencesRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of SiteReferencesRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public SiteReferencesRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByContextRequestUri(string subscriptionId, string resourceGroupName, string contextName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByContextRequest(string subscriptionId, string resourceGroupName, string contextName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Site Reference Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SiteReferenceListResult>> ListByContextAsync(string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateListByContextRequest(subscriptionId, resourceGroupName, contextName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SiteReferenceListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SiteReferenceListResult.DeserializeSiteReferenceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Site Reference Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SiteReferenceListResult> ListByContext(string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateListByContextRequest(subscriptionId, resourceGroupName, contextName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SiteReferenceListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SiteReferenceListResult.DeserializeSiteReferenceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences/", false);
            uri.AppendPath(siteReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences/", false);
            uri.AppendPath(siteReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get Site Reference Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSiteReferenceData>> GetAsync(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName, siteReferenceName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSiteReferenceData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSiteReferenceData.DeserializeEdgeSiteReferenceData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSiteReferenceData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get Site Reference Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSiteReferenceData> Get(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName, siteReferenceName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSiteReferenceData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSiteReferenceData.DeserializeEdgeSiteReferenceData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSiteReferenceData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, EdgeSiteReferenceData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences/", false);
            uri.AppendPath(siteReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, EdgeSiteReferenceData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences/", false);
            uri.AppendPath(siteReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get Site Reference Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="siteReferenceName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, EdgeSiteReferenceData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, siteReferenceName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get Site Reference Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="siteReferenceName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, EdgeSiteReferenceData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, siteReferenceName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, EdgeSiteReferencePatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences/", false);
            uri.AppendPath(siteReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, EdgeSiteReferencePatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences/", false);
            uri.AppendPath(siteReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get Site Reference Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="siteReferenceName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, EdgeSiteReferencePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, siteReferenceName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get Site Reference Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="siteReferenceName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, EdgeSiteReferencePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, siteReferenceName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences/", false);
            uri.AppendPath(siteReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/siteReferences/", false);
            uri.AppendPath(siteReferenceName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get Site Reference Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName, siteReferenceName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get Site Reference Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="siteReferenceName"> The name of the SiteReference. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="siteReferenceName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string contextName, string siteReferenceName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(siteReferenceName, nameof(siteReferenceName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName, siteReferenceName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByContextNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string contextName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByContextNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string contextName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Site Reference Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SiteReferenceListResult>> ListByContextNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateListByContextNextPageRequest(nextLink, subscriptionId, resourceGroupName, contextName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SiteReferenceListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SiteReferenceListResult.DeserializeSiteReferenceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Site Reference Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SiteReferenceListResult> ListByContextNextPage(string nextLink, string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateListByContextNextPageRequest(nextLink, subscriptionId, resourceGroupName, contextName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SiteReferenceListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SiteReferenceListResult.DeserializeSiteReferenceListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/SolutionsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class SolutionsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of SolutionsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public SolutionsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByTargetRequestUri(string subscriptionId, string resourceGroupName, string targetName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByTargetRequest(string subscriptionId, string resourceGroupName, string targetName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Solution resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionListResult>> ListByTargetAsync(string subscriptionId, string resourceGroupName, string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var message = CreateListByTargetRequest(subscriptionId, resourceGroupName, targetName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionListResult.DeserializeSolutionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Solution resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionListResult> ListByTarget(string subscriptionId, string resourceGroupName, string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var message = CreateListByTargetRequest(subscriptionId, resourceGroupName, targetName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionListResult.DeserializeSolutionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Solution resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSolutionData>> GetAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName, solutionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSolutionData.DeserializeEdgeSolutionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSolutionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Solution resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSolutionData> Get(string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName, solutionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSolutionData.DeserializeEdgeSolutionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSolutionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, EdgeSolutionData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, EdgeSolutionData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Solution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, EdgeSolutionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Solution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string targetName, string solutionName, EdgeSolutionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, EdgeSolutionPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, EdgeSolutionPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Update a Solution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, EdgeSolutionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Update a Solution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string targetName, string solutionName, EdgeSolutionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Solution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, targetName, solutionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Solution Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, targetName, solutionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByTargetNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string targetName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByTargetNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string targetName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Solution resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionListResult>> ListByTargetNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var message = CreateListByTargetNextPageRequest(nextLink, subscriptionId, resourceGroupName, targetName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionListResult.DeserializeSolutionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Solution resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionListResult> ListByTargetNextPage(string nextLink, string subscriptionId, string resourceGroupName, string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var message = CreateListByTargetNextPageRequest(nextLink, subscriptionId, resourceGroupName, targetName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionListResult.DeserializeSolutionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/SolutionTemplatesRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class SolutionTemplatesRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of SolutionTemplatesRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public SolutionTemplatesRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySubscriptionRequestUri(string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionRequest(string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionTemplateListResult>> ListBySubscriptionAsync(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionTemplateListResult.DeserializeSolutionTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionTemplateListResult> ListBySubscription(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionTemplateListResult.DeserializeSolutionTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupRequestUri(string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupRequest(string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionTemplateListResult>> ListByResourceGroupAsync(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionTemplateListResult.DeserializeSolutionTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionTemplateListResult> ListByResourceGroup(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionTemplateListResult.DeserializeSolutionTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Solution Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSolutionTemplateData>> GetAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, solutionTemplateName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionTemplateData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSolutionTemplateData.DeserializeEdgeSolutionTemplateData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSolutionTemplateData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Solution Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSolutionTemplateData> Get(string subscriptionId, string resourceGroupName, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, solutionTemplateName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionTemplateData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSolutionTemplateData.DeserializeEdgeSolutionTemplateData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSolutionTemplateData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName, EdgeSolutionTemplateData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName, EdgeSolutionTemplateData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Solution Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, EdgeSolutionTemplateData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, solutionTemplateName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Solution Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string solutionTemplateName, EdgeSolutionTemplateData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, solutionTemplateName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName, EdgeSolutionTemplatePatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName, EdgeSolutionTemplatePatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update a Solution Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSolutionTemplateData>> UpdateAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, EdgeSolutionTemplatePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, solutionTemplateName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionTemplateData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSolutionTemplateData.DeserializeEdgeSolutionTemplateData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update a Solution Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSolutionTemplateData> Update(string subscriptionId, string resourceGroupName, string solutionTemplateName, EdgeSolutionTemplatePatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, solutionTemplateName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionTemplateData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSolutionTemplateData.DeserializeEdgeSolutionTemplateData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Solution Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, solutionTemplateName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Solution Template Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, solutionTemplateName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateVersionRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName, SolutionTemplateVersionWithUpdateType body)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/createVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateVersionRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName, SolutionTemplateVersionWithUpdateType body)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/createVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(body, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create a Solution Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateVersionAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, SolutionTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(body, nameof(body));

            using var message = CreateCreateVersionRequest(subscriptionId, resourceGroupName, solutionTemplateName, body);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create a Solution Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="body"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateVersion(string subscriptionId, string resourceGroupName, string solutionTemplateName, SolutionTemplateVersionWithUpdateType body, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(body, nameof(body));

            using var message = CreateCreateVersionRequest(subscriptionId, resourceGroupName, solutionTemplateName, body);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateRemoveVersionRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName, WorkloadOrchestrationVersionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/removeVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateRemoveVersionRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName, WorkloadOrchestrationVersionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/removeVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Remove Solution Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> RemoveVersionAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateRemoveVersionRequest(subscriptionId, resourceGroupName, solutionTemplateName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Remove Solution Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response RemoveVersion(string subscriptionId, string resourceGroupName, string solutionTemplateName, WorkloadOrchestrationVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateRemoveVersionRequest(subscriptionId, resourceGroupName, solutionTemplateName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySubscriptionNextPageRequestUri(string nextLink, string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionNextPageRequest(string nextLink, string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionTemplateListResult>> ListBySubscriptionNextPageAsync(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionTemplateListResult.DeserializeSolutionTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionTemplateListResult> ListBySubscriptionNextPage(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionTemplateListResult.DeserializeSolutionTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionTemplateListResult>> ListByResourceGroupNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionTemplateListResult.DeserializeSolutionTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionTemplateListResult> ListByResourceGroupNextPage(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionTemplateListResult.DeserializeSolutionTemplateListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/SolutionTemplateVersionsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class SolutionTemplateVersionsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of SolutionTemplateVersionsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public SolutionTemplateVersionsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySolutionTemplateRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySolutionTemplateRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Solution Template Version Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionTemplateVersionListResult>> ListBySolutionTemplateAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var message = CreateListBySolutionTemplateRequest(subscriptionId, resourceGroupName, solutionTemplateName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionTemplateVersionListResult.DeserializeSolutionTemplateVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Solution Template Version Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionTemplateVersionListResult> ListBySolutionTemplate(string subscriptionId, string resourceGroupName, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var message = CreateListBySolutionTemplateRequest(subscriptionId, resourceGroupName, solutionTemplateName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionTemplateVersionListResult.DeserializeSolutionTemplateVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionTemplateVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionTemplateVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Solution Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSolutionTemplateVersionData>> GetAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, solutionTemplateName, solutionTemplateVersionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionTemplateVersionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSolutionTemplateVersionData.DeserializeEdgeSolutionTemplateVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSolutionTemplateVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Solution Template Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSolutionTemplateVersionData> Get(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, solutionTemplateName, solutionTemplateVersionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionTemplateVersionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSolutionTemplateVersionData.DeserializeEdgeSolutionTemplateVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSolutionTemplateVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateBulkDeploySolutionRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkDeploySolutionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionTemplateVersionName, true);
            uri.AppendPath("/bulkDeploySolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateBulkDeploySolutionRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkDeploySolutionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionTemplateVersionName, true);
            uri.AppendPath("/bulkDeploySolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request for bulk deploy. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> BulkDeploySolutionAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkDeploySolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateBulkDeploySolutionRequest(subscriptionId, resourceGroupName, solutionTemplateName, solutionTemplateVersionName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request for bulk deploy. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response BulkDeploySolution(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkDeploySolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateBulkDeploySolutionRequest(subscriptionId, resourceGroupName, solutionTemplateName, solutionTemplateVersionName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateBulkPublishSolutionRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkPublishSolutionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionTemplateVersionName, true);
            uri.AppendPath("/bulkPublishSolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateBulkPublishSolutionRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkPublishSolutionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionTemplateVersionName, true);
            uri.AppendPath("/bulkPublishSolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request for bulk publish. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> BulkPublishSolutionAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkPublishSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateBulkPublishSolutionRequest(subscriptionId, resourceGroupName, solutionTemplateName, solutionTemplateVersionName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request for bulk publish. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response BulkPublishSolution(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkPublishSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateBulkPublishSolutionRequest(subscriptionId, resourceGroupName, solutionTemplateName, solutionTemplateVersionName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateBulkReviewSolutionRequestUri(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkReviewSolutionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionTemplateVersionName, true);
            uri.AppendPath("/bulkReviewSolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateBulkReviewSolutionRequest(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkReviewSolutionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/solutionTemplates/", false);
            uri.AppendPath(solutionTemplateName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionTemplateVersionName, true);
            uri.AppendPath("/bulkReviewSolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request for bulk review. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> BulkReviewSolutionAsync(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkReviewSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateBulkReviewSolutionRequest(subscriptionId, resourceGroupName, solutionTemplateName, solutionTemplateVersionName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request for bulk review. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="solutionTemplateVersionName"> The name of the SolutionTemplateVersion. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/>, <paramref name="solutionTemplateVersionName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="solutionTemplateName"/> or <paramref name="solutionTemplateVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response BulkReviewSolution(string subscriptionId, string resourceGroupName, string solutionTemplateName, string solutionTemplateVersionName, WorkloadOrchestrationBulkReviewSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));
            Argument.AssertNotNullOrEmpty(solutionTemplateVersionName, nameof(solutionTemplateVersionName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateBulkReviewSolutionRequest(subscriptionId, resourceGroupName, solutionTemplateName, solutionTemplateVersionName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySolutionTemplateNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string solutionTemplateName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySolutionTemplateNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string solutionTemplateName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Solution Template Version Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionTemplateVersionListResult>> ListBySolutionTemplateNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var message = CreateListBySolutionTemplateNextPageRequest(nextLink, subscriptionId, resourceGroupName, solutionTemplateName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionTemplateVersionListResult.DeserializeSolutionTemplateVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Solution Template Version Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="solutionTemplateName"> The name of the SolutionTemplate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="solutionTemplateName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionTemplateVersionListResult> ListBySolutionTemplateNextPage(string nextLink, string subscriptionId, string resourceGroupName, string solutionTemplateName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(solutionTemplateName, nameof(solutionTemplateName));

            using var message = CreateListBySolutionTemplateNextPageRequest(nextLink, subscriptionId, resourceGroupName, solutionTemplateName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionTemplateVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionTemplateVersionListResult.DeserializeSolutionTemplateVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/SolutionVersionsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class SolutionVersionsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of SolutionVersionsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public SolutionVersionsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySolutionRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySolutionRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Solution Version Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionVersionListResult>> ListBySolutionAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateListBySolutionRequest(subscriptionId, resourceGroupName, targetName, solutionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionVersionListResult.DeserializeSolutionVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Solution Version Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionVersionListResult> ListBySolution(string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateListBySolutionRequest(subscriptionId, resourceGroupName, targetName, solutionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionVersionListResult.DeserializeSolutionVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Solution Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeSolutionVersionData>> GetAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName, solutionName, solutionVersionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionVersionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeSolutionVersionData.DeserializeEdgeSolutionVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSolutionVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Solution Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeSolutionVersionData> Get(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName, solutionName, solutionVersionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeSolutionVersionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeSolutionVersionData.DeserializeEdgeSolutionVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeSolutionVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, EdgeSolutionVersionData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, EdgeSolutionVersionData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Solution Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="solutionVersionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, EdgeSolutionVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, solutionVersionName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Solution Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="solutionVersionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, EdgeSolutionVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, solutionVersionName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, EdgeSolutionVersionPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, EdgeSolutionVersionPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Update a Solution Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="solutionVersionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, EdgeSolutionVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, solutionVersionName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Update a Solution Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/>, <paramref name="solutionVersionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, EdgeSolutionVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, targetName, solutionName, solutionVersionName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/solutions/", false);
            uri.AppendPath(solutionName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(solutionVersionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Solution Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, targetName, solutionName, solutionVersionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Solution Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="solutionVersionName"> Name of the solution version. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/>, <paramref name="solutionName"/> or <paramref name="solutionVersionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string targetName, string solutionName, string solutionVersionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));
            Argument.AssertNotNullOrEmpty(solutionVersionName, nameof(solutionVersionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, targetName, solutionName, solutionVersionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySolutionNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySolutionNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Solution Version Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<SolutionVersionListResult>> ListBySolutionNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateListBySolutionNextPageRequest(nextLink, subscriptionId, resourceGroupName, targetName, solutionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = SolutionVersionListResult.DeserializeSolutionVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Solution Version Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="solutionName"> Name of the solution. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="solutionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<SolutionVersionListResult> ListBySolutionNextPage(string nextLink, string subscriptionId, string resourceGroupName, string targetName, string solutionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNullOrEmpty(solutionName, nameof(solutionName));

            using var message = CreateListBySolutionNextPageRequest(nextLink, subscriptionId, resourceGroupName, targetName, solutionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SolutionVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = SolutionVersionListResult.DeserializeSolutionVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/TargetsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class TargetsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of TargetsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public TargetsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListBySubscriptionRequestUri(string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionRequest(string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<TargetListResult>> ListBySubscriptionAsync(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TargetListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = TargetListResult.DeserializeTargetListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<TargetListResult> ListBySubscription(string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionRequest(subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TargetListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = TargetListResult.DeserializeTargetListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupRequestUri(string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupRequest(string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<TargetListResult>> ListByResourceGroupAsync(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TargetListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = TargetListResult.DeserializeTargetListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<TargetListResult> ListByResourceGroup(string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TargetListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = TargetListResult.DeserializeTargetListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string targetName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string targetName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Target Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeTargetData>> GetAsync(string subscriptionId, string resourceGroupName, string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeTargetData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeTargetData.DeserializeEdgeTargetData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeTargetData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Target Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeTargetData> Get(string subscriptionId, string resourceGroupName, string targetName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, targetName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeTargetData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeTargetData.DeserializeEdgeTargetData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeTargetData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string targetName, EdgeTargetData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string targetName, EdgeTargetData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Target Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string targetName, EdgeTargetData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, targetName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Target Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string targetName, EdgeTargetData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, targetName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string targetName, EdgeTargetPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string targetName, EdgeTargetPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update a Target Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string targetName, EdgeTargetPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, targetName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update a Target Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string targetName, EdgeTargetPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, targetName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string targetName, bool? forceDelete)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (forceDelete != null)
            {
                uri.AppendQuery("forceDelete", forceDelete.Value, true);
            }
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string targetName, bool? forceDelete)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (forceDelete != null)
            {
                uri.AppendQuery("forceDelete", forceDelete.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Target Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="forceDelete"> Force delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string targetName, bool? forceDelete = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, targetName, forceDelete);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Target Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="forceDelete"> Force delete. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string targetName, bool? forceDelete = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, targetName, forceDelete);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateInstallSolutionRequestUri(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationInstallSolutionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/installSolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateInstallSolutionRequest(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationInstallSolutionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/installSolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request to deploy. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> InstallSolutionAsync(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationInstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateInstallSolutionRequest(subscriptionId, resourceGroupName, targetName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request to deploy. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response InstallSolution(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationInstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateInstallSolutionRequest(subscriptionId, resourceGroupName, targetName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreatePublishSolutionVersionRequestUri(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionVersionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/publishSolutionVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreatePublishSolutionVersionRequest(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionVersionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/publishSolutionVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request to publish. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> PublishSolutionVersionAsync(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreatePublishSolutionVersionRequest(subscriptionId, resourceGroupName, targetName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request to publish. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response PublishSolutionVersion(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreatePublishSolutionVersionRequest(subscriptionId, resourceGroupName, targetName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateRemoveRevisionRequestUri(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationRemoveRevisionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/removeRevision", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateRemoveRevisionRequest(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationRemoveRevisionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/removeRevision", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request to remove solution version revision. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> RemoveRevisionAsync(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationRemoveRevisionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateRemoveRevisionRequest(subscriptionId, resourceGroupName, targetName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request to remove solution version revision. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response RemoveRevision(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationRemoveRevisionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateRemoveRevisionRequest(subscriptionId, resourceGroupName, targetName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateResolveConfigurationRequestUri(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionTemplateContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/resolveConfiguration", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateResolveConfigurationRequest(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionTemplateContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/resolveConfiguration", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request to resolve configuration. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> ResolveConfigurationAsync(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateResolveConfigurationRequest(subscriptionId, resourceGroupName, targetName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request to resolve configuration. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response ResolveConfiguration(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateResolveConfigurationRequest(subscriptionId, resourceGroupName, targetName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateReviewSolutionVersionRequestUri(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionTemplateContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/reviewSolutionVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateReviewSolutionVersionRequest(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionTemplateContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/reviewSolutionVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request to review configuration. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> ReviewSolutionVersionAsync(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateReviewSolutionVersionRequest(subscriptionId, resourceGroupName, targetName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request to review configuration. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response ReviewSolutionVersion(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionTemplateContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateReviewSolutionVersionRequest(subscriptionId, resourceGroupName, targetName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUninstallSolutionRequestUri(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationUninstallSolutionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/uninstallSolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUninstallSolutionRequest(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationUninstallSolutionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/uninstallSolution", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request to uninstall. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UninstallSolutionAsync(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationUninstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateUninstallSolutionRequest(subscriptionId, resourceGroupName, targetName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request to uninstall. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response UninstallSolution(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationUninstallSolutionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateUninstallSolutionRequest(subscriptionId, resourceGroupName, targetName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUnstageSolutionVersionRequestUri(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionVersionContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/unstageSolutionVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUnstageSolutionVersionRequest(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionVersionContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/unstageSolutionVersion", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request to unstage solution version. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UnstageSolutionVersionAsync(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateUnstageSolutionVersionRequest(subscriptionId, resourceGroupName, targetName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request to unstage solution version. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response UnstageSolutionVersion(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationSolutionVersionContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateUnstageSolutionVersionRequest(subscriptionId, resourceGroupName, targetName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateExternalValidationStatusRequestUri(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationUpdateExternalValidationStatusContent content)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/updateExternalValidationStatus", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateExternalValidationStatusRequest(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationUpdateExternalValidationStatusContent content)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/targets/", false);
            uri.AppendPath(targetName, true);
            uri.AppendPath("/updateExternalValidationStatus", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content0 = new Utf8JsonRequestContent();
            content0.JsonWriter.WriteObjectValue(content, ModelSerializationExtensions.WireOptions);
            request.Content = content0;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Post request to update external validation status. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateExternalValidationStatusAsync(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationUpdateExternalValidationStatusContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateUpdateExternalValidationStatusRequest(subscriptionId, resourceGroupName, targetName, content);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Post request to update external validation status. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="targetName"> Name of the target. </param>
        /// <param name="content"> The content of the action request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="targetName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="targetName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response UpdateExternalValidationStatus(string subscriptionId, string resourceGroupName, string targetName, WorkloadOrchestrationUpdateExternalValidationStatusContent content, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(targetName, nameof(targetName));
            Argument.AssertNotNull(content, nameof(content));

            using var message = CreateUpdateExternalValidationStatusRequest(subscriptionId, resourceGroupName, targetName, content);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListBySubscriptionNextPageRequestUri(string nextLink, string subscriptionId)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListBySubscriptionNextPageRequest(string nextLink, string subscriptionId)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<TargetListResult>> ListBySubscriptionNextPageAsync(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TargetListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = TargetListResult.DeserializeTargetListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by subscription. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/> or <paramref name="subscriptionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<TargetListResult> ListBySubscriptionNextPage(string nextLink, string subscriptionId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));

            using var message = CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TargetListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = TargetListResult.DeserializeTargetListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByResourceGroupNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByResourceGroupNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<TargetListResult>> ListByResourceGroupNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TargetListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = TargetListResult.DeserializeTargetListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List by specified resource group. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> or <paramref name="resourceGroupName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<TargetListResult> ListByResourceGroupNextPage(string nextLink, string subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));

            using var message = CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TargetListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = TargetListResult.DeserializeTargetListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/WorkflowsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class WorkflowsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of WorkflowsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public WorkflowsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByContextRequestUri(string subscriptionId, string resourceGroupName, string contextName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByContextRequest(string subscriptionId, string resourceGroupName, string contextName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Workflow resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<WorkflowListResult>> ListByContextAsync(string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateListByContextRequest(subscriptionId, resourceGroupName, contextName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkflowListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = WorkflowListResult.DeserializeWorkflowListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Workflow resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<WorkflowListResult> ListByContext(string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateListByContextRequest(subscriptionId, resourceGroupName, contextName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkflowListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = WorkflowListResult.DeserializeWorkflowListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Workflow resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeWorkflowData>> GetAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName, workflowName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeWorkflowData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeWorkflowData.DeserializeEdgeWorkflowData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeWorkflowData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Workflow resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeWorkflowData> Get(string subscriptionId, string resourceGroupName, string contextName, string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName, workflowName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeWorkflowData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeWorkflowData.DeserializeEdgeWorkflowData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeWorkflowData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, EdgeWorkflowData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, EdgeWorkflowData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Workflow resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, EdgeWorkflowData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Workflow resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string contextName, string workflowName, EdgeWorkflowData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, EdgeWorkflowPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, EdgeWorkflowPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update a Workflow resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, EdgeWorkflowPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update a Workflow resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string contextName, string workflowName, EdgeWorkflowPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Workflow resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName, workflowName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Workflow resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string contextName, string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName, workflowName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByContextNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string contextName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByContextNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string contextName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Workflow resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<WorkflowListResult>> ListByContextNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateListByContextNextPageRequest(nextLink, subscriptionId, resourceGroupName, contextName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkflowListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = WorkflowListResult.DeserializeWorkflowListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Workflow resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/> or <paramref name="contextName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<WorkflowListResult> ListByContextNextPage(string nextLink, string subscriptionId, string resourceGroupName, string contextName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));

            using var message = CreateListByContextNextPageRequest(nextLink, subscriptionId, resourceGroupName, contextName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkflowListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = WorkflowListResult.DeserializeWorkflowListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}



================================================
FILE: Generated/RestOperations/WorkflowVersionsRestOperations.cs
================================================
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager.WorkloadOrchestration.Models;

namespace Azure.ResourceManager.WorkloadOrchestration
{
    internal partial class WorkflowVersionsRestOperations
    {
        private readonly TelemetryDetails _userAgent;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> Initializes a new instance of WorkflowVersionsRestOperations. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="applicationId"> The application id to use for user agent. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pipeline"/> or <paramref name="apiVersion"/> is null. </exception>
        public WorkflowVersionsRestOperations(HttpPipeline pipeline, string applicationId, Uri endpoint = null, string apiVersion = default)
        {
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? new Uri("https://management.azure.com");
            _apiVersion = apiVersion ?? "2025-08-01";
            _userAgent = new TelemetryDetails(GetType().Assembly, applicationId);
        }

        internal RequestUriBuilder CreateListByWorkflowRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateListByWorkflowRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Workflow Version Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<WorkflowVersionListResult>> ListByWorkflowAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var message = CreateListByWorkflowRequest(subscriptionId, resourceGroupName, contextName, workflowName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkflowVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = WorkflowVersionListResult.DeserializeWorkflowVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Workflow Version Resources. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<WorkflowVersionListResult> ListByWorkflow(string subscriptionId, string resourceGroupName, string contextName, string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var message = CreateListByWorkflowRequest(subscriptionId, resourceGroupName, contextName, workflowName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkflowVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = WorkflowVersionListResult.DeserializeWorkflowVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateGetRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateGetRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Get a Workflow Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<EdgeWorkflowVersionData>> GetAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeWorkflowVersionData value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = EdgeWorkflowVersionData.DeserializeEdgeWorkflowVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeWorkflowVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Get a Workflow Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<EdgeWorkflowVersionData> Get(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var message = CreateGetRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        EdgeWorkflowVersionData value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = EdgeWorkflowVersionData.DeserializeEdgeWorkflowVersionData(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                case 404:
                    return Response.FromValue((EdgeWorkflowVersionData)null, message.Response);
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateCreateOrUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, EdgeWorkflowVersionData data)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateCreateOrUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, EdgeWorkflowVersionData data)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(data, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Create or update a Workflow Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> CreateOrUpdateAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, EdgeWorkflowVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, data);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Create or update a Workflow Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="data"> Resource create parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="data"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response CreateOrUpdate(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, EdgeWorkflowVersionData data, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNull(data, nameof(data));

            using var message = CreateCreateOrUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, data);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 201:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateUpdateRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, EdgeWorkflowVersionPatch patch)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateUpdateRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, EdgeWorkflowVersionPatch patch)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(patch, ModelSerializationExtensions.WireOptions);
            request.Content = content;
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> update an WorkflowVersion Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> UpdateAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, EdgeWorkflowVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, patch);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> update an WorkflowVersion Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="patch"> The resource properties to be updated. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/>, <paramref name="versionName"/> or <paramref name="patch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Update(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, EdgeWorkflowVersionPatch patch, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));
            Argument.AssertNotNull(patch, nameof(patch));

            using var message = CreateUpdateRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName, patch);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateDeleteRequestUri(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            return uri;
        }

        internal HttpMessage CreateDeleteRequest(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(subscriptionId, true);
            uri.AppendPath("/resourceGroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.Edge/contexts/", false);
            uri.AppendPath(contextName, true);
            uri.AppendPath("/workflows/", false);
            uri.AppendPath(workflowName, true);
            uri.AppendPath("/versions/", false);
            uri.AppendPath(versionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> Delete a Workflow Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response> DeleteAsync(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Delete a Workflow Version Resource. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="versionName"> The name of the workflowVersion. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/>, <paramref name="workflowName"/> or <paramref name="versionName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response Delete(string subscriptionId, string resourceGroupName, string contextName, string workflowName, string versionName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));
            Argument.AssertNotNullOrEmpty(versionName, nameof(versionName));

            using var message = CreateDeleteRequest(subscriptionId, resourceGroupName, contextName, workflowName, versionName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 202:
                case 204:
                    return message.Response;
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        internal RequestUriBuilder CreateListByWorkflowNextPageRequestUri(string nextLink, string subscriptionId, string resourceGroupName, string contextName, string workflowName)
        {
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            return uri;
        }

        internal HttpMessage CreateListByWorkflowNextPageRequest(string nextLink, string subscriptionId, string resourceGroupName, string contextName, string workflowName)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            _userAgent.Apply(message);
            return message;
        }

        /// <summary> List Workflow Version Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public async Task<Response<WorkflowVersionListResult>> ListByWorkflowNextPageAsync(string nextLink, string subscriptionId, string resourceGroupName, string contextName, string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var message = CreateListByWorkflowNextPageRequest(nextLink, subscriptionId, resourceGroupName, contextName, workflowName);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkflowVersionListResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions, cancellationToken).ConfigureAwait(false);
                        value = WorkflowVersionListResult.DeserializeWorkflowVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> List Workflow Version Resources. </summary>
        /// <param name="nextLink"> The URL to the next page of results. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="contextName"> The name of the Context. </param>
        /// <param name="workflowName"> Name of the workflow. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="nextLink"/>, <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/>, <paramref name="resourceGroupName"/>, <paramref name="contextName"/> or <paramref name="workflowName"/> is an empty string, and was expected to be non-empty. </exception>
        public Response<WorkflowVersionListResult> ListByWorkflowNextPage(string nextLink, string subscriptionId, string resourceGroupName, string contextName, string workflowName, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(nextLink, nameof(nextLink));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(contextName, nameof(contextName));
            Argument.AssertNotNullOrEmpty(workflowName, nameof(workflowName));

            using var message = CreateListByWorkflowNextPageRequest(nextLink, subscriptionId, resourceGroupName, contextName, workflowName);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        WorkflowVersionListResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream, ModelSerializationExtensions.JsonDocumentOptions);
                        value = WorkflowVersionListResult.DeserializeWorkflowVersionListResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}


