// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Vision.Face
{
    // Data plane generated client.
    /// <summary> The FaceAdministration service client. </summary>
    public partial class FaceAdministrationClient
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private static readonly string[] AuthorizationScopes = new string[] { "https://cognitiveservices.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of FaceAdministrationClient for mocking. </summary>
        protected FaceAdministrationClient()
        {
        }

        /// <summary> Initializes a new instance of FaceAdministrationClient. </summary>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://{resource-name}.cognitiveservices.azure.com).
        /// </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public FaceAdministrationClient(Uri endpoint, AzureKeyCredential credential) : this(endpoint, credential, new AzureAIVisionFaceClientOptions())
        {
        }

        /// <summary> Initializes a new instance of FaceAdministrationClient. </summary>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://{resource-name}.cognitiveservices.azure.com).
        /// </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public FaceAdministrationClient(Uri endpoint, TokenCredential credential) : this(endpoint, credential, new AzureAIVisionFaceClientOptions())
        {
        }

        /// <summary> Initializes a new instance of FaceAdministrationClient. </summary>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://{resource-name}.cognitiveservices.azure.com).
        /// </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public FaceAdministrationClient(Uri endpoint, AzureKeyCredential credential, AzureAIVisionFaceClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new AzureAIVisionFaceClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _keyCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new AzureKeyCredentialPolicy(_keyCredential, AuthorizationHeader) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Initializes a new instance of FaceAdministrationClient. </summary>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://{resource-name}.cognitiveservices.azure.com).
        /// </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public FaceAdministrationClient(Uri endpoint, TokenCredential credential, AzureAIVisionFaceClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new AzureAIVisionFaceClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Create an empty Face List with user-specified faceListId, name, an optional userData and recognitionModel. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with this face list. Supported 'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Up to 64 Face Lists are allowed in one subscription.
        ///
        /// Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".
        ///
        /// After creation, user should use "Add Face List Face" to import the faces. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List" is called.
        ///
        /// "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use Person Group / Large Person Group and "Identify".
        ///
        /// Please consider Large Face List when the face number is large. It can support up to 1,000,000 faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateFaceListAsync(string,string,string,FaceRecognitionModel?,CancellationToken)']/*" />
        public virtual async Task<Response> CreateFaceListAsync(string faceListId, string name, string userData = null, FaceRecognitionModel? recognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(name, nameof(name));

            CreateFaceListRequest createFaceListRequest = new CreateFaceListRequest(name, userData, recognitionModel, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateFaceListAsync(faceListId, createFaceListRequest.ToRequestContent(), context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Create an empty Face List with user-specified faceListId, name, an optional userData and recognitionModel. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with this face list. Supported 'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Up to 64 Face Lists are allowed in one subscription.
        ///
        /// Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".
        ///
        /// After creation, user should use "Add Face List Face" to import the faces. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List" is called.
        ///
        /// "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use Person Group / Large Person Group and "Identify".
        ///
        /// Please consider Large Face List when the face number is large. It can support up to 1,000,000 faces.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateFaceList(string,string,string,FaceRecognitionModel?,CancellationToken)']/*" />
        public virtual Response CreateFaceList(string faceListId, string name, string userData = null, FaceRecognitionModel? recognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(name, nameof(name));

            CreateFaceListRequest createFaceListRequest = new CreateFaceListRequest(name, userData, recognitionModel, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateFaceList(faceListId, createFaceListRequest.ToRequestContent(), context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Create an empty Face List with user-specified faceListId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFaceListAsync(string,string,string,FaceRecognitionModel?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateFaceListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateFaceListAsync(string faceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateFaceListRequest(faceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create an empty Face List with user-specified faceListId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateFaceList(string,string,string,FaceRecognitionModel?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateFaceList(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateFaceList(string faceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateFaceListRequest(faceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a specified Face List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteFaceListAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteFaceListAsync(string faceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceListRequest(faceListId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a specified Face List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteFaceList(string,RequestContext)']/*" />
        public virtual Response DeleteFaceList(string faceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceListRequest(faceListId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceListAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<FaceList>> GetFaceListAsync(string faceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFaceListAsync(faceListId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(FaceList.FromResponse(response), response);
        }

        /// <summary> Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceList(string,bool?,CancellationToken)']/*" />
        public virtual Response<FaceList> GetFaceList(string faceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFaceList(faceListId, returnRecognitionModel, context);
            return Response.FromValue(FaceList.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceListAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceListAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetFaceListAsync(string faceListId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceListRequest(faceListId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceList(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceList(string,bool?,RequestContext)']/*" />
        public virtual Response GetFaceList(string faceListId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceListRequest(faceListId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update information of a Face List, including name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateFaceListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateFaceListAsync(string faceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceListRequest(faceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update information of a Face List, including name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateFaceList(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateFaceList(string faceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceListRequest(faceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Face Lists' faceListId, name, userData and recognitionModel.
        ///
        /// To get face information inside Face List use "Get Face List".
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceListsAsync(bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<FaceListItem>>> GetFaceListsAsync(bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFaceListsAsync(returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<FaceListItem> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<FaceListItem> array = new List<FaceListItem>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FaceListItem.DeserializeFaceListItem(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// List Face Lists' faceListId, name, userData and recognitionModel.
        ///
        /// To get face information inside Face List use "Get Face List".
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceLists(bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<FaceListItem>> GetFaceLists(bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFaceLists(returnRecognitionModel, context);
            IReadOnlyList<FaceListItem> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<FaceListItem> array = new List<FaceListItem>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(FaceListItem.DeserializeFaceListItem(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List Face Lists' faceListId, name, userData and recognitionModel.
        ///
        /// To get face information inside Face List use "Get Face List".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceListsAsync(bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceListsAsync(bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetFaceListsAsync(bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetFaceLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceListsRequest(returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List Face Lists' faceListId, name, userData and recognitionModel.
        ///
        /// To get face information inside Face List use "Get Face List".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceLists(bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetFaceLists(bool?,RequestContext)']/*" />
        public virtual Response GetFaceLists(bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetFaceLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceListsRequest(returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a specified Face List, up to 1,000 faces. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="uri"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceFromUrlAsync(string,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddFaceListFaceFromUrlAsync(string faceListId, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(uri, nameof(uri));

            AddFaceListFaceFromUrlRequest addFaceListFaceFromUrlRequest = new AddFaceListFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AddFaceListFaceFromUrlAsync(faceListId, addFaceListFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a specified Face List, up to 1,000 faces. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="uri"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceFromUrl(string,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddFaceListFaceFromUrl(string faceListId, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(uri, nameof(uri));

            AddFaceListFaceFromUrlRequest addFaceListFaceFromUrlRequest = new AddFaceListFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AddFaceListFaceFromUrl(faceListId, addFaceListFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified Face List, up to 1,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceListFaceFromUrlAsync(string,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceFromUrlAsync(string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddFaceListFaceFromUrlAsync(string faceListId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddFaceListFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceListFaceFromUrlRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified Face List, up to 1,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceListFaceFromUrl(string,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceFromUrl(string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response AddFaceListFaceFromUrl(string faceListId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddFaceListFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceListFaceFromUrlRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a specified Face List, up to 1,000 faces. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceAsync(string,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddFaceListFaceAsync(string faceListId, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AddFaceListFaceAsync(faceListId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a specified Face List, up to 1,000 faces. </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List Face" or "Delete Face List" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFace(string,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddFaceListFace(string faceListId, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AddFaceListFace(faceListId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified Face List, up to 1,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceListFaceAsync(string,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFaceAsync(string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddFaceListFaceAsync(string faceListId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceListFaceRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified Face List, up to 1,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceListFace(string,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddFaceListFace(string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response AddFaceListFace(string faceListId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceListFaceRequest(faceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a Face List by specified faceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteFaceListFaceAsync(string,Guid,RequestContext)']/*" />
        public virtual async Task<Response> DeleteFaceListFaceAsync(string faceListId, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceListFaceRequest(faceListId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a Face List by specified faceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="faceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="faceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="faceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteFaceListFace(string,Guid,RequestContext)']/*" />
        public virtual Response DeleteFaceListFace(string faceListId, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(faceListId, nameof(faceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceListFaceRequest(faceListId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and recognitionModel. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with this face list. Supported 'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large Face List".
        ///
        /// After creation, user should use Add Large Face List Face to import the faces and Train Large Face List to make it ready for "Find Similar". No image will be stored. Only the extracted face feature(s) will be stored on server until Delete Large Face List is called.
        ///
        /// "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use Person Group / Large Person Group and "Identify".
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 64 Large Face Lists.
        /// &gt;   * S0-tier subscription quota: 1,000,000 Large Face Lists.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargeFaceListAsync(string,string,string,FaceRecognitionModel?,CancellationToken)']/*" />
        public virtual async Task<Response> CreateLargeFaceListAsync(string largeFaceListId, string name, string userData = null, FaceRecognitionModel? recognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(name, nameof(name));

            CreateLargeFaceListRequest createLargeFaceListRequest = new CreateLargeFaceListRequest(name, userData, recognitionModel, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateLargeFaceListAsync(largeFaceListId, createLargeFaceListRequest.ToRequestContent(), context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and recognitionModel. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with this face list. Supported 'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large Face List".
        ///
        /// After creation, user should use Add Large Face List Face to import the faces and Train Large Face List to make it ready for "Find Similar". No image will be stored. Only the extracted face feature(s) will be stored on server until Delete Large Face List is called.
        ///
        /// "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering, or as a light way face identification. But if the actual use is to identify person, please use Person Group / Large Person Group and "Identify".
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 64 Large Face Lists.
        /// &gt;   * S0-tier subscription quota: 1,000,000 Large Face Lists.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargeFaceList(string,string,string,FaceRecognitionModel?,CancellationToken)']/*" />
        public virtual Response CreateLargeFaceList(string largeFaceListId, string name, string userData = null, FaceRecognitionModel? recognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(name, nameof(name));

            CreateLargeFaceListRequest createLargeFaceListRequest = new CreateLargeFaceListRequest(name, userData, recognitionModel, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateLargeFaceList(largeFaceListId, createLargeFaceListRequest.ToRequestContent(), context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargeFaceListAsync(string,string,string,FaceRecognitionModel?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargeFaceListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateLargeFaceListAsync(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargeFaceListRequest(largeFaceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargeFaceList(string,string,string,FaceRecognitionModel?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargeFaceList(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateLargeFaceList(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargeFaceListRequest(largeFaceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargeFaceListAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargeFaceListAsync(string largeFaceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargeFaceListRequest(largeFaceListId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargeFaceList(string,RequestContext)']/*" />
        public virtual Response DeleteLargeFaceList(string largeFaceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargeFaceListRequest(largeFaceListId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<LargeFaceList>> GetLargeFaceListAsync(string largeFaceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListAsync(largeFaceListId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(LargeFaceList.FromResponse(response), response);
        }

        /// <summary> Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceList(string,bool?,CancellationToken)']/*" />
        public virtual Response<LargeFaceList> GetLargeFaceList(string largeFaceListId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceList(largeFaceListId, returnRecognitionModel, context);
            return Response.FromValue(LargeFaceList.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListAsync(string largeFaceListId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListRequest(largeFaceListId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceList(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceList(string,bool?,RequestContext)']/*" />
        public virtual Response GetLargeFaceList(string largeFaceListId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListRequest(largeFaceListId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update information of a Large Face List, including name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargeFaceListAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargeFaceListAsync(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargeFaceListRequest(largeFaceListId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update information of a Large Face List, including name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargeFaceList(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargeFaceList(string largeFaceListId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargeFaceListRequest(largeFaceListId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// To get face information inside largeFaceList use "Get Large Face List Face".
        ///
        /// Large Face Lists are stored in alphabetical order of largeFaceListId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListsAsync(string,int?,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargeFaceList>>> GetLargeFaceListsAsync(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListsAsync(start, top, returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<LargeFaceList> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargeFaceList> array = new List<LargeFaceList>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceList.DeserializeLargeFaceList(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// To get face information inside largeFaceList use "Get Large Face List Face".
        ///
        /// Large Face Lists are stored in alphabetical order of largeFaceListId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceLists(string,int?,bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargeFaceList>> GetLargeFaceLists(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceLists(start, top, returnRecognitionModel, context);
            IReadOnlyList<LargeFaceList> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargeFaceList> array = new List<LargeFaceList>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceList.DeserializeLargeFaceList(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListsAsync(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListsAsync(string,int?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListsAsync(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListsRequest(start, top, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceLists(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceLists(string,int?,bool?,RequestContext)']/*" />
        public virtual Response GetLargeFaceLists(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceLists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListsRequest(start, top, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// To check the Large Face List training status completed or still ongoing. Large Face List training is an asynchronous operation triggered by "Train Large Face List".
        ///
        /// Training time depends on the number of face entries in a Large Face List. It could be in seconds, or up to half an hour for 1,000,000 faces.
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListTrainingStatusAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<FaceCollectionTrainingResult>> GetLargeFaceListTrainingStatusAsync(string largeFaceListId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListTrainingStatusAsync(largeFaceListId, context).ConfigureAwait(false);
            return Response.FromValue(FaceCollectionTrainingResult.FromResponse(response), response);
        }

        /// <summary>
        /// To check the Large Face List training status completed or still ongoing. Large Face List training is an asynchronous operation triggered by "Train Large Face List".
        ///
        /// Training time depends on the number of face entries in a Large Face List. It could be in seconds, or up to half an hour for 1,000,000 faces.
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListTrainingStatus(string,CancellationToken)']/*" />
        public virtual Response<FaceCollectionTrainingResult> GetLargeFaceListTrainingStatus(string largeFaceListId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceListTrainingStatus(largeFaceListId, context);
            return Response.FromValue(FaceCollectionTrainingResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] To check the Large Face List training status completed or still ongoing. Large Face List training is an asynchronous operation triggered by "Train Large Face List".
        ///
        /// Training time depends on the number of face entries in a Large Face List. It could be in seconds, or up to half an hour for 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListTrainingStatusAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListTrainingStatusAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListTrainingStatusAsync(string largeFaceListId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListTrainingStatusRequest(largeFaceListId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] To check the Large Face List training status completed or still ongoing. Large Face List training is an asynchronous operation triggered by "Train Large Face List".
        ///
        /// Training time depends on the number of face entries in a Large Face List. It could be in seconds, or up to half an hour for 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListTrainingStatus(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListTrainingStatus(string,RequestContext)']/*" />
        public virtual Response GetLargeFaceListTrainingStatus(string largeFaceListId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListTrainingStatusRequest(largeFaceListId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a specified Large Face List, up to 1,000,000 faces. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="uri"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 1,000 faces per Large Face List.
        /// &gt;   * S0-tier subscription quota: 1,000,000 faces per Large Face List.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceFromUrlAsync(string,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddLargeFaceListFaceFromUrlAsync(string largeFaceListId, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(uri, nameof(uri));

            AddLargeFaceListFaceFromUrlRequest addLargeFaceListFaceFromUrlRequest = new AddLargeFaceListFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AddLargeFaceListFaceFromUrlAsync(largeFaceListId, addLargeFaceListFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a specified Large Face List, up to 1,000,000 faces. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="uri"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 1,000 faces per Large Face List.
        /// &gt;   * S0-tier subscription quota: 1,000,000 faces per Large Face List.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceFromUrl(string,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddLargeFaceListFaceFromUrl(string largeFaceListId, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(uri, nameof(uri));

            AddLargeFaceListFaceFromUrlRequest addLargeFaceListFaceFromUrlRequest = new AddLargeFaceListFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AddLargeFaceListFaceFromUrl(largeFaceListId, addLargeFaceListFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified Large Face List, up to 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargeFaceListFaceFromUrlAsync(string,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceFromUrlAsync(string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddLargeFaceListFaceFromUrlAsync(string largeFaceListId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargeFaceListFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargeFaceListFaceFromUrlRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified Large Face List, up to 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargeFaceListFaceFromUrl(string,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceFromUrl(string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response AddLargeFaceListFaceFromUrl(string largeFaceListId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargeFaceListFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargeFaceListFaceFromUrlRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a specified Large Face List, up to 1,000,000 faces. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 1,000 faces per Large Face List.
        /// &gt;   * S0-tier subscription quota: 1,000,000 faces per Large Face List.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceAsync(string,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddLargeFaceListFaceAsync(string largeFaceListId, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AddLargeFaceListFaceAsync(largeFaceListId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a specified Large Face List, up to 1,000,000 faces. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Face List Face" or "Delete Large Face List" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 1,000 faces per Large Face List.
        /// &gt;   * S0-tier subscription quota: 1,000,000 faces per Large Face List.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFace(string,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddLargeFaceListFace(string largeFaceListId, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AddLargeFaceListFace(largeFaceListId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified Large Face List, up to 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargeFaceListFaceAsync(string,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFaceAsync(string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddLargeFaceListFaceAsync(string largeFaceListId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargeFaceListFaceRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a specified Large Face List, up to 1,000,000 faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargeFaceListFace(string,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargeFaceListFace(string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response AddLargeFaceListFace(string largeFaceListId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargeFaceListFaceRequest(largeFaceListId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargeFaceListFaceAsync(string,Guid,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargeFaceListFaceAsync(string largeFaceListId, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargeFaceListFace(string,Guid,RequestContext)']/*" />
        public virtual Response DeleteLargeFaceListFace(string largeFaceListId, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve persisted face in Large Face List by largeFaceListId and persistedFaceId. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFaceAsync(string,Guid,CancellationToken)']/*" />
        public virtual async Task<Response<LargeFaceListFace>> GetLargeFaceListFaceAsync(string largeFaceListId, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListFaceAsync(largeFaceListId, persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(LargeFaceListFace.FromResponse(response), response);
        }

        /// <summary> Retrieve persisted face in Large Face List by largeFaceListId and persistedFaceId. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFace(string,Guid,CancellationToken)']/*" />
        public virtual Response<LargeFaceListFace> GetLargeFaceListFace(string largeFaceListId, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceListFace(largeFaceListId, persistedFaceId, context);
            return Response.FromValue(LargeFaceListFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve persisted face in Large Face List by largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListFaceAsync(string,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFaceAsync(string,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListFaceAsync(string largeFaceListId, Guid persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve persisted face in Large Face List by largeFaceListId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListFace(string,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFace(string,Guid,RequestContext)']/*" />
        public virtual Response GetLargeFaceListFace(string largeFaceListId, Guid persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a specified face's userData field in a Large Face List by its persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargeFaceListFaceAsync(string,Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargeFaceListFaceAsync(string largeFaceListId, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a specified face's userData field in a Large Face List by its persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargeFaceListFace(string,Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargeFaceListFace(string largeFaceListId, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargeFaceListFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargeFaceListFaceRequest(largeFaceListId, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List faces' persistedFaceId and userData in a specified Large Face List. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Faces are stored in alphabetical order of persistedFaceId created in "Add Large Face List Face".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFacesAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargeFaceListFace>>> GetLargeFaceListFacesAsync(string largeFaceListId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargeFaceListFacesAsync(largeFaceListId, start, top, context).ConfigureAwait(false);
            IReadOnlyList<LargeFaceListFace> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargeFaceListFace> array = new List<LargeFaceListFace>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceListFace.DeserializeLargeFaceListFace(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List faces' persistedFaceId and userData in a specified Large Face List. </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Faces are stored in alphabetical order of persistedFaceId created in "Add Large Face List Face".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFaces(string,string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargeFaceListFace>> GetLargeFaceListFaces(string largeFaceListId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargeFaceListFaces(largeFaceListId, start, top, context);
            IReadOnlyList<LargeFaceListFace> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargeFaceListFace> array = new List<LargeFaceListFace>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargeFaceListFace.DeserializeLargeFaceListFace(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List faces' persistedFaceId and userData in a specified Large Face List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListFacesAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFacesAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargeFaceListFacesAsync(string largeFaceListId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListFacesRequest(largeFaceListId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List faces' persistedFaceId and userData in a specified Large Face List.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargeFaceListFaces(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargeFaceListFaces(string,string,int?,RequestContext)']/*" />
        public virtual Response GetLargeFaceListFaces(string largeFaceListId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargeFaceListFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargeFaceListFacesRequest(largeFaceListId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new Person Group with specified personGroupId, name, user-provided userData and recognitionModel. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with this face list. Supported 'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Person Group is a container holding the uploaded person data, including face recognition features.
        ///
        /// After creation, use "Create Person Group Person" to add persons into the group, and then call "Train Person Group" to get this group ready for "Identify From Person Group".
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until "Delete Person Group Person" or "Delete Person Group" is called.
        ///
        /// 'recognitionModel' should be specified to associate with this Person Group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing Person Group will use the recognition model that's already associated with the collection. Existing face feature(s) in a Person Group can't be updated to features extracted by another version of recognition model.
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
        /// &gt;   * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
        /// &gt;   * to handle larger scale face identification problem, please consider using Large Person Group.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupAsync(string,string,string,FaceRecognitionModel?,CancellationToken)']/*" />
        public virtual async Task<Response> CreatePersonGroupAsync(string personGroupId, string name, string userData = null, FaceRecognitionModel? recognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreatePersonGroupRequest createPersonGroupRequest = new CreatePersonGroupRequest(name, userData, recognitionModel, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreatePersonGroupAsync(personGroupId, createPersonGroupRequest.ToRequestContent(), context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Create a new Person Group with specified personGroupId, name, user-provided userData and recognitionModel. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with this face list. Supported 'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Person Group is a container holding the uploaded person data, including face recognition features.
        ///
        /// After creation, use "Create Person Group Person" to add persons into the group, and then call "Train Person Group" to get this group ready for "Identify From Person Group".
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until "Delete Person Group Person" or "Delete Person Group" is called.
        ///
        /// 'recognitionModel' should be specified to associate with this Person Group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing Person Group will use the recognition model that's already associated with the collection. Existing face feature(s) in a Person Group can't be updated to features extracted by another version of recognition model.
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
        /// &gt;   * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
        /// &gt;   * to handle larger scale face identification problem, please consider using Large Person Group.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroup(string,string,string,FaceRecognitionModel?,CancellationToken)']/*" />
        public virtual Response CreatePersonGroup(string personGroupId, string name, string userData = null, FaceRecognitionModel? recognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreatePersonGroupRequest createPersonGroupRequest = new CreatePersonGroupRequest(name, userData, recognitionModel, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreatePersonGroup(personGroupId, createPersonGroupRequest.ToRequestContent(), context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Create a new Person Group with specified personGroupId, name, user-provided userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonGroupAsync(string,string,string,FaceRecognitionModel?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreatePersonGroupAsync(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonGroupRequest(personGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a new Person Group with specified personGroupId, name, user-provided userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonGroup(string,string,string,FaceRecognitionModel?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreatePersonGroup(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonGroupRequest(personGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing Person Group with specified personGroupId. Persisted data in this Person Group will be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeletePersonGroupAsync(string personGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupRequest(personGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing Person Group with specified personGroupId. Persisted data in this Person Group will be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroup(string,RequestContext)']/*" />
        public virtual Response DeletePersonGroup(string personGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupRequest(personGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve Person Group name, userData and recognitionModel. To get person information under this personGroup, use "Get Person Group Persons". </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<PersonGroup>> GetPersonGroupAsync(string personGroupId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupAsync(personGroupId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(PersonGroup.FromResponse(response), response);
        }

        /// <summary> Retrieve Person Group name, userData and recognitionModel. To get person information under this personGroup, use "Get Person Group Persons". </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroup(string,bool?,CancellationToken)']/*" />
        public virtual Response<PersonGroup> GetPersonGroup(string personGroupId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroup(personGroupId, returnRecognitionModel, context);
            return Response.FromValue(PersonGroup.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve Person Group name, userData and recognitionModel. To get person information under this personGroup, use "Get Person Group Persons".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupAsync(string personGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupRequest(personGroupId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve Person Group name, userData and recognitionModel. To get person information under this personGroup, use "Get Person Group Persons".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroup(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroup(string,bool?,RequestContext)']/*" />
        public virtual Response GetPersonGroup(string personGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupRequest(personGroupId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing Person Group's name and userData. The properties keep unchanged if they are not in request body.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonGroupAsync(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupRequest(personGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing Person Group's name and userData. The properties keep unchanged if they are not in request body.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePersonGroup(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupRequest(personGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List Person Groups' personGroupId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Person Groups are stored in alphabetical order of personGroupId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupsAsync(string,int?,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<PersonGroup>>> GetPersonGroupsAsync(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupsAsync(start, top, returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<PersonGroup> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<PersonGroup> array = new List<PersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonGroup.DeserializePersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List Person Groups' personGroupId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Person Groups are stored in alphabetical order of personGroupId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroups(string,int?,bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<PersonGroup>> GetPersonGroups(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroups(start, top, returnRecognitionModel, context);
            IReadOnlyList<PersonGroup> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<PersonGroup> array = new List<PersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonGroup.DeserializePersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List Person Groups' personGroupId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupsAsync(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupsAsync(string,int?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupsAsync(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupsRequest(start, top, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List Person Groups' personGroupId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroups(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroups(string,int?,bool?,RequestContext)']/*" />
        public virtual Response GetPersonGroups(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupsRequest(start, top, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> To check Person Group training status completed or still ongoing. Person Group training is an asynchronous operation triggered by "Train Person Group" API. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupTrainingStatusAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<FaceCollectionTrainingResult>> GetPersonGroupTrainingStatusAsync(string personGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupTrainingStatusAsync(personGroupId, context).ConfigureAwait(false);
            return Response.FromValue(FaceCollectionTrainingResult.FromResponse(response), response);
        }

        /// <summary> To check Person Group training status completed or still ongoing. Person Group training is an asynchronous operation triggered by "Train Person Group" API. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupTrainingStatus(string,CancellationToken)']/*" />
        public virtual Response<FaceCollectionTrainingResult> GetPersonGroupTrainingStatus(string personGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroupTrainingStatus(personGroupId, context);
            return Response.FromValue(FaceCollectionTrainingResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] To check Person Group training status completed or still ongoing. Person Group training is an asynchronous operation triggered by "Train Person Group" API.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupTrainingStatusAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupTrainingStatusAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupTrainingStatusAsync(string personGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupTrainingStatusRequest(personGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] To check Person Group training status completed or still ongoing. Person Group training is an asynchronous operation triggered by "Train Person Group" API.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupTrainingStatus(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupTrainingStatus(string,RequestContext)']/*" />
        public virtual Response GetPersonGroupTrainingStatus(string personGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupTrainingStatusRequest(personGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new person in a specified Person Group. To add face to this person, please call "Add Person Group Person Face". </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota:
        /// &gt;     * 1,000 persons in all Person Groups.
        /// &gt;   * S0-tier subscription quota:
        /// &gt;     * 10,000 persons per Person Group.
        /// &gt;     * 1,000,000 Person Groups.
        /// &gt;     * 100,000,000 persons in all Person Groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupPersonAsync(string,string,string,CancellationToken)']/*" />
        public virtual async Task<Response<CreatePersonResult>> CreatePersonGroupPersonAsync(string personGroupId, string name, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreatePersonGroupPersonRequest createPersonGroupPersonRequest = new CreatePersonGroupPersonRequest(name, userData, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreatePersonGroupPersonAsync(personGroupId, createPersonGroupPersonRequest.ToRequestContent(), context).ConfigureAwait(false);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary> Create a new person in a specified Person Group. To add face to this person, please call "Add Person Group Person Face". </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota:
        /// &gt;     * 1,000 persons in all Person Groups.
        /// &gt;   * S0-tier subscription quota:
        /// &gt;     * 10,000 persons per Person Group.
        /// &gt;     * 1,000,000 Person Groups.
        /// &gt;     * 100,000,000 persons in all Person Groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupPerson(string,string,string,CancellationToken)']/*" />
        public virtual Response<CreatePersonResult> CreatePersonGroupPerson(string personGroupId, string name, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreatePersonGroupPersonRequest createPersonGroupPersonRequest = new CreatePersonGroupPersonRequest(name, userData, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreatePersonGroupPerson(personGroupId, createPersonGroupPersonRequest.ToRequestContent(), context);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Create a new person in a specified Person Group. To add face to this person, please call "Add Person Group Person Face".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonGroupPersonAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupPersonAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreatePersonGroupPersonAsync(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonGroupPersonRequest(personGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a new person in a specified Person Group. To add face to this person, please call "Add Person Group Person Face".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonGroupPerson(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonGroupPerson(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreatePersonGroupPerson(string personGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonGroupPersonRequest(personGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from a Person Group. The persistedFaceId, userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupPersonAsync(string,Guid,RequestContext)']/*" />
        public virtual async Task<Response> DeletePersonGroupPersonAsync(string personGroupId, Guid personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupPersonRequest(personGroupId, personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from a Person Group. The persistedFaceId, userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupPerson(string,Guid,RequestContext)']/*" />
        public virtual Response DeletePersonGroupPerson(string personGroupId, Guid personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupPersonRequest(personGroupId, personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s). </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonAsync(string,Guid,CancellationToken)']/*" />
        public virtual async Task<Response<PersonGroupPerson>> GetPersonGroupPersonAsync(string personGroupId, Guid personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupPersonAsync(personGroupId, personId, context).ConfigureAwait(false);
            return Response.FromValue(PersonGroupPerson.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s). </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPerson(string,Guid,CancellationToken)']/*" />
        public virtual Response<PersonGroupPerson> GetPersonGroupPerson(string personGroupId, Guid personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroupPerson(personGroupId, personId, context);
            return Response.FromValue(PersonGroupPerson.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersonAsync(string,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonAsync(string,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupPersonAsync(string personGroupId, Guid personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonRequest(personGroupId, personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPerson(string,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPerson(string,Guid,RequestContext)']/*" />
        public virtual Response GetPersonGroupPerson(string personGroupId, Guid personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonRequest(personGroupId, personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupPersonAsync(string,Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonGroupPersonAsync(string personGroupId, Guid personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupPersonRequest(personGroupId, personId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupPerson(string,Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePersonGroupPerson(string personGroupId, Guid personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupPersonRequest(personGroupId, personId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons' information in the specified Person Group, including personId, name, userData and persistedFaceIds of registered person faces. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in "Create Person Group Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonsAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<PersonGroupPerson>>> GetPersonGroupPersonsAsync(string personGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupPersonsAsync(personGroupId, start, top, context).ConfigureAwait(false);
            IReadOnlyList<PersonGroupPerson> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<PersonGroupPerson> array = new List<PersonGroupPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonGroupPerson.DeserializePersonGroupPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all persons' information in the specified Person Group, including personId, name, userData and persistedFaceIds of registered person faces. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in "Create Person Group Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersons(string,string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<PersonGroupPerson>> GetPersonGroupPersons(string personGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroupPersons(personGroupId, start, top, context);
            IReadOnlyList<PersonGroupPerson> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<PersonGroupPerson> array = new List<PersonGroupPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonGroupPerson.DeserializePersonGroupPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in the specified Person Group, including personId, name, userData and persistedFaceIds of registered person faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersonsAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonsAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupPersonsAsync(string personGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonsRequest(personGroupId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in the specified Person Group, including personId, name, userData and persistedFaceIds of registered person faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersons(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersons(string,string,int?,RequestContext)']/*" />
        public virtual Response GetPersonGroupPersons(string personGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonsRequest(personGroupId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person into a Person Group for face identification or verification. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="uri"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or "Delete Person Group" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceFromUrlAsync(string,Guid,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddPersonGroupPersonFaceFromUrlAsync(string personGroupId, Guid personId, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(uri, nameof(uri));

            AddPersonGroupPersonFaceFromUrlRequest addPersonGroupPersonFaceFromUrlRequest = new AddPersonGroupPersonFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AddPersonGroupPersonFaceFromUrlAsync(personGroupId, personId, addPersonGroupPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person into a Person Group for face identification or verification. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="uri"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or "Delete Person Group" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceFromUrl(string,Guid,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddPersonGroupPersonFaceFromUrl(string personGroupId, Guid personId, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(uri, nameof(uri));

            AddPersonGroupPersonFaceFromUrlRequest addPersonGroupPersonFaceFromUrlRequest = new AddPersonGroupPersonFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AddPersonGroupPersonFaceFromUrl(personGroupId, personId, addPersonGroupPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a Person Group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonGroupPersonFaceFromUrlAsync(string,Guid,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceFromUrlAsync(string,Guid,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddPersonGroupPersonFaceFromUrlAsync(string personGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonGroupPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonGroupPersonFaceFromUrlRequest(personGroupId, personId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a Person Group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonGroupPersonFaceFromUrl(string,Guid,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceFromUrl(string,Guid,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response AddPersonGroupPersonFaceFromUrl(string personGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonGroupPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonGroupPersonFaceFromUrlRequest(personGroupId, personId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person into a Person Group for face identification or verification. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or "Delete Person Group" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceAsync(string,Guid,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddPersonGroupPersonFaceAsync(string personGroupId, Guid personId, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AddPersonGroupPersonFaceAsync(personGroupId, personId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person into a Person Group for face identification or verification. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Person Group Person Face", "Delete Person Group Person" or "Delete Person Group" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFace(string,Guid,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddPersonGroupPersonFace(string personGroupId, Guid personId, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AddPersonGroupPersonFace(personGroupId, personId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a Person Group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonGroupPersonFaceAsync(string,Guid,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFaceAsync(string,Guid,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddPersonGroupPersonFaceAsync(string personGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonGroupPersonFaceRequest(personGroupId, personId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a Person Group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonGroupPersonFace(string,Guid,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonGroupPersonFace(string,Guid,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response AddPersonGroupPersonFace(string personGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonGroupPersonFaceRequest(personGroupId, personId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a person in a Person Group by specified personGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupPersonFaceAsync(string,Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> DeletePersonGroupPersonFaceAsync(string personGroupId, Guid personId, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a person in a Person Group by specified personGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonGroupPersonFace(string,Guid,Guid,RequestContext)']/*" />
        public virtual Response DeletePersonGroupPersonFace(string personGroupId, Guid personId, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personGroupId, personId and persistedFaceId. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonFaceAsync(string,Guid,Guid,CancellationToken)']/*" />
        public virtual async Task<Response<PersonGroupPersonFace>> GetPersonGroupPersonFaceAsync(string personGroupId, Guid personId, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonGroupPersonFaceAsync(personGroupId, personId, persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(PersonGroupPersonFace.FromResponse(response), response);
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personGroupId, personId and persistedFaceId. </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonFace(string,Guid,Guid,CancellationToken)']/*" />
        public virtual Response<PersonGroupPersonFace> GetPersonGroupPersonFace(string personGroupId, Guid personId, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonGroupPersonFace(personGroupId, personId, persistedFaceId, context);
            return Response.FromValue(PersonGroupPersonFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersonFaceAsync(string,Guid,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonFaceAsync(string,Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonGroupPersonFaceAsync(string personGroupId, Guid personId, Guid persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonGroupPersonFace(string,Guid,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonGroupPersonFace(string,Guid,Guid,RequestContext)']/*" />
        public virtual Response GetPersonGroupPersonFace(string personGroupId, Guid personId, Guid persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupPersonFaceAsync(string,Guid,Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonGroupPersonFaceAsync(string personGroupId, Guid personId, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonGroupPersonFace(string,Guid,Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePersonGroupPersonFace(string personGroupId, Guid personId, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonGroupPersonFaceRequest(personGroupId, personId, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and recognitionModel. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with this face list. Supported 'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Large Person Group is a container holding the uploaded person data, including the face recognition features. It can hold up to 1,000,000 entities.
        ///
        /// After creation, use "Create Large Person Group Person" to add person into the group, and call "Train Large Person Group" to get this group ready for "Identify From Large Person Group".
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until "Delete Large Person Group Person" or "Delete Large Person Group" is called.
        ///
        /// 'recognitionModel' should be specified to associate with this Large Person Group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing Large Person Group will use the recognition model that's already associated with the collection. Existing face feature(s) in a Large Person Group can't be updated to features extracted by another version of recognition model.
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 1,000 Large Person Groups.
        /// &gt;   * S0-tier subscription quota: 1,000,000 Large Person Groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupAsync(string,string,string,FaceRecognitionModel?,CancellationToken)']/*" />
        public virtual async Task<Response> CreateLargePersonGroupAsync(string largePersonGroupId, string name, string userData = null, FaceRecognitionModel? recognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreateLargePersonGroupRequest createLargePersonGroupRequest = new CreateLargePersonGroupRequest(name, userData, recognitionModel, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateLargePersonGroupAsync(largePersonGroupId, createLargePersonGroupRequest.ToRequestContent(), context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and recognitionModel. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with this face list. Supported 'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and 'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and 'recognition_02'. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Large Person Group is a container holding the uploaded person data, including the face recognition features. It can hold up to 1,000,000 entities.
        ///
        /// After creation, use "Create Large Person Group Person" to add person into the group, and call "Train Large Person Group" to get this group ready for "Identify From Large Person Group".
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until "Delete Large Person Group Person" or "Delete Large Person Group" is called.
        ///
        /// 'recognitionModel' should be specified to associate with this Large Person Group. The default value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly specify the model you need in this parameter. New faces that are added to an existing Large Person Group will use the recognition model that's already associated with the collection. Existing face feature(s) in a Large Person Group can't be updated to features extracted by another version of recognition model.
        ///
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota: 1,000 Large Person Groups.
        /// &gt;   * S0-tier subscription quota: 1,000,000 Large Person Groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroup(string,string,string,FaceRecognitionModel?,CancellationToken)']/*" />
        public virtual Response CreateLargePersonGroup(string largePersonGroupId, string name, string userData = null, FaceRecognitionModel? recognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreateLargePersonGroupRequest createLargePersonGroupRequest = new CreateLargePersonGroupRequest(name, userData, recognitionModel, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateLargePersonGroup(largePersonGroupId, createLargePersonGroupRequest.ToRequestContent(), context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargePersonGroupAsync(string,string,string,FaceRecognitionModel?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateLargePersonGroupAsync(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargePersonGroupRequest(largePersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a new Large Person Group with user-specified largePersonGroupId, name, an optional userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargePersonGroup(string,string,string,FaceRecognitionModel?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateLargePersonGroup(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargePersonGroupRequest(largePersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing Large Person Group with specified personGroupId. Persisted data in this Large Person Group will be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargePersonGroupAsync(string largePersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupRequest(largePersonGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing Large Person Group with specified personGroupId. Persisted data in this Large Person Group will be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroup(string,RequestContext)']/*" />
        public virtual Response DeleteLargePersonGroup(string largePersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupRequest(largePersonGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve the information of a Large Person Group, including its name, userData and recognitionModel. This API returns Large Person Group information only, use "Get Large Person Group Persons" instead to retrieve person information under the Large Person Group. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupAsync(string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<LargePersonGroup>> GetLargePersonGroupAsync(string largePersonGroupId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupAsync(largePersonGroupId, returnRecognitionModel, context).ConfigureAwait(false);
            return Response.FromValue(LargePersonGroup.FromResponse(response), response);
        }

        /// <summary> Retrieve the information of a Large Person Group, including its name, userData and recognitionModel. This API returns Large Person Group information only, use "Get Large Person Group Persons" instead to retrieve person information under the Large Person Group. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroup(string,bool?,CancellationToken)']/*" />
        public virtual Response<LargePersonGroup> GetLargePersonGroup(string largePersonGroupId, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroup(largePersonGroupId, returnRecognitionModel, context);
            return Response.FromValue(LargePersonGroup.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a Large Person Group, including its name, userData and recognitionModel. This API returns Large Person Group information only, use "Get Large Person Group Persons" instead to retrieve person information under the Large Person Group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupAsync(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupAsync(string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupAsync(string largePersonGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupRequest(largePersonGroupId, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a Large Person Group, including its name, userData and recognitionModel. This API returns Large Person Group information only, use "Get Large Person Group Persons" instead to retrieve person information under the Large Person Group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroup(string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroup(string,bool?,RequestContext)']/*" />
        public virtual Response GetLargePersonGroup(string largePersonGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupRequest(largePersonGroupId, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing Large Person Group's name and userData. The properties keep unchanged if they are not in request body.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargePersonGroupAsync(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupRequest(largePersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update an existing Large Person Group's name and userData. The properties keep unchanged if they are not in request body.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargePersonGroup(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupRequest(largePersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Large Person Groups are stored in alphabetical order of largePersonGroupId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupsAsync(string,int?,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargePersonGroup>>> GetLargePersonGroupsAsync(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupsAsync(start, top, returnRecognitionModel, context).ConfigureAwait(false);
            IReadOnlyList<LargePersonGroup> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargePersonGroup> array = new List<LargePersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargePersonGroup.DeserializeLargePersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Large Person Groups are stored in alphabetical order of largePersonGroupId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroups(string,int?,bool?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargePersonGroup>> GetLargePersonGroups(string start = null, int? top = null, bool? returnRecognitionModel = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroups(start, top, returnRecognitionModel, context);
            IReadOnlyList<LargePersonGroup> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargePersonGroup> array = new List<LargePersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargePersonGroup.DeserializeLargePersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupsAsync(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupsAsync(string,int?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupsAsync(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupsRequest(start, top, returnRecognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroups(string,int?,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="returnRecognitionModel"> Return 'recognitionModel' or not. The default value is false. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroups(string,int?,bool?,RequestContext)']/*" />
        public virtual Response GetLargePersonGroups(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupsRequest(start, top, returnRecognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> To check Large Person Group training status completed or still ongoing. Large Person Group training is an asynchronous operation triggered by "Train Large Person Group" API. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Training time depends on the number of person entries, and their faces in a Large Person Group. It could be in seconds, or up to half an hour for 1,000,000 persons. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupTrainingStatusAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<FaceCollectionTrainingResult>> GetLargePersonGroupTrainingStatusAsync(string largePersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupTrainingStatusAsync(largePersonGroupId, context).ConfigureAwait(false);
            return Response.FromValue(FaceCollectionTrainingResult.FromResponse(response), response);
        }

        /// <summary> To check Large Person Group training status completed or still ongoing. Large Person Group training is an asynchronous operation triggered by "Train Large Person Group" API. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Training time depends on the number of person entries, and their faces in a Large Person Group. It could be in seconds, or up to half an hour for 1,000,000 persons. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupTrainingStatus(string,CancellationToken)']/*" />
        public virtual Response<FaceCollectionTrainingResult> GetLargePersonGroupTrainingStatus(string largePersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroupTrainingStatus(largePersonGroupId, context);
            return Response.FromValue(FaceCollectionTrainingResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] To check Large Person Group training status completed or still ongoing. Large Person Group training is an asynchronous operation triggered by "Train Large Person Group" API.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupTrainingStatusAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupTrainingStatusAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupTrainingStatusAsync(string largePersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupTrainingStatusRequest(largePersonGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] To check Large Person Group training status completed or still ongoing. Large Person Group training is an asynchronous operation triggered by "Train Large Person Group" API.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupTrainingStatus(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupTrainingStatus(string,RequestContext)']/*" />
        public virtual Response GetLargePersonGroupTrainingStatus(string largePersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupTrainingStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupTrainingStatusRequest(largePersonGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large Person Group Person Face". </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota:
        /// &gt;     * 1,000 persons in all Large Person Groups.
        /// &gt;   * S0-tier subscription quota:
        /// &gt;     * 1,000,000 persons per Large Person Group.
        /// &gt;     * 1,000,000 Large Person Groups.
        /// &gt;     * 1,000,000,000 persons in all Large Person Groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupPersonAsync(string,string,string,CancellationToken)']/*" />
        public virtual async Task<Response<CreatePersonResult>> CreateLargePersonGroupPersonAsync(string largePersonGroupId, string name, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreateLargePersonGroupPersonRequest createLargePersonGroupPersonRequest = new CreateLargePersonGroupPersonRequest(name, userData, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateLargePersonGroupPersonAsync(largePersonGroupId, createLargePersonGroupPersonRequest.ToRequestContent(), context).ConfigureAwait(false);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary> Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large Person Group Person Face". </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// &gt; [!NOTE]
        /// &gt;
        /// &gt; *
        /// &gt;   * Free-tier subscription quota:
        /// &gt;     * 1,000 persons in all Large Person Groups.
        /// &gt;   * S0-tier subscription quota:
        /// &gt;     * 1,000,000 persons per Large Person Group.
        /// &gt;     * 1,000,000 Large Person Groups.
        /// &gt;     * 1,000,000,000 persons in all Large Person Groups.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupPerson(string,string,string,CancellationToken)']/*" />
        public virtual Response<CreatePersonResult> CreateLargePersonGroupPerson(string largePersonGroupId, string name, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreateLargePersonGroupPersonRequest createLargePersonGroupPersonRequest = new CreateLargePersonGroupPersonRequest(name, userData, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateLargePersonGroupPerson(largePersonGroupId, createLargePersonGroupPersonRequest.ToRequestContent(), context);
            return Response.FromValue(CreatePersonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large Person Group Person Face".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargePersonGroupPersonAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupPersonAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateLargePersonGroupPersonAsync(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargePersonGroupPersonRequest(largePersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Create a new person in a specified Large Person Group. To add face to this person, please call "Add Large Person Group Person Face".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateLargePersonGroupPerson(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateLargePersonGroupPerson(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateLargePersonGroupPerson(string largePersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateLargePersonGroupPersonRequest(largePersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from a Large Person Group. The persistedFaceId, userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupPersonAsync(string,Guid,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargePersonGroupPersonAsync(string largePersonGroupId, Guid personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupPersonRequest(largePersonGroupId, personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from a Large Person Group. The persistedFaceId, userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupPerson(string,Guid,RequestContext)']/*" />
        public virtual Response DeleteLargePersonGroupPerson(string largePersonGroupId, Guid personId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupPersonRequest(largePersonGroupId, personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s). </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonAsync(string,Guid,CancellationToken)']/*" />
        public virtual async Task<Response<LargePersonGroupPerson>> GetLargePersonGroupPersonAsync(string largePersonGroupId, Guid personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupPersonAsync(largePersonGroupId, personId, context).ConfigureAwait(false);
            return Response.FromValue(LargePersonGroupPerson.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s). </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPerson(string,Guid,CancellationToken)']/*" />
        public virtual Response<LargePersonGroupPerson> GetLargePersonGroupPerson(string largePersonGroupId, Guid personId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroupPerson(largePersonGroupId, personId, context);
            return Response.FromValue(LargePersonGroupPerson.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersonAsync(string,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonAsync(string,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupPersonAsync(string largePersonGroupId, Guid personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonRequest(largePersonGroupId, personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData, and the persisted faceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPerson(string,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPerson(string,Guid,RequestContext)']/*" />
        public virtual Response GetLargePersonGroupPerson(string largePersonGroupId, Guid personId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonRequest(largePersonGroupId, personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupPersonAsync(string,Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargePersonGroupPersonAsync(string largePersonGroupId, Guid personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupPersonRequest(largePersonGroupId, personId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupPerson(string,Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargePersonGroupPerson(string largePersonGroupId, Guid personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroupPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupPersonRequest(largePersonGroupId, personId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons' information in the specified Large Person Group, including personId, name, userData and persistedFaceIds of registered person faces. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in "Create Large Person Group Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonsAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<LargePersonGroupPerson>>> GetLargePersonGroupPersonsAsync(string largePersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupPersonsAsync(largePersonGroupId, start, top, context).ConfigureAwait(false);
            IReadOnlyList<LargePersonGroupPerson> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<LargePersonGroupPerson> array = new List<LargePersonGroupPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargePersonGroupPerson.DeserializeLargePersonGroupPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all persons' information in the specified Large Person Group, including personId, name, userData and persistedFaceIds of registered person faces. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in "Create Large Person Group Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersons(string,string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<LargePersonGroupPerson>> GetLargePersonGroupPersons(string largePersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroupPersons(largePersonGroupId, start, top, context);
            IReadOnlyList<LargePersonGroupPerson> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<LargePersonGroupPerson> array = new List<LargePersonGroupPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(LargePersonGroupPerson.DeserializeLargePersonGroupPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in the specified Large Person Group, including personId, name, userData and persistedFaceIds of registered person faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersonsAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonsAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupPersonsAsync(string largePersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonsRequest(largePersonGroupId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in the specified Large Person Group, including personId, name, userData and persistedFaceIds of registered person faces.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersons(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersons(string,string,int?,RequestContext)']/*" />
        public virtual Response GetLargePersonGroupPersons(string largePersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonsRequest(largePersonGroupId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person into a Large Person Group for face identification or verification. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="uri"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person Group Person" or "Delete Large Person Group" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceFromUrlAsync(string,Guid,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddLargePersonGroupPersonFaceFromUrlAsync(string largePersonGroupId, Guid personId, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(uri, nameof(uri));

            AddLargePersonGroupPersonFaceFromUrlRequest addLargePersonGroupPersonFaceFromUrlRequest = new AddLargePersonGroupPersonFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AddLargePersonGroupPersonFaceFromUrlAsync(largePersonGroupId, personId, addLargePersonGroupPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person into a Large Person Group for face identification or verification. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="uri"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person Group Person" or "Delete Large Person Group" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceFromUrl(string,Guid,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddLargePersonGroupPersonFaceFromUrl(string largePersonGroupId, Guid personId, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(uri, nameof(uri));

            AddLargePersonGroupPersonFaceFromUrlRequest addLargePersonGroupPersonFaceFromUrlRequest = new AddLargePersonGroupPersonFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AddLargePersonGroupPersonFaceFromUrl(largePersonGroupId, personId, addLargePersonGroupPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a Large Person Group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargePersonGroupPersonFaceFromUrlAsync(string,Guid,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceFromUrlAsync(string,Guid,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddLargePersonGroupPersonFaceFromUrlAsync(string largePersonGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargePersonGroupPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargePersonGroupPersonFaceFromUrlRequest(largePersonGroupId, personId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a Large Person Group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargePersonGroupPersonFaceFromUrl(string,Guid,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceFromUrl(string,Guid,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response AddLargePersonGroupPersonFaceFromUrl(string largePersonGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargePersonGroupPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargePersonGroupPersonFaceFromUrlRequest(largePersonGroupId, personId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person into a Large Person Group for face identification or verification. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person Group Person" or "Delete Large Person Group" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceAsync(string,Guid,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AddFaceResult>> AddLargePersonGroupPersonFaceAsync(string largePersonGroupId, Guid personId, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await AddLargePersonGroupPersonFaceAsync(largePersonGroupId, personId, content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary> Add a face to a person into a Large Person Group for face identification or verification. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="imageContent"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Person Group Person Face", "Delete Large Person Group Person" or "Delete Large Person Group" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFace(string,Guid,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Response<AddFaceResult> AddLargePersonGroupPersonFace(string largePersonGroupId, Guid personId, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = AddLargePersonGroupPersonFace(largePersonGroupId, personId, content, targetFace, detectionModel?.ToString(), userData, context);
            return Response.FromValue(AddFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a Large Person Group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargePersonGroupPersonFaceAsync(string,Guid,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFaceAsync(string,Guid,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Response> AddLargePersonGroupPersonFaceAsync(string largePersonGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, content, targetFace, detectionModel, userData, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person into a Large Person Group for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddLargePersonGroupPersonFace(string,Guid,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddLargePersonGroupPersonFace(string,Guid,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Response AddLargePersonGroupPersonFace(string largePersonGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, content, targetFace, detectionModel, userData, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a person in a Large Person Group by specified largePersonGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupPersonFaceAsync(string,Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> DeleteLargePersonGroupPersonFaceAsync(string largePersonGroupId, Guid personId, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete a face from a person in a Large Person Group by specified largePersonGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteLargePersonGroupPersonFace(string,Guid,Guid,RequestContext)']/*" />
        public virtual Response DeleteLargePersonGroupPersonFace(string largePersonGroupId, Guid personId, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and persistedFaceId. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonFaceAsync(string,Guid,Guid,CancellationToken)']/*" />
        public virtual async Task<Response<LargePersonGroupPersonFace>> GetLargePersonGroupPersonFaceAsync(string largePersonGroupId, Guid personId, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetLargePersonGroupPersonFaceAsync(largePersonGroupId, personId, persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(LargePersonGroupPersonFace.FromResponse(response), response);
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and persistedFaceId. </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonFace(string,Guid,Guid,CancellationToken)']/*" />
        public virtual Response<LargePersonGroupPersonFace> GetLargePersonGroupPersonFace(string largePersonGroupId, Guid personId, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetLargePersonGroupPersonFace(largePersonGroupId, personId, persistedFaceId, context);
            return Response.FromValue(LargePersonGroupPersonFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersonFaceAsync(string,Guid,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonFaceAsync(string,Guid,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetLargePersonGroupPersonFaceAsync(string largePersonGroupId, Guid personId, Guid persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its largePersonGroupId, personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetLargePersonGroupPersonFace(string,Guid,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetLargePersonGroupPersonFace(string,Guid,Guid,RequestContext)']/*" />
        public virtual Response GetLargePersonGroupPersonFace(string largePersonGroupId, Guid personId, Guid persistedFaceId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupPersonFaceAsync(string,Guid,Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateLargePersonGroupPersonFaceAsync(string largePersonGroupId, Guid personId, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a person persisted face's userData field.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="personId"> ID of the person. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateLargePersonGroupPersonFace(string,Guid,Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateLargePersonGroupPersonFace(string largePersonGroupId, Guid personId, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateLargePersonGroupPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateLargePersonGroupPersonFaceRequest(largePersonGroupId, personId, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a person's name and userData from Person Directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonAsync(Guid,CancellationToken)']/*" />
        public virtual async Task<Response<PersonDirectoryPerson>> GetPersonAsync(Guid personId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonAsync(personId, context).ConfigureAwait(false);
            return Response.FromValue(PersonDirectoryPerson.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's name and userData from Person Directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPerson(Guid,CancellationToken)']/*" />
        public virtual Response<PersonDirectoryPerson> GetPerson(Guid personId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPerson(personId, context);
            return Response.FromValue(PersonDirectoryPerson.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData from Person Directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonAsync(Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonAsync(Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonAsync(Guid personId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonRequest(personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData from Person Directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPerson(Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPerson(Guid,RequestContext)']/*" />
        public virtual Response GetPerson(Guid personId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonRequest(personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonAsync(Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonAsync(Guid personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonRequest(personId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePerson(Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePerson(Guid personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonRequest(personId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons' information in Person Directory, including personId, name, and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonsAsync(string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<PersonDirectoryPerson>>> GetPersonsAsync(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonsAsync(start, top, context).ConfigureAwait(false);
            IReadOnlyList<PersonDirectoryPerson> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<PersonDirectoryPerson> array = new List<PersonDirectoryPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonDirectoryPerson.DeserializePersonDirectoryPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all persons' information in Person Directory, including personId, name, and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersons(string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<PersonDirectoryPerson>> GetPersons(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersons(start, top, context);
            IReadOnlyList<PersonDirectoryPerson> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<PersonDirectoryPerson> array = new List<PersonDirectoryPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonDirectoryPerson.DeserializePersonDirectoryPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in Person Directory, including personId, name, and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonsAsync(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonsAsync(string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonsAsync(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonsRequest(start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in Person Directory, including personId, name, and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersons(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersons(string,int?,RequestContext)']/*" />
        public virtual Response GetPersons(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonsRequest(start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all Dynamic Person Groups a person has been referenced by in Person Directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Dynamic Person Groups are stored in alphabetical order of Dynamic Person Group ID created in Person Directory "Create Dynamic Person Group".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferencesAsync(Guid,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<ListGroupReferenceResult>> GetDynamicPersonGroupReferencesAsync(Guid personId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupReferencesAsync(personId, start, top, context).ConfigureAwait(false);
            return Response.FromValue(ListGroupReferenceResult.FromResponse(response), response);
        }

        /// <summary> List all Dynamic Person Groups a person has been referenced by in Person Directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Dynamic Person Groups are stored in alphabetical order of Dynamic Person Group ID created in Person Directory "Create Dynamic Person Group".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferences(Guid,string,int?,CancellationToken)']/*" />
        public virtual Response<ListGroupReferenceResult> GetDynamicPersonGroupReferences(Guid personId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroupReferences(personId, start, top, context);
            return Response.FromValue(ListGroupReferenceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] List all Dynamic Person Groups a person has been referenced by in Person Directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupReferencesAsync(Guid,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferencesAsync(Guid,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupReferencesAsync(Guid personId, string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroupReferences");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupReferencesRequest(personId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all Dynamic Person Groups a person has been referenced by in Person Directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupReferences(Guid,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferences(Guid,string,int?,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroupReferences(Guid personId, string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroupReferences");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupReferencesRequest(personId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFaceAsync(Guid,FaceRecognitionModel,Guid,CancellationToken)']/*" />
        public virtual async Task<Response<PersonDirectoryFace>> GetPersonFaceAsync(Guid personId, FaceRecognitionModel recognitionModel, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonFaceAsync(personId, recognitionModel.ToString(), persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(PersonDirectoryFace.FromResponse(response), response);
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFace(Guid,FaceRecognitionModel,Guid,CancellationToken)']/*" />
        public virtual Response<PersonDirectoryFace> GetPersonFace(Guid personId, FaceRecognitionModel recognitionModel, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonFace(personId, recognitionModel.ToString(), persistedFaceId, context);
            return Response.FromValue(PersonDirectoryFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonFaceAsync(Guid,FaceRecognitionModel,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFaceAsync(Guid,string,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonFaceAsync(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonFace(Guid,FaceRecognitionModel,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFace(Guid,string,Guid,RequestContext)']/*" />
        public virtual Response GetPersonFace(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a persisted face's userData field of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonFaceAsync(Guid,string,Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonFaceAsync(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonFaceRequest(personId, recognitionModel, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a persisted face's userData field of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdatePersonFace(Guid,string,Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePersonFace(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdatePersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonFaceRequest(personId, recognitionModel, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a person's persistedFaceIds representing the registered person face feature(s). </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFacesAsync(Guid,FaceRecognitionModel,CancellationToken)']/*" />
        public virtual async Task<Response<ListFaceResult>> GetPersonFacesAsync(Guid personId, FaceRecognitionModel recognitionModel, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonFacesAsync(personId, recognitionModel.ToString(), context).ConfigureAwait(false);
            return Response.FromValue(ListFaceResult.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's persistedFaceIds representing the registered person face feature(s). </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFaces(Guid,FaceRecognitionModel,CancellationToken)']/*" />
        public virtual Response<ListFaceResult> GetPersonFaces(Guid personId, FaceRecognitionModel recognitionModel, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersonFaces(personId, recognitionModel.ToString(), context);
            return Response.FromValue(ListFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's persistedFaceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonFacesAsync(Guid,FaceRecognitionModel,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFacesAsync(Guid,string,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonFacesAsync(Guid personId, string recognitionModel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonFacesRequest(personId, recognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's persistedFaceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonFaces(Guid,FaceRecognitionModel,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetPersonFaces(Guid,string,RequestContext)']/*" />
        public virtual Response GetPersonFaces(Guid personId, string recognitionModel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetPersonFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonFacesRequest(personId, recognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
        ///
        /// Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group" is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until Person Directory "Delete Person" or "Delete Person Face" is called.
        ///
        /// 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided during "Identify" determine the 'recognitionModel' used.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateDynamicPersonGroupAsync(string,string,string,CancellationToken)']/*" />
        public virtual async Task<Response> CreateDynamicPersonGroupAsync(string dynamicPersonGroupId, string name, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreateDynamicPersonGroupRequest createDynamicPersonGroupRequest = new CreateDynamicPersonGroupRequest(name, userData, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateDynamicPersonGroupAsync(dynamicPersonGroupId, createDynamicPersonGroupRequest.ToRequestContent(), context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="name"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
        ///
        /// Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group" is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until Person Directory "Delete Person" or "Delete Person Face" is called.
        ///
        /// 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided during "Identify" determine the 'recognitionModel' used.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateDynamicPersonGroup(string,string,string,CancellationToken)']/*" />
        public virtual Response CreateDynamicPersonGroup(string dynamicPersonGroupId, string name, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(name, nameof(name));

            CreateDynamicPersonGroupRequest createDynamicPersonGroupRequest = new CreateDynamicPersonGroupRequest(name, userData, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateDynamicPersonGroup(dynamicPersonGroupId, createDynamicPersonGroupRequest.ToRequestContent(), context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroupAsync(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateDynamicPersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateDynamicPersonGroupAsync(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroup(string,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateDynamicPersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateDynamicPersonGroup(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve the information of a Dynamic Person Group, including its name and userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> This API returns Dynamic Person Group information only, use Person Directory "Get Dynamic Person Group Persons" instead to retrieve person information under the Dynamic Person Group. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<DynamicPersonGroup>> GetDynamicPersonGroupAsync(string dynamicPersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupAsync(dynamicPersonGroupId, context).ConfigureAwait(false);
            return Response.FromValue(DynamicPersonGroup.FromResponse(response), response);
        }

        /// <summary> Retrieve the information of a Dynamic Person Group, including its name and userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> This API returns Dynamic Person Group information only, use Person Directory "Get Dynamic Person Group Persons" instead to retrieve person information under the Dynamic Person Group. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroup(string,CancellationToken)']/*" />
        public virtual Response<DynamicPersonGroup> GetDynamicPersonGroup(string dynamicPersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroup(dynamicPersonGroupId, context);
            return Response.FromValue(DynamicPersonGroup.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a Dynamic Person Group, including its name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupAsync(string dynamicPersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a Dynamic Person Group, including its name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroup(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroup(string,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroup(string dynamicPersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateDynamicPersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateDynamicPersonGroupAsync(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateDynamicPersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateDynamicPersonGroup(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Dynamic Person Groups are stored in alphabetical order of dynamicPersonGroupId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupsAsync(string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<DynamicPersonGroup>>> GetDynamicPersonGroupsAsync(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupsAsync(start, top, context).ConfigureAwait(false);
            IReadOnlyList<DynamicPersonGroup> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<DynamicPersonGroup> array = new List<DynamicPersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(DynamicPersonGroup.DeserializeDynamicPersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Dynamic Person Groups are stored in alphabetical order of dynamicPersonGroupId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroups(string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<DynamicPersonGroup>> GetDynamicPersonGroups(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroups(start, top, context);
            IReadOnlyList<DynamicPersonGroup> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<DynamicPersonGroup> array = new List<DynamicPersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(DynamicPersonGroup.DeserializeDynamicPersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupsAsync(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupsAsync(string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupsAsync(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupsRequest(start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroups(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroups(string,int?,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroups(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupsRequest(start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons in the specified Dynamic Person Group. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersonsAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<ListPersonResult>> GetDynamicPersonGroupPersonsAsync(string dynamicPersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupPersonsAsync(dynamicPersonGroupId, start, top, context).ConfigureAwait(false);
            return Response.FromValue(ListPersonResult.FromResponse(response), response);
        }

        /// <summary> List all persons in the specified Dynamic Person Group. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersons(string,string,int?,CancellationToken)']/*" />
        public virtual Response<ListPersonResult> GetDynamicPersonGroupPersons(string dynamicPersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroupPersons(dynamicPersonGroupId, start, top, context);
            return Response.FromValue(ListPersonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] List all persons in the specified Dynamic Person Group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupPersonsAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersonsAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupPersonsAsync(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupPersonsRequest(dynamicPersonGroupId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons in the specified Dynamic Person Group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupPersons(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersons(string,string,int?,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroupPersons(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.GetDynamicPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupPersonsRequest(dynamicPersonGroupId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a Large Face List training task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainLargeFaceListAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> TrainLargeFaceListAsync(WaitUntil waitUntil, string largeFaceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainLargeFaceListRequest(largeFaceListId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainLargeFaceList", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a Large Face List training task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largeFaceListId"> Valid character is letter in lower case or digit or '-' or '_', maximum length is 64. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largeFaceListId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largeFaceListId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainLargeFaceList(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation TrainLargeFaceList(WaitUntil waitUntil, string largeFaceListId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largeFaceListId, nameof(largeFaceListId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainLargeFaceList");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainLargeFaceListRequest(largeFaceListId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainLargeFaceList", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by "Identify From Person Group".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainPersonGroupAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> TrainPersonGroupAsync(WaitUntil waitUntil, string personGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainPersonGroupRequest(personGroupId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a Person Group training task. Training is a crucial step that only a trained Person Group can be used by "Identify From Person Group".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="personGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="personGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainPersonGroup(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation TrainPersonGroup(WaitUntil waitUntil, string personGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(personGroupId, nameof(personGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainPersonGroupRequest(personGroupId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can be used by "Identify From Large Person Group".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainLargePersonGroupAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> TrainLargePersonGroupAsync(WaitUntil waitUntil, string largePersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainLargePersonGroupRequest(largePersonGroupId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainLargePersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Submit a Large Person Group training task. Training is a crucial step that only a trained Large Person Group can be used by "Identify From Large Person Group".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="largePersonGroupId"> ID of the container. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="largePersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="largePersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='TrainLargePersonGroup(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation TrainLargePersonGroup(WaitUntil waitUntil, string largePersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(largePersonGroupId, nameof(largePersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.TrainLargePersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTrainLargePersonGroupRequest(largePersonGroupId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.TrainLargePersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person Face". </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonAsync(WaitUntil,string,string,CancellationToken)']/*" />
        public virtual async Task<Operation<PersonDirectoryPerson>> CreatePersonAsync(WaitUntil waitUntil, string name, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));

            CreatePersonRequest createPersonRequest = new CreatePersonRequest(name, userData, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = await CreatePersonAsync(waitUntil, createPersonRequest.ToRequestContent(), context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryPerson.FromResponse, ClientDiagnostics, "FaceAdministrationClient.CreatePerson");
        }

        /// <summary> Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person Face". </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="name"/> is null. </exception>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePerson(WaitUntil,string,string,CancellationToken)']/*" />
        public virtual Operation<PersonDirectoryPerson> CreatePerson(WaitUntil waitUntil, string name, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(name, nameof(name));

            CreatePersonRequest createPersonRequest = new CreatePersonRequest(name, userData, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = CreatePerson(waitUntil, createPersonRequest.ToRequestContent(), context);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryPerson.FromResponse, ClientDiagnostics, "FaceAdministrationClient.CreatePerson");
        }

        /// <summary>
        /// [Protocol Method] Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person Face".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonAsync(WaitUntil,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePersonAsync(WaitUntil,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CreatePersonAsync(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonRequest(content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.CreatePerson", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person Face".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePerson(WaitUntil,string,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreatePerson(WaitUntil,RequestContent,RequestContext)']/*" />
        public virtual Operation<BinaryData> CreatePerson(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonRequest(content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.CreatePerson", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonAsync(WaitUntil,Guid,RequestContext)']/*" />
        public virtual async Task<Operation> DeletePersonAsync(WaitUntil waitUntil, Guid personId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonRequest(personId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeletePerson", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePerson(WaitUntil,Guid,RequestContext)']/*" />
        public virtual Operation DeletePerson(WaitUntil waitUntil, Guid personId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonRequest(personId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeletePerson", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person (see Person Directory "Create Person") for face identification or verification. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uri"/> is null. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// *
        ///   * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        ///   * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to "Identify". For further information about Operation-Locations see "Get Face Operation Status".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonFaceFromUrlAsync(WaitUntil,Guid,FaceRecognitionModel,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Operation<PersonDirectoryFace>> AddPersonFaceFromUrlAsync(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(uri, nameof(uri));

            AddPersonFaceFromUrlRequest addPersonFaceFromUrlRequest = new AddPersonFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = await AddPersonFaceFromUrlAsync(waitUntil, personId, recognitionModel.ToString(), addPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryFace.FromResponse, ClientDiagnostics, "FaceAdministrationClient.AddPersonFaceFromUrl");
        }

        /// <summary> Add a face to a person (see Person Directory "Create Person") for face identification or verification. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uri"/> is null. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// *
        ///   * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        ///   * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to "Identify". For further information about Operation-Locations see "Get Face Operation Status".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonFaceFromUrl(WaitUntil,Guid,FaceRecognitionModel,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Operation<PersonDirectoryFace> AddPersonFaceFromUrl(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(uri, nameof(uri));

            AddPersonFaceFromUrlRequest addPersonFaceFromUrlRequest = new AddPersonFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = AddPersonFaceFromUrl(waitUntil, personId, recognitionModel.ToString(), addPersonFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryFace.FromResponse, ClientDiagnostics, "FaceAdministrationClient.AddPersonFaceFromUrl");
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see Person Directory "Create Person") for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonFaceFromUrlAsync(WaitUntil,Guid,FaceRecognitionModel,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonFaceFromUrlAsync(WaitUntil,Guid,string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> AddPersonFaceFromUrlAsync(WaitUntil waitUntil, Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonFaceFromUrlRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.AddPersonFaceFromUrl", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see Person Directory "Create Person") for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonFaceFromUrl(WaitUntil,Guid,FaceRecognitionModel,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonFaceFromUrl(WaitUntil,Guid,string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Operation<BinaryData> AddPersonFaceFromUrl(WaitUntil waitUntil, Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonFaceFromUrlRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.AddPersonFaceFromUrl", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person (see Person Directory "Create Person") for face identification or verification. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="imageContent"/> is null. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// *
        ///   * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        ///   * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to "Identify". For further information about Operation-Locations see "Get Face Operation Status".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonFaceAsync(WaitUntil,Guid,FaceRecognitionModel,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Operation<PersonDirectoryFace>> AddPersonFaceAsync(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = await AddPersonFaceAsync(waitUntil, personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryFace.FromResponse, ClientDiagnostics, "FaceAdministrationClient.AddPersonFace");
        }

        /// <summary> Add a face to a person (see Person Directory "Create Person") for face identification or verification. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="imageContent"/> is null. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// *
        ///   * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        ///   * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to "Identify". For further information about Operation-Locations see "Get Face Operation Status".
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonFace(WaitUntil,Guid,FaceRecognitionModel,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Operation<PersonDirectoryFace> AddPersonFace(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = AddPersonFace(waitUntil, personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryFace.FromResponse, ClientDiagnostics, "FaceAdministrationClient.AddPersonFace");
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see Person Directory "Create Person") for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonFaceAsync(WaitUntil,Guid,FaceRecognitionModel,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonFaceAsync(WaitUntil,Guid,string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> AddPersonFaceAsync(WaitUntil waitUntil, Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonFaceRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.AddPersonFace", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see Person Directory "Create Person") for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddPersonFace(WaitUntil,Guid,FaceRecognitionModel,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='AddPersonFace(WaitUntil,Guid,string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Operation<BinaryData> AddPersonFace(WaitUntil waitUntil, Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.AddPersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddPersonFaceRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.AddPersonFace", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a face from a person in Person Directory by specified personId and persistedFaceId. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonFaceAsync(WaitUntil,Guid,FaceRecognitionModel,Guid,CancellationToken)']/*" />
        public virtual async Task<Operation> DeletePersonFaceAsync(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            return await DeletePersonFaceAsync(waitUntil, personId, recognitionModel.ToString(), persistedFaceId, context).ConfigureAwait(false);
        }

        /// <summary> Delete a face from a person in Person Directory by specified personId and persistedFaceId. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonFace(WaitUntil,Guid,FaceRecognitionModel,Guid,CancellationToken)']/*" />
        public virtual Operation DeletePersonFace(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            return DeletePersonFace(waitUntil, personId, recognitionModel.ToString(), persistedFaceId, context);
        }

        /// <summary>
        /// [Protocol Method] Delete a face from a person in Person Directory by specified personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeletePersonFaceAsync(WaitUntil,Guid,FaceRecognitionModel,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonFaceAsync(WaitUntil,Guid,string,Guid,RequestContext)']/*" />
        public virtual async Task<Operation> DeletePersonFaceAsync(WaitUntil waitUntil, Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeletePersonFace", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a face from a person in Person Directory by specified personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeletePersonFace(WaitUntil,Guid,FaceRecognitionModel,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeletePersonFace(WaitUntil,Guid,string,Guid,RequestContext)']/*" />
        public virtual Operation DeletePersonFace(WaitUntil waitUntil, Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeletePersonFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeletePersonFace", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="addPersonIds"> Array of personIds created by Person Directory "Create Person" to be added. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/>, <paramref name="name"/> or <paramref name="addPersonIds"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
        ///
        /// Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group" is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until Person Directory "Delete Person" or "Delete Person Face" is called.
        ///
        /// 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided during "Identify" determine the 'recognitionModel' used.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateDynamicPersonGroupWithPersonAsync(WaitUntil,string,string,IEnumerable{Guid},string,CancellationToken)']/*" />
        public virtual async Task<Operation<DynamicPersonGroup>> CreateDynamicPersonGroupWithPersonAsync(WaitUntil waitUntil, string dynamicPersonGroupId, string name, IEnumerable<Guid> addPersonIds, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(addPersonIds, nameof(addPersonIds));

            CreateDynamicPersonGroupWithPersonRequest createDynamicPersonGroupWithPersonRequest = new CreateDynamicPersonGroupWithPersonRequest(name, userData, addPersonIds.ToList(), null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = await CreateDynamicPersonGroupWithPersonAsync(waitUntil, dynamicPersonGroupId, createDynamicPersonGroupWithPersonRequest.ToRequestContent(), context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, DynamicPersonGroup.FromResponse, ClientDiagnostics, "FaceAdministrationClient.CreateDynamicPersonGroupWithPerson");
        }

        /// <summary> Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="addPersonIds"> Array of personIds created by Person Directory "Create Person" to be added. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/>, <paramref name="name"/> or <paramref name="addPersonIds"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
        ///
        /// Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group" is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until Person Directory "Delete Person" or "Delete Person Face" is called.
        ///
        /// 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided during "Identify" determine the 'recognitionModel' used.
        /// </remarks>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateDynamicPersonGroupWithPerson(WaitUntil,string,string,IEnumerable{Guid},string,CancellationToken)']/*" />
        public virtual Operation<DynamicPersonGroup> CreateDynamicPersonGroupWithPerson(WaitUntil waitUntil, string dynamicPersonGroupId, string name, IEnumerable<Guid> addPersonIds, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(addPersonIds, nameof(addPersonIds));

            CreateDynamicPersonGroupWithPersonRequest createDynamicPersonGroupWithPersonRequest = new CreateDynamicPersonGroupWithPersonRequest(name, userData, addPersonIds.ToList(), null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = CreateDynamicPersonGroupWithPerson(waitUntil, dynamicPersonGroupId, createDynamicPersonGroupWithPersonRequest.ToRequestContent(), context);
            return ProtocolOperationHelpers.Convert(response, DynamicPersonGroup.FromResponse, ClientDiagnostics, "FaceAdministrationClient.CreateDynamicPersonGroupWithPerson");
        }

        /// <summary>
        /// [Protocol Method] Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroupWithPersonAsync(WaitUntil,string,string,IEnumerable{Guid},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateDynamicPersonGroupWithPersonAsync(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CreateDynamicPersonGroupWithPersonAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateDynamicPersonGroupWithPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupWithPersonRequest(dynamicPersonGroupId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.CreateDynamicPersonGroupWithPerson", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroupWithPerson(WaitUntil,string,string,IEnumerable{Guid},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='CreateDynamicPersonGroupWithPerson(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual Operation<BinaryData> CreateDynamicPersonGroupWithPerson(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.CreateDynamicPersonGroupWithPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupWithPersonRequest(dynamicPersonGroupId, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.CreateDynamicPersonGroupWithPerson", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteDynamicPersonGroupAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> DeleteDynamicPersonGroupAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeleteDynamicPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='DeleteDynamicPersonGroup(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation DeleteDynamicPersonGroup(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.DeleteDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.DeleteDynamicPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateDynamicPersonGroupWithPersonChangesAsync(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation> UpdateDynamicPersonGroupWithPersonChangesAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateDynamicPersonGroupWithPersonChanges");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupWithPersonChangesRequest(dynamicPersonGroupId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.UpdateDynamicPersonGroupWithPersonChanges", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/FaceAdministrationClient.xml" path="doc/members/member[@name='UpdateDynamicPersonGroupWithPersonChanges(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual Operation UpdateDynamicPersonGroupWithPersonChanges(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("FaceAdministrationClient.UpdateDynamicPersonGroupWithPersonChanges");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupWithPersonChangesRequest(dynamicPersonGroupId, content, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "FaceAdministrationClient.UpdateDynamicPersonGroupWithPersonChanges", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateFaceListRequest(string faceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteFaceListRequest(string faceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetFaceListRequest(string faceListId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateFaceListRequest(string faceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetFaceListsRequest(bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/facelists", false);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddFaceListFaceFromUrlRequest(string faceListId, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddFaceListFaceRequest(string faceListId, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteFaceListFaceRequest(string faceListId, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/facelists/", false);
            uri.AppendPath(faceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateLargeFaceListRequest(string largeFaceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargeFaceListRequest(string largeFaceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListRequest(string largeFaceListId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargeFaceListRequest(string largeFaceListId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListsRequest(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListTrainingStatusRequest(string largeFaceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/training", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateTrainLargeFaceListRequest(string largeFaceListId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/train", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddLargeFaceListFaceFromUrlRequest(string largeFaceListId, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddLargeFaceListFaceRequest(string largeFaceListId, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargeFaceListFaceRequest(string largeFaceListId, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListFaceRequest(string largeFaceListId, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargeFaceListFaceRequest(string largeFaceListId, Guid persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLargeFaceListFacesRequest(string largeFaceListId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largefacelists/", false);
            uri.AppendPath(largeFaceListId, true);
            uri.AppendPath("/persistedfaces", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreatePersonGroupRequest(string personGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonGroupRequest(string personGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonGroupRequest(string personGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonGroupRequest(string personGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPersonGroupsRequest(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonGroupTrainingStatusRequest(string personGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/training", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateTrainPersonGroupRequest(string personGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/train", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreatePersonGroupPersonRequest(string personGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonGroupPersonRequest(string personGroupId, Guid personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonGroupPersonRequest(string personGroupId, Guid personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonGroupPersonRequest(string personGroupId, Guid personId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPersonGroupPersonsRequest(string personGroupId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddPersonGroupPersonFaceFromUrlRequest(string personGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddPersonGroupPersonFaceRequest(string personGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonGroupPersonFaceRequest(string personGroupId, Guid personId, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonGroupPersonFaceRequest(string personGroupId, Guid personId, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonGroupPersonFaceRequest(string personGroupId, Guid personId, Guid persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persongroups/", false);
            uri.AppendPath(personGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateLargePersonGroupRequest(string largePersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargePersonGroupRequest(string largePersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupRequest(string largePersonGroupId, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargePersonGroupRequest(string largePersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupsRequest(string start, int? top, bool? returnRecognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            if (returnRecognitionModel != null)
            {
                uri.AppendQuery("returnRecognitionModel", returnRecognitionModel.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupTrainingStatusRequest(string largePersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/training", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateTrainLargePersonGroupRequest(string largePersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/train", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateLargePersonGroupPersonRequest(string largePersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargePersonGroupPersonRequest(string largePersonGroupId, Guid personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupPersonRequest(string largePersonGroupId, Guid personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargePersonGroupPersonRequest(string largePersonGroupId, Guid personId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupPersonsRequest(string largePersonGroupId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddLargePersonGroupPersonFaceFromUrlRequest(string largePersonGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddLargePersonGroupPersonFaceRequest(string largePersonGroupId, Guid personId, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteLargePersonGroupPersonFaceRequest(string largePersonGroupId, Guid personId, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLargePersonGroupPersonFaceRequest(string largePersonGroupId, Guid personId, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateLargePersonGroupPersonFaceRequest(string largePersonGroupId, Guid personId, Guid persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/largepersongroups/", false);
            uri.AppendPath(largePersonGroupId, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreatePersonRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonRequest(Guid personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonRequest(Guid personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonRequest(Guid personId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPersonsRequest(string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupReferencesRequest(Guid personId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/dynamicPersonGroupReferences", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddPersonFaceFromUrlRequest(Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddPersonFaceRequest(Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonFaceRequest(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonFaceRequest(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonFaceRequest(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPersonFacesRequest(Guid personId, string recognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateDynamicPersonGroupWithPersonRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateDynamicPersonGroupWithPersonChangesRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupsRequest(string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupPersonsRequest(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
    }
}
