// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.AI.Vision.Face
{
    // Data plane generated sub-client.
    /// <summary> The PersonDirectory sub-client. </summary>
    public partial class PersonDirectory
    {
        private const string AuthorizationHeader = "Ocp-Apim-Subscription-Key";
        private readonly AzureKeyCredential _keyCredential;
        private static readonly string[] AuthorizationScopes = new string[] { "https://cognitiveservices.azure.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of PersonDirectory for mocking. </summary>
        protected PersonDirectory()
        {
        }

        /// <summary> Initializes a new instance of PersonDirectory. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="keyCredential"> The key credential to copy. </param>
        /// <param name="tokenCredential"> The token credential to copy. </param>
        /// <param name="endpoint">
        /// Supported Cognitive Services endpoints (protocol and hostname, for example:
        /// https://{resource-name}.cognitiveservices.azure.com).
        /// </param>
        /// <param name="apiVersion"> API Version. Allowed values: "v1.1-preview.1". </param>
        internal PersonDirectory(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, AzureKeyCredential keyCredential, TokenCredential tokenCredential, Uri endpoint, string apiVersion)
        {
            ClientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
            _keyCredential = keyCredential;
            _tokenCredential = tokenCredential;
            _endpoint = endpoint;
            _apiVersion = apiVersion;
        }

        /// <summary> Retrieve a person's name and userData from Person Directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetPersonAsync(Guid,CancellationToken)']/*" />
        public virtual async Task<Response<PersonDirectoryPerson>> GetPersonAsync(Guid personId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonAsync(personId, context).ConfigureAwait(false);
            return Response.FromValue(PersonDirectoryPerson.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's name and userData from Person Directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetPerson(Guid,CancellationToken)']/*" />
        public virtual Response<PersonDirectoryPerson> GetPerson(Guid personId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPerson(personId, context);
            return Response.FromValue(PersonDirectoryPerson.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData from Person Directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonAsync(Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetPersonAsync(Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonAsync(Guid personId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonRequest(personId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's name and userData from Person Directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPerson(Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetPerson(Guid,RequestContext)']/*" />
        public virtual Response GetPerson(Guid personId, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonRequest(personId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='UpdatePersonAsync(Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdatePersonAsync(Guid personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.UpdatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonRequest(personId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update name or userData of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='UpdatePerson(Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UpdatePerson(Guid personId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.UpdatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePersonRequest(personId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons' information in Person Directory, including personId, name, and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetPersonsAsync(string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<PersonDirectoryPerson>>> GetPersonsAsync(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPersonsAsync(start, top, context).ConfigureAwait(false);
            IReadOnlyList<PersonDirectoryPerson> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<PersonDirectoryPerson> array = new List<PersonDirectoryPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonDirectoryPerson.DeserializePersonDirectoryPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all persons' information in Person Directory, including personId, name, and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetPersons(string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<PersonDirectoryPerson>> GetPersons(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPersons(start, top, context);
            IReadOnlyList<PersonDirectoryPerson> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<PersonDirectoryPerson> array = new List<PersonDirectoryPerson>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(PersonDirectoryPerson.DeserializePersonDirectoryPerson(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in Person Directory, including personId, name, and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersonsAsync(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetPersonsAsync(string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetPersonsAsync(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonsRequest(start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons' information in Person Directory, including personId, name, and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPersons(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetPersons(string,int?,RequestContext)']/*" />
        public virtual Response GetPersons(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPersonsRequest(start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all Dynamic Person Groups a person has been referenced by in Person Directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Dynamic Person Groups are stored in alphabetical order of Dynamic Person Group ID created in Person Directory "Create Dynamic Person Group".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferencesAsync(Guid,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<ListGroupReferenceResult>> GetDynamicPersonGroupReferencesAsync(Guid personId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupReferencesAsync(personId, start, top, context).ConfigureAwait(false);
            return Response.FromValue(ListGroupReferenceResult.FromResponse(response), response);
        }

        /// <summary> List all Dynamic Person Groups a person has been referenced by in Person Directory. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Dynamic Person Groups are stored in alphabetical order of Dynamic Person Group ID created in Person Directory "Create Dynamic Person Group".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferences(Guid,string,int?,CancellationToken)']/*" />
        public virtual Response<ListGroupReferenceResult> GetDynamicPersonGroupReferences(Guid personId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroupReferences(personId, start, top, context);
            return Response.FromValue(ListGroupReferenceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] List all Dynamic Person Groups a person has been referenced by in Person Directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupReferencesAsync(Guid,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferencesAsync(Guid,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupReferencesAsync(Guid personId, string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetDynamicPersonGroupReferences");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupReferencesRequest(personId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all Dynamic Person Groups a person has been referenced by in Person Directory.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupReferences(Guid,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupReferences(Guid,string,int?,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroupReferences(Guid personId, string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetDynamicPersonGroupReferences");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupReferencesRequest(personId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetFaceAsync(Guid,FaceRecognitionModel,Guid,CancellationToken)']/*" />
        public virtual async Task<Response<PersonDirectoryFace>> GetFaceAsync(Guid personId, FaceRecognitionModel recognitionModel, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFaceAsync(personId, recognitionModel.ToString(), persistedFaceId, context).ConfigureAwait(false);
            return Response.FromValue(PersonDirectoryFace.FromResponse(response), response);
        }

        /// <summary> Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId. </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetFace(Guid,FaceRecognitionModel,Guid,CancellationToken)']/*" />
        public virtual Response<PersonDirectoryFace> GetFace(Guid personId, FaceRecognitionModel recognitionModel, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFace(personId, recognitionModel.ToString(), persistedFaceId, context);
            return Response.FromValue(PersonDirectoryFace.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaceAsync(Guid,FaceRecognitionModel,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetFaceAsync(Guid,string,Guid,RequestContext)']/*" />
        public virtual async Task<Response> GetFaceAsync(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve person face information. The persisted person face is specified by its personId. recognitionModel, and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFace(Guid,FaceRecognitionModel,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetFace(Guid,string,Guid,RequestContext)']/*" />
        public virtual Response GetFace(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a persisted face's userData field of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='UpdateFaceAsync(Guid,string,Guid,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateFaceAsync(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.UpdateFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceRequest(personId, recognitionModel, persistedFaceId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update a persisted face's userData field of a person.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='UpdateFace(Guid,string,Guid,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateFace(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.UpdateFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateFaceRequest(personId, recognitionModel, persistedFaceId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve a person's persistedFaceIds representing the registered person face feature(s). </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetFacesAsync(Guid,FaceRecognitionModel,CancellationToken)']/*" />
        public virtual async Task<Response<ListFaceResult>> GetFacesAsync(Guid personId, FaceRecognitionModel recognitionModel, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetFacesAsync(personId, recognitionModel.ToString(), context).ConfigureAwait(false);
            return Response.FromValue(ListFaceResult.FromResponse(response), response);
        }

        /// <summary> Retrieve a person's persistedFaceIds representing the registered person face feature(s). </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetFaces(Guid,FaceRecognitionModel,CancellationToken)']/*" />
        public virtual Response<ListFaceResult> GetFaces(Guid personId, FaceRecognitionModel recognitionModel, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetFaces(personId, recognitionModel.ToString(), context);
            return Response.FromValue(ListFaceResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's persistedFaceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFacesAsync(Guid,FaceRecognitionModel,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetFacesAsync(Guid,string,RequestContext)']/*" />
        public virtual async Task<Response> GetFacesAsync(Guid personId, string recognitionModel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFacesRequest(personId, recognitionModel, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve a person's persistedFaceIds representing the registered person face feature(s).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFaces(Guid,FaceRecognitionModel,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetFaces(Guid,string,RequestContext)']/*" />
        public virtual Response GetFaces(Guid personId, string recognitionModel, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetFaces");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetFacesRequest(personId, recognitionModel, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="userDefinedFields"> The <see cref="UserDefinedFields"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="userDefinedFields"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
        ///
        /// Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group" is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until Person Directory "Delete Person" or "Delete Person Face" is called.
        ///
        /// 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided during "Identify" determine the 'recognitionModel' used.
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreateDynamicPersonGroupAsync(string,UserDefinedFields,CancellationToken)']/*" />
        public virtual async Task<Response> CreateDynamicPersonGroupAsync(string dynamicPersonGroupId, UserDefinedFields userDefinedFields, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(userDefinedFields, nameof(userDefinedFields));

            using RequestContent content = userDefinedFields.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await CreateDynamicPersonGroupAsync(dynamicPersonGroupId, content, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="userDefinedFields"> The <see cref="UserDefinedFields"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="userDefinedFields"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
        ///
        /// Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group" is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until Person Directory "Delete Person" or "Delete Person Face" is called.
        ///
        /// 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided during "Identify" determine the 'recognitionModel' used.
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreateDynamicPersonGroup(string,UserDefinedFields,CancellationToken)']/*" />
        public virtual Response CreateDynamicPersonGroup(string dynamicPersonGroupId, UserDefinedFields userDefinedFields, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(userDefinedFields, nameof(userDefinedFields));

            using RequestContent content = userDefinedFields.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = CreateDynamicPersonGroup(dynamicPersonGroupId, content, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroupAsync(string,UserDefinedFields,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreateDynamicPersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> CreateDynamicPersonGroupAsync(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.CreateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroup(string,UserDefinedFields,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreateDynamicPersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response CreateDynamicPersonGroup(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.CreateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve the information of a Dynamic Person Group, including its name and userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> This API returns Dynamic Person Group information only, use Person Directory "Get Dynamic Person Group Persons" instead to retrieve person information under the Dynamic Person Group. </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupAsync(string,CancellationToken)']/*" />
        public virtual async Task<Response<DynamicPersonGroup>> GetDynamicPersonGroupAsync(string dynamicPersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupAsync(dynamicPersonGroupId, context).ConfigureAwait(false);
            return Response.FromValue(DynamicPersonGroup.FromResponse(response), response);
        }

        /// <summary> Retrieve the information of a Dynamic Person Group, including its name and userData. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> This API returns Dynamic Person Group information only, use Person Directory "Get Dynamic Person Group Persons" instead to retrieve person information under the Dynamic Person Group. </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroup(string,CancellationToken)']/*" />
        public virtual Response<DynamicPersonGroup> GetDynamicPersonGroup(string dynamicPersonGroupId, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroup(dynamicPersonGroupId, context);
            return Response.FromValue(DynamicPersonGroup.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a Dynamic Person Group, including its name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupAsync(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupAsync(string,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupAsync(string dynamicPersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Retrieve the information of a Dynamic Person Group, including its name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroup(string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroup(string,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroup(string dynamicPersonGroupId, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='UpdateDynamicPersonGroupAsync(string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Response> UpdateDynamicPersonGroupAsync(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.UpdateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='UpdateDynamicPersonGroup(string,RequestContent,RequestContext)']/*" />
        public virtual Response UpdateDynamicPersonGroup(string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.UpdateDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupRequest(dynamicPersonGroupId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Dynamic Person Groups are stored in alphabetical order of dynamicPersonGroupId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupsAsync(string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<IReadOnlyList<DynamicPersonGroup>>> GetDynamicPersonGroupsAsync(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupsAsync(start, top, context).ConfigureAwait(false);
            IReadOnlyList<DynamicPersonGroup> value = default;
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            List<DynamicPersonGroup> array = new List<DynamicPersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(DynamicPersonGroup.DeserializeDynamicPersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary> List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData. </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// Dynamic Person Groups are stored in alphabetical order of dynamicPersonGroupId.
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroups(string,int?,CancellationToken)']/*" />
        public virtual Response<IReadOnlyList<DynamicPersonGroup>> GetDynamicPersonGroups(string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroups(start, top, context);
            IReadOnlyList<DynamicPersonGroup> value = default;
            using var document = JsonDocument.Parse(response.ContentStream);
            List<DynamicPersonGroup> array = new List<DynamicPersonGroup>();
            foreach (var item in document.RootElement.EnumerateArray())
            {
                array.Add(DynamicPersonGroup.DeserializeDynamicPersonGroup(item));
            }
            value = array;
            return Response.FromValue(value, response);
        }

        /// <summary>
        /// [Protocol Method] List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupsAsync(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupsAsync(string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupsAsync(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetDynamicPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupsRequest(start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all existing Dynamic Person Groups by dynamicPersonGroupId along with name and userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroups(string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroups(string,int?,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroups(string start, int? top, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetDynamicPersonGroups");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupsRequest(start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> List all persons in the specified Dynamic Person Group. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersonsAsync(string,string,int?,CancellationToken)']/*" />
        public virtual async Task<Response<ListPersonResult>> GetDynamicPersonGroupPersonsAsync(string dynamicPersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetDynamicPersonGroupPersonsAsync(dynamicPersonGroupId, start, top, context).ConfigureAwait(false);
            return Response.FromValue(ListPersonResult.FromResponse(response), response);
        }

        /// <summary> List all persons in the specified Dynamic Person Group. </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Persons are stored in alphabetical order of personId created in Person Directory "Create Person".
        /// &gt;
        /// *
        ///   * "start" parameter (string, optional) specifies an ID value from which returned entries will have larger IDs based on string comparison. Setting "start" to an empty value indicates that entries should be returned starting from the first item.
        ///   * "top" parameter (int, optional) determines the maximum number of entries to be returned, with a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit, specify "start" with the personId of the last entry returned in the current call.
        ///
        /// &gt; [!TIP]
        /// &gt;
        /// &gt; * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".
        /// &gt;   * "start=&amp;top=" will return all 5 items.
        /// &gt;   * "start=&amp;top=2" will return "itemId1", "itemId2".
        /// &gt;   * "start=itemId2&amp;top=3" will return "itemId3", "itemId4", "itemId5".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersons(string,string,int?,CancellationToken)']/*" />
        public virtual Response<ListPersonResult> GetDynamicPersonGroupPersons(string dynamicPersonGroupId, string start = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetDynamicPersonGroupPersons(dynamicPersonGroupId, start, top, context);
            return Response.FromValue(ListPersonResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] List all persons in the specified Dynamic Person Group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupPersonsAsync(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersonsAsync(string,string,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetDynamicPersonGroupPersonsAsync(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetDynamicPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupPersonsRequest(dynamicPersonGroupId, start, top, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] List all persons in the specified Dynamic Person Group.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetDynamicPersonGroupPersons(string,string,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="start"> List resources greater than the "start". It contains no more than 64 characters. Default is empty. </param>
        /// <param name="top"> The number of items to list, ranging in [1, 1000]. Default is 1000. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='GetDynamicPersonGroupPersons(string,string,int?,RequestContext)']/*" />
        public virtual Response GetDynamicPersonGroupPersons(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.GetDynamicPersonGroupPersons");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDynamicPersonGroupPersonsRequest(dynamicPersonGroupId, start, top, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person Face". </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="userDefinedFields"> The <see cref="UserDefinedFields"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userDefinedFields"/> is null. </exception>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreatePersonAsync(WaitUntil,UserDefinedFields,CancellationToken)']/*" />
        public virtual async Task<Operation<PersonDirectoryPerson>> CreatePersonAsync(WaitUntil waitUntil, UserDefinedFields userDefinedFields, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(userDefinedFields, nameof(userDefinedFields));

            using RequestContent content = userDefinedFields.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = await CreatePersonAsync(waitUntil, content, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryPerson.FromResponse, ClientDiagnostics, "PersonDirectory.CreatePerson");
        }

        /// <summary> Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person Face". </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="userDefinedFields"> The <see cref="UserDefinedFields"/> to use. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="userDefinedFields"/> is null. </exception>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreatePerson(WaitUntil,UserDefinedFields,CancellationToken)']/*" />
        public virtual Operation<PersonDirectoryPerson> CreatePerson(WaitUntil waitUntil, UserDefinedFields userDefinedFields, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(userDefinedFields, nameof(userDefinedFields));

            using RequestContent content = userDefinedFields.ToRequestContent();
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = CreatePerson(waitUntil, content, context);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryPerson.FromResponse, ClientDiagnostics, "PersonDirectory.CreatePerson");
        }

        /// <summary>
        /// [Protocol Method] Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person Face".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePersonAsync(WaitUntil,UserDefinedFields,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreatePersonAsync(WaitUntil,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CreatePersonAsync(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.CreatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonRequest(content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "PersonDirectory.CreatePerson", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a new person in a Person Directory. To add face to this person, please call Person Directory "Add Person Face".
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreatePerson(WaitUntil,UserDefinedFields,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreatePerson(WaitUntil,RequestContent,RequestContext)']/*" />
        public virtual Operation<BinaryData> CreatePerson(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.CreatePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreatePersonRequest(content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "PersonDirectory.CreatePerson", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='DeletePersonAsync(WaitUntil,Guid,RequestContext)']/*" />
        public virtual async Task<Operation> DeletePersonAsync(WaitUntil waitUntil, Guid personId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.DeletePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonRequest(personId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "PersonDirectory.DeletePerson", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Delete an existing person from Person Directory. The persistedFaceId(s), userData, person name and face feature(s) in the person entry will all be deleted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='DeletePerson(WaitUntil,Guid,RequestContext)']/*" />
        public virtual Operation DeletePerson(WaitUntil waitUntil, Guid personId, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.DeletePerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeletePersonRequest(personId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "PersonDirectory.DeletePerson", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person (see Person Directory "Create Person") for face identification or verification. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uri"/> is null. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// *
        ///   * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        ///   * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to "Identify". For further information about Operation-Locations see "Get Face Operation Status".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='AddFaceFromUrlAsync(WaitUntil,Guid,FaceRecognitionModel,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Operation<PersonDirectoryFace>> AddFaceFromUrlAsync(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(uri, nameof(uri));

            AddFaceFromUrlRequest addFaceFromUrlRequest = new AddFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = await AddFaceFromUrlAsync(waitUntil, personId, recognitionModel.ToString(), addFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryFace.FromResponse, ClientDiagnostics, "PersonDirectory.AddFaceFromUrl");
        }

        /// <summary> Add a face to a person (see Person Directory "Create Person") for face identification or verification. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="uri"> URL of input image. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="uri"/> is null. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// *
        ///   * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        ///   * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to "Identify". For further information about Operation-Locations see "Get Face Operation Status".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='AddFaceFromUrl(WaitUntil,Guid,FaceRecognitionModel,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Operation<PersonDirectoryFace> AddFaceFromUrl(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, Uri uri, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(uri, nameof(uri));

            AddFaceFromUrlRequest addFaceFromUrlRequest = new AddFaceFromUrlRequest(uri, null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = AddFaceFromUrl(waitUntil, personId, recognitionModel.ToString(), addFaceFromUrlRequest.ToRequestContent(), targetFace, detectionModel?.ToString(), userData, context);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryFace.FromResponse, ClientDiagnostics, "PersonDirectory.AddFaceFromUrl");
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see Person Directory "Create Person") for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromUrlAsync(WaitUntil,Guid,FaceRecognitionModel,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='AddFaceFromUrlAsync(WaitUntil,Guid,string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> AddFaceFromUrlAsync(WaitUntil waitUntil, Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.AddFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromUrlRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "PersonDirectory.AddFaceFromUrl", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see Person Directory "Create Person") for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceFromUrl(WaitUntil,Guid,FaceRecognitionModel,Uri,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='AddFaceFromUrl(WaitUntil,Guid,string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Operation<BinaryData> AddFaceFromUrl(WaitUntil waitUntil, Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.AddFaceFromUrl");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceFromUrlRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "PersonDirectory.AddFaceFromUrl", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Add a face to a person (see Person Directory "Create Person") for face identification or verification. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="imageContent"/> is null. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// *
        ///   * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        ///   * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to "Identify". For further information about Operation-Locations see "Get Face Operation Status".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='AddFaceAsync(WaitUntil,Guid,FaceRecognitionModel,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual async Task<Operation<PersonDirectoryFace>> AddFaceAsync(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = await AddFaceAsync(waitUntil, personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryFace.FromResponse, ClientDiagnostics, "PersonDirectory.AddFace");
        }

        /// <summary> Add a face to a person (see Person Directory "Create Person") for face identification or verification. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="imageContent"> The image to be analyzed. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="imageContent"/> is null. </exception>
        /// <remarks>
        /// To deal with an image containing multiple faces, input face can be specified as an image with a targetFace rectangle. It returns a persistedFaceId representing the added face. No image will be stored. Only the extracted face feature(s) will be stored on server until Person Directory "Delete Person Face" or "Delete Person" is called.
        ///
        /// Note that persistedFaceId is different from faceId generated by "Detect".
        /// &gt;
        /// *
        ///   * Higher face image quality means better recognition precision. Please consider high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        ///   * Each person entry can hold up to 248 faces.
        ///   * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size is from 1KB to 6MB.
        ///   * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an error. If the provided "targetFace" rectangle is not returned from "Detect", there's no guarantee to detect and add the face successfully.
        ///   * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions will cause failures.
        ///   * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels. Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum face size.
        ///   * Different 'detectionModel' values can be provided. To use and compare different detection models, please refer to https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model
        /// *
        ///   * Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel.
        ///   * This is a long running operation. Use Response Header "Operation-Location" to determine when the AddFace operation has successfully propagated for future requests to "Identify". For further information about Operation-Locations see "Get Face Operation Status".
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='AddFace(WaitUntil,Guid,FaceRecognitionModel,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)']/*" />
        public virtual Operation<PersonDirectoryFace> AddFace(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, BinaryData imageContent, IEnumerable<int> targetFace = null, FaceDetectionModel? detectionModel = null, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(imageContent, nameof(imageContent));

            using RequestContent content = imageContent;
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = AddFace(waitUntil, personId, recognitionModel.ToString(), content, targetFace, detectionModel?.ToString(), userData, context);
            return ProtocolOperationHelpers.Convert(response, PersonDirectoryFace.FromResponse, ClientDiagnostics, "PersonDirectory.AddFace");
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see Person Directory "Create Person") for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFaceAsync(WaitUntil,Guid,FaceRecognitionModel,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='AddFaceAsync(WaitUntil,Guid,string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> AddFaceAsync(WaitUntil waitUntil, Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.AddFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "PersonDirectory.AddFace", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Add a face to a person (see Person Directory "Create Person") for face identification or verification.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="AddFace(WaitUntil,Guid,FaceRecognitionModel,BinaryData,IEnumerable{int},FaceDetectionModel?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="targetFace"> A face rectangle to specify the target face to be added to a person, in the format of 'targetFace=left,top,width,height'. </param>
        /// <param name="detectionModel"> The 'detectionModel' associated with the detected faceIds. Supported 'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default value is 'detection_01'. Allowed values: "detection_01" | "detection_02" | "detection_03". </param>
        /// <param name="userData"> User-provided data attached to the face. The size limit is 1K. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='AddFace(WaitUntil,Guid,string,RequestContent,IEnumerable{int},string,string,RequestContext)']/*" />
        public virtual Operation<BinaryData> AddFace(WaitUntil waitUntil, Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace = null, string detectionModel = null, string userData = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.AddFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddFaceRequest(personId, recognitionModel, content, targetFace, detectionModel, userData, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "PersonDirectory.AddFace", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Delete a face from a person in Person Directory by specified personId and persistedFaceId. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='DeleteFaceAsync(WaitUntil,Guid,FaceRecognitionModel,Guid,CancellationToken)']/*" />
        public virtual async Task<Operation> DeleteFaceAsync(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            return await DeleteFaceAsync(waitUntil, personId, recognitionModel.ToString(), persistedFaceId, context).ConfigureAwait(false);
        }

        /// <summary> Delete a face from a person in Person Directory by specified personId and persistedFaceId. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks> Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting faces to/from different persons are processed in parallel. </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='DeleteFace(WaitUntil,Guid,FaceRecognitionModel,Guid,CancellationToken)']/*" />
        public virtual Operation DeleteFace(WaitUntil waitUntil, Guid personId, FaceRecognitionModel recognitionModel, Guid persistedFaceId, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            return DeleteFace(waitUntil, personId, recognitionModel.ToString(), persistedFaceId, context);
        }

        /// <summary>
        /// [Protocol Method] Delete a face from a person in Person Directory by specified personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteFaceAsync(WaitUntil,Guid,FaceRecognitionModel,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='DeleteFaceAsync(WaitUntil,Guid,string,Guid,RequestContext)']/*" />
        public virtual async Task<Operation> DeleteFaceAsync(WaitUntil waitUntil, Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.DeleteFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "PersonDirectory.DeleteFace", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Delete a face from a person in Person Directory by specified personId and persistedFaceId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteFace(WaitUntil,Guid,FaceRecognitionModel,Guid,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="personId"> Person ID of the person. </param>
        /// <param name="recognitionModel"> The 'recognitionModel' associated with faces. Allowed values: "recognition_01" | "recognition_02" | "recognition_03" | "recognition_04". </param>
        /// <param name="persistedFaceId"> Face ID of the face. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="recognitionModel"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="recognitionModel"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='DeleteFace(WaitUntil,Guid,string,Guid,RequestContext)']/*" />
        public virtual Operation DeleteFace(WaitUntil waitUntil, Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(recognitionModel, nameof(recognitionModel));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.DeleteFace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteFaceRequest(personId, recognitionModel, persistedFaceId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "PersonDirectory.DeleteFace", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="addPersonIds"> Array of personIds created by Person Directory "Create Person" to be added. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/>, <paramref name="name"/> or <paramref name="addPersonIds"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
        ///
        /// Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group" is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until Person Directory "Delete Person" or "Delete Person Face" is called.
        ///
        /// 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided during "Identify" determine the 'recognitionModel' used.
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreateDynamicPersonGroupWithPersonAsync(WaitUntil,string,string,IEnumerable{Guid},string,CancellationToken)']/*" />
        public virtual async Task<Operation<DynamicPersonGroup>> CreateDynamicPersonGroupWithPersonAsync(WaitUntil waitUntil, string dynamicPersonGroupId, string name, IEnumerable<Guid> addPersonIds, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(addPersonIds, nameof(addPersonIds));

            CreateDynamicPersonGroupWithPersonRequest createDynamicPersonGroupWithPersonRequest = new CreateDynamicPersonGroupWithPersonRequest(name, userData, addPersonIds.ToList(), null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = await CreateDynamicPersonGroupWithPersonAsync(waitUntil, dynamicPersonGroupId, createDynamicPersonGroupWithPersonRequest.ToRequestContent(), context).ConfigureAwait(false);
            return ProtocolOperationHelpers.Convert(response, DynamicPersonGroup.FromResponse, ClientDiagnostics, "PersonDirectory.CreateDynamicPersonGroupWithPerson");
        }

        /// <summary> Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="name"> User defined name, maximum length is 128. </param>
        /// <param name="addPersonIds"> Array of personIds created by Person Directory "Create Person" to be added. </param>
        /// <param name="userData"> Optional user defined data. Length should not exceed 16K. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/>, <paramref name="name"/> or <paramref name="addPersonIds"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// A Dynamic Person Group is a container that references Person Directory "Create Person". After creation, use Person Directory "Update Dynamic Person Group" to add/remove persons to/from the Dynamic Person Group.
        ///
        /// Dynamic Person Group and user data will be stored on server until Person Directory "Delete Dynamic Person Group" is called. Use "Identify From Dynamic Person Group" with the dynamicPersonGroupId parameter to identify against persons.
        ///
        /// No image will be stored. Only the person's extracted face feature(s) and userData will be stored on server until Person Directory "Delete Person" or "Delete Person Face" is called.
        ///
        /// 'recognitionModel' does not need to be specified with Dynamic Person Groups. Dynamic Person Groups are references to Person Directory "Create Person" and therefore work with most all 'recognitionModels'. The faceId's provided during "Identify" determine the 'recognitionModel' used.
        /// </remarks>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreateDynamicPersonGroupWithPerson(WaitUntil,string,string,IEnumerable{Guid},string,CancellationToken)']/*" />
        public virtual Operation<DynamicPersonGroup> CreateDynamicPersonGroupWithPerson(WaitUntil waitUntil, string dynamicPersonGroupId, string name, IEnumerable<Guid> addPersonIds, string userData = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(name, nameof(name));
            Argument.AssertNotNull(addPersonIds, nameof(addPersonIds));

            CreateDynamicPersonGroupWithPersonRequest createDynamicPersonGroupWithPersonRequest = new CreateDynamicPersonGroupWithPersonRequest(name, userData, addPersonIds.ToList(), null);
            RequestContext context = FromCancellationToken(cancellationToken);
            Operation<BinaryData> response = CreateDynamicPersonGroupWithPerson(waitUntil, dynamicPersonGroupId, createDynamicPersonGroupWithPersonRequest.ToRequestContent(), context);
            return ProtocolOperationHelpers.Convert(response, DynamicPersonGroup.FromResponse, ClientDiagnostics, "PersonDirectory.CreateDynamicPersonGroupWithPerson");
        }

        /// <summary>
        /// [Protocol Method] Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroupWithPersonAsync(WaitUntil,string,string,IEnumerable{Guid},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreateDynamicPersonGroupWithPersonAsync(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> CreateDynamicPersonGroupWithPersonAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.CreateDynamicPersonGroupWithPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupWithPersonRequest(dynamicPersonGroupId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "PersonDirectory.CreateDynamicPersonGroupWithPerson", OperationFinalStateVia.OriginalUri, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a new Dynamic Person Group with specified dynamicPersonGroupId, name, and user-provided userData.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateDynamicPersonGroupWithPerson(WaitUntil,string,string,IEnumerable{Guid},string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='CreateDynamicPersonGroupWithPerson(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual Operation<BinaryData> CreateDynamicPersonGroupWithPerson(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.CreateDynamicPersonGroupWithPerson");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateDynamicPersonGroupWithPersonRequest(dynamicPersonGroupId, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "PersonDirectory.CreateDynamicPersonGroupWithPerson", OperationFinalStateVia.OriginalUri, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='DeleteDynamicPersonGroupAsync(WaitUntil,string,RequestContext)']/*" />
        public virtual async Task<Operation> DeleteDynamicPersonGroupAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.DeleteDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "PersonDirectory.DeleteDynamicPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes an existing Dynamic Person Group with specified dynamicPersonGroupId.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='DeleteDynamicPersonGroup(WaitUntil,string,RequestContext)']/*" />
        public virtual Operation DeleteDynamicPersonGroup(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.DeleteDynamicPersonGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDynamicPersonGroupRequest(dynamicPersonGroupId, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "PersonDirectory.DeleteDynamicPersonGroup", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='UpdateDynamicPersonGroupWithPersonChangesAsync(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation> UpdateDynamicPersonGroupWithPersonChangesAsync(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.UpdateDynamicPersonGroupWithPersonChanges");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupWithPersonChangesRequest(dynamicPersonGroupId, content, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "PersonDirectory.UpdateDynamicPersonGroupWithPersonChanges", OperationFinalStateVia.OperationLocation, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Update the name or userData of an existing Dynamic Person Group, and manage its members by adding or removing persons.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="dynamicPersonGroupId"> ID of the dynamic person group. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="dynamicPersonGroupId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="dynamicPersonGroupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/PersonDirectory.xml" path="doc/members/member[@name='UpdateDynamicPersonGroupWithPersonChanges(WaitUntil,string,RequestContent,RequestContext)']/*" />
        public virtual Operation UpdateDynamicPersonGroupWithPersonChanges(WaitUntil waitUntil, string dynamicPersonGroupId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(dynamicPersonGroupId, nameof(dynamicPersonGroupId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PersonDirectory.UpdateDynamicPersonGroupWithPersonChanges");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDynamicPersonGroupWithPersonChangesRequest(dynamicPersonGroupId, content, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "PersonDirectory.UpdateDynamicPersonGroupWithPersonChanges", OperationFinalStateVia.OperationLocation, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreatePersonRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeletePersonRequest(Guid personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPersonRequest(Guid personId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdatePersonRequest(Guid personId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPersonsRequest(string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupReferencesRequest(Guid personId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/dynamicPersonGroupReferences", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddFaceFromUrlRequest(Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateAddFaceRequest(Guid personId, string recognitionModel, RequestContent content, IEnumerable<int> targetFace, string detectionModel, string userData, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            if (targetFace != null && !(targetFace is ChangeTrackingList<int> changeTrackingList && changeTrackingList.IsUndefined))
            {
                uri.AppendQueryDelimited("targetFace", targetFace, ",", true);
            }
            if (detectionModel != null)
            {
                uri.AppendQuery("detectionModel", detectionModel, true);
            }
            if (userData != null)
            {
                uri.AppendQuery("userData", userData, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("content-type", "application/octet-stream");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteFaceRequest(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetFaceRequest(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateFaceRequest(Guid personId, string recognitionModel, Guid persistedFaceId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces/", false);
            uri.AppendPath(persistedFaceId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetFacesRequest(Guid personId, string recognitionModel, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/persons/", false);
            uri.AppendPath(personId, true);
            uri.AppendPath("/recognitionModels/", false);
            uri.AppendPath(recognitionModel, true);
            uri.AppendPath("/persistedfaces", false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateDynamicPersonGroupWithPersonRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateDynamicPersonGroupWithPersonChangesRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateDynamicPersonGroupRequest(string dynamicPersonGroupId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupsRequest(string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDynamicPersonGroupPersonsRequest(string dynamicPersonGroupId, string start, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRaw("/face/", false);
            uri.AppendRaw(_apiVersion, true);
            uri.AppendPath("/dynamicpersongroups/", false);
            uri.AppendPath(dynamicPersonGroupId, true);
            uri.AppendPath("/persons", false);
            if (start != null)
            {
                uri.AppendQuery("start", start, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
