// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using System.Collections.Generic;
using System.Linq;
using Microsoft.Azure.Management.Sql.Models;
using Microsoft.Azure.Management.ResourceManager;
using Microsoft.Azure.Management.ResourceManager.Models;
using Microsoft.Azure.Management.Sql;
using Xunit;
using System;
using Microsoft.Rest.Azure;
using System.Threading.Tasks;
using Microsoft.Azure.Management.Storage;
using Microsoft.Azure.Management.Storage.Models;
using Microsoft.WindowsAzure.Storage.Blob;
using Microsoft.Azure.Test.HttpRecorder;
using Microsoft.WindowsAzure.Storage;

namespace Sql.Tests
{
    public class DatabaseVulnerabilityAssessmentScenarioTests
    {
        [Fact]
        public async void TestCreateUpdateGetDatabaseVulnerabilityAssessments()
        {
            string testPrefix = "sqlvulnerabilityassessmentcrudtest-";
            using (SqlManagementTestContext context = new SqlManagementTestContext(this))
            {
                ResourceGroup resourceGroup = context.CreateResourceGroup();
                SqlManagementClient sqlClient = context.GetClient<SqlManagementClient>();
                Server server = context.CreateServer(resourceGroup);

                // Create database
                //
                string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
                var db1 = sqlClient.Databases.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, new Database()
                {
                    Location = server.Location,
                });
                Assert.NotNull(db1);

                // Turn ON database threat detection as a prerequisite to use VA
                DatabaseSecurityAlertPolicy updatedDatabasePolicy = new DatabaseSecurityAlertPolicy
                {
                    State = SecurityAlertPolicyState.Enabled,
                    EmailAccountAdmins = SecurityAlertPolicyEmailAccountAdmins.Enabled
                };
                sqlClient.DatabaseThreatDetectionPolicies.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, updatedDatabasePolicy);

                // Verify Policy is empty to begin with
                DatabaseVulnerabilityAssessment policyThatWasReceived = sqlClient.DatabaseVulnerabilityAssessments.Get(resourceGroup.Name, server.Name, dbName);
                Assert.Null(policyThatWasReceived.StorageContainerPath);
                Assert.Null(policyThatWasReceived.StorageContainerSasKey);
                Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);

                // Set policy and then get policy and verify correctness
                DatabaseVulnerabilityAssessment policyThatWasSet = await SetPolicy(context, sqlClient, resourceGroup, server, dbName);

                policyThatWasReceived = sqlClient.DatabaseVulnerabilityAssessments.Get(resourceGroup.Name, server.Name, dbName);
                Assert.Equal(policyThatWasSet.StorageContainerPath, policyThatWasReceived.StorageContainerPath);
                Assert.Null(policyThatWasSet.StorageContainerSasKey);
                Assert.Equal(policyThatWasSet.RecurringScans.IsEnabled, policyThatWasReceived.RecurringScans.IsEnabled);
                SqlManagementTestUtilities.AssertCollection(policyThatWasSet.RecurringScans.Emails, policyThatWasReceived.RecurringScans.Emails);
                Assert.Equal(policyThatWasSet.RecurringScans.EmailSubscriptionAdmins, policyThatWasReceived.RecurringScans.EmailSubscriptionAdmins);

                // Delete policy and then get policy and verify correctness
                sqlClient.DatabaseVulnerabilityAssessments.Delete(resourceGroup.Name, server.Name, dbName);

                // Get policy after deletion
                policyThatWasReceived = sqlClient.DatabaseVulnerabilityAssessments.Get(resourceGroup.Name, server.Name, dbName);
                Assert.Null(policyThatWasReceived.StorageContainerPath);
                Assert.Null(policyThatWasReceived.StorageContainerSasKey);
                Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);
            };
        }

        [Fact]
        public async void TestCreateUpdateGetDeleteDatabaseVulnerabilityAssessmentBaselines()
        {
            using (SqlManagementTestContext context = new SqlManagementTestContext(this))
            {
                string testPrefix = "sqlvulnerabilityassessmentbaselinetest-";

                ResourceGroup resourceGroup = context.CreateResourceGroup();
                SqlManagementClient sqlClient = context.GetClient<SqlManagementClient>();
                Server server = context.CreateServer(resourceGroup);

                // Create database
                //
                string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
                var db1 = sqlClient.Databases.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, new Database()
                {
                    Location = server.Location,
                });
                Assert.NotNull(db1);

                // Turn ON database threat detection as a prerequisite to use VA
                DatabaseSecurityAlertPolicy updatedDatabasePolicy = new DatabaseSecurityAlertPolicy
                {
                    State = SecurityAlertPolicyState.Enabled,
                    EmailAccountAdmins = SecurityAlertPolicyEmailAccountAdmins.Enabled
                };
                sqlClient.DatabaseThreatDetectionPolicies.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, updatedDatabasePolicy);

                // Set policy
                await SetPolicy(context, sqlClient, resourceGroup, server, dbName);

                // Test baseline for database level rule
                ValidateBaselineRule(sqlClient, resourceGroup, server, dbName, isServerLevelRule: true);

                // Test baseline for server level rule
                ValidateBaselineRule(sqlClient, resourceGroup, server, dbName, isServerLevelRule: false);

                // Test baseline for database level rule - backward compatibility
                ValidateBaselineRule(sqlClient, resourceGroup, server, dbName, isServerLevelRule: null);
            }
        }

        [Fact]
        public async void TestExecuteGetListDatabaseVulnerabilityAssessmentScans()
        {
            using (SqlManagementTestContext context = new SqlManagementTestContext(this))
            {
                string testPrefix = "sqlvulnerabilityassessmentscantest-";

                ResourceGroup resourceGroup = context.CreateResourceGroup();
                SqlManagementClient sqlClient = context.GetClient<SqlManagementClient>();
                Server server = context.CreateServer(resourceGroup);

                // Create database
                //
                string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
                var db1 = sqlClient.Databases.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, new Database()
                {
                    Location = server.Location,
                });
                Assert.NotNull(db1);

                // Turn ON database threat detection as a prerequisite to use VA
                DatabaseSecurityAlertPolicy updatedDatabasePolicy = new DatabaseSecurityAlertPolicy
                {
                    State = SecurityAlertPolicyState.Enabled,
                    EmailAccountAdmins = SecurityAlertPolicyEmailAccountAdmins.Enabled
                };
                sqlClient.DatabaseThreatDetectionPolicies.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, updatedDatabasePolicy);

                // Set policy
                await SetPolicy(context, sqlClient, resourceGroup, server, dbName);

                // Run some scans
                string scanId = string.Format("scantest1_{0}", testPrefix);
                sqlClient.DatabaseVulnerabilityAssessmentScans.InitiateScan(resourceGroup.Name, server.Name, dbName, scanId);

                string scanId1 = string.Format("scantest2_{0}", testPrefix);
                sqlClient.DatabaseVulnerabilityAssessmentScans.InitiateScan(resourceGroup.Name, server.Name, dbName, scanId1);

                // Verify get scan and list scans
                VulnerabilityAssessmentScanRecord scanRecord = sqlClient.DatabaseVulnerabilityAssessmentScans.Get(resourceGroup.Name, server.Name, dbName, scanId);
                Assert.Equal(scanId, scanRecord.ScanId);

                IPage<VulnerabilityAssessmentScanRecord> scanRecords = sqlClient.DatabaseVulnerabilityAssessmentScans.ListByDatabase(resourceGroup.Name, server.Name, dbName);
                Assert.Equal(2, scanRecords.ToList().Count);
                Assert.Contains(scanRecords.ToList(), item => item.ScanId == scanId);
                Assert.Contains(scanRecords.ToList(), item => item.ScanId == scanId1);

                VulnerabilityAssessmentScanRecord scanId1Record = sqlClient.DatabaseVulnerabilityAssessmentScans.Get(resourceGroup.Name, server.Name, dbName, scanId1);
                VulnerabilityAssessmentScanRecord scanId1RecordFromList = scanRecords.FirstOrDefault(item => item.ScanId == scanId1);
                Assert.Equal(scanId1Record.ScanId, scanId1RecordFromList.ScanId);
                Assert.Equal(scanId1Record.TriggerType, scanId1RecordFromList.TriggerType);
                Assert.Equal(scanId1Record.State, scanId1RecordFromList.State);
                Assert.Equal(scanId1Record.StartTime, scanId1RecordFromList.StartTime);
                Assert.Equal(scanId1Record.EndTime, scanId1RecordFromList.EndTime);
                Assert.Equal(scanId1Record.Errors, scanId1RecordFromList.Errors);
                Assert.Equal(scanId1Record.StorageContainerPath, scanId1RecordFromList.StorageContainerPath);
                Assert.Equal(scanId1Record.NumberOfFailedSecurityChecks, scanId1RecordFromList.NumberOfFailedSecurityChecks);
            }
        }

        [Fact]
        public async void TestExportDatabaseVulnerabilityAssessmentScans()
        {
            using (SqlManagementTestContext context = new SqlManagementTestContext(this))
            {
                string testPrefix = "sqlvulnerabilityassessmentexportscantest-";

                ResourceGroup resourceGroup = context.CreateResourceGroup();
                SqlManagementClient sqlClient = context.GetClient<SqlManagementClient>();
                Server server = context.CreateServer(resourceGroup);

                // Create database
                //
                string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
                var db1 = sqlClient.Databases.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, new Database()
                {
                    Location = server.Location,
                });
                Assert.NotNull(db1);

                // Turn ON database threat detection as a prerequisite to use VA
                DatabaseSecurityAlertPolicy updatedDatabasePolicy = new DatabaseSecurityAlertPolicy
                {
                    State = SecurityAlertPolicyState.Enabled,
                    EmailAccountAdmins = SecurityAlertPolicyEmailAccountAdmins.Enabled
                };
                sqlClient.DatabaseThreatDetectionPolicies.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, updatedDatabasePolicy);

                // Set policy
                await SetPolicy(context, sqlClient, resourceGroup, server, dbName);

                // Run some scans
                string scanId = string.Format("scan1_{0}", testPrefix);
                sqlClient.DatabaseVulnerabilityAssessmentScans.InitiateScan(resourceGroup.Name, server.Name, dbName, scanId);
                sqlClient.DatabaseVulnerabilityAssessmentScans.Export(resourceGroup.Name, server.Name, dbName, scanId);
            }
        }

        private async Task<DatabaseVulnerabilityAssessment> SetPolicy(SqlManagementTestContext context, SqlManagementClient sqlClient, ResourceGroup resourceGroup,
            Server server, string dbName)
        {
            StorageContainerInfo StorageContainerInfo = await CreateStorageContainer(context, resourceGroup);
            DatabaseVulnerabilityAssessment policy = new DatabaseVulnerabilityAssessment()
            {
                StorageContainerPath = StorageContainerInfo.StorageContainerPath.ToString(),
                StorageContainerSasKey = StorageContainerInfo.StorageAccountSasKey,
                RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                {
                    IsEnabled = false,
                    Emails = new List<string>() { "fakemail1@mail.com", "fakemail2@mail.com" },
                    EmailSubscriptionAdmins = true
                }
            };

            return sqlClient.DatabaseVulnerabilityAssessments.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, policy);
        }

        private struct StorageContainerInfo
        {
            public string StorageAccountSasKey;
            public Uri StorageContainerPath;
        }

        private async Task<StorageContainerInfo> CreateStorageContainer(SqlManagementTestContext context, ResourceGroup resourceGroup)
        {
            StorageManagementClient storageClient = context.GetClient<StorageManagementClient>();
            StorageAccount storageAccount = await storageClient.StorageAccounts.CreateAsync(
                resourceGroup.Name,
                accountName: SqlManagementTestUtilities.GenerateName(prefix: "sqlvatest"),
                parameters: new StorageAccountCreateParameters(
                    new Microsoft.Azure.Management.Storage.Models.Sku(SkuName.StandardLRS, SkuTier.Standard),
                    Kind.BlobStorage,
                    resourceGroup.Location,
                    accessTier: AccessTier.Cool));

            StorageAccountListKeysResult keys =
                storageClient.StorageAccounts.ListKeys(resourceGroup.Name, storageAccount.Name);
            string key = keys.Keys.First().Value;

            string containerName = "vulnerability-assessment";
            var sasToken = string.Empty;

            // Create container
            // Since this is a data-plane client and not an ARM client it's harder to inject
            // HttpMockServer into it to record/playback, but that's fine because we don't need
            // any of the response data to continue with the test.
            if (HttpMockServer.Mode == HttpRecorderMode.Record)
            {
                CloudStorageAccount storageAccountClient = new CloudStorageAccount(
                    new Microsoft.WindowsAzure.Storage.Auth.StorageCredentials(
                        storageAccount.Name,
                        key),
                    useHttps: true);
                CloudBlobClient blobClient = storageAccountClient.CreateCloudBlobClient();
                CloudBlobContainer containerReference = blobClient.GetContainerReference(containerName);
                await containerReference.CreateIfNotExistsAsync();

                SharedAccessBlobPolicy sharedAccessPolicy = new SharedAccessBlobPolicy
                {
                    SharedAccessExpiryTime = new DateTimeOffset(DateTime.UtcNow.Add(TimeSpan.FromHours(1))),
                    Permissions = SharedAccessBlobPermissions.Write | SharedAccessBlobPermissions.Read | SharedAccessBlobPermissions.List
                };

                // Generate the SAS Token
                sasToken = containerReference.GetSharedAccessSignature(sharedAccessPolicy);
            }

            return new StorageContainerInfo
            {
                StorageAccountSasKey = sasToken,
                StorageContainerPath = new Uri(storageAccount.PrimaryEndpoints.Blob + containerName)
            };
        }

        private void ValidateBaselineRule(SqlManagementClient sqlClient, ResourceGroup resourceGroup, Server server, string dbName, bool? isServerLevelRule)
        {
            string testRuleId = "VA2031";
            var ruleBaselineToSet = new DatabaseVulnerabilityAssessmentRuleBaseline(
                    new List<DatabaseVulnerabilityAssessmentRuleBaselineItem>()
                    {
                            new DatabaseVulnerabilityAssessmentRuleBaselineItem()
                            {
                                Result = new string[] { "userA", "SELECT" }
                            },
                            new DatabaseVulnerabilityAssessmentRuleBaselineItem()
                            {
                                Result = new string[] { "userB", "SELECT" }
                            }
                    });

            VulnerabilityAssessmentPolicyBaselineName baselineName = isServerLevelRule.HasValue && isServerLevelRule.Value
                ? VulnerabilityAssessmentPolicyBaselineName.Master
                : VulnerabilityAssessmentPolicyBaselineName.Default;

            if (isServerLevelRule.HasValue)
            {
                sqlClient.DatabaseVulnerabilityAssessmentRuleBaselines.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, testRuleId, baselineName, ruleBaselineToSet);
            }
            else
            {
                sqlClient.DatabaseVulnerabilityAssessmentRuleBaselines.CreateOrUpdate(resourceGroup.Name, server.Name, dbName, testRuleId, ruleBaselineToSet);
            }

            // Get baseline
            DatabaseVulnerabilityAssessmentRuleBaseline actualBaseline = isServerLevelRule.HasValue
                ? sqlClient.DatabaseVulnerabilityAssessmentRuleBaselines.Get(resourceGroup.Name, server.Name, dbName, testRuleId, baselineName)
                : sqlClient.DatabaseVulnerabilityAssessmentRuleBaselines.Get(resourceGroup.Name, server.Name, dbName, testRuleId);

            Assert.Equal(ruleBaselineToSet.BaselineResults.Count(), actualBaseline.BaselineResults.Count());
            SqlManagementTestUtilities.AssertCollection(ruleBaselineToSet.BaselineResults[0].Result, actualBaseline.BaselineResults[0].Result);
            SqlManagementTestUtilities.AssertCollection(ruleBaselineToSet.BaselineResults[1].Result, actualBaseline.BaselineResults[1].Result);

            // Delete baseline
            if (isServerLevelRule.HasValue)
            {
                sqlClient.DatabaseVulnerabilityAssessmentRuleBaselines.Delete(resourceGroup.Name, server.Name, dbName, testRuleId, baselineName);
            }
            else
            {
                sqlClient.DatabaseVulnerabilityAssessmentRuleBaselines.Delete(resourceGroup.Name, server.Name, dbName, testRuleId);
            }

            // Get baseline should fail after deleting the baseline
            Assert.Throws<CloudException>(() =>
            {
                if (isServerLevelRule.HasValue)
                {
                    sqlClient.DatabaseVulnerabilityAssessmentRuleBaselines.Get(resourceGroup.Name, server.Name, dbName, testRuleId, baselineName);
                }
                else
                {
                    sqlClient.DatabaseVulnerabilityAssessmentRuleBaselines.Get(resourceGroup.Name, server.Name, dbName, testRuleId);
                }
            });
        }
    }
}
