// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using System.Collections.Generic;
using Microsoft.Azure.Management.Sql.Models;
using Microsoft.Azure.Management.ResourceManager;
using Microsoft.Azure.Management.ResourceManager.Models;
using Microsoft.Azure.Management.Sql;
using Xunit;
using System.Threading.Tasks;
using Microsoft.Azure.Management.Storage;

namespace Sql.Tests
{
    public class ServerVulnerabilityAssessmentScenarioTests
    {
        [Fact]
        public async void TestCreateUpdateGetServerVulnerabilityAssessments()
        {
            using (SqlManagementTestContext context = new SqlManagementTestContext(this))
            {
                ResourceGroup resourceGroup = context.CreateResourceGroup();
                SqlManagementClient sqlClient = context.GetClient<SqlManagementClient>();
                Server server = context.CreateServer(resourceGroup);

                // Turn ON Server ATP(threat detection) as a prerequisite to use VA
                ServerSecurityAlertPolicy updatedServerPolicy = new ServerSecurityAlertPolicy
                {
                    State = SecurityAlertPolicyState.Enabled,
                    EmailAccountAdmins = true
                };

                //Set security alert policy for server
                sqlClient.ServerSecurityAlertPolicies.CreateOrUpdate(resourceGroup.Name, server.Name, updatedServerPolicy);

                // Verify Policy is empty to begin with
                ServerVulnerabilityAssessment policyThatWasReceived = sqlClient.ServerVulnerabilityAssessments.Get(resourceGroup.Name, server.Name);
                Assert.Null(policyThatWasReceived.StorageContainerPath);
                Assert.Null(policyThatWasReceived.StorageAccountAccessKey);
                Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);

                // Set policy and then get policy and verify correctness
                ServerVulnerabilityAssessment policyThatWasSet = await SetPolicy(context, sqlClient, resourceGroup, server);

                policyThatWasReceived = sqlClient.ServerVulnerabilityAssessments.Get(resourceGroup.Name, server.Name);
                Assert.Equal(policyThatWasSet.StorageContainerPath, policyThatWasReceived.StorageContainerPath);
                Assert.Null(policyThatWasSet.StorageAccountAccessKey);
                Assert.Equal(policyThatWasSet.RecurringScans.IsEnabled, policyThatWasReceived.RecurringScans.IsEnabled);
                SqlManagementTestUtilities.AssertCollection(policyThatWasSet.RecurringScans.Emails, policyThatWasReceived.RecurringScans.Emails);
                Assert.Equal(policyThatWasSet.RecurringScans.EmailSubscriptionAdmins, policyThatWasReceived.RecurringScans.EmailSubscriptionAdmins);

                // Delete policy and then get policy and verify correctness
                sqlClient.ServerVulnerabilityAssessments.Delete(resourceGroup.Name, server.Name);

                // Get policy after deletion
                policyThatWasReceived = sqlClient.ServerVulnerabilityAssessments.Get(resourceGroup.Name, server.Name);
                Assert.Null(policyThatWasReceived.StorageContainerPath);
                Assert.Null(policyThatWasReceived.StorageAccountAccessKey);
                Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);
            };
        }

        private async Task<ServerVulnerabilityAssessment> SetPolicy(SqlManagementTestContext context, SqlManagementClient sqlClient, ResourceGroup resourceGroup,
            Server server)
        {
            VulnerabilityAssessmentTestUtilities.StorageContainerInfo StorageContainerInfo = await VulnerabilityAssessmentTestUtilities.CreateStorageContainer(context, resourceGroup);
            ServerVulnerabilityAssessment policy = new ServerVulnerabilityAssessment()
            {
                StorageContainerPath = StorageContainerInfo.StorageContainerPath.ToString(),
                StorageAccountAccessKey = StorageContainerInfo.StorageAccountAccessKey,
                RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                {
                    IsEnabled = false,
                    Emails = new List<string>() { "fakemail1@mail.com", "fakemail2@mail.com" },
                    EmailSubscriptionAdmins = true
                }
            };

            return sqlClient.ServerVulnerabilityAssessments.CreateOrUpdate(resourceGroup.Name, server.Name, policy);
        }
    }
}
