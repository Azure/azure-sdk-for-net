using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Azure.Management.ResourceManager.Models;
using Microsoft.Azure.Management.Sql;
using Microsoft.Azure.Management.Sql.Models;
using Microsoft.Azure.Management.Storage;
using Microsoft.Azure.Management.Storage.Models;
using Microsoft.Azure.Test.HttpRecorder;
using Microsoft.Rest.Azure;
using Microsoft.WindowsAzure.Storage;
using Microsoft.WindowsAzure.Storage.Blob;
using Xunit;

namespace Sql.Tests
{
    public class ManagedDatabaseVulnerabilityAssessmentScenarioTests
    {
        [Fact]
        public async void TestCreateUpdateGetDatabaseVulnerabilityAssessments()
        {
            using (SqlManagementTestContext context = new SqlManagementTestContext(this))
            {
                string testPrefix = "sqlvulnerabilityassessmentcrudtest-";

                SqlManagementClient sqlClient = context.GetClient<SqlManagementClient>();
                var resourceGroup = context.CreateResourceGroup();
                var managedInstance = context.CreateManagedInstance(resourceGroup);

                // Create managed database
                //
                string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
                var db1 = sqlClient.ManagedDatabases.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, dbName, new ManagedDatabase()
                {
                    Location = managedInstance.Location,
                });
                Assert.NotNull(db1);

                // Verify Policy is empty to begin with
                DatabaseVulnerabilityAssessment policyThatWasReceived = sqlClient.ManagedDatabaseVulnerabilityAssessments.Get(resourceGroup.Name, managedInstance.Name, dbName);
                Assert.Null(policyThatWasReceived.StorageContainerPath);
                Assert.Null(policyThatWasReceived.StorageContainerSasKey);
                Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);

                // Set policy and then get policy and verify correctness
                DatabaseVulnerabilityAssessment policyThatWasSet = await SetPolicy(context, sqlClient, resourceGroup, managedInstance, dbName);

                policyThatWasReceived = sqlClient.ManagedDatabaseVulnerabilityAssessments.Get(resourceGroup.Name, managedInstance.Name, dbName);
                Assert.Equal(policyThatWasSet.StorageContainerPath, policyThatWasReceived.StorageContainerPath);
                Assert.Null(policyThatWasSet.StorageContainerSasKey);
                Assert.Equal(policyThatWasSet.RecurringScans.IsEnabled, policyThatWasReceived.RecurringScans.IsEnabled);
                SqlManagementTestUtilities.AssertCollection(policyThatWasSet.RecurringScans.Emails, policyThatWasReceived.RecurringScans.Emails);
                Assert.Equal(policyThatWasSet.RecurringScans.EmailSubscriptionAdmins, policyThatWasReceived.RecurringScans.EmailSubscriptionAdmins);

                // Delete policy and then get policy and verify correctness
                sqlClient.ManagedDatabaseVulnerabilityAssessments.Delete(resourceGroup.Name, managedInstance.Name, dbName);

                // Get policy after deletion
                policyThatWasReceived = sqlClient.ManagedDatabaseVulnerabilityAssessments.Get(resourceGroup.Name, managedInstance.Name, dbName);
                Assert.Null(policyThatWasReceived.StorageContainerPath);
                Assert.Null(policyThatWasReceived.StorageContainerSasKey);
                Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);
            }
        }

        [Fact(Skip = "Rule 'VA2031' does not exist.")]
        public async void TestCreateUpdateGetDeleteDatabaseVulnerabilityAssessmentBaselines()
        {
            using (SqlManagementTestContext context = new SqlManagementTestContext(this))
            {
                string testPrefix = "sqlvulnerabilityassessmentbaselinetest-";

                SqlManagementClient sqlClient = context.GetClient<SqlManagementClient>();
                var resourceGroup = context.CreateResourceGroup();
                var managedInstance = context.CreateManagedInstance(resourceGroup);

                // Create managed database
                //
                string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
                var db1 = sqlClient.ManagedDatabases.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, dbName, new ManagedDatabase()
                {
                    Location = managedInstance.Location,
                });
                Assert.NotNull(db1);

                // Set policy
                await SetPolicy(context, sqlClient, resourceGroup, managedInstance, dbName);

                // Test baseline for database level rule
                ValidateBaselineRule(sqlClient, resourceGroup, managedInstance, dbName, isServerLevelRule: true);

                // Test baseline for server level rule
                ValidateBaselineRule(sqlClient, resourceGroup, managedInstance, dbName, isServerLevelRule: false);
            }
        }

        [Fact]
        public async void TestExecuteGetListDatabaseVulnerabilityAssessmentScans()
        {
            using (SqlManagementTestContext context = new SqlManagementTestContext(this))
            {
                string testPrefix = "sqlvulnerabilityassessmentscantest-";

                SqlManagementClient sqlClient = context.GetClient<SqlManagementClient>();
                var resourceGroup = context.CreateResourceGroup();
                var managedInstance = context.CreateManagedInstance(resourceGroup);

                // Create managed database
                //
                string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
                var db1 = sqlClient.ManagedDatabases.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, dbName, new ManagedDatabase()
                {
                    Location = managedInstance.Location,
                });
                Assert.NotNull(db1);

                // Set policy
                await SetPolicy(context, sqlClient, resourceGroup, managedInstance, dbName);

                // Run some scans
                string scanId = string.Format("scantest1_{0}", testPrefix);
                sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.InitiateScan(resourceGroup.Name, managedInstance.Name, dbName, scanId);

                string scanId1 = string.Format("scantest2_{0}", testPrefix);
                sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.InitiateScan(resourceGroup.Name, managedInstance.Name, dbName, scanId1);

                // Verify get scan and list scans
                VulnerabilityAssessmentScanRecord scanRecord = sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.Get(resourceGroup.Name, managedInstance.Name, dbName, scanId);
                Assert.Equal(scanId, scanRecord.ScanId);

                IPage<VulnerabilityAssessmentScanRecord> scanRecords = sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.ListByDatabase(resourceGroup.Name, managedInstance.Name, dbName);
                Assert.Equal(2, scanRecords.ToList().Count);
                Assert.Contains(scanRecords.ToList(), item => item.ScanId == scanId);
                Assert.Contains(scanRecords.ToList(), item => item.ScanId == scanId1);

                VulnerabilityAssessmentScanRecord scanId1Record = sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.Get(resourceGroup.Name, managedInstance.Name, dbName, scanId1);
                VulnerabilityAssessmentScanRecord scanId1RecordFromList = scanRecords.FirstOrDefault(item => item.ScanId == scanId1);
                Assert.Equal(scanId1Record.ScanId, scanId1RecordFromList.ScanId);
                Assert.Equal(scanId1Record.TriggerType, scanId1RecordFromList.TriggerType);
                Assert.Equal(scanId1Record.State, scanId1RecordFromList.State);
                Assert.Equal(scanId1Record.StartTime, scanId1RecordFromList.StartTime);
                Assert.Equal(scanId1Record.EndTime, scanId1RecordFromList.EndTime);
                Assert.Equal(scanId1Record.Errors, scanId1RecordFromList.Errors);
                Assert.Equal(scanId1Record.StorageContainerPath, scanId1RecordFromList.StorageContainerPath);
                Assert.Equal(scanId1Record.NumberOfFailedSecurityChecks, scanId1RecordFromList.NumberOfFailedSecurityChecks);
            }
        }

        [Fact]
        public async void TestExportDatabaseVulnerabilityAssessmentScans()
        {
            using (SqlManagementTestContext context = new SqlManagementTestContext(this))
            {
                string testPrefix = "sqlvulnerabilityassessmentexportscantest-";

                SqlManagementClient sqlClient = context.GetClient<SqlManagementClient>();
                var resourceGroup = context.CreateResourceGroup();
                var managedInstance = context.CreateManagedInstance(resourceGroup);

                // Create managed database
                //
                string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
                var db1 = sqlClient.ManagedDatabases.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, dbName, new ManagedDatabase()
                {
                    Location = managedInstance.Location,
                });
                Assert.NotNull(db1);

                // Set policy
                await SetPolicy(context, sqlClient, resourceGroup, managedInstance, dbName);

                // Run some scans
                string scanId = string.Format("scan1_{0}", testPrefix);
                sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.InitiateScan(resourceGroup.Name, managedInstance.Name, dbName, scanId);
                sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.Export(resourceGroup.Name, managedInstance.Name, dbName, scanId);
            }
        }

        private async Task<DatabaseVulnerabilityAssessment> SetPolicy(SqlManagementTestContext context, SqlManagementClient sqlClient, ResourceGroup resourceGroup,
            ManagedInstance managedInstance, string dbName)
        {
			// Modify the policy properties, send and receive and see it its still ok
			ManagedServerSecurityAlertPolicy updatedManagedServerPolicy = new ManagedServerSecurityAlertPolicy
			{
				State = SecurityAlertsPolicyState.Enabled,
				EmailAccountAdmins = true
			};

			//Set security alert policy for server
			sqlClient.ManagedServerSecurityAlertPolicies.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, updatedManagedServerPolicy);

			StorageContainerInfo StorageContainerInfo = await CreateStorageContainer(context, resourceGroup);
            DatabaseVulnerabilityAssessment policy = new DatabaseVulnerabilityAssessment()
            {
                StorageContainerPath = StorageContainerInfo.StorageContainerPath.ToString(),
                StorageContainerSasKey = StorageContainerInfo.StorageAccountSasKey,
                RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                {
                    IsEnabled = false,
                    Emails = new List<string>() { "fakemail1@mail.com", "fakemail2@mail.com" },
                    EmailSubscriptionAdmins = true
                }
            };

            return sqlClient.ManagedDatabaseVulnerabilityAssessments.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, dbName, policy);
        }

        private struct StorageContainerInfo
        {
            public string StorageAccountSasKey;
            public Uri StorageContainerPath;
        }

        private async Task<StorageContainerInfo> CreateStorageContainer(SqlManagementTestContext context, ResourceGroup resourceGroup)
        {
            StorageManagementClient storageClient = context.GetClient<StorageManagementClient>();
            StorageAccount storageAccount = await storageClient.StorageAccounts.CreateAsync(
                resourceGroup.Name,
                accountName: SqlManagementTestUtilities.GenerateName(prefix: "sqlvatest"),
                parameters: new StorageAccountCreateParameters(
                    new Microsoft.Azure.Management.Storage.Models.Sku(SkuName.StandardLRS, SkuTier.Standard),
                    Kind.BlobStorage,
                    resourceGroup.Location,
                    accessTier: AccessTier.Cool));

            StorageAccountListKeysResult keys =
                storageClient.StorageAccounts.ListKeys(resourceGroup.Name, storageAccount.Name);
            string key = keys.Keys.First().Value;

            string containerName = "vulnerability-assessment";
            var sasToken = string.Empty;

            // Create container
            // Since this is a data-plane client and not an ARM client it's harder to inject
            // HttpMockServer into it to record/playback, but that's fine because we don't need
            // any of the response data to continue with the test.
            if (HttpMockServer.Mode == HttpRecorderMode.Record)
            {
                CloudStorageAccount storageAccountClient = new CloudStorageAccount(
                    new Microsoft.WindowsAzure.Storage.Auth.StorageCredentials(
                        storageAccount.Name,
                        key),
                    useHttps: true);
                CloudBlobClient blobClient = storageAccountClient.CreateCloudBlobClient();
                CloudBlobContainer containerReference = blobClient.GetContainerReference(containerName);
                await containerReference.CreateIfNotExistsAsync();

                SharedAccessBlobPolicy sharedAccessPolicy = new SharedAccessBlobPolicy
                {
                    SharedAccessExpiryTime = new DateTimeOffset(DateTime.UtcNow.Add(TimeSpan.FromHours(1))),
                    Permissions = SharedAccessBlobPermissions.Write | SharedAccessBlobPermissions.Read | SharedAccessBlobPermissions.List | SharedAccessBlobPermissions.Delete
                };

                // Generate the SAS Token
                sasToken = containerReference.GetSharedAccessSignature(sharedAccessPolicy);
            }

            return new StorageContainerInfo
            {
                StorageAccountSasKey = sasToken,
                StorageContainerPath = new Uri(storageAccount.PrimaryEndpoints.Blob + containerName)
            };
        }

        private void ValidateBaselineRule(SqlManagementClient sqlClient, ResourceGroup resourceGroup, ManagedInstance managedInstance, string dbName, bool isServerLevelRule)
        {
            string testRuleId = "VA2031";
            var ruleBaselineToSet = new DatabaseVulnerabilityAssessmentRuleBaseline(
                    new List<DatabaseVulnerabilityAssessmentRuleBaselineItem>()
                    {
                            new DatabaseVulnerabilityAssessmentRuleBaselineItem()
                            {
                                Result = new string[] { "userA", "SELECT" }
                            },
                            new DatabaseVulnerabilityAssessmentRuleBaselineItem()
                            {
                                Result = new string[] { "userB", "SELECT" }
                            }
                    });

            VulnerabilityAssessmentPolicyBaselineName baselineName = isServerLevelRule
                ? VulnerabilityAssessmentPolicyBaselineName.Master
                : VulnerabilityAssessmentPolicyBaselineName.Default;

            sqlClient.ManagedDatabaseVulnerabilityAssessmentRuleBaselines.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, dbName, testRuleId, baselineName, ruleBaselineToSet);

            // Get baseline
            DatabaseVulnerabilityAssessmentRuleBaseline actualBaseline = sqlClient.ManagedDatabaseVulnerabilityAssessmentRuleBaselines.Get(resourceGroup.Name, managedInstance.Name, dbName, testRuleId, baselineName);

            Assert.Equal(ruleBaselineToSet.BaselineResults.Count(), actualBaseline.BaselineResults.Count());
            SqlManagementTestUtilities.AssertCollection(ruleBaselineToSet.BaselineResults[0].Result, actualBaseline.BaselineResults[0].Result);
            SqlManagementTestUtilities.AssertCollection(ruleBaselineToSet.BaselineResults[1].Result, actualBaseline.BaselineResults[1].Result);

            // Delete baseline
            sqlClient.ManagedDatabaseVulnerabilityAssessmentRuleBaselines.Delete(resourceGroup.Name, managedInstance.Name, dbName, testRuleId, baselineName);

            // Get baseline should fail after deleting the baseline
            Assert.Throws<CloudException>(() =>
            {
                sqlClient.ManagedDatabaseVulnerabilityAssessmentRuleBaselines.Get(resourceGroup.Name, managedInstance.Name, dbName, testRuleId, baselineName);
            });
        }
    }
}
