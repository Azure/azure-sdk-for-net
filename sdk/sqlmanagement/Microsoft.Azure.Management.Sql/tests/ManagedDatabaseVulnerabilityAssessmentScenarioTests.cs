using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Azure.Management.ResourceManager.Models;
using Microsoft.Azure.Management.Sql;
using Microsoft.Azure.Management.Sql.Models;
using Microsoft.Azure.Management.Storage;
using Microsoft.Azure.Management.Storage.Models;
using Microsoft.Azure.Test.HttpRecorder;
using Microsoft.Rest.Azure;
using Microsoft.WindowsAzure.Storage;
using Microsoft.WindowsAzure.Storage.Blob;
using Xunit;

namespace Sql.Tests
{
    public class ManagedDatabaseVulnerabilityAssessmentScenarioTests : IClassFixture<ManagedDatabaseVulnerabilityAssessmentTestFixture>
    {
        private readonly ManagedDatabaseVulnerabilityAssessmentTestFixture m_testFixture;

        public ManagedDatabaseVulnerabilityAssessmentScenarioTests(ManagedDatabaseVulnerabilityAssessmentTestFixture testFixture)
        {
            m_testFixture = testFixture;
        }

        [Fact]
        public async void TestCreateUpdateGetDatabaseVulnerabilityAssessments()
        {
            string testPrefix = "sqlvulnerabilityassessmentcrudtest-";

            SqlManagementClient sqlClient = m_testFixture.Context.GetClient<SqlManagementClient>();

            // Create managed database
            //
            string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
            var db1 = sqlClient.ManagedDatabases.CreateOrUpdate(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, new ManagedDatabase()
            {
                Location = m_testFixture.ManagedInstance.Location,
            });
            Assert.NotNull(db1);

            // Verify Policy is empty to begin with
            DatabaseVulnerabilityAssessment policyThatWasReceived = sqlClient.ManagedDatabaseVulnerabilityAssessments.Get(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName);
            Assert.Null(policyThatWasReceived.StorageContainerPath);
            Assert.Null(policyThatWasReceived.StorageContainerSasKey);
            Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);

            // Set policy and then get policy and verify correctness
            DatabaseVulnerabilityAssessment policyThatWasSet = await SetPolicy(m_testFixture.Context, sqlClient, m_testFixture.ResourceGroup, m_testFixture.ManagedInstance, dbName);

            policyThatWasReceived = sqlClient.ManagedDatabaseVulnerabilityAssessments.Get(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName);
            Assert.Equal(policyThatWasSet.StorageContainerPath, policyThatWasReceived.StorageContainerPath);
            Assert.Null(policyThatWasSet.StorageContainerSasKey);
            Assert.Equal(policyThatWasSet.RecurringScans.IsEnabled, policyThatWasReceived.RecurringScans.IsEnabled);
            SqlManagementTestUtilities.AssertCollection(policyThatWasSet.RecurringScans.Emails, policyThatWasReceived.RecurringScans.Emails);
            Assert.Equal(policyThatWasSet.RecurringScans.EmailSubscriptionAdmins, policyThatWasReceived.RecurringScans.EmailSubscriptionAdmins);

            // Delete policy and then get policy and verify correctness
            sqlClient.ManagedDatabaseVulnerabilityAssessments.Delete(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName);

            // Get policy after deletion
            policyThatWasReceived = sqlClient.ManagedDatabaseVulnerabilityAssessments.Get(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName);
            Assert.Null(policyThatWasReceived.StorageContainerPath);
            Assert.Null(policyThatWasReceived.StorageContainerSasKey);
            Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);
        }

        [Fact]
        public async void TestCreateUpdateGetDeleteDatabaseVulnerabilityAssessmentBaselines()
        {
            string testPrefix = "sqlvulnerabilityassessmentbaselinetest-";

            SqlManagementClient sqlClient = m_testFixture.Context.GetClient<SqlManagementClient>();

            // Create managed database
            //
            string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
            var db1 = sqlClient.ManagedDatabases.CreateOrUpdate(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, new ManagedDatabase()
            {
                Location = m_testFixture.ManagedInstance.Location,
            });
            Assert.NotNull(db1);

            // Set policy
            await SetPolicy(m_testFixture.Context, sqlClient, m_testFixture.ResourceGroup, m_testFixture.ManagedInstance, dbName);

            // Test baseline for database level rule
            ValidateBaselineRule(sqlClient, m_testFixture.ResourceGroup, m_testFixture.ManagedInstance, dbName, isServerLevelRule: true);

            // Test baseline for server level rule
            ValidateBaselineRule(sqlClient, m_testFixture.ResourceGroup, m_testFixture.ManagedInstance, dbName, isServerLevelRule: false);
        }

        [Fact]
        public async void TestExecuteGetListDatabaseVulnerabilityAssessmentScans()
        {
            string testPrefix = "sqlvulnerabilityassessmentscantest-";

            SqlManagementClient sqlClient = m_testFixture.Context.GetClient<SqlManagementClient>();

            // Create managed database
            //
            string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
            var db1 = sqlClient.ManagedDatabases.CreateOrUpdate(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, new ManagedDatabase()
            {
                Location = m_testFixture.ManagedInstance.Location,
            });
            Assert.NotNull(db1);

            // Set policy
            await SetPolicy(m_testFixture.Context, sqlClient, m_testFixture.ResourceGroup, m_testFixture.ManagedInstance, dbName);

            // Run some scans
            string scanId = string.Format("scantest1_{0}", testPrefix);
            sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.InitiateScan(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, scanId);

            string scanId1 = string.Format("scantest2_{0}", testPrefix);
            sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.InitiateScan(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, scanId1);

            // Verify get scan and list scans
            VulnerabilityAssessmentScanRecord scanRecord = sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.Get(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, scanId);
            Assert.Equal(scanId, scanRecord.ScanId);

            IPage<VulnerabilityAssessmentScanRecord> scanRecords = sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.ListByDatabase(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName);
            Assert.Equal(2, scanRecords.ToList().Count);
            Assert.Contains(scanRecords.ToList(), item => item.ScanId == scanId);
            Assert.Contains(scanRecords.ToList(), item => item.ScanId == scanId1);

            VulnerabilityAssessmentScanRecord scanId1Record = sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.Get(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, scanId1);
            VulnerabilityAssessmentScanRecord scanId1RecordFromList = scanRecords.FirstOrDefault(item => item.ScanId == scanId1);
            Assert.Equal(scanId1Record.ScanId, scanId1RecordFromList.ScanId);
            Assert.Equal(scanId1Record.TriggerType, scanId1RecordFromList.TriggerType);
            Assert.Equal(scanId1Record.State, scanId1RecordFromList.State);
            Assert.Equal(scanId1Record.StartTime, scanId1RecordFromList.StartTime);
            Assert.Equal(scanId1Record.EndTime, scanId1RecordFromList.EndTime);
            Assert.Equal(scanId1Record.Errors, scanId1RecordFromList.Errors);
            Assert.Equal(scanId1Record.StorageContainerPath, scanId1RecordFromList.StorageContainerPath);
            Assert.Equal(scanId1Record.NumberOfFailedSecurityChecks, scanId1RecordFromList.NumberOfFailedSecurityChecks);
        }

        [Fact]
        public async void TestExportDatabaseVulnerabilityAssessmentScans()
        {
            string testPrefix = "sqlvulnerabilityassessmentexportscantest-";

            SqlManagementClient sqlClient = m_testFixture.Context.GetClient<SqlManagementClient>();

            // Create managed database
            //
            string dbName = SqlManagementTestUtilities.GenerateName(testPrefix);
            var db1 = sqlClient.ManagedDatabases.CreateOrUpdate(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, new ManagedDatabase()
            {
                Location = m_testFixture.ManagedInstance.Location,
            });
            Assert.NotNull(db1);

            // Set policy
            await SetPolicy(m_testFixture.Context, sqlClient, m_testFixture.ResourceGroup, m_testFixture.ManagedInstance, dbName);

            // Run some scans
            string scanId = string.Format("scan1_{0}", testPrefix);
            sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.InitiateScan(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, scanId);
            sqlClient.ManagedDatabaseVulnerabilityAssessmentScans.Export(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name, dbName, scanId);
        }

        private async Task<DatabaseVulnerabilityAssessment> SetPolicy(SqlManagementTestContext context, SqlManagementClient sqlClient, ResourceGroup resourceGroup,
            ManagedInstance managedInstance, string dbName)
        {
			// Modify the policy properties, send and receive and see it its still ok
			ManagedServerSecurityAlertPolicy updatedManagedServerPolicy = new ManagedServerSecurityAlertPolicy
			{
				State = SecurityAlertPolicyState.Enabled,
				EmailAccountAdmins = true
			};

			//Set security alert policy for server
			sqlClient.ManagedServerSecurityAlertPolicies.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, updatedManagedServerPolicy);

			StorageContainerInfo StorageContainerInfo = await CreateStorageContainer(context, resourceGroup);
            DatabaseVulnerabilityAssessment policy = new DatabaseVulnerabilityAssessment()
            {
                StorageContainerPath = StorageContainerInfo.StorageContainerPath.ToString(),
                StorageContainerSasKey = StorageContainerInfo.StorageAccountSasKey,
                RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                {
                    IsEnabled = false,
                    Emails = new List<string>() { "fakemail1@mail.com", "fakemail2@mail.com" },
                    EmailSubscriptionAdmins = true
                }
            };

            return sqlClient.ManagedDatabaseVulnerabilityAssessments.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, dbName, policy);
        }

        private struct StorageContainerInfo
        {
            public string StorageAccountSasKey;
            public Uri StorageContainerPath;
        }

        private async Task<StorageContainerInfo> CreateStorageContainer(SqlManagementTestContext context, ResourceGroup resourceGroup)
        {
            StorageManagementClient storageClient = context.GetClient<StorageManagementClient>();
            StorageAccount storageAccount = await storageClient.StorageAccounts.CreateAsync(
                resourceGroup.Name,
                accountName: SqlManagementTestUtilities.GenerateName(prefix: "sqlvatest"),
                parameters: new StorageAccountCreateParameters(
                    new Microsoft.Azure.Management.Storage.Models.Sku(SkuName.StandardLRS, SkuTier.Standard),
                    Kind.BlobStorage,
                    resourceGroup.Location,
                    accessTier: AccessTier.Cool));

            StorageAccountListKeysResult keys =
                storageClient.StorageAccounts.ListKeys(resourceGroup.Name, storageAccount.Name);
            string key = keys.Keys.First().Value;

            string containerName = "vulnerability-assessment";
            var sasToken = string.Empty;

            // Create container
            // Since this is a data-plane client and not an ARM client it's harder to inject
            // HttpMockServer into it to record/playback, but that's fine because we don't need
            // any of the response data to continue with the test.
            if (HttpMockServer.Mode == HttpRecorderMode.Record)
            {
                CloudStorageAccount storageAccountClient = new CloudStorageAccount(
                    new Microsoft.WindowsAzure.Storage.Auth.StorageCredentials(
                        storageAccount.Name,
                        key),
                    useHttps: true);
                CloudBlobClient blobClient = storageAccountClient.CreateCloudBlobClient();
                CloudBlobContainer containerReference = blobClient.GetContainerReference(containerName);
                await containerReference.CreateIfNotExistsAsync();

                SharedAccessBlobPolicy sharedAccessPolicy = new SharedAccessBlobPolicy
                {
                    SharedAccessExpiryTime = new DateTimeOffset(DateTime.UtcNow.Add(TimeSpan.FromHours(1))),
                    Permissions = SharedAccessBlobPermissions.Write | SharedAccessBlobPermissions.Read | SharedAccessBlobPermissions.List
                };

                // Generate the SAS Token
                sasToken = containerReference.GetSharedAccessSignature(sharedAccessPolicy);
            }

            return new StorageContainerInfo
            {
                StorageAccountSasKey = sasToken,
                StorageContainerPath = new Uri(storageAccount.PrimaryEndpoints.Blob + containerName)
            };
        }

        private void ValidateBaselineRule(SqlManagementClient sqlClient, ResourceGroup resourceGroup, ManagedInstance managedInstance, string dbName, bool isServerLevelRule)
        {
            string testRuleId = "VA2031";
            var ruleBaselineToSet = new DatabaseVulnerabilityAssessmentRuleBaseline(
                    new List<DatabaseVulnerabilityAssessmentRuleBaselineItem>()
                    {
                            new DatabaseVulnerabilityAssessmentRuleBaselineItem()
                            {
                                Result = new string[] { "userA", "SELECT" }
                            },
                            new DatabaseVulnerabilityAssessmentRuleBaselineItem()
                            {
                                Result = new string[] { "userB", "SELECT" }
                            }
                    });

            VulnerabilityAssessmentPolicyBaselineName baselineName = isServerLevelRule
                ? VulnerabilityAssessmentPolicyBaselineName.Master
                : VulnerabilityAssessmentPolicyBaselineName.Default;

            sqlClient.ManagedDatabaseVulnerabilityAssessmentRuleBaselines.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, dbName, testRuleId, baselineName, ruleBaselineToSet);

            // Get baseline
            DatabaseVulnerabilityAssessmentRuleBaseline actualBaseline = sqlClient.ManagedDatabaseVulnerabilityAssessmentRuleBaselines.Get(resourceGroup.Name, managedInstance.Name, dbName, testRuleId, baselineName);

            Assert.Equal(ruleBaselineToSet.BaselineResults.Count(), actualBaseline.BaselineResults.Count());
            SqlManagementTestUtilities.AssertCollection(ruleBaselineToSet.BaselineResults[0].Result, actualBaseline.BaselineResults[0].Result);
            SqlManagementTestUtilities.AssertCollection(ruleBaselineToSet.BaselineResults[1].Result, actualBaseline.BaselineResults[1].Result);

            // Delete baseline
            sqlClient.ManagedDatabaseVulnerabilityAssessmentRuleBaselines.Delete(resourceGroup.Name, managedInstance.Name, dbName, testRuleId, baselineName);

            // Get baseline should fail after deleting the baseline
            Assert.Throws<CloudException>(() =>
            {
                sqlClient.ManagedDatabaseVulnerabilityAssessmentRuleBaselines.Get(resourceGroup.Name, managedInstance.Name, dbName, testRuleId, baselineName);
            });
        }
    }
}
