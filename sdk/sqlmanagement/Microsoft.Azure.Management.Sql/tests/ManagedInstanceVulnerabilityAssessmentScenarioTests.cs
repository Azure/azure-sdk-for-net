// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using System.Collections.Generic;
using Microsoft.Azure.Management.Sql.Models;
using Microsoft.Azure.Management.ResourceManager;
using Microsoft.Azure.Management.ResourceManager.Models;
using Microsoft.Azure.Management.Sql;
using Xunit;
using System.Threading.Tasks;
using Microsoft.Azure.Management.Storage;

namespace Sql.Tests
{
    public class ManagedInstanceVulnerabilityAssessmentScenarioTests : IClassFixture<ManagedInstanceVulnerabilityAssessmentTestFixture>
    {
        private readonly ManagedInstanceVulnerabilityAssessmentTestFixture m_testFixture;

        public ManagedInstanceVulnerabilityAssessmentScenarioTests(ManagedInstanceVulnerabilityAssessmentTestFixture testFixture)
        {
            m_testFixture = testFixture;
        }

        [Fact]
        public async void TestCreateUpdateGetManagedInstanceVulnerabilityAssessments()
        {
            SqlManagementClient sqlClient = m_testFixture.Context.GetClient<SqlManagementClient>();

            // Verify Policy is empty to begin with
            ManagedInstanceVulnerabilityAssessment policyThatWasReceived = sqlClient.ManagedInstanceVulnerabilityAssessments.Get(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name);
            Assert.Null(policyThatWasReceived.StorageContainerPath);
            Assert.Null(policyThatWasReceived.StorageAccountAccessKey);
            Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);

            // Set policy and then get policy and verify correctness
            ManagedInstanceVulnerabilityAssessment policyThatWasSet = await SetPolicy(m_testFixture.Context, sqlClient, m_testFixture.ResourceGroup, m_testFixture.ManagedInstance);

            policyThatWasReceived = sqlClient.ManagedInstanceVulnerabilityAssessments.Get(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name);
            Assert.Equal(policyThatWasSet.StorageContainerPath, policyThatWasReceived.StorageContainerPath);
            Assert.Null(policyThatWasSet.StorageAccountAccessKey);
            Assert.Equal(policyThatWasSet.RecurringScans.IsEnabled, policyThatWasReceived.RecurringScans.IsEnabled);
            SqlManagementTestUtilities.AssertCollection(policyThatWasSet.RecurringScans.Emails, policyThatWasReceived.RecurringScans.Emails);
            Assert.Equal(policyThatWasSet.RecurringScans.EmailSubscriptionAdmins, policyThatWasReceived.RecurringScans.EmailSubscriptionAdmins);

            // Delete policy and then get policy and verify correctness
            sqlClient.ManagedInstanceVulnerabilityAssessments.Delete(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name);

            // Get policy after deletion
            policyThatWasReceived = sqlClient.ManagedInstanceVulnerabilityAssessments.Get(m_testFixture.ResourceGroup.Name, m_testFixture.ManagedInstance.Name);
            Assert.Null(policyThatWasReceived.StorageContainerPath);
            Assert.Null(policyThatWasReceived.StorageAccountAccessKey);
            Assert.False(policyThatWasReceived.RecurringScans.IsEnabled);
        }

        private async Task<ManagedInstanceVulnerabilityAssessment> SetPolicy(SqlManagementTestContext context, SqlManagementClient sqlClient, ResourceGroup resourceGroup,
                ManagedInstance managedInstance)
        {
			// Modify the policy properties, send and receive and see it its still ok
			ManagedServerSecurityAlertPolicy updatedManagedServerPolicy = new ManagedServerSecurityAlertPolicy
			{
				State = SecurityAlertPolicyState.Enabled,
				EmailAccountAdmins = true
			};

			//Set security alert policy for server
			sqlClient.ManagedServerSecurityAlertPolicies.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, updatedManagedServerPolicy);

			VulnerabilityAssessmentTestUtilities.StorageContainerInfo StorageContainerInfo = await VulnerabilityAssessmentTestUtilities.CreateStorageContainer(context, resourceGroup);
            ManagedInstanceVulnerabilityAssessment policy = new ManagedInstanceVulnerabilityAssessment()
            {
                StorageContainerPath = StorageContainerInfo.StorageContainerPath.ToString(),
                StorageContainerSasKey = StorageContainerInfo.StorageAccountAccessKey,
                RecurringScans = new VulnerabilityAssessmentRecurringScansProperties()
                {
                    IsEnabled = false,
                    Emails = new List<string>() { "fakemail1@mail.com", "fakemail2@mail.com" },
                    EmailSubscriptionAdmins = true
                }
            };

            return sqlClient.ManagedInstanceVulnerabilityAssessments.CreateOrUpdate(resourceGroup.Name, managedInstance.Name, policy);
        }
    }
}
