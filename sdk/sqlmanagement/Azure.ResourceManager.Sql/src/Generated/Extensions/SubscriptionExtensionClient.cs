// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager;
using Azure.ResourceManager.Core;
using Azure.ResourceManager.Resources.Models;
using Azure.ResourceManager.Sql.Models;

namespace Azure.ResourceManager.Sql
{
    /// <summary> A class to add extension methods to Subscription. </summary>
    internal partial class SubscriptionExtensionClient : ArmResource
    {
        private ClientDiagnostics _deletedServerClientDiagnostics;
        private DeletedServersRestOperations _deletedServerRestClient;
        private ClientDiagnostics _instancePoolClientDiagnostics;
        private InstancePoolsRestOperations _instancePoolRestClient;
        private ClientDiagnostics _capabilitiesClientDiagnostics;
        private CapabilitiesRestOperations _capabilitiesRestClient;
        private ClientDiagnostics _longTermRetentionBackupsClientDiagnostics;
        private LongTermRetentionBackupsRestOperations _longTermRetentionBackupsRestClient;
        private ClientDiagnostics _longTermRetentionManagedInstanceBackupsClientDiagnostics;
        private LongTermRetentionManagedInstanceBackupsRestOperations _longTermRetentionManagedInstanceBackupsRestClient;
        private ClientDiagnostics _managedInstanceClientDiagnostics;
        private ManagedInstancesRestOperations _managedInstanceRestClient;
        private ClientDiagnostics _operationsHealthClientDiagnostics;
        private OperationsHealthRestOperations _operationsHealthRestClient;
        private ClientDiagnostics _syncGroupClientDiagnostics;
        private SyncGroupsRestOperations _syncGroupRestClient;
        private ClientDiagnostics _virtualClusterClientDiagnostics;
        private VirtualClustersRestOperations _virtualClusterRestClient;
        private ClientDiagnostics _sqlServerServersClientDiagnostics;
        private ServersRestOperations _sqlServerServersRestClient;

        /// <summary> Initializes a new instance of the <see cref="SubscriptionExtensionClient"/> class for mocking. </summary>
        protected SubscriptionExtensionClient()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="SubscriptionExtensionClient"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal SubscriptionExtensionClient(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
        }

        private ClientDiagnostics DeletedServerClientDiagnostics => _deletedServerClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", DeletedServer.ResourceType.Namespace, DiagnosticOptions);
        private DeletedServersRestOperations DeletedServerRestClient => _deletedServerRestClient ??= new DeletedServersRestOperations(DeletedServerClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(DeletedServer.ResourceType));
        private ClientDiagnostics InstancePoolClientDiagnostics => _instancePoolClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", InstancePool.ResourceType.Namespace, DiagnosticOptions);
        private InstancePoolsRestOperations InstancePoolRestClient => _instancePoolRestClient ??= new InstancePoolsRestOperations(InstancePoolClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(InstancePool.ResourceType));
        private ClientDiagnostics CapabilitiesClientDiagnostics => _capabilitiesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private CapabilitiesRestOperations CapabilitiesRestClient => _capabilitiesRestClient ??= new CapabilitiesRestOperations(CapabilitiesClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics LongTermRetentionBackupsClientDiagnostics => _longTermRetentionBackupsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private LongTermRetentionBackupsRestOperations LongTermRetentionBackupsRestClient => _longTermRetentionBackupsRestClient ??= new LongTermRetentionBackupsRestOperations(LongTermRetentionBackupsClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics LongTermRetentionManagedInstanceBackupsClientDiagnostics => _longTermRetentionManagedInstanceBackupsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private LongTermRetentionManagedInstanceBackupsRestOperations LongTermRetentionManagedInstanceBackupsRestClient => _longTermRetentionManagedInstanceBackupsRestClient ??= new LongTermRetentionManagedInstanceBackupsRestOperations(LongTermRetentionManagedInstanceBackupsClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics ManagedInstanceClientDiagnostics => _managedInstanceClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", ManagedInstance.ResourceType.Namespace, DiagnosticOptions);
        private ManagedInstancesRestOperations ManagedInstanceRestClient => _managedInstanceRestClient ??= new ManagedInstancesRestOperations(ManagedInstanceClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(ManagedInstance.ResourceType));
        private ClientDiagnostics OperationsHealthClientDiagnostics => _operationsHealthClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", ProviderConstants.DefaultProviderNamespace, DiagnosticOptions);
        private OperationsHealthRestOperations OperationsHealthRestClient => _operationsHealthRestClient ??= new OperationsHealthRestOperations(OperationsHealthClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri);
        private ClientDiagnostics SyncGroupClientDiagnostics => _syncGroupClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", SyncGroup.ResourceType.Namespace, DiagnosticOptions);
        private SyncGroupsRestOperations SyncGroupRestClient => _syncGroupRestClient ??= new SyncGroupsRestOperations(SyncGroupClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(SyncGroup.ResourceType));
        private ClientDiagnostics VirtualClusterClientDiagnostics => _virtualClusterClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", VirtualCluster.ResourceType.Namespace, DiagnosticOptions);
        private VirtualClustersRestOperations VirtualClusterRestClient => _virtualClusterRestClient ??= new VirtualClustersRestOperations(VirtualClusterClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(VirtualCluster.ResourceType));
        private ClientDiagnostics SqlServerServersClientDiagnostics => _sqlServerServersClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.Sql", SqlServer.ResourceType.Namespace, DiagnosticOptions);
        private ServersRestOperations SqlServerServersRestClient => _sqlServerServersRestClient ??= new ServersRestOperations(SqlServerServersClientDiagnostics, Pipeline, DiagnosticOptions.ApplicationId, BaseUri, GetApiVersionOrNull(SqlServer.ResourceType));

        private string GetApiVersionOrNull(ResourceType resourceType)
        {
            Client.TryGetApiVersion(resourceType, out string apiVersion);
            return apiVersion;
        }

        /// <summary> Gets a collection of DeletedServers in the DeletedServer. </summary>
        /// <param name="locationName"> The name of the region where the resource is located. </param>
        /// <returns> An object representing collection of DeletedServers and their operations over a DeletedServer. </returns>
        public virtual DeletedServerCollection GetDeletedServers(string locationName)
        {
            return new DeletedServerCollection(Client, Id, locationName);
        }

        /// <summary> Gets a collection of SubscriptionLongTermRetentionBackups in the SubscriptionLongTermRetentionBackup. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="longTermRetentionServerName"> The name of the server. </param>
        /// <param name="longTermRetentionDatabaseName"> The name of the database. </param>
        /// <returns> An object representing collection of SubscriptionLongTermRetentionBackups and their operations over a SubscriptionLongTermRetentionBackup. </returns>
        public virtual SubscriptionLongTermRetentionBackupCollection GetSubscriptionLongTermRetentionBackups(string locationName, string longTermRetentionServerName, string longTermRetentionDatabaseName)
        {
            return new SubscriptionLongTermRetentionBackupCollection(Client, Id, locationName, longTermRetentionServerName, longTermRetentionDatabaseName);
        }

        /// <summary> Gets a collection of SubscriptionLongTermRetentionManagedInstanceBackups in the SubscriptionLongTermRetentionManagedInstanceBackup. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="managedInstanceName"> The name of the managed instance. </param>
        /// <param name="databaseName"> The name of the managed database. </param>
        /// <returns> An object representing collection of SubscriptionLongTermRetentionManagedInstanceBackups and their operations over a SubscriptionLongTermRetentionManagedInstanceBackup. </returns>
        public virtual SubscriptionLongTermRetentionManagedInstanceBackupCollection GetSubscriptionLongTermRetentionManagedInstanceBackups(string locationName, string managedInstanceName, string databaseName)
        {
            return new SubscriptionLongTermRetentionManagedInstanceBackupCollection(Client, Id, locationName, managedInstanceName, databaseName);
        }

        /// <summary> Gets a collection of SubscriptionUsages in the SubscriptionUsage. </summary>
        /// <param name="locationName"> The name of the region where the resource is located. </param>
        /// <returns> An object representing collection of SubscriptionUsages and their operations over a SubscriptionUsage. </returns>
        public virtual SubscriptionUsageCollection GetSubscriptionUsages(string locationName)
        {
            return new SubscriptionUsageCollection(Client, Id, locationName);
        }

        /// <summary> Gets a collection of SqlTimeZones in the SqlTimeZone. </summary>
        /// <param name="locationName"> The String to use. </param>
        /// <returns> An object representing collection of SqlTimeZones and their operations over a SqlTimeZone. </returns>
        public virtual SqlTimeZoneCollection GetSqlTimeZones(string locationName)
        {
            return new SqlTimeZoneCollection(Client, Id, locationName);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/deletedServers
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: DeletedServers_List
        /// <summary> Gets a list of all deleted servers in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="DeletedServer" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<DeletedServer> GetDeletedServersAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<DeletedServer>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = DeletedServerClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDeletedServers");
                scope.Start();
                try
                {
                    var response = await DeletedServerRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new DeletedServer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<DeletedServer>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = DeletedServerClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDeletedServers");
                scope.Start();
                try
                {
                    var response = await DeletedServerRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new DeletedServer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/deletedServers
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: DeletedServers_List
        /// <summary> Gets a list of all deleted servers in a subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="DeletedServer" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<DeletedServer> GetDeletedServers(CancellationToken cancellationToken = default)
        {
            Page<DeletedServer> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = DeletedServerClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDeletedServers");
                scope.Start();
                try
                {
                    var response = DeletedServerRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new DeletedServer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<DeletedServer> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = DeletedServerClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetDeletedServers");
                scope.Start();
                try
                {
                    var response = DeletedServerRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new DeletedServer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/instancePools
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: InstancePools_List
        /// <summary> Gets a list of all instance pools in the subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="InstancePool" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<InstancePool> GetInstancePoolsAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<InstancePool>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = InstancePoolClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetInstancePools");
                scope.Start();
                try
                {
                    var response = await InstancePoolRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new InstancePool(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<InstancePool>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = InstancePoolClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetInstancePools");
                scope.Start();
                try
                {
                    var response = await InstancePoolRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new InstancePool(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/instancePools
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: InstancePools_List
        /// <summary> Gets a list of all instance pools in the subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="InstancePool" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<InstancePool> GetInstancePools(CancellationToken cancellationToken = default)
        {
            Page<InstancePool> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = InstancePoolClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetInstancePools");
                scope.Start();
                try
                {
                    var response = InstancePoolRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new InstancePool(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<InstancePool> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = InstancePoolClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetInstancePools");
                scope.Start();
                try
                {
                    var response = InstancePoolRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new InstancePool(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/capabilities
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: Capabilities_ListByLocation
        /// <summary> Gets the subscription capabilities available for the specified location. </summary>
        /// <param name="locationName"> The location name whose capabilities are retrieved. </param>
        /// <param name="include"> If specified, restricts the response to only include the selected item. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<LocationCapabilities>> GetByLocationCapabilityAsync(string locationName, CapabilityGroup? include = null, CancellationToken cancellationToken = default)
        {
            using var scope = CapabilitiesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetByLocationCapability");
            scope.Start();
            try
            {
                var response = await CapabilitiesRestClient.ListByLocationAsync(Id.SubscriptionId, locationName, include, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/capabilities
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: Capabilities_ListByLocation
        /// <summary> Gets the subscription capabilities available for the specified location. </summary>
        /// <param name="locationName"> The location name whose capabilities are retrieved. </param>
        /// <param name="include"> If specified, restricts the response to only include the selected item. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<LocationCapabilities> GetByLocationCapability(string locationName, CapabilityGroup? include = null, CancellationToken cancellationToken = default)
        {
            using var scope = CapabilitiesClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetByLocationCapability");
            scope.Start();
            try
            {
                var response = CapabilitiesRestClient.ListByLocation(Id.SubscriptionId, locationName, include, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionBackups
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: LongTermRetentionBackups_ListByLocation
        /// <summary> Lists the long term retention backups for a given location. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="onlyLatestPerDatabase"> Whether or not to only get the latest backup for each database. </param>
        /// <param name="databaseState"> Whether to query against just live databases, just deleted databases, or all databases. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="SubscriptionLongTermRetentionBackup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<SubscriptionLongTermRetentionBackup> GetLongTermRetentionBackupsByLocationAsync(string locationName, bool? onlyLatestPerDatabase = null, DatabaseState? databaseState = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<SubscriptionLongTermRetentionBackup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LongTermRetentionBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionBackupsByLocation");
                scope.Start();
                try
                {
                    var response = await LongTermRetentionBackupsRestClient.ListByLocationAsync(Id.SubscriptionId, locationName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<SubscriptionLongTermRetentionBackup>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LongTermRetentionBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionBackupsByLocation");
                scope.Start();
                try
                {
                    var response = await LongTermRetentionBackupsRestClient.ListByLocationNextPageAsync(nextLink, Id.SubscriptionId, locationName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionBackups
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: LongTermRetentionBackups_ListByLocation
        /// <summary> Lists the long term retention backups for a given location. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="onlyLatestPerDatabase"> Whether or not to only get the latest backup for each database. </param>
        /// <param name="databaseState"> Whether to query against just live databases, just deleted databases, or all databases. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="SubscriptionLongTermRetentionBackup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<SubscriptionLongTermRetentionBackup> GetLongTermRetentionBackupsByLocation(string locationName, bool? onlyLatestPerDatabase = null, DatabaseState? databaseState = null, CancellationToken cancellationToken = default)
        {
            Page<SubscriptionLongTermRetentionBackup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LongTermRetentionBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionBackupsByLocation");
                scope.Start();
                try
                {
                    var response = LongTermRetentionBackupsRestClient.ListByLocation(Id.SubscriptionId, locationName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<SubscriptionLongTermRetentionBackup> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LongTermRetentionBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionBackupsByLocation");
                scope.Start();
                try
                {
                    var response = LongTermRetentionBackupsRestClient.ListByLocationNextPage(nextLink, Id.SubscriptionId, locationName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionBackups
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: LongTermRetentionBackups_ListByServer
        /// <summary> Lists the long term retention backups for a given server. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="longTermRetentionServerName"> The name of the server. </param>
        /// <param name="onlyLatestPerDatabase"> Whether or not to only get the latest backup for each database. </param>
        /// <param name="databaseState"> Whether to query against just live databases, just deleted databases, or all databases. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="SubscriptionLongTermRetentionBackup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<SubscriptionLongTermRetentionBackup> GetLongTermRetentionBackupsByServerAsync(string locationName, string longTermRetentionServerName, bool? onlyLatestPerDatabase = null, DatabaseState? databaseState = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<SubscriptionLongTermRetentionBackup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LongTermRetentionBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionBackupsByServer");
                scope.Start();
                try
                {
                    var response = await LongTermRetentionBackupsRestClient.ListByServerAsync(Id.SubscriptionId, locationName, longTermRetentionServerName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<SubscriptionLongTermRetentionBackup>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LongTermRetentionBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionBackupsByServer");
                scope.Start();
                try
                {
                    var response = await LongTermRetentionBackupsRestClient.ListByServerNextPageAsync(nextLink, Id.SubscriptionId, locationName, longTermRetentionServerName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionServers/{longTermRetentionServerName}/longTermRetentionBackups
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: LongTermRetentionBackups_ListByServer
        /// <summary> Lists the long term retention backups for a given server. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="longTermRetentionServerName"> The name of the server. </param>
        /// <param name="onlyLatestPerDatabase"> Whether or not to only get the latest backup for each database. </param>
        /// <param name="databaseState"> Whether to query against just live databases, just deleted databases, or all databases. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="SubscriptionLongTermRetentionBackup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<SubscriptionLongTermRetentionBackup> GetLongTermRetentionBackupsByServer(string locationName, string longTermRetentionServerName, bool? onlyLatestPerDatabase = null, DatabaseState? databaseState = null, CancellationToken cancellationToken = default)
        {
            Page<SubscriptionLongTermRetentionBackup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LongTermRetentionBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionBackupsByServer");
                scope.Start();
                try
                {
                    var response = LongTermRetentionBackupsRestClient.ListByServer(Id.SubscriptionId, locationName, longTermRetentionServerName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<SubscriptionLongTermRetentionBackup> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LongTermRetentionBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionBackupsByServer");
                scope.Start();
                try
                {
                    var response = LongTermRetentionBackupsRestClient.ListByServerNextPage(nextLink, Id.SubscriptionId, locationName, longTermRetentionServerName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionManagedInstanceBackups
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: LongTermRetentionManagedInstanceBackups_ListByInstance
        /// <summary> Lists the long term retention backups for a given managed instance. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="managedInstanceName"> The name of the managed instance. </param>
        /// <param name="onlyLatestPerDatabase"> Whether or not to only get the latest backup for each database. </param>
        /// <param name="databaseState"> Whether to query against just live databases, just deleted databases, or all databases. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="SubscriptionLongTermRetentionManagedInstanceBackup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<SubscriptionLongTermRetentionManagedInstanceBackup> GetLongTermRetentionManagedInstanceBackupsByInstanceAsync(string locationName, string managedInstanceName, bool? onlyLatestPerDatabase = null, DatabaseState? databaseState = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<SubscriptionLongTermRetentionManagedInstanceBackup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LongTermRetentionManagedInstanceBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionManagedInstanceBackupsByInstance");
                scope.Start();
                try
                {
                    var response = await LongTermRetentionManagedInstanceBackupsRestClient.ListByInstanceAsync(Id.SubscriptionId, locationName, managedInstanceName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionManagedInstanceBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<SubscriptionLongTermRetentionManagedInstanceBackup>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LongTermRetentionManagedInstanceBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionManagedInstanceBackupsByInstance");
                scope.Start();
                try
                {
                    var response = await LongTermRetentionManagedInstanceBackupsRestClient.ListByInstanceNextPageAsync(nextLink, Id.SubscriptionId, locationName, managedInstanceName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionManagedInstanceBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstances/{managedInstanceName}/longTermRetentionManagedInstanceBackups
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: LongTermRetentionManagedInstanceBackups_ListByInstance
        /// <summary> Lists the long term retention backups for a given managed instance. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="managedInstanceName"> The name of the managed instance. </param>
        /// <param name="onlyLatestPerDatabase"> Whether or not to only get the latest backup for each database. </param>
        /// <param name="databaseState"> Whether to query against just live databases, just deleted databases, or all databases. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="SubscriptionLongTermRetentionManagedInstanceBackup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<SubscriptionLongTermRetentionManagedInstanceBackup> GetLongTermRetentionManagedInstanceBackupsByInstance(string locationName, string managedInstanceName, bool? onlyLatestPerDatabase = null, DatabaseState? databaseState = null, CancellationToken cancellationToken = default)
        {
            Page<SubscriptionLongTermRetentionManagedInstanceBackup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LongTermRetentionManagedInstanceBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionManagedInstanceBackupsByInstance");
                scope.Start();
                try
                {
                    var response = LongTermRetentionManagedInstanceBackupsRestClient.ListByInstance(Id.SubscriptionId, locationName, managedInstanceName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionManagedInstanceBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<SubscriptionLongTermRetentionManagedInstanceBackup> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LongTermRetentionManagedInstanceBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionManagedInstanceBackupsByInstance");
                scope.Start();
                try
                {
                    var response = LongTermRetentionManagedInstanceBackupsRestClient.ListByInstanceNextPage(nextLink, Id.SubscriptionId, locationName, managedInstanceName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionManagedInstanceBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstanceBackups
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: LongTermRetentionManagedInstanceBackups_ListByLocation
        /// <summary> Lists the long term retention backups for managed databases in a given location. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="onlyLatestPerDatabase"> Whether or not to only get the latest backup for each database. </param>
        /// <param name="databaseState"> Whether to query against just live databases, just deleted databases, or all databases. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="SubscriptionLongTermRetentionManagedInstanceBackup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<SubscriptionLongTermRetentionManagedInstanceBackup> GetLongTermRetentionManagedInstanceBackupsByLocationAsync(string locationName, bool? onlyLatestPerDatabase = null, DatabaseState? databaseState = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<SubscriptionLongTermRetentionManagedInstanceBackup>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LongTermRetentionManagedInstanceBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionManagedInstanceBackupsByLocation");
                scope.Start();
                try
                {
                    var response = await LongTermRetentionManagedInstanceBackupsRestClient.ListByLocationAsync(Id.SubscriptionId, locationName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionManagedInstanceBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<SubscriptionLongTermRetentionManagedInstanceBackup>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LongTermRetentionManagedInstanceBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionManagedInstanceBackupsByLocation");
                scope.Start();
                try
                {
                    var response = await LongTermRetentionManagedInstanceBackupsRestClient.ListByLocationNextPageAsync(nextLink, Id.SubscriptionId, locationName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionManagedInstanceBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/longTermRetentionManagedInstanceBackups
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: LongTermRetentionManagedInstanceBackups_ListByLocation
        /// <summary> Lists the long term retention backups for managed databases in a given location. </summary>
        /// <param name="locationName"> The location of the database. </param>
        /// <param name="onlyLatestPerDatabase"> Whether or not to only get the latest backup for each database. </param>
        /// <param name="databaseState"> Whether to query against just live databases, just deleted databases, or all databases. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="SubscriptionLongTermRetentionManagedInstanceBackup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<SubscriptionLongTermRetentionManagedInstanceBackup> GetLongTermRetentionManagedInstanceBackupsByLocation(string locationName, bool? onlyLatestPerDatabase = null, DatabaseState? databaseState = null, CancellationToken cancellationToken = default)
        {
            Page<SubscriptionLongTermRetentionManagedInstanceBackup> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = LongTermRetentionManagedInstanceBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionManagedInstanceBackupsByLocation");
                scope.Start();
                try
                {
                    var response = LongTermRetentionManagedInstanceBackupsRestClient.ListByLocation(Id.SubscriptionId, locationName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionManagedInstanceBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<SubscriptionLongTermRetentionManagedInstanceBackup> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = LongTermRetentionManagedInstanceBackupsClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetLongTermRetentionManagedInstanceBackupsByLocation");
                scope.Start();
                try
                {
                    var response = LongTermRetentionManagedInstanceBackupsRestClient.ListByLocationNextPage(nextLink, Id.SubscriptionId, locationName, onlyLatestPerDatabase, databaseState, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SubscriptionLongTermRetentionManagedInstanceBackup(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/managedInstances
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: ManagedInstances_List
        /// <summary> Gets a list of all managed instances in the subscription. </summary>
        /// <param name="expand"> The child resources to include in the response. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ManagedInstance" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ManagedInstance> GetManagedInstancesAsync(string expand = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<ManagedInstance>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ManagedInstanceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetManagedInstances");
                scope.Start();
                try
                {
                    var response = await ManagedInstanceRestClient.ListAsync(Id.SubscriptionId, expand, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ManagedInstance(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<ManagedInstance>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ManagedInstanceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetManagedInstances");
                scope.Start();
                try
                {
                    var response = await ManagedInstanceRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, expand, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new ManagedInstance(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/managedInstances
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: ManagedInstances_List
        /// <summary> Gets a list of all managed instances in the subscription. </summary>
        /// <param name="expand"> The child resources to include in the response. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ManagedInstance" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ManagedInstance> GetManagedInstances(string expand = null, CancellationToken cancellationToken = default)
        {
            Page<ManagedInstance> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = ManagedInstanceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetManagedInstances");
                scope.Start();
                try
                {
                    var response = ManagedInstanceRestClient.List(Id.SubscriptionId, expand, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ManagedInstance(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<ManagedInstance> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = ManagedInstanceClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetManagedInstances");
                scope.Start();
                try
                {
                    var response = ManagedInstanceRestClient.ListNextPage(nextLink, Id.SubscriptionId, expand, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new ManagedInstance(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/operationsHealth
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: OperationsHealth_ListByLocation
        /// <summary> Gets a service operation health status. </summary>
        /// <param name="locationName"> The name of the region where the resource is located. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="OperationsHealth" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<OperationsHealth> GetOperationsHealthsByLocationAsync(string locationName, CancellationToken cancellationToken = default)
        {
            async Task<Page<OperationsHealth>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = OperationsHealthClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetOperationsHealthsByLocation");
                scope.Start();
                try
                {
                    var response = await OperationsHealthRestClient.ListByLocationAsync(Id.SubscriptionId, locationName, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<OperationsHealth>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = OperationsHealthClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetOperationsHealthsByLocation");
                scope.Start();
                try
                {
                    var response = await OperationsHealthRestClient.ListByLocationNextPageAsync(nextLink, Id.SubscriptionId, locationName, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/operationsHealth
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: OperationsHealth_ListByLocation
        /// <summary> Gets a service operation health status. </summary>
        /// <param name="locationName"> The name of the region where the resource is located. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="OperationsHealth" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<OperationsHealth> GetOperationsHealthsByLocation(string locationName, CancellationToken cancellationToken = default)
        {
            Page<OperationsHealth> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = OperationsHealthClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetOperationsHealthsByLocation");
                scope.Start();
                try
                {
                    var response = OperationsHealthRestClient.ListByLocation(Id.SubscriptionId, locationName, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<OperationsHealth> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = OperationsHealthClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetOperationsHealthsByLocation");
                scope.Start();
                try
                {
                    var response = OperationsHealthRestClient.ListByLocationNextPage(nextLink, Id.SubscriptionId, locationName, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/syncDatabaseIds
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: SyncGroups_ListSyncDatabaseIds
        /// <summary> Gets a collection of sync database ids. </summary>
        /// <param name="locationName"> The name of the region where the resource is located. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="SubResource" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<SubResource> GetSyncDatabaseIdsSyncGroupsAsync(string locationName, CancellationToken cancellationToken = default)
        {
            async Task<Page<SubResource>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = SyncGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSyncDatabaseIdsSyncGroups");
                scope.Start();
                try
                {
                    var response = await SyncGroupRestClient.ListSyncDatabaseIdsAsync(Id.SubscriptionId, locationName, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<SubResource>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = SyncGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSyncDatabaseIdsSyncGroups");
                scope.Start();
                try
                {
                    var response = await SyncGroupRestClient.ListSyncDatabaseIdsNextPageAsync(nextLink, Id.SubscriptionId, locationName, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationName}/syncDatabaseIds
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: SyncGroups_ListSyncDatabaseIds
        /// <summary> Gets a collection of sync database ids. </summary>
        /// <param name="locationName"> The name of the region where the resource is located. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="SubResource" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<SubResource> GetSyncDatabaseIdsSyncGroups(string locationName, CancellationToken cancellationToken = default)
        {
            Page<SubResource> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = SyncGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSyncDatabaseIdsSyncGroups");
                scope.Start();
                try
                {
                    var response = SyncGroupRestClient.ListSyncDatabaseIds(Id.SubscriptionId, locationName, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<SubResource> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = SyncGroupClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSyncDatabaseIdsSyncGroups");
                scope.Start();
                try
                {
                    var response = SyncGroupRestClient.ListSyncDatabaseIdsNextPage(nextLink, Id.SubscriptionId, locationName, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/virtualClusters
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: VirtualClusters_List
        /// <summary> Gets a list of all virtualClusters in the subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="VirtualCluster" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<VirtualCluster> GetVirtualClustersAsync(CancellationToken cancellationToken = default)
        {
            async Task<Page<VirtualCluster>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualClusterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualClusters");
                scope.Start();
                try
                {
                    var response = await VirtualClusterRestClient.ListAsync(Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualCluster(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<VirtualCluster>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualClusterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualClusters");
                scope.Start();
                try
                {
                    var response = await VirtualClusterRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualCluster(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/virtualClusters
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: VirtualClusters_List
        /// <summary> Gets a list of all virtualClusters in the subscription. </summary>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="VirtualCluster" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<VirtualCluster> GetVirtualClusters(CancellationToken cancellationToken = default)
        {
            Page<VirtualCluster> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = VirtualClusterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualClusters");
                scope.Start();
                try
                {
                    var response = VirtualClusterRestClient.List(Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualCluster(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<VirtualCluster> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = VirtualClusterClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetVirtualClusters");
                scope.Start();
                try
                {
                    var response = VirtualClusterRestClient.ListNextPage(nextLink, Id.SubscriptionId, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new VirtualCluster(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/servers
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: Servers_List
        /// <summary> Gets a list of all servers in the subscription. </summary>
        /// <param name="expand"> The child resources to include in the response. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="SqlServer" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<SqlServer> GetSqlServersAsync(string expand = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<SqlServer>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = SqlServerServersClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSqlServers");
                scope.Start();
                try
                {
                    var response = await SqlServerServersRestClient.ListAsync(Id.SubscriptionId, expand, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SqlServer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            async Task<Page<SqlServer>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = SqlServerServersClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSqlServers");
                scope.Start();
                try
                {
                    var response = await SqlServerServersRestClient.ListNextPageAsync(nextLink, Id.SubscriptionId, expand, cancellationToken: cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value.Select(value => new SqlServer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/servers
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: Servers_List
        /// <summary> Gets a list of all servers in the subscription. </summary>
        /// <param name="expand"> The child resources to include in the response. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="SqlServer" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<SqlServer> GetSqlServers(string expand = null, CancellationToken cancellationToken = default)
        {
            Page<SqlServer> FirstPageFunc(int? pageSizeHint)
            {
                using var scope = SqlServerServersClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSqlServers");
                scope.Start();
                try
                {
                    var response = SqlServerServersRestClient.List(Id.SubscriptionId, expand, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SqlServer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            Page<SqlServer> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope = SqlServerServersClientDiagnostics.CreateScope("SubscriptionExtensionClient.GetSqlServers");
                scope.Start();
                try
                {
                    var response = SqlServerServersRestClient.ListNextPage(nextLink, Id.SubscriptionId, expand, cancellationToken: cancellationToken);
                    return Page.FromValues(response.Value.Value.Select(value => new SqlServer(Client, value)), response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/checkNameAvailability
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: Servers_CheckNameAvailability
        /// <summary> Determines whether a resource can be created with the specified name. </summary>
        /// <param name="parameters"> The name availability request parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async virtual Task<Response<CheckNameAvailabilityResponse>> CheckNameAvailabilityServerAsync(CheckNameAvailabilityRequest parameters, CancellationToken cancellationToken = default)
        {
            using var scope = SqlServerServersClientDiagnostics.CreateScope("SubscriptionExtensionClient.CheckNameAvailabilityServer");
            scope.Start();
            try
            {
                var response = await SqlServerServersRestClient.CheckNameAvailabilityAsync(Id.SubscriptionId, parameters, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// RequestPath: /subscriptions/{subscriptionId}/providers/Microsoft.Sql/checkNameAvailability
        /// ContextualPath: /subscriptions/{subscriptionId}
        /// OperationId: Servers_CheckNameAvailability
        /// <summary> Determines whether a resource can be created with the specified name. </summary>
        /// <param name="parameters"> The name availability request parameters. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<CheckNameAvailabilityResponse> CheckNameAvailabilityServer(CheckNameAvailabilityRequest parameters, CancellationToken cancellationToken = default)
        {
            using var scope = SqlServerServersClientDiagnostics.CreateScope("SubscriptionExtensionClient.CheckNameAvailabilityServer");
            scope.Start();
            try
            {
                var response = SqlServerServersRestClient.CheckNameAvailability(Id.SubscriptionId, parameters, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
