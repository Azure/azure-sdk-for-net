// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Azure.Core.TestFramework;
using NUnit.Framework;

namespace Azure.AI.FormRecognizer.DocumentAnalysis.Tests
{
    /// <summary>
    /// The suite of tests for the document classifier methods in the <see cref="DocumentModelAdministrationClient"/> class.
    /// </summary>
    /// <remarks>
    /// These tests have a dependency on live Azure services and may incur costs for the associated
    /// Azure subscription.
    /// </remarks>
    [ServiceVersion(Min = DocumentAnalysisClientOptions.ServiceVersion.V2023_02_28_Preview)]
    public class DocumentClassifierAdministrationLiveTests : DocumentAnalysisLiveTestBase
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DocumentClassifierAdministrationLiveTests"/> class.
        /// </summary>
        /// <param name="isAsync">A flag used by the Azure Core Test Framework to differentiate between tests for asynchronous and synchronous methods.</param>
        public DocumentClassifierAdministrationLiveTests(bool isAsync, DocumentAnalysisClientOptions.ServiceVersion serviceVersion)
            : base(isAsync, serviceVersion)
        {
        }

        #region Build

        [RecordedTest]
        public async Task BuildDocumentClassifierCanAuthenticateWithTokenCredential()
        {
            var client = CreateDocumentModelAdministrationClient(useTokenCredential: true);
            var classifierId = Recording.GenerateId();
            await using var disposableClassifier = await BuildDisposableDocumentClassifier(client, classifierId);

            // Sanity check to make sure we got an actual response back from the service.
            Assert.AreEqual(classifierId, disposableClassifier.Value.ClassifierId);
        }

        [RecordedTest]
        public async Task BuildDocumentClassifierWithAzureBlobContentSource()
        {
            var client = CreateDocumentModelAdministrationClient();
            var classifierId = Recording.GenerateId();
            var description = "This classifier was generated by a .NET test.";
            var startTime = Recording.UtcNow;

            var trainingFilesUri = new Uri(TestEnvironment.ClassifierTrainingSasUrl);
            var sourceA = new AzureBlobContentSource(trainingFilesUri) { Prefix = "IRS-1040-A/train" };
            var sourceB = new AzureBlobContentSource(trainingFilesUri) { Prefix = "IRS-1040-B/train" };

            var documentTypes = new Dictionary<string, ClassifierDocumentTypeDetails>()
            {
                { "IRS-1040-A", new ClassifierDocumentTypeDetails(sourceA) },
                { "IRS-1040-B", new ClassifierDocumentTypeDetails(sourceB) }
            };

            BuildDocumentClassifierOperation operation = null;

            try
            {
                operation = await client.BuildDocumentClassifierAsync(WaitUntil.Completed, documentTypes, classifierId, description);
            }
            finally
            {
                if (operation.HasValue)
                {
                    await client.DeleteDocumentClassifierAsync(classifierId);
                }
            }

            Assert.IsTrue(operation.HasValue);

            DocumentClassifierDetails classifier = operation.Value;

            Assert.AreEqual(classifierId, classifier.ClassifierId);
            Assert.AreEqual(description, classifier.Description);
            Assert.AreEqual(ServiceVersionString, classifier.ApiVersion);
            Assert.Greater(classifier.CreatedOn, startTime);
            Assert.Greater(classifier.ExpiresOn, classifier.CreatedOn);

            AssertDocumentTypesAreEqual(documentTypes, classifier.DocumentTypes);
        }

        [RecordedTest]
        public async Task BuildDocumentClassifierWithAzureBlobFileListSource()
        {
            var client = CreateDocumentModelAdministrationClient();
            var classifierId = Recording.GenerateId();
            var description = "This classifier was generated by a .NET test.";
            var startTime = Recording.UtcNow;

            var trainingFilesUri = new Uri(TestEnvironment.ClassifierTrainingSasUrl);
            var sourceA = new AzureBlobFileListSource(trainingFilesUri, "IRS-1040-A.jsonl");
            var sourceB = new AzureBlobFileListSource(trainingFilesUri, "IRS-1040-B.jsonl");

            var documentTypes = new Dictionary<string, ClassifierDocumentTypeDetails>()
            {
                { "IRS-1040-A", new ClassifierDocumentTypeDetails(sourceA) },
                { "IRS-1040-B", new ClassifierDocumentTypeDetails(sourceB) }
            };

            BuildDocumentClassifierOperation operation = null;

            try
            {
                operation = await client.BuildDocumentClassifierAsync(WaitUntil.Completed, documentTypes, classifierId, description);
            }
            finally
            {
                if (operation.HasValue)
                {
                    await client.DeleteDocumentClassifierAsync(classifierId);
                }
            }

            Assert.IsTrue(operation.HasValue);

            DocumentClassifierDetails classifier = operation.Value;

            Assert.AreEqual(classifierId, classifier.ClassifierId);
            Assert.AreEqual(description, classifier.Description);
            Assert.AreEqual(ServiceVersionString, classifier.ApiVersion);
            Assert.Greater(classifier.CreatedOn, startTime);
            Assert.Greater(classifier.ExpiresOn, classifier.CreatedOn);

            AssertDocumentTypesAreEqual(documentTypes, classifier.DocumentTypes);
        }

        #endregion Build

        #region Get

        [RecordedTest]
        [TestCase(true, Ignore = "https://github.com/Azure/azure-sdk-for-net/issues/35243")]
        [TestCase(false)]
        public async Task GetDocumentClassifier(bool useTokenCredential)
        {
            var client = CreateDocumentModelAdministrationClient(useTokenCredential);
            var classifierId = Recording.GenerateId();
            var description = "This classifier was generated by a .NET test.";
            await using var disposableClassifier = await BuildDisposableDocumentClassifier(client, classifierId, description);

            DocumentClassifierDetails expected = disposableClassifier.Value;
            DocumentClassifierDetails classifier = await client.GetDocumentClassifierAsync(classifierId);

            Assert.AreEqual(expected.ClassifierId, classifier.ClassifierId);
            Assert.AreEqual(expected.Description, classifier.Description);
            Assert.AreEqual(expected.ApiVersion, classifier.ApiVersion);
            Assert.AreEqual(expected.CreatedOn, classifier.CreatedOn);
            Assert.AreEqual(expected.ExpiresOn, classifier.ExpiresOn);

            AssertDocumentTypesAreEqual(expected.DocumentTypes, classifier.DocumentTypes);
        }

        [RecordedTest]
        public void GetDocumentClassifierThrowsWhenClassifierDoesNotExist()
        {
            var client = CreateDocumentModelAdministrationClient();
            var fakeId = "00000000-0000-0000-0000-000000000000";

            RequestFailedException ex = Assert.ThrowsAsync<RequestFailedException>(async () => await client.GetDocumentClassifierAsync(fakeId));
            Assert.AreEqual("NotFound", ex.ErrorCode);
        }

        #endregion Get

        #region List

        [RecordedTest]
        [TestCase(true)]
        [TestCase(false)]
        public async Task GetDocumentClassifiers(bool useTokenCredential)
        {
            var client = CreateDocumentModelAdministrationClient(useTokenCredential);
            var classifierIds = new string[] { Recording.GenerateId(), Recording.GenerateId() };
            var description = "This classifier was generated by a .NET test.";

            await using var disposableClassifier0 = await BuildDisposableDocumentClassifier(client, classifierIds[0], description);
            await using var disposableClassifier1 = await BuildDisposableDocumentClassifier(client, classifierIds[1], description);

            var idMapping = new Dictionary<string, DocumentClassifierDetails>();
            var expectedIdMapping = new Dictionary<string, DocumentClassifierDetails>()
            {
                { disposableClassifier0.Value.ClassifierId, disposableClassifier0.Value },
                { disposableClassifier1.Value.ClassifierId, disposableClassifier1.Value }
            };

            await foreach (DocumentClassifierDetails classifier in client.GetDocumentClassifiersAsync())
            {
                if (expectedIdMapping.ContainsKey(classifier.ClassifierId))
                {
                    idMapping.Add(classifier.ClassifierId, classifier);
                }

                if (idMapping.Count == expectedIdMapping.Count)
                {
                    break;
                }
            }

            foreach (string id in expectedIdMapping.Keys)
            {
                Assert.True(idMapping.ContainsKey(id));

                DocumentClassifierDetails classifier = idMapping[id];
                DocumentClassifierDetails expected = expectedIdMapping[id];

                Assert.AreEqual(expected.ClassifierId, classifier.ClassifierId);
                Assert.AreEqual(expected.Description, classifier.Description);
                Assert.AreEqual(expected.ApiVersion, classifier.ApiVersion);
                Assert.AreEqual(expected.CreatedOn, classifier.CreatedOn);
                Assert.AreEqual(expected.ExpiresOn, classifier.ExpiresOn);

                AssertDocumentTypesAreEqual(expected.DocumentTypes, classifier.DocumentTypes);
            }
        }

        #endregion

        #region Delete

        [RecordedTest]
        [TestCase(true)]
        [TestCase(false)]
        public async Task DeleteDocumentClassifier(bool useTokenCredential)
        {
            var client = CreateDocumentModelAdministrationClient(useTokenCredential);
            var classifierId = Recording.GenerateId();

            await BuildDisposableDocumentClassifier(client, classifierId);

            var response = await client.DeleteDocumentClassifierAsync(classifierId);

            Assert.AreEqual((int)HttpStatusCode.NoContent, response.Status);
        }

        [RecordedTest]
        public void DeleteDocumentClassifierThrowsWhenClassifierDoesNotExist()
        {
            var client = CreateDocumentModelAdministrationClient();
            var fakeId = "00000000-0000-0000-0000-000000000000";

            RequestFailedException ex = Assert.ThrowsAsync<RequestFailedException>(async () => await client.DeleteDocumentClassifierAsync(fakeId));
            Assert.AreEqual("NotFound", ex.ErrorCode);
        }

        #endregion Delete

        private async Task<DisposableDocumentClassifier> BuildDisposableDocumentClassifier(DocumentModelAdministrationClient client, string classifierId, string description = null)
        {
            var trainingFilesUri = new Uri(TestEnvironment.ClassifierTrainingSasUrl);
            var sourceA = new AzureBlobContentSource(trainingFilesUri) { Prefix = "IRS-1040-A/train" };
            var sourceB = new AzureBlobContentSource(trainingFilesUri) { Prefix = "IRS-1040-B/train" };
            var sourceC = new AzureBlobContentSource(trainingFilesUri) { Prefix = "IRS-1040-C/train" };
            var sourceD = new AzureBlobContentSource(trainingFilesUri) { Prefix = "IRS-1040-D/train" };
            var sourceE = new AzureBlobContentSource(trainingFilesUri) { Prefix = "IRS-1040-E/train" };

            var documentTypes = new Dictionary<string, ClassifierDocumentTypeDetails>()
            {
                { "IRS-1040-A", new ClassifierDocumentTypeDetails(sourceA) },
                { "IRS-1040-B", new ClassifierDocumentTypeDetails(sourceB) },
                { "IRS-1040-C", new ClassifierDocumentTypeDetails(sourceC) },
                { "IRS-1040-D", new ClassifierDocumentTypeDetails(sourceD) },
                { "IRS-1040-E", new ClassifierDocumentTypeDetails(sourceE) }
            };

            return await DisposableDocumentClassifier.BuildAsync(client, documentTypes, classifierId, description);
        }

        private void AssertDocumentTypesAreEqual(IReadOnlyDictionary<string, ClassifierDocumentTypeDetails> docTypes1, IReadOnlyDictionary<string, ClassifierDocumentTypeDetails> docTypes2)
        {
            Assert.AreEqual(docTypes1.Count, docTypes2.Count);

            foreach (string key in docTypes1.Keys)
            {
                ClassifierDocumentTypeDetails docType1 = docTypes1[key];
                ClassifierDocumentTypeDetails docType2 = docTypes2[key];

                if (docType1.AzureBlobSource == null)
                {
                    Assert.Null(docType2.AzureBlobSource);
                }
                else
                {
                    AzureBlobContentSource source1 = docType1.AzureBlobSource;
                    AzureBlobContentSource source2 = docType2.AzureBlobSource;

                    // The URI returned by the service does not include query parameters, so we're
                    // making sure they're not included in our comparison.
                    string uri1 = source1.ContainerUri.GetLeftPart(UriPartial.Path);
                    string uri2 = source2.ContainerUri.GetLeftPart(UriPartial.Path);

                    Assert.AreEqual(uri1, uri2);
                    Assert.AreEqual(source1.Prefix, source2.Prefix);
                }

                if (docType1.AzureBlobFileListSource == null)
                {
                    Assert.Null(docType2.AzureBlobFileListSource);
                }
                else
                {
                    AzureBlobFileListSource source1 = docType1.AzureBlobFileListSource;
                    AzureBlobFileListSource source2 = docType2.AzureBlobFileListSource;

                    // The URI returned by the service does not include query parameters, so we're
                    // making sure they're not included in our comparison.
                    string uri1 = source1.ContainerUri.GetLeftPart(UriPartial.Path);
                    string uri2 = source2.ContainerUri.GetLeftPart(UriPartial.Path);

                    Assert.AreEqual(uri1, uri2);
                    Assert.AreEqual(source1.FileList, source2.FileList);
                }
            }
        }
    }
}
