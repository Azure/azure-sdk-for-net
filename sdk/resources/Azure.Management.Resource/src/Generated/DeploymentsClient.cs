// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Management.Resource.Models;

namespace Azure.Management.Resource
{
    /// <summary> The Deployments service client. </summary>
    public partial class DeploymentsClient
    {
        private readonly ClientDiagnostics _clientDiagnostics;
        private readonly HttpPipeline _pipeline;
        internal DeploymentsRestClient RestClient { get; }
        /// <summary> Initializes a new instance of DeploymentsClient for mocking. </summary>
        protected DeploymentsClient()
        {
        }

        /// <summary> Initializes a new instance of DeploymentsClient. </summary>
        public DeploymentsClient(string subscriptionId, TokenCredential tokenCredential, ResourceManagementClientOptions options = null) : this(subscriptionId, "https://management.azure.com", tokenCredential, options)
        {
        }

        /// <summary> Initializes a new instance of DeploymentsClient. </summary>
        public DeploymentsClient(string subscriptionId, string host, TokenCredential tokenCredential, ResourceManagementClientOptions options = null)
        {
            options ??= new ResourceManagementClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _pipeline = ManagementPipelineBuilder.Build(tokenCredential, host, options);
            RestClient = new DeploymentsRestClient(_clientDiagnostics, _pipeline, subscriptionId: subscriptionId, host: host);
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistenceAtScope");
            scope0.Start();
            try
            {
                return await RestClient.CheckExistenceAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistenceAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistenceAtScope");
            scope0.Start();
            try
            {
                return RestClient.CheckExistenceAtScope(scope, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.GetAtScope");
            scope0.Start();
            try
            {
                return await RestClient.GetAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> GetAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.GetAtScope");
            scope0.Start();
            try
            {
                return RestClient.GetAtScope(scope, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CancelAtScope");
            scope0.Start();
            try
            {
                return await RestClient.CancelAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CancelAtScope");
            scope0.Start();
            try
            {
                return RestClient.CancelAtScope(scope, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplateAtScope");
            scope0.Start();
            try
            {
                return await RestClient.ExportTemplateAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplateAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplateAtScope");
            scope0.Start();
            try
            {
                return RestClient.ExportTemplateAtScope(scope, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistenceAtTenantScope");
            scope0.Start();
            try
            {
                return await RestClient.CheckExistenceAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistenceAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistenceAtTenantScope");
            scope0.Start();
            try
            {
                return RestClient.CheckExistenceAtTenantScope(deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.GetAtTenantScope");
            scope0.Start();
            try
            {
                return await RestClient.GetAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> GetAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.GetAtTenantScope");
            scope0.Start();
            try
            {
                return RestClient.GetAtTenantScope(deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CancelAtTenantScope");
            scope0.Start();
            try
            {
                return await RestClient.CancelAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CancelAtTenantScope");
            scope0.Start();
            try
            {
                return RestClient.CancelAtTenantScope(deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplateAtTenantScope");
            scope0.Start();
            try
            {
                return await RestClient.ExportTemplateAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplateAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplateAtTenantScope");
            scope0.Start();
            try
            {
                return RestClient.ExportTemplateAtTenantScope(deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistenceAtManagementGroupScope");
            scope0.Start();
            try
            {
                return await RestClient.CheckExistenceAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistenceAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistenceAtManagementGroupScope");
            scope0.Start();
            try
            {
                return RestClient.CheckExistenceAtManagementGroupScope(groupId, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.GetAtManagementGroupScope");
            scope0.Start();
            try
            {
                return await RestClient.GetAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> GetAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.GetAtManagementGroupScope");
            scope0.Start();
            try
            {
                return RestClient.GetAtManagementGroupScope(groupId, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CancelAtManagementGroupScope");
            scope0.Start();
            try
            {
                return await RestClient.CancelAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CancelAtManagementGroupScope");
            scope0.Start();
            try
            {
                return RestClient.CancelAtManagementGroupScope(groupId, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplateAtManagementGroupScope");
            scope0.Start();
            try
            {
                return await RestClient.ExportTemplateAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplateAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplateAtManagementGroupScope");
            scope0.Start();
            try
            {
                return RestClient.ExportTemplateAtManagementGroupScope(groupId, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistenceAtSubscriptionScope");
            scope0.Start();
            try
            {
                return await RestClient.CheckExistenceAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistenceAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistenceAtSubscriptionScope");
            scope0.Start();
            try
            {
                return RestClient.CheckExistenceAtSubscriptionScope(deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.GetAtSubscriptionScope");
            scope0.Start();
            try
            {
                return await RestClient.GetAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> GetAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.GetAtSubscriptionScope");
            scope0.Start();
            try
            {
                return RestClient.GetAtSubscriptionScope(deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CancelAtSubscriptionScope");
            scope0.Start();
            try
            {
                return await RestClient.CancelAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resources partially deployed. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CancelAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CancelAtSubscriptionScope");
            scope0.Start();
            try
            {
                return RestClient.CancelAtSubscriptionScope(deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplateAtSubscriptionScope");
            scope0.Start();
            try
            {
                return await RestClient.ExportTemplateAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplateAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplateAtSubscriptionScope");
            scope0.Start();
            try
            {
                return RestClient.ExportTemplateAtSubscriptionScope(deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployment to check. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CheckExistenceAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistence");
            scope0.Start();
            try
            {
                return await RestClient.CheckExistenceAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Checks whether the deployment exists. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployment to check. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response CheckExistence(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CheckExistence");
            scope0.Start();
            try
            {
                return RestClient.CheckExistence(resourceGroupName, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExtended>> GetAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.Get");
            scope0.Start();
            try
            {
                return await RestClient.GetAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a deployment. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExtended> Get(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.Get");
            scope0.Start();
            try
            {
                return RestClient.Get(resourceGroupName, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response> CancelAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.Cancel");
            scope0.Start();
            try
            {
                return await RestClient.CancelAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is set to Canceled. Canceling a template deployment stops the currently running template deployment and leaves the resource group partially deployed. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response Cancel(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.Cancel");
            scope0.Start();
            try
            {
                return RestClient.Cancel(resourceGroupName, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<DeploymentExportResult>> ExportTemplateAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplate");
            scope0.Start();
            try
            {
                return await RestClient.ExportTemplateAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Exports the template used for specified deployment. </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<DeploymentExportResult> ExportTemplate(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ExportTemplate");
            scope0.Start();
            try
            {
                return RestClient.ExportTemplate(resourceGroupName, deploymentName, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Calculate the hash of the given template. </summary>
        /// <param name="template"> The template provided to calculate hash. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<TemplateHashResult>> CalculateTemplateHashAsync(object template, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CalculateTemplateHash");
            scope0.Start();
            try
            {
                return await RestClient.CalculateTemplateHashAsync(template, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Calculate the hash of the given template. </summary>
        /// <param name="template"> The template provided to calculate hash. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<TemplateHashResult> CalculateTemplateHash(object template, CancellationToken cancellationToken = default)
        {
            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.CalculateTemplateHash");
            scope0.Start();
            try
            {
                return RestClient.CalculateTemplateHash(template, cancellationToken);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Get all the deployments at the given scope. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListAtScopeAsync(string scope, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }

            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtScope");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListAtScopeAsync(scope, filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtScope");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListAtScopeNextPageAsync(nextLink, scope, filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments at the given scope. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListAtScope(string scope, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }

            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtScope");
                scope0.Start();
                try
                {
                    var response = RestClient.ListAtScope(scope, filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtScope");
                scope0.Start();
                try
                {
                    var response = RestClient.ListAtScopeNextPage(nextLink, scope, filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments at the tenant scope. </summary>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListAtTenantScopeAsync(string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtTenantScope");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListAtTenantScopeAsync(filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtTenantScope");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListAtTenantScopeNextPageAsync(nextLink, filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments at the tenant scope. </summary>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListAtTenantScope(string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtTenantScope");
                scope0.Start();
                try
                {
                    var response = RestClient.ListAtTenantScope(filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtTenantScope");
                scope0.Start();
                try
                {
                    var response = RestClient.ListAtTenantScopeNextPage(nextLink, filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a management group. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListAtManagementGroupScopeAsync(string groupId, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }

            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtManagementGroupScope");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListAtManagementGroupScopeAsync(groupId, filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtManagementGroupScope");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListAtManagementGroupScopeNextPageAsync(nextLink, groupId, filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a management group. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListAtManagementGroupScope(string groupId, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }

            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtManagementGroupScope");
                scope0.Start();
                try
                {
                    var response = RestClient.ListAtManagementGroupScope(groupId, filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtManagementGroupScope");
                scope0.Start();
                try
                {
                    var response = RestClient.ListAtManagementGroupScopeNextPage(nextLink, groupId, filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a subscription. </summary>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListAtSubscriptionScopeAsync(string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtSubscriptionScope");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListAtSubscriptionScopeAsync(filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtSubscriptionScope");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListAtSubscriptionScopeNextPageAsync(nextLink, filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a subscription. </summary>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListAtSubscriptionScope(string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtSubscriptionScope");
                scope0.Start();
                try
                {
                    var response = RestClient.ListAtSubscriptionScope(filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListAtSubscriptionScope");
                scope0.Start();
                try
                {
                    var response = RestClient.ListAtSubscriptionScopeNextPage(nextLink, filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a resource group. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployments to get. The name is case insensitive. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual AsyncPageable<DeploymentExtended> ListByResourceGroupAsync(string resourceGroupName, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }

            async Task<Page<DeploymentExtended>> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListByResourceGroup");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListByResourceGroupAsync(resourceGroupName, filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            async Task<Page<DeploymentExtended>> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListByResourceGroup");
                scope0.Start();
                try
                {
                    var response = await RestClient.ListByResourceGroupNextPageAsync(nextLink, resourceGroupName, filter, top, cancellationToken).ConfigureAwait(false);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateAsyncEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> Get all the deployments for a resource group. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployments to get. The name is case insensitive. </param>
        /// <param name="filter"> The filter to apply on the operation. For example, you can use $filter=provisioningState eq &apos;{state}&apos;. </param>
        /// <param name="top"> The number of results to get. If null is passed, returns all deployments. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Pageable<DeploymentExtended> ListByResourceGroup(string resourceGroupName, string filter = null, int? top = null, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }

            Page<DeploymentExtended> FirstPageFunc(int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListByResourceGroup");
                scope0.Start();
                try
                {
                    var response = RestClient.ListByResourceGroup(resourceGroupName, filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            Page<DeploymentExtended> NextPageFunc(string nextLink, int? pageSizeHint)
            {
                using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.ListByResourceGroup");
                scope0.Start();
                try
                {
                    var response = RestClient.ListByResourceGroupNextPage(nextLink, resourceGroupName, filter, top, cancellationToken);
                    return Page.FromValues(response.Value.Value, response.Value.NextLink, response.GetRawResponse());
                }
                catch (Exception e)
                {
                    scope0.Failed(e);
                    throw;
                }
            }
            return PageableHelpers.CreateEnumerable(FirstPageFunc, NextPageFunc);
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsDeleteAtScopeOperation> StartDeleteAtScopeAsync(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDeleteAtScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.DeleteAtScopeAsync(scope, deploymentName, cancellationToken).ConfigureAwait(false);
                return new DeploymentsDeleteAtScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteAtScopeRequest(scope, deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsDeleteAtScopeOperation StartDeleteAtScope(string scope, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDeleteAtScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.DeleteAtScope(scope, deploymentName, cancellationToken);
                return new DeploymentsDeleteAtScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteAtScopeRequest(scope, deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsCreateOrUpdateAtScopeOperation> StartCreateOrUpdateAtScopeAsync(string scope, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdateAtScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.CreateOrUpdateAtScopeAsync(scope, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsCreateOrUpdateAtScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateAtScopeRequest(scope, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsCreateOrUpdateAtScopeOperation StartCreateOrUpdateAtScope(string scope, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdateAtScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.CreateOrUpdateAtScope(scope, deploymentName, parameters, cancellationToken);
                return new DeploymentsCreateOrUpdateAtScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateAtScopeRequest(scope, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsValidateAtScopeOperation> StartValidateAtScopeAsync(string scope, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidateAtScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.ValidateAtScopeAsync(scope, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsValidateAtScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateAtScopeRequest(scope, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="scope"> The resource scope. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsValidateAtScopeOperation StartValidateAtScope(string scope, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (scope == null)
            {
                throw new ArgumentNullException(nameof(scope));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidateAtScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.ValidateAtScope(scope, deploymentName, parameters, cancellationToken);
                return new DeploymentsValidateAtScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateAtScopeRequest(scope, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsDeleteAtTenantScopeOperation> StartDeleteAtTenantScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDeleteAtTenantScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.DeleteAtTenantScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
                return new DeploymentsDeleteAtTenantScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteAtTenantScopeRequest(deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsDeleteAtTenantScopeOperation StartDeleteAtTenantScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDeleteAtTenantScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.DeleteAtTenantScope(deploymentName, cancellationToken);
                return new DeploymentsDeleteAtTenantScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteAtTenantScopeRequest(deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsCreateOrUpdateAtTenantScopeOperation> StartCreateOrUpdateAtTenantScopeAsync(string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdateAtTenantScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.CreateOrUpdateAtTenantScopeAsync(deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsCreateOrUpdateAtTenantScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateAtTenantScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsCreateOrUpdateAtTenantScopeOperation StartCreateOrUpdateAtTenantScope(string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdateAtTenantScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.CreateOrUpdateAtTenantScope(deploymentName, parameters, cancellationToken);
                return new DeploymentsCreateOrUpdateAtTenantScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateAtTenantScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsValidateAtTenantScopeOperation> StartValidateAtTenantScopeAsync(string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidateAtTenantScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.ValidateAtTenantScopeAsync(deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsValidateAtTenantScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateAtTenantScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsValidateAtTenantScopeOperation StartValidateAtTenantScope(string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidateAtTenantScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.ValidateAtTenantScope(deploymentName, parameters, cancellationToken);
                return new DeploymentsValidateAtTenantScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateAtTenantScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsDeleteAtManagementGroupScopeOperation> StartDeleteAtManagementGroupScopeAsync(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDeleteAtManagementGroupScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.DeleteAtManagementGroupScopeAsync(groupId, deploymentName, cancellationToken).ConfigureAwait(false);
                return new DeploymentsDeleteAtManagementGroupScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteAtManagementGroupScopeRequest(groupId, deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsDeleteAtManagementGroupScopeOperation StartDeleteAtManagementGroupScope(string groupId, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDeleteAtManagementGroupScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.DeleteAtManagementGroupScope(groupId, deploymentName, cancellationToken);
                return new DeploymentsDeleteAtManagementGroupScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteAtManagementGroupScopeRequest(groupId, deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsCreateOrUpdateAtManagementGroupScopeOperation> StartCreateOrUpdateAtManagementGroupScopeAsync(string groupId, string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdateAtManagementGroupScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.CreateOrUpdateAtManagementGroupScopeAsync(groupId, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsCreateOrUpdateAtManagementGroupScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateAtManagementGroupScopeRequest(groupId, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsCreateOrUpdateAtManagementGroupScopeOperation StartCreateOrUpdateAtManagementGroupScope(string groupId, string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdateAtManagementGroupScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.CreateOrUpdateAtManagementGroupScope(groupId, deploymentName, parameters, cancellationToken);
                return new DeploymentsCreateOrUpdateAtManagementGroupScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateAtManagementGroupScopeRequest(groupId, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsValidateAtManagementGroupScopeOperation> StartValidateAtManagementGroupScopeAsync(string groupId, string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidateAtManagementGroupScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.ValidateAtManagementGroupScopeAsync(groupId, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsValidateAtManagementGroupScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateAtManagementGroupScopeRequest(groupId, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="groupId"> The management group ID. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsValidateAtManagementGroupScopeOperation StartValidateAtManagementGroupScope(string groupId, string deploymentName, ScopedDeployment parameters, CancellationToken cancellationToken = default)
        {
            if (groupId == null)
            {
                throw new ArgumentNullException(nameof(groupId));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidateAtManagementGroupScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.ValidateAtManagementGroupScope(groupId, deploymentName, parameters, cancellationToken);
                return new DeploymentsValidateAtManagementGroupScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateAtManagementGroupScopeRequest(groupId, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsDeleteAtSubscriptionScopeOperation> StartDeleteAtSubscriptionScopeAsync(string deploymentName, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDeleteAtSubscriptionScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.DeleteAtSubscriptionScopeAsync(deploymentName, cancellationToken).ConfigureAwait(false);
                return new DeploymentsDeleteAtSubscriptionScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteAtSubscriptionScopeRequest(deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsDeleteAtSubscriptionScopeOperation StartDeleteAtSubscriptionScope(string deploymentName, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDeleteAtSubscriptionScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.DeleteAtSubscriptionScope(deploymentName, cancellationToken);
                return new DeploymentsDeleteAtSubscriptionScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteAtSubscriptionScopeRequest(deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsCreateOrUpdateAtSubscriptionScopeOperation> StartCreateOrUpdateAtSubscriptionScopeAsync(string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdateAtSubscriptionScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.CreateOrUpdateAtSubscriptionScopeAsync(deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsCreateOrUpdateAtSubscriptionScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateAtSubscriptionScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsCreateOrUpdateAtSubscriptionScopeOperation StartCreateOrUpdateAtSubscriptionScope(string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdateAtSubscriptionScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.CreateOrUpdateAtSubscriptionScope(deploymentName, parameters, cancellationToken);
                return new DeploymentsCreateOrUpdateAtSubscriptionScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateAtSubscriptionScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsValidateAtSubscriptionScopeOperation> StartValidateAtSubscriptionScopeAsync(string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidateAtSubscriptionScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.ValidateAtSubscriptionScopeAsync(deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsValidateAtSubscriptionScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateAtSubscriptionScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsValidateAtSubscriptionScopeOperation StartValidateAtSubscriptionScope(string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidateAtSubscriptionScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.ValidateAtSubscriptionScope(deploymentName, parameters, cancellationToken);
                return new DeploymentsValidateAtSubscriptionScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateAtSubscriptionScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the subscription. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to What If. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsWhatIfAtSubscriptionScopeOperation> StartWhatIfAtSubscriptionScopeAsync(string deploymentName, DeploymentWhatIf parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartWhatIfAtSubscriptionScope");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.WhatIfAtSubscriptionScopeAsync(deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsWhatIfAtSubscriptionScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateWhatIfAtSubscriptionScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the subscription. </summary>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to What If. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsWhatIfAtSubscriptionScopeOperation StartWhatIfAtSubscriptionScope(string deploymentName, DeploymentWhatIf parameters, CancellationToken cancellationToken = default)
        {
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartWhatIfAtSubscriptionScope");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.WhatIfAtSubscriptionScope(deploymentName, parameters, cancellationToken);
                return new DeploymentsWhatIfAtSubscriptionScopeOperation(_clientDiagnostics, _pipeline, RestClient.CreateWhatIfAtSubscriptionScopeRequest(deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployment to delete. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsDeleteOperation> StartDeleteAsync(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDelete");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.DeleteAsync(resourceGroupName, deploymentName, cancellationToken).ConfigureAwait(false);
                return new DeploymentsDeleteOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteRequest(resourceGroupName, deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations. Deleting a template deployment does not affect the state of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code. </summary>
        /// <param name="resourceGroupName"> The name of the resource group with the deployment to delete. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsDeleteOperation StartDelete(string resourceGroupName, string deploymentName, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartDelete");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.Delete(resourceGroupName, deploymentName, cancellationToken);
                return new DeploymentsDeleteOperation(_clientDiagnostics, _pipeline, RestClient.CreateDeleteRequest(resourceGroupName, deploymentName).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="resourceGroupName"> The name of the resource group to deploy the resources to. The name is case insensitive. The resource group must already exist. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsCreateOrUpdateOperation> StartCreateOrUpdateAsync(string resourceGroupName, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdate");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.CreateOrUpdateAsync(resourceGroupName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsCreateOrUpdateOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateRequest(resourceGroupName, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> You can provide the template and parameters directly in the request or link to JSON files. </summary>
        /// <param name="resourceGroupName"> The name of the resource group to deploy the resources to. The name is case insensitive. The resource group must already exist. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Additional parameters supplied to the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsCreateOrUpdateOperation StartCreateOrUpdate(string resourceGroupName, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartCreateOrUpdate");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.CreateOrUpdate(resourceGroupName, deploymentName, parameters, cancellationToken);
                return new DeploymentsCreateOrUpdateOperation(_clientDiagnostics, _pipeline, RestClient.CreateCreateOrUpdateRequest(resourceGroupName, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="resourceGroupName"> The name of the resource group the template will be deployed to. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsValidateOperation> StartValidateAsync(string resourceGroupName, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidate");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.ValidateAsync(resourceGroupName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsValidateOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateRequest(resourceGroupName, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager.. </summary>
        /// <param name="resourceGroupName"> The name of the resource group the template will be deployed to. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsValidateOperation StartValidate(string resourceGroupName, string deploymentName, Deployment parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartValidate");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.Validate(resourceGroupName, deploymentName, parameters, cancellationToken);
                return new DeploymentsValidateOperation(_clientDiagnostics, _pipeline, RestClient.CreateValidateRequest(resourceGroupName, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the resource group. </summary>
        /// <param name="resourceGroupName"> The name of the resource group the template will be deployed to. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async ValueTask<DeploymentsWhatIfOperation> StartWhatIfAsync(string resourceGroupName, string deploymentName, DeploymentWhatIf parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartWhatIf");
            scope0.Start();
            try
            {
                var originalResponse = await RestClient.WhatIfAsync(resourceGroupName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                return new DeploymentsWhatIfOperation(_clientDiagnostics, _pipeline, RestClient.CreateWhatIfRequest(resourceGroupName, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }

        /// <summary> Returns changes that will be made by the deployment if executed at the scope of the resource group. </summary>
        /// <param name="resourceGroupName"> The name of the resource group the template will be deployed to. The name is case insensitive. </param>
        /// <param name="deploymentName"> The name of the deployment. </param>
        /// <param name="parameters"> Parameters to validate. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual DeploymentsWhatIfOperation StartWhatIf(string resourceGroupName, string deploymentName, DeploymentWhatIf parameters, CancellationToken cancellationToken = default)
        {
            if (resourceGroupName == null)
            {
                throw new ArgumentNullException(nameof(resourceGroupName));
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException(nameof(deploymentName));
            }
            if (parameters == null)
            {
                throw new ArgumentNullException(nameof(parameters));
            }

            using var scope0 = _clientDiagnostics.CreateScope("DeploymentsClient.StartWhatIf");
            scope0.Start();
            try
            {
                var originalResponse = RestClient.WhatIf(resourceGroupName, deploymentName, parameters, cancellationToken);
                return new DeploymentsWhatIfOperation(_clientDiagnostics, _pipeline, RestClient.CreateWhatIfRequest(resourceGroupName, deploymentName, parameters).Request, originalResponse);
            }
            catch (Exception e)
            {
                scope0.Failed(e);
                throw;
            }
        }
    }
}
