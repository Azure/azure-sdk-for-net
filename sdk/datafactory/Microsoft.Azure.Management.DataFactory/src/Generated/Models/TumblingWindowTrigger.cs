// <auto-generated>
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Microsoft.Azure.Management.DataFactory.Models
{
    using Microsoft.Rest;
    using Microsoft.Rest.Serialization;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Trigger that schedules pipeline runs for all fixed time interval
    /// windows from a start time without gaps and also supports backfill
    /// scenarios (when start time is in the past).
    /// </summary>
    [Rest.Serialization.JsonTransformation]
    public partial class TumblingWindowTrigger : Trigger
    {
        /// <summary>
        /// Initializes a new instance of the TumblingWindowTrigger class.
        /// </summary>
        public TumblingWindowTrigger()
        {
            Pipeline = new TriggerPipelineReference();
            CustomInit();
        }

        /// <summary>
        /// Initializes a new instance of the TumblingWindowTrigger class.
        /// </summary>
        /// <param name="pipeline">Pipeline for which runs are created when an
        /// event is fired for trigger window that is ready.</param>
        /// <param name="frequency">The frequency of the time windows. Possible
        /// values include: 'Minute', 'Hour', 'Month'</param>
        /// <param name="interval">The interval of the time windows. The
        /// minimum interval allowed is 15 Minutes.</param>
        /// <param name="startTime">The start time for the time period for the
        /// trigger during which events are fired for windows that are ready.
        /// Only UTC time is currently supported.</param>
        /// <param name="maxConcurrency">The max number of parallel time
        /// windows (ready for execution) for which a new run is
        /// triggered.</param>
        /// <param name="additionalProperties">Unmatched properties from the
        /// message are deserialized this collection</param>
        /// <param name="description">Trigger description.</param>
        /// <param name="runtimeState">Indicates if trigger is running or not.
        /// Updated when Start/Stop APIs are called on the Trigger. Possible
        /// values include: 'Started', 'Stopped', 'Disabled'</param>
        /// <param name="annotations">List of tags that can be used for
        /// describing the trigger.</param>
        /// <param name="endTime">The end time for the time period for the
        /// trigger during which events are fired for windows that are ready.
        /// Only UTC time is currently supported.</param>
        /// <param name="delay">Specifies how long the trigger waits past due
        /// time before triggering new run. It doesn't alter window start and
        /// end time. The default is 0. Type: string (or Expression with
        /// resultType string), pattern:
        /// ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).</param>
        /// <param name="retryPolicy">Retry policy that will be applied for
        /// failed pipeline runs.</param>
        /// <param name="dependsOn">Triggers that this trigger depends on. Only
        /// tumbling window triggers are supported.</param>
        public TumblingWindowTrigger(TriggerPipelineReference pipeline, string frequency, int interval, System.DateTime startTime, int maxConcurrency, IDictionary<string, object> additionalProperties = default(IDictionary<string, object>), string description = default(string), string runtimeState = default(string), IList<object> annotations = default(IList<object>), System.DateTime? endTime = default(System.DateTime?), object delay = default(object), RetryPolicy retryPolicy = default(RetryPolicy), IList<DependencyReference> dependsOn = default(IList<DependencyReference>))
            : base(additionalProperties, description, runtimeState, annotations)
        {
            Pipeline = pipeline;
            Frequency = frequency;
            Interval = interval;
            StartTime = startTime;
            EndTime = endTime;
            Delay = delay;
            MaxConcurrency = maxConcurrency;
            RetryPolicy = retryPolicy;
            DependsOn = dependsOn;
            CustomInit();
        }

        /// <summary>
        /// An initialization method that performs custom operations like setting defaults
        /// </summary>
        partial void CustomInit();

        /// <summary>
        /// Gets or sets pipeline for which runs are created when an event is
        /// fired for trigger window that is ready.
        /// </summary>
        [JsonProperty(PropertyName = "pipeline")]
        public TriggerPipelineReference Pipeline { get; set; }

        /// <summary>
        /// Gets or sets the frequency of the time windows. Possible values
        /// include: 'Minute', 'Hour', 'Month'
        /// </summary>
        [JsonProperty(PropertyName = "typeProperties.frequency")]
        public string Frequency { get; set; }

        /// <summary>
        /// Gets or sets the interval of the time windows. The minimum interval
        /// allowed is 15 Minutes.
        /// </summary>
        [JsonProperty(PropertyName = "typeProperties.interval")]
        public int Interval { get; set; }

        /// <summary>
        /// Gets or sets the start time for the time period for the trigger
        /// during which events are fired for windows that are ready. Only UTC
        /// time is currently supported.
        /// </summary>
        [JsonProperty(PropertyName = "typeProperties.startTime")]
        public System.DateTime StartTime { get; set; }

        /// <summary>
        /// Gets or sets the end time for the time period for the trigger
        /// during which events are fired for windows that are ready. Only UTC
        /// time is currently supported.
        /// </summary>
        [JsonProperty(PropertyName = "typeProperties.endTime")]
        public System.DateTime? EndTime { get; set; }

        /// <summary>
        /// Gets or sets specifies how long the trigger waits past due time
        /// before triggering new run. It doesn't alter window start and end
        /// time. The default is 0. Type: string (or Expression with resultType
        /// string), pattern:
        /// ((\d+)\.)?(\d\d):(60|([0-5][0-9])):(60|([0-5][0-9])).
        /// </summary>
        [JsonProperty(PropertyName = "typeProperties.delay")]
        public object Delay { get; set; }

        /// <summary>
        /// Gets or sets the max number of parallel time windows (ready for
        /// execution) for which a new run is triggered.
        /// </summary>
        [JsonProperty(PropertyName = "typeProperties.maxConcurrency")]
        public int MaxConcurrency { get; set; }

        /// <summary>
        /// Gets or sets retry policy that will be applied for failed pipeline
        /// runs.
        /// </summary>
        [JsonProperty(PropertyName = "typeProperties.retryPolicy")]
        public RetryPolicy RetryPolicy { get; set; }

        /// <summary>
        /// Gets or sets triggers that this trigger depends on. Only tumbling
        /// window triggers are supported.
        /// </summary>
        [JsonProperty(PropertyName = "typeProperties.dependsOn")]
        public IList<DependencyReference> DependsOn { get; set; }

        /// <summary>
        /// Validate the object.
        /// </summary>
        /// <exception cref="ValidationException">
        /// Thrown if validation fails
        /// </exception>
        public virtual void Validate()
        {
            if (Pipeline == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Pipeline");
            }
            if (Frequency == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "Frequency");
            }
            if (Pipeline != null)
            {
                Pipeline.Validate();
            }
            if (MaxConcurrency > 50)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "MaxConcurrency", 50);
            }
            if (MaxConcurrency < 1)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "MaxConcurrency", 1);
            }
            if (RetryPolicy != null)
            {
                RetryPolicy.Validate();
            }
        }
    }
}
