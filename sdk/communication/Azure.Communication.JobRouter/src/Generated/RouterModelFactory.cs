// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Linq;
using Azure.Communication.JobRouter;

namespace Azure.Communication.JobRouter.Models
{
    /// <summary> Model factory for generated models. </summary>
    public static partial class RouterModelFactory
    {
        /// <summary> Initializes a new instance of ClassificationPolicy. </summary>
        /// <param name="id"> Unique identifier of this policy. </param>
        /// <param name="name"> Friendly name of this policy. </param>
        /// <param name="fallbackQueueId"> The fallback queue to select if the queue selector doesn&apos;t find a match. </param>
        /// <param name="queueSelectors">
        /// The queue selectors to resolve a queue for a given job.
        /// Please note <see cref="QueueSelectorAttachment"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ConditionalQueueSelectorAttachment"/>, <see cref="PassThroughQueueSelectorAttachment"/>, <see cref="RuleEngineQueueSelectorAttachment"/>, <see cref="StaticQueueSelectorAttachment"/> and <see cref="WeightedAllocationQueueSelectorAttachment"/>.
        /// </param>
        /// <param name="prioritizationRule">
        /// A rule of one of the following types:
        ///             
        /// StaticRule:  A rule providing static rules that always return the same result, regardless of input.
        /// DirectMapRule:  A rule that return the same labels as the input labels.
        /// ExpressionRule: A rule providing inline expression rules.
        /// AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
        /// Please note <see cref="RouterRule"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="FunctionRule"/>, <see cref="DirectMapRule"/>, <see cref="ExpressionRule"/> and <see cref="StaticRule"/>.
        /// </param>
        /// <param name="workerSelectors">
        /// The worker label selectors to attach to a given job.
        /// Please note <see cref="WorkerSelectorAttachment"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="ConditionalWorkerSelectorAttachment"/>, <see cref="PassThroughWorkerSelectorAttachment"/>, <see cref="RuleEngineWorkerSelectorAttachment"/>, <see cref="StaticWorkerSelectorAttachment"/> and <see cref="WeightedAllocationWorkerSelectorAttachment"/>.
        /// </param>
        /// <returns> A new <see cref="Models.ClassificationPolicy"/> instance for mocking. </returns>
        public static ClassificationPolicy ClassificationPolicy(string id = null, string name = null, string fallbackQueueId = null, IEnumerable<QueueSelectorAttachment> queueSelectors = null, RouterRule prioritizationRule = null, IEnumerable<WorkerSelectorAttachment> workerSelectors = null)
        {
            queueSelectors ??= new List<QueueSelectorAttachment>();
            workerSelectors ??= new List<WorkerSelectorAttachment>();

            return new ClassificationPolicy(id, name, fallbackQueueId, queueSelectors?.ToList(), prioritizationRule, workerSelectors?.ToList());
        }

        /// <summary> Initializes a new instance of QueueSelectorAttachment. </summary>
        /// <param name="kind"> The type discriminator describing the type of label selector attachment. </param>
        /// <returns> A new <see cref="JobRouter.QueueSelectorAttachment"/> instance for mocking. </returns>
        public static QueueSelectorAttachment QueueSelectorAttachment(string kind = null)
        {
            return new UnknownQueueSelectorAttachment(kind);
        }

        /// <summary> Initializes a new instance of RouterRule. </summary>
        /// <param name="kind"> The type discriminator describing a sub-type of Rule. </param>
        /// <returns> A new <see cref="JobRouter.RouterRule"/> instance for mocking. </returns>
        public static RouterRule RouterRule(string kind = null)
        {
            return new UnknownRouterRule(kind);
        }

        /// <summary> Initializes a new instance of WorkerSelectorAttachment. </summary>
        /// <param name="kind"> The type discriminator describing the type of label selector attachment. </param>
        /// <returns> A new <see cref="JobRouter.WorkerSelectorAttachment"/> instance for mocking. </returns>
        public static WorkerSelectorAttachment WorkerSelectorAttachment(string kind = null)
        {
            return new UnknownWorkerSelectorAttachment(kind);
        }

        /// <summary> Initializes a new instance of JobRouterError. </summary>
        /// <param name="code"> The error code. </param>
        /// <param name="message"> The error message. </param>
        /// <param name="target"> The error target. </param>
        /// <param name="details"> Further details about specific errors that led to this error. </param>
        /// <param name="innerError"> The inner error if any. </param>
        /// <returns> A new <see cref="Models.JobRouterError"/> instance for mocking. </returns>
        public static JobRouterError JobRouterError(string code = null, string message = null, string target = null, IEnumerable<JobRouterError> details = null, JobRouterError innerError = null)
        {
            details ??= new List<JobRouterError>();

            return new JobRouterError(code, message, target, details?.ToList(), innerError);
        }

        /// <summary> Initializes a new instance of ClassificationPolicyItem. </summary>
        /// <param name="classificationPolicy"> A container for the rules that govern how jobs are classified. </param>
        /// <param name="etag"> (Optional) The Concurrency Token. </param>
        /// <returns> A new <see cref="Models.ClassificationPolicyItem"/> instance for mocking. </returns>
        public static ClassificationPolicyItem ClassificationPolicyItem(ClassificationPolicy classificationPolicy = null, string etag = null)
        {
            return new ClassificationPolicyItem(classificationPolicy, etag);
        }

        /// <summary> Initializes a new instance of DistributionPolicy. </summary>
        /// <param name="id"> The unique identifier of the policy. </param>
        /// <param name="name"> The human readable name of the policy. </param>
        /// <param name="offerTtlSeconds"> The expiry time of any offers created under this policy will be governed by the offer time to live. </param>
        /// <param name="mode">
        /// Abstract base class for defining a distribution mode
        /// Please note <see cref="DistributionMode"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="BestWorkerMode"/>, <see cref="LongestIdleMode"/> and <see cref="RoundRobinMode"/>.
        /// </param>
        /// <returns> A new <see cref="Models.DistributionPolicy"/> instance for mocking. </returns>
        public static DistributionPolicy DistributionPolicy(string id = null, string name = null, double? offerTtlSeconds = null, DistributionMode mode = null)
        {
            return new DistributionPolicy(id, name, offerTtlSeconds, mode);
        }

        /// <summary> Initializes a new instance of DistributionMode. </summary>
        /// <param name="kind"> The type discriminator describing a sub-type of Mode. </param>
        /// <param name="minConcurrentOffers"> Governs the minimum desired number of active concurrent offers a job can have. </param>
        /// <param name="maxConcurrentOffers"> Governs the maximum number of active concurrent offers a job can have. </param>
        /// <param name="bypassSelectors">
        /// (Optional)
        /// If set to true, then router will match workers to jobs even if they don&apos;t match label selectors.
        /// Warning: You may get workers that are not qualified for the job they are matched with if you set this
        /// variable to true. This flag is intended more for temporary usage.
        /// By default, set to false.
        /// </param>
        /// <returns> A new <see cref="JobRouter.DistributionMode"/> instance for mocking. </returns>
        public static DistributionMode DistributionMode(string kind = null, int minConcurrentOffers = default, int maxConcurrentOffers = default, bool? bypassSelectors = null)
        {
            return new UnknownDistributionMode(kind, minConcurrentOffers, maxConcurrentOffers, bypassSelectors);
        }

        /// <summary> Initializes a new instance of DistributionPolicyItem. </summary>
        /// <param name="distributionPolicy"> Policy governing how jobs are distributed to workers. </param>
        /// <param name="etag"> (Optional) The Concurrency Token. </param>
        /// <returns> A new <see cref="Models.DistributionPolicyItem"/> instance for mocking. </returns>
        public static DistributionPolicyItem DistributionPolicyItem(DistributionPolicy distributionPolicy = null, string etag = null)
        {
            return new DistributionPolicyItem(distributionPolicy, etag);
        }

        /// <summary> Initializes a new instance of ExceptionPolicy. </summary>
        /// <param name="id"> The Id of the exception policy. </param>
        /// <param name="name"> (Optional) The name of the exception policy. </param>
        /// <param name="exceptionRules"> (Optional) A dictionary collection of exception rules on the exception policy. Key is the Id of each exception rule. </param>
        /// <returns> A new <see cref="Models.ExceptionPolicy"/> instance for mocking. </returns>
        public static ExceptionPolicy ExceptionPolicy(string id = null, string name = null, IDictionary<string, ExceptionRule> exceptionRules = null)
        {
            exceptionRules ??= new Dictionary<string, ExceptionRule>();

            return new ExceptionPolicy(id, name, exceptionRules);
        }

        /// <summary> Initializes a new instance of JobExceptionTrigger. </summary>
        /// <param name="kind"> The type discriminator describing a sub-type of ExceptionTrigger. </param>
        /// <returns> A new <see cref="JobRouter.JobExceptionTrigger"/> instance for mocking. </returns>
        public static JobExceptionTrigger JobExceptionTrigger(string kind = null)
        {
            return new UnknownJobExceptionTrigger(kind);
        }

        /// <summary> Initializes a new instance of ExceptionAction. </summary>
        /// <param name="kind"> The type discriminator describing a sub-type of ExceptionAction. </param>
        /// <returns> A new <see cref="JobRouter.ExceptionAction"/> instance for mocking. </returns>
        public static ExceptionAction ExceptionAction(string kind = null)
        {
            return new UnknownExceptionAction(kind);
        }

        /// <summary> Initializes a new instance of ExceptionPolicyItem. </summary>
        /// <param name="exceptionPolicy"> A policy that defines actions to execute when exception are triggered. </param>
        /// <param name="etag"> (Optional) The Concurrency Token. </param>
        /// <returns> A new <see cref="Models.ExceptionPolicyItem"/> instance for mocking. </returns>
        public static ExceptionPolicyItem ExceptionPolicyItem(ExceptionPolicy exceptionPolicy = null, string etag = null)
        {
            return new ExceptionPolicyItem(exceptionPolicy, etag);
        }

        /// <summary> Initializes a new instance of RouterJob. </summary>
        /// <param name="id"> The id of the job. </param>
        /// <param name="channelReference"> Reference to an external parent context, eg. call ID. </param>
        /// <param name="jobStatus"> The state of the Job. </param>
        /// <param name="enqueueTimeUtc"> The time a job was queued. </param>
        /// <param name="channelId"> The channel identifier. eg. voice, chat, etc. </param>
        /// <param name="classificationPolicyId"> The Id of the Classification policy used for classifying a job. </param>
        /// <param name="queueId"> The Id of the Queue that this job is queued to. </param>
        /// <param name="priority"> The priority of this job. </param>
        /// <param name="dispositionCode"> Reason code for cancelled or closed jobs. </param>
        /// <param name="requestedWorkerSelectors"> A collection of manually specified label selectors, which a worker must satisfy in order to process this job. </param>
        /// <param name="attachedWorkerSelectors"> A collection of label selectors attached by a classification policy, which a worker must satisfy in order to process this job. </param>
        /// <param name="labels"> A set of key/value pairs that are identifying attributes used by the rules engines to make decisions. </param>
        /// <param name="assignments">
        /// A collection of the assignments of the job.
        /// Key is AssignmentId.
        /// </param>
        /// <param name="tags"> A set of non-identifying attributes attached to this job. </param>
        /// <param name="notes"> Notes attached to a job, sorted by timestamp. </param>
        /// <returns> A new <see cref="Models.RouterJob"/> instance for mocking. </returns>
        public static RouterJob RouterJob(string id = null, string channelReference = null, RouterJobStatus? jobStatus = null, DateTimeOffset? enqueueTimeUtc = null, string channelId = null, string classificationPolicyId = null, string queueId = null, int? priority = null, string dispositionCode = null, IEnumerable<WorkerSelector> requestedWorkerSelectors = null, IEnumerable<WorkerSelector> attachedWorkerSelectors = null, IDictionary<string, object> labels = null, IReadOnlyDictionary<string, JobAssignment> assignments = null, IDictionary<string, object> tags = null, IDictionary<string, string> notes = null)
        {
            requestedWorkerSelectors ??= new List<WorkerSelector>();
            attachedWorkerSelectors ??= new List<WorkerSelector>();
            labels ??= new Dictionary<string, object>();
            assignments ??= new Dictionary<string, JobAssignment>();
            tags ??= new Dictionary<string, object>();
            notes ??= new Dictionary<string, string>();

            return new RouterJob(id, channelReference, jobStatus, enqueueTimeUtc, channelId, classificationPolicyId, queueId, priority, dispositionCode, requestedWorkerSelectors?.ToList(), attachedWorkerSelectors?.ToList(), labels, assignments, tags, notes);
        }

        /// <summary> Initializes a new instance of WorkerSelector. </summary>
        /// <param name="key"> The label key to query against. </param>
        /// <param name="labelOperator"> Describes how the value of the label is compared to the value defined on the label selector. </param>
        /// <param name="value"> The value to compare against the actual label value with the given operator. </param>
        /// <param name="ttlSeconds"> Describes how long this label selector is valid in seconds. </param>
        /// <param name="expedite"> Pushes the job to the front of the queue as long as this selector is active. </param>
        /// <param name="state"> The state of the worker selector. </param>
        /// <param name="expireTime"> The time at which this worker selector expires in UTC. </param>
        /// <returns> A new <see cref="JobRouter.WorkerSelector"/> instance for mocking. </returns>
        public static WorkerSelector WorkerSelector(string key = null, LabelOperator labelOperator = default, object value = null, double? ttlSeconds = null, bool? expedite = null, WorkerSelectorState? state = null, DateTimeOffset? expireTime = null)
        {
            return new WorkerSelector(key, labelOperator, value, ttlSeconds, expedite, state, expireTime);
        }

        /// <summary> Initializes a new instance of JobAssignment. </summary>
        /// <param name="id"> The Id of the job assignment. </param>
        /// <param name="workerId"> The Id of the Worker assigned to the job. </param>
        /// <param name="assignTime"> The assignment time of the job. </param>
        /// <param name="completeTime"> The time the job was marked as completed after being assigned. </param>
        /// <param name="closeTime"> The time the job was marked as closed after being completed. </param>
        /// <returns> A new <see cref="Models.JobAssignment"/> instance for mocking. </returns>
        public static JobAssignment JobAssignment(string id = null, string workerId = null, DateTimeOffset assignTime = default, DateTimeOffset? completeTime = null, DateTimeOffset? closeTime = null)
        {
            return new JobAssignment(id, workerId, assignTime, completeTime, closeTime);
        }

        /// <summary> Initializes a new instance of RouterJobItem. </summary>
        /// <param name="routerJob"> A unit of work to be routed. </param>
        /// <param name="etag"> (Optional) The Concurrency Token. </param>
        /// <returns> A new <see cref="Models.RouterJobItem"/> instance for mocking. </returns>
        public static RouterJobItem RouterJobItem(RouterJob routerJob = null, string etag = null)
        {
            return new RouterJobItem(routerJob, etag);
        }

        /// <summary> Initializes a new instance of JobPositionDetails. </summary>
        /// <param name="jobId"> Id of the job these details are about. </param>
        /// <param name="position"> Position of the job in question within that queue. </param>
        /// <param name="queueId"> Id of the queue this job is enqueued in. </param>
        /// <param name="queueLength"> Length of the queue: total number of enqueued jobs. </param>
        /// <param name="estimatedWaitTimeMinutes"> Estimated wait time of the job rounded up to the nearest minute. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="queueId"/> is null. </exception>
        /// <returns> A new <see cref="Models.JobPositionDetails"/> instance for mocking. </returns>
        public static JobPositionDetails JobPositionDetails(string jobId = null, int position = default, string queueId = null, int queueLength = default, double estimatedWaitTimeMinutes = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (queueId == null)
            {
                throw new ArgumentNullException(nameof(queueId));
            }

            return new JobPositionDetails(jobId, position, queueId, queueLength, estimatedWaitTimeMinutes);
        }

        /// <summary> Initializes a new instance of UnassignJobResult. </summary>
        /// <param name="jobId"> The Id of the job unassigned. </param>
        /// <param name="unassignmentCount"> The number of times a job is unassigned. At a maximum 3. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <returns> A new <see cref="Models.UnassignJobResult"/> instance for mocking. </returns>
        public static UnassignJobResult UnassignJobResult(string jobId = null, int unassignmentCount = default)
        {
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            return new UnassignJobResult(jobId, unassignmentCount);
        }

        /// <summary> Initializes a new instance of AcceptJobOfferResult. </summary>
        /// <param name="assignmentId"> The assignment Id that assigns a worker that has accepted an offer to a job. </param>
        /// <param name="jobId"> The Id of the job assigned. </param>
        /// <param name="workerId"> The Id of the worker that has been assigned this job. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="assignmentId"/>, <paramref name="jobId"/> or <paramref name="workerId"/> is null. </exception>
        /// <returns> A new <see cref="Models.AcceptJobOfferResult"/> instance for mocking. </returns>
        public static AcceptJobOfferResult AcceptJobOfferResult(string assignmentId = null, string jobId = null, string workerId = null)
        {
            if (assignmentId == null)
            {
                throw new ArgumentNullException(nameof(assignmentId));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }
            if (workerId == null)
            {
                throw new ArgumentNullException(nameof(workerId));
            }

            return new AcceptJobOfferResult(assignmentId, jobId, workerId);
        }

        /// <summary> Initializes a new instance of JobQueue. </summary>
        /// <param name="id"> The Id of this queue. </param>
        /// <param name="name"> The name of this queue. </param>
        /// <param name="distributionPolicyId"> The ID of the distribution policy that will determine how a job is distributed to workers. </param>
        /// <param name="labels"> A set of key/value pairs that are identifying attributes used by the rules engines to make decisions. </param>
        /// <param name="exceptionPolicyId"> (Optional) The ID of the exception policy that determines various job escalation rules. </param>
        /// <returns> A new <see cref="Models.JobQueue"/> instance for mocking. </returns>
        public static JobQueue JobQueue(string id = null, string name = null, string distributionPolicyId = null, IDictionary<string, object> labels = null, string exceptionPolicyId = null)
        {
            labels ??= new Dictionary<string, object>();

            return new JobQueue(id, name, distributionPolicyId, labels, exceptionPolicyId);
        }

        /// <summary> Initializes a new instance of JobQueueItem. </summary>
        /// <param name="jobQueue"> A queue that can contain jobs to be routed. </param>
        /// <param name="etag"> (Optional) The Concurrency Token. </param>
        /// <returns> A new <see cref="Models.JobQueueItem"/> instance for mocking. </returns>
        public static JobQueueItem JobQueueItem(JobQueue jobQueue = null, string etag = null)
        {
            return new JobQueueItem(jobQueue, etag);
        }

        /// <summary> Initializes a new instance of QueueStatistics. </summary>
        /// <param name="queueId"> Id of the queue these details are about. </param>
        /// <param name="length"> Length of the queue: total number of enqueued jobs. </param>
        /// <param name="estimatedWaitTimeMinutes"> The estimated wait time of this queue rounded up to the nearest minute, grouped by job priority. </param>
        /// <param name="longestJobWaitTimeMinutes"> The wait time of the job that has been enqueued in this queue for the longest. </param>
        /// <returns> A new <see cref="Models.QueueStatistics"/> instance for mocking. </returns>
        public static QueueStatistics QueueStatistics(string queueId = null, int length = default, IReadOnlyDictionary<string, double> estimatedWaitTimeMinutes = null, double? longestJobWaitTimeMinutes = null)
        {
            estimatedWaitTimeMinutes ??= new Dictionary<string, double>();

            return new QueueStatistics(queueId, length, estimatedWaitTimeMinutes, longestJobWaitTimeMinutes);
        }

        /// <summary> Initializes a new instance of RouterWorker. </summary>
        /// <param name="id"></param>
        /// <param name="state"> The current state of the worker. </param>
        /// <param name="queueAssignments"> The queue(s) that this worker can receive work from. </param>
        /// <param name="totalCapacity"> The total capacity score this worker has to manage multiple concurrent jobs. </param>
        /// <param name="labels"> A set of key/value pairs that are identifying attributes used by the rules engines to make decisions. </param>
        /// <param name="tags"> A set of non-identifying attributes attached to this worker. </param>
        /// <param name="channelConfigurations"> The channel(s) this worker can handle and their impact on the workers capacity. </param>
        /// <param name="offers"> A list of active offers issued to this worker. </param>
        /// <param name="assignedJobs"> A list of assigned jobs attached to this worker. </param>
        /// <param name="loadRatio"> A value indicating the workers capacity. A value of &apos;1&apos; means all capacity is consumed. A value of &apos;0&apos; means no capacity is currently consumed. </param>
        /// <param name="availableForOffers"> A flag indicating this worker is open to receive offers or not. </param>
        /// <returns> A new <see cref="Models.RouterWorker"/> instance for mocking. </returns>
        public static RouterWorker RouterWorker(string id = null, RouterWorkerState? state = null, IDictionary<string, object> queueAssignments = null, int? totalCapacity = null, IDictionary<string, object> labels = null, IDictionary<string, object> tags = null, IDictionary<string, ChannelConfiguration> channelConfigurations = null, IEnumerable<JobOffer> offers = null, IEnumerable<WorkerAssignment> assignedJobs = null, double? loadRatio = null, bool? availableForOffers = null)
        {
            queueAssignments ??= new Dictionary<string, object>();
            labels ??= new Dictionary<string, object>();
            tags ??= new Dictionary<string, object>();
            channelConfigurations ??= new Dictionary<string, ChannelConfiguration>();
            offers ??= new List<JobOffer>();
            assignedJobs ??= new List<WorkerAssignment>();

            return new RouterWorker(id, state, queueAssignments, totalCapacity, labels, tags, channelConfigurations, offers?.ToList(), assignedJobs?.ToList(), loadRatio, availableForOffers);
        }

        /// <summary> Initializes a new instance of JobOffer. </summary>
        /// <param name="id"> The Id of the offer. </param>
        /// <param name="jobId"> The Id of the job. </param>
        /// <param name="capacityCost"> The capacity cost consumed by the job offer. </param>
        /// <param name="offerTimeUtc"> The time the offer was created. </param>
        /// <param name="expiryTimeUtc"> The time that the offer will expire. </param>
        /// <returns> A new <see cref="Models.JobOffer"/> instance for mocking. </returns>
        public static JobOffer JobOffer(string id = null, string jobId = null, int capacityCost = default, DateTimeOffset? offerTimeUtc = null, DateTimeOffset? expiryTimeUtc = null)
        {
            return new JobOffer(id, jobId, capacityCost, offerTimeUtc, expiryTimeUtc);
        }

        /// <summary> Initializes a new instance of WorkerAssignment. </summary>
        /// <param name="id"> The Id of the assignment. </param>
        /// <param name="jobId"> The Id of the Job assigned. </param>
        /// <param name="capacityCost"> The amount of capacity this assignment has consumed on the worker. </param>
        /// <param name="assignTime"> The assignment time of the job. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="id"/> or <paramref name="jobId"/> is null. </exception>
        /// <returns> A new <see cref="Models.WorkerAssignment"/> instance for mocking. </returns>
        public static WorkerAssignment WorkerAssignment(string id = null, string jobId = null, int capacityCost = default, DateTimeOffset assignTime = default)
        {
            if (id == null)
            {
                throw new ArgumentNullException(nameof(id));
            }
            if (jobId == null)
            {
                throw new ArgumentNullException(nameof(jobId));
            }

            return new WorkerAssignment(id, jobId, capacityCost, assignTime);
        }

        /// <summary> Initializes a new instance of RouterWorkerItem. </summary>
        /// <param name="routerWorker"> An entity for jobs to be routed to. </param>
        /// <param name="etag"> (Optional) The Concurrency Token. </param>
        /// <returns> A new <see cref="Models.RouterWorkerItem"/> instance for mocking. </returns>
        public static RouterWorkerItem RouterWorkerItem(RouterWorker routerWorker = null, string etag = null)
        {
            return new RouterWorkerItem(routerWorker, etag);
        }

        /// <summary> Initializes a new instance of BestWorkerMode. </summary>
        /// <param name="minConcurrentOffers"> Governs the minimum desired number of active concurrent offers a job can have. </param>
        /// <param name="maxConcurrentOffers"> Governs the maximum number of active concurrent offers a job can have. </param>
        /// <param name="bypassSelectors">
        /// (Optional)
        /// If set to true, then router will match workers to jobs even if they don&apos;t match label selectors.
        /// Warning: You may get workers that are not qualified for the job they are matched with if you set this
        /// variable to true. This flag is intended more for temporary usage.
        /// By default, set to false.
        /// </param>
        /// <param name="scoringRule">
        /// A rule of one of the following types:
        ///             
        /// StaticRule:  A rule providing static rules that always return the same result, regardless of input.
        /// DirectMapRule:  A rule that return the same labels as the input labels.
        /// ExpressionRule: A rule providing inline expression rules.
        /// AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
        /// Please note <see cref="RouterRule"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="FunctionRule"/>, <see cref="DirectMapRule"/>, <see cref="ExpressionRule"/> and <see cref="StaticRule"/>.
        /// </param>
        /// <param name="scoringRuleOptions"> Encapsulates all options that can be passed as parameters for scoring rule with BestWorkerMode. </param>
        /// <returns> A new <see cref="JobRouter.BestWorkerMode"/> instance for mocking. </returns>
        public static BestWorkerMode BestWorkerMode(int minConcurrentOffers = default, int maxConcurrentOffers = default, bool? bypassSelectors = null, RouterRule scoringRule = null, ScoringRuleOptions scoringRuleOptions = null)
        {
            return new BestWorkerMode("best-worker", minConcurrentOffers, maxConcurrentOffers, bypassSelectors, scoringRule, scoringRuleOptions);
        }

        /// <summary> Initializes a new instance of ScoringRuleOptions. </summary>
        /// <param name="batchSize"> (Optional) Set batch size when AllowScoringBatchOfWorkers is set to true. </param>
        /// <param name="scoringParameters">
        /// (Optional) List of extra parameters from the job that will be sent as part of the payload to scoring rule.
        /// If not set, the job&apos;s labels (sent in the payload as `job`) and the job&apos;s worker selectors (sent in the payload as `selectors`)
        /// are added to the payload of the scoring rule by default.
        /// Note: Worker labels are always sent with scoring payload.
        /// </param>
        /// <param name="allowScoringBatchOfWorkers">
        /// (Optional)
        /// If set to true, will score workers in batches, and the parameter name of the worker labels will be sent as `workers`.
        /// By default, set to false and the parameter name for the worker labels will be sent as `worker`.
        /// Note: If enabled, use BatchSize to set batch size.
        /// </param>
        /// <param name="descendingOrder">
        /// (Optional)
        /// If false, will sort scores by ascending order. By default, set to true.
        /// </param>
        /// <returns> A new <see cref="JobRouter.ScoringRuleOptions"/> instance for mocking. </returns>
        public static ScoringRuleOptions ScoringRuleOptions(int? batchSize = null, IEnumerable<ScoringRuleParameterSelector> scoringParameters = null, bool? allowScoringBatchOfWorkers = null, bool? descendingOrder = null)
        {
            scoringParameters ??= new List<ScoringRuleParameterSelector>();

            return new ScoringRuleOptions(batchSize, scoringParameters?.ToList(), allowScoringBatchOfWorkers, descendingOrder);
        }

        /// <summary> Initializes a new instance of CancelExceptionAction. </summary>
        /// <param name="note"> (Optional) A note that will be appended to the jobs&apos; Notes collection with th current timestamp. </param>
        /// <param name="dispositionCode"> (Optional) Indicates the outcome of the job, populate this field with your own custom values. </param>
        /// <returns> A new <see cref="JobRouter.CancelExceptionAction"/> instance for mocking. </returns>
        public static CancelExceptionAction CancelExceptionAction(string note = null, string dispositionCode = null)
        {
            return new CancelExceptionAction("cancel", note, dispositionCode);
        }

        /// <summary> Initializes a new instance of ConditionalQueueSelectorAttachment. </summary>
        /// <param name="condition">
        /// A rule of one of the following types:
        ///             
        /// StaticRule:  A rule providing static rules that always return the same result, regardless of input.
        /// DirectMapRule:  A rule that return the same labels as the input labels.
        /// ExpressionRule: A rule providing inline expression rules.
        /// AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
        /// Please note <see cref="RouterRule"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="FunctionRule"/>, <see cref="DirectMapRule"/>, <see cref="ExpressionRule"/> and <see cref="StaticRule"/>.
        /// </param>
        /// <param name="labelSelectors"> The label selectors to attach. </param>
        /// <returns> A new <see cref="JobRouter.ConditionalQueueSelectorAttachment"/> instance for mocking. </returns>
        public static ConditionalQueueSelectorAttachment ConditionalQueueSelectorAttachment(RouterRule condition = null, IEnumerable<QueueSelector> labelSelectors = null)
        {
            labelSelectors ??= new List<QueueSelector>();

            return new ConditionalQueueSelectorAttachment("conditional", condition, labelSelectors?.ToList());
        }

        /// <summary> Initializes a new instance of QueueSelector. </summary>
        /// <param name="key"> The label key to query against. </param>
        /// <param name="labelOperator"> Describes how the value of the label is compared to the value defined on the label selector. </param>
        /// <param name="value"> The value to compare against the actual label value with the given operator. </param>
        /// <returns> A new <see cref="JobRouter.QueueSelector"/> instance for mocking. </returns>
        public static QueueSelector QueueSelector(string key = null, LabelOperator labelOperator = default, object value = null)
        {
            return new QueueSelector(key, labelOperator, value);
        }

        /// <summary> Initializes a new instance of ConditionalWorkerSelectorAttachment. </summary>
        /// <param name="condition">
        /// A rule of one of the following types:
        ///             
        /// StaticRule:  A rule providing static rules that always return the same result, regardless of input.
        /// DirectMapRule:  A rule that return the same labels as the input labels.
        /// ExpressionRule: A rule providing inline expression rules.
        /// AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
        /// Please note <see cref="RouterRule"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="FunctionRule"/>, <see cref="DirectMapRule"/>, <see cref="ExpressionRule"/> and <see cref="StaticRule"/>.
        /// </param>
        /// <param name="labelSelectors"> The label selectors to attach. </param>
        /// <returns> A new <see cref="JobRouter.ConditionalWorkerSelectorAttachment"/> instance for mocking. </returns>
        public static ConditionalWorkerSelectorAttachment ConditionalWorkerSelectorAttachment(RouterRule condition = null, IEnumerable<WorkerSelector> labelSelectors = null)
        {
            labelSelectors ??= new List<WorkerSelector>();

            return new ConditionalWorkerSelectorAttachment("conditional", condition, labelSelectors?.ToList());
        }

        /// <summary> Initializes a new instance of DirectMapRule. </summary>
        /// <returns> A new <see cref="JobRouter.DirectMapRule"/> instance for mocking. </returns>
        public static DirectMapRule DirectMapRule()
        {
            return new DirectMapRule("direct-map-rule");
        }

        /// <summary> Initializes a new instance of ExpressionRule. </summary>
        /// <param name="language"> The expression language to compile to and execute. </param>
        /// <param name="expression"> The string containing the expression to evaluate. Should contain return statement with calculated values. </param>
        /// <returns> A new <see cref="JobRouter.ExpressionRule"/> instance for mocking. </returns>
        public static ExpressionRule ExpressionRule(string language = null, string expression = null)
        {
            return new ExpressionRule("expression-rule", language, expression);
        }

        /// <summary> Initializes a new instance of FunctionRule. </summary>
        /// <param name="functionUri"> URL for Azure Function. </param>
        /// <param name="credential"> Credentials used to access Azure function rule. </param>
        /// <returns> A new <see cref="JobRouter.FunctionRule"/> instance for mocking. </returns>
        public static FunctionRule FunctionRule(Uri functionUri = null, FunctionRuleCredential credential = null)
        {
            return new FunctionRule("azure-function-rule", functionUri, credential);
        }

        /// <summary> Initializes a new instance of FunctionRuleCredential. </summary>
        /// <param name="functionKey"> (Optional) Access key scoped to a particular function. </param>
        /// <param name="appKey">
        /// (Optional) Access key scoped to a Azure Function app.
        /// This key grants access to all functions under the app.
        /// </param>
        /// <param name="clientId">
        /// (Optional) Client id, when AppKey is provided
        /// In context of Azure function, this is usually the name of the key
        /// </param>
        /// <returns> A new <see cref="JobRouter.FunctionRuleCredential"/> instance for mocking. </returns>
        public static FunctionRuleCredential FunctionRuleCredential(string functionKey = null, string appKey = null, string clientId = null)
        {
            return new FunctionRuleCredential(functionKey, appKey, clientId);
        }

        /// <summary> Initializes a new instance of LongestIdleMode. </summary>
        /// <param name="minConcurrentOffers"> Governs the minimum desired number of active concurrent offers a job can have. </param>
        /// <param name="maxConcurrentOffers"> Governs the maximum number of active concurrent offers a job can have. </param>
        /// <param name="bypassSelectors">
        /// (Optional)
        /// If set to true, then router will match workers to jobs even if they don&apos;t match label selectors.
        /// Warning: You may get workers that are not qualified for the job they are matched with if you set this
        /// variable to true. This flag is intended more for temporary usage.
        /// By default, set to false.
        /// </param>
        /// <returns> A new <see cref="JobRouter.LongestIdleMode"/> instance for mocking. </returns>
        public static LongestIdleMode LongestIdleMode(int minConcurrentOffers = default, int maxConcurrentOffers = default, bool? bypassSelectors = null)
        {
            return new LongestIdleMode("longest-idle", minConcurrentOffers, maxConcurrentOffers, bypassSelectors);
        }

        /// <summary> Initializes a new instance of ManualReclassifyExceptionAction. </summary>
        /// <param name="queueId"> Updated QueueId. </param>
        /// <param name="priority"> Updated Priority. </param>
        /// <param name="workerSelectors"> Updated WorkerSelectors. </param>
        /// <returns> A new <see cref="JobRouter.ManualReclassifyExceptionAction"/> instance for mocking. </returns>
        public static ManualReclassifyExceptionAction ManualReclassifyExceptionAction(string queueId = null, int? priority = null, IEnumerable<WorkerSelector> workerSelectors = null)
        {
            workerSelectors ??= new List<WorkerSelector>();

            return new ManualReclassifyExceptionAction("manual-reclassify", queueId, priority, workerSelectors?.ToList());
        }

        /// <summary> Initializes a new instance of PassThroughQueueSelectorAttachment. </summary>
        /// <param name="key"> The label key to query against. </param>
        /// <param name="labelOperator"> Describes how the value of the label is compared to the value pass through. </param>
        /// <returns> A new <see cref="JobRouter.PassThroughQueueSelectorAttachment"/> instance for mocking. </returns>
        public static PassThroughQueueSelectorAttachment PassThroughQueueSelectorAttachment(string key = null, LabelOperator labelOperator = default)
        {
            return new PassThroughQueueSelectorAttachment("pass-through", key, labelOperator);
        }

        /// <summary> Initializes a new instance of PassThroughWorkerSelectorAttachment. </summary>
        /// <param name="key"> The label key to query against. </param>
        /// <param name="labelOperator"> Describes how the value of the label is compared to the value pass through. </param>
        /// <param name="ttlSeconds"> Describes how long the attached label selector is valid in seconds. </param>
        /// <returns> A new <see cref="JobRouter.PassThroughWorkerSelectorAttachment"/> instance for mocking. </returns>
        public static PassThroughWorkerSelectorAttachment PassThroughWorkerSelectorAttachment(string key = null, LabelOperator labelOperator = default, double? ttlSeconds = null)
        {
            return new PassThroughWorkerSelectorAttachment("pass-through", key, labelOperator, ttlSeconds);
        }

        /// <summary> Initializes a new instance of QueueLengthExceptionTrigger. </summary>
        /// <param name="threshold"> Threshold of number of jobs ahead in the queue to for this trigger to fire. </param>
        /// <returns> A new <see cref="JobRouter.QueueLengthExceptionTrigger"/> instance for mocking. </returns>
        public static QueueLengthExceptionTrigger QueueLengthExceptionTrigger(int threshold = default)
        {
            return new QueueLengthExceptionTrigger("queue-length", threshold);
        }

        /// <summary> Initializes a new instance of ReclassifyExceptionAction. </summary>
        /// <param name="classificationPolicyId"> (optional) The new classification policy that will determine queue, priority and worker selectors. </param>
        /// <param name="labelsToUpsert"> (optional) Dictionary containing the labels to update (or add if not existing) in key-value pairs. </param>
        /// <returns> A new <see cref="JobRouter.ReclassifyExceptionAction"/> instance for mocking. </returns>
        public static ReclassifyExceptionAction ReclassifyExceptionAction(string classificationPolicyId = null, IDictionary<string, object> labelsToUpsert = null)
        {
            labelsToUpsert ??= new Dictionary<string, object>();

            return new ReclassifyExceptionAction("reclassify", classificationPolicyId, labelsToUpsert);
        }

        /// <summary> Initializes a new instance of RoundRobinMode. </summary>
        /// <param name="minConcurrentOffers"> Governs the minimum desired number of active concurrent offers a job can have. </param>
        /// <param name="maxConcurrentOffers"> Governs the maximum number of active concurrent offers a job can have. </param>
        /// <param name="bypassSelectors">
        /// (Optional)
        /// If set to true, then router will match workers to jobs even if they don&apos;t match label selectors.
        /// Warning: You may get workers that are not qualified for the job they are matched with if you set this
        /// variable to true. This flag is intended more for temporary usage.
        /// By default, set to false.
        /// </param>
        /// <returns> A new <see cref="JobRouter.RoundRobinMode"/> instance for mocking. </returns>
        public static RoundRobinMode RoundRobinMode(int minConcurrentOffers = default, int maxConcurrentOffers = default, bool? bypassSelectors = null)
        {
            return new RoundRobinMode("round-robin", minConcurrentOffers, maxConcurrentOffers, bypassSelectors);
        }

        /// <summary> Initializes a new instance of RuleEngineQueueSelectorAttachment. </summary>
        /// <param name="rule">
        /// A rule of one of the following types:
        ///             
        /// StaticRule:  A rule providing static rules that always return the same result, regardless of input.
        /// DirectMapRule:  A rule that return the same labels as the input labels.
        /// ExpressionRule: A rule providing inline expression rules.
        /// AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
        /// Please note <see cref="RouterRule"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="FunctionRule"/>, <see cref="DirectMapRule"/>, <see cref="ExpressionRule"/> and <see cref="StaticRule"/>.
        /// </param>
        /// <returns> A new <see cref="JobRouter.RuleEngineQueueSelectorAttachment"/> instance for mocking. </returns>
        public static RuleEngineQueueSelectorAttachment RuleEngineQueueSelectorAttachment(RouterRule rule = null)
        {
            return new RuleEngineQueueSelectorAttachment("rule-engine", rule);
        }

        /// <summary> Initializes a new instance of RuleEngineWorkerSelectorAttachment. </summary>
        /// <param name="rule">
        /// A rule of one of the following types:
        ///             
        /// StaticRule:  A rule providing static rules that always return the same result, regardless of input.
        /// DirectMapRule:  A rule that return the same labels as the input labels.
        /// ExpressionRule: A rule providing inline expression rules.
        /// AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
        /// Please note <see cref="RouterRule"/> is the base class. According to the scenario, a derived class of the base class might need to be assigned here, or this property needs to be casted to one of the possible derived classes.
        /// The available derived classes include <see cref="FunctionRule"/>, <see cref="DirectMapRule"/>, <see cref="ExpressionRule"/> and <see cref="StaticRule"/>.
        /// </param>
        /// <returns> A new <see cref="JobRouter.RuleEngineWorkerSelectorAttachment"/> instance for mocking. </returns>
        public static RuleEngineWorkerSelectorAttachment RuleEngineWorkerSelectorAttachment(RouterRule rule = null)
        {
            return new RuleEngineWorkerSelectorAttachment("rule-engine", rule);
        }

        /// <summary> Initializes a new instance of StaticQueueSelectorAttachment. </summary>
        /// <param name="labelSelector"> Describes a condition that must be met against a set of labels for queue selection. </param>
        /// <returns> A new <see cref="JobRouter.StaticQueueSelectorAttachment"/> instance for mocking. </returns>
        public static StaticQueueSelectorAttachment StaticQueueSelectorAttachment(QueueSelector labelSelector = null)
        {
            return new StaticQueueSelectorAttachment("static", labelSelector);
        }

        /// <summary> Initializes a new instance of StaticRule. </summary>
        /// <param name="value"> The static value this rule always returns. </param>
        /// <returns> A new <see cref="JobRouter.StaticRule"/> instance for mocking. </returns>
        public static StaticRule StaticRule(object value = null)
        {
            return new StaticRule("static-rule", value);
        }

        /// <summary> Initializes a new instance of StaticWorkerSelectorAttachment. </summary>
        /// <param name="labelSelector"> Describes a condition that must be met against a set of labels for worker selection. </param>
        /// <returns> A new <see cref="JobRouter.StaticWorkerSelectorAttachment"/> instance for mocking. </returns>
        public static StaticWorkerSelectorAttachment StaticWorkerSelectorAttachment(WorkerSelector labelSelector = null)
        {
            return new StaticWorkerSelectorAttachment("static", labelSelector);
        }

        /// <summary> Initializes a new instance of WaitTimeExceptionTrigger. </summary>
        /// <param name="thresholdSeconds"> Threshold for wait time for this trigger. </param>
        /// <returns> A new <see cref="JobRouter.WaitTimeExceptionTrigger"/> instance for mocking. </returns>
        public static WaitTimeExceptionTrigger WaitTimeExceptionTrigger(double thresholdSeconds = default)
        {
            return new WaitTimeExceptionTrigger("wait-time", thresholdSeconds);
        }

        /// <summary> Initializes a new instance of WeightedAllocationQueueSelectorAttachment. </summary>
        /// <param name="allocations"> A collection of percentage based weighted allocations. </param>
        /// <returns> A new <see cref="JobRouter.WeightedAllocationQueueSelectorAttachment"/> instance for mocking. </returns>
        public static WeightedAllocationQueueSelectorAttachment WeightedAllocationQueueSelectorAttachment(IEnumerable<QueueWeightedAllocation> allocations = null)
        {
            allocations ??= new List<QueueWeightedAllocation>();

            return new WeightedAllocationQueueSelectorAttachment("weighted-allocation-queue-selector", allocations?.ToList());
        }

        /// <summary> Initializes a new instance of WeightedAllocationWorkerSelectorAttachment. </summary>
        /// <param name="allocations"> A collection of percentage based weighted allocations. </param>
        /// <returns> A new <see cref="JobRouter.WeightedAllocationWorkerSelectorAttachment"/> instance for mocking. </returns>
        public static WeightedAllocationWorkerSelectorAttachment WeightedAllocationWorkerSelectorAttachment(IEnumerable<WorkerWeightedAllocation> allocations = null)
        {
            allocations ??= new List<WorkerWeightedAllocation>();

            return new WeightedAllocationWorkerSelectorAttachment("weighted-allocation-worker-selector", allocations?.ToList());
        }
    }
}
