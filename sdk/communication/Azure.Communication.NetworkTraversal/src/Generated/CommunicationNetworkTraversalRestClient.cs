// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Communication.NetworkTraversal
{
    internal partial class CommunicationNetworkTraversalRestClient
    {
        private readonly HttpPipeline _pipeline;
        private readonly string _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> Initializes a new instance of CommunicationNetworkTraversalRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> The communication resource, for example https://my-resource.communication.azure.com. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientDiagnostics"/>, <paramref name="pipeline"/>, <paramref name="endpoint"/> or <paramref name="apiVersion"/> is null. </exception>
        public CommunicationNetworkTraversalRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string endpoint, string apiVersion = "2022-03-01-preview")
        {
            ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException(nameof(clientDiagnostics));
            _pipeline = pipeline ?? throw new ArgumentNullException(nameof(pipeline));
            _endpoint = endpoint ?? throw new ArgumentNullException(nameof(endpoint));
            _apiVersion = apiVersion ?? throw new ArgumentNullException(nameof(apiVersion));
        }

        internal HttpMessage CreateIssueRelayConfigurationRequest(string id, RouteType? routeType, int? ttl)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_endpoint, false);
            uri.AppendPath("/networkTraversal/:issueRelayConfiguration", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var model = new CommunicationRelayConfigurationRequest()
            {
                Id = id,
                RouteType = routeType,
                Ttl = ttl
            };
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(model);
            request.Content = content;
            return message;
        }

        /// <summary> Issue a configuration for an STUN/TURN server. </summary>
        /// <param name="id"> An identity to be associated with telemetry for data relayed using the returned credentials. Must be an existing ACS user identity. If not provided, the telemetry will not contain an associated identity value. </param>
        /// <param name="routeType"> Filter the routing methodology returned. If not provided, will return all route types in separate ICE servers. </param>
        /// <param name="ttl"> The credential Time-To-Live (TTL), in seconds. The default value will be used if given value exceeds it. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<CommunicationRelayConfiguration>> IssueRelayConfigurationAsync(string id = null, RouteType? routeType = null, int? ttl = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateIssueRelayConfigurationRequest(id, routeType, ttl);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CommunicationRelayConfiguration value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = CommunicationRelayConfiguration.DeserializeCommunicationRelayConfiguration(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }

        /// <summary> Issue a configuration for an STUN/TURN server. </summary>
        /// <param name="id"> An identity to be associated with telemetry for data relayed using the returned credentials. Must be an existing ACS user identity. If not provided, the telemetry will not contain an associated identity value. </param>
        /// <param name="routeType"> Filter the routing methodology returned. If not provided, will return all route types in separate ICE servers. </param>
        /// <param name="ttl"> The credential Time-To-Live (TTL), in seconds. The default value will be used if given value exceeds it. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<CommunicationRelayConfiguration> IssueRelayConfiguration(string id = null, RouteType? routeType = null, int? ttl = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateIssueRelayConfigurationRequest(id, routeType, ttl);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        CommunicationRelayConfiguration value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = CommunicationRelayConfiguration.DeserializeCommunicationRelayConfiguration(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw new RequestFailedException(message.Response);
            }
        }
    }
}
