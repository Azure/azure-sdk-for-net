// <auto-generated>
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Azure.Maps.Elevation
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// ElevationOperations operations.
    /// </summary>
    public partial class ElevationOperations : IServiceOperations<ElevationClient>, IElevationOperations
    {
        /// <summary>
        /// Initializes a new instance of the ElevationOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public ElevationOperations(ElevationClient client)
        {
            if (client == null)
            {
                throw new System.ArgumentNullException("client");
            }
            Client = client;
        }

        /// <summary>
        /// Gets a reference to the ElevationClient
        /// </summary>
        public ElevationClient Client { get; private set; }

        /// <summary>
        /// Get Elevation Data on One or More Points
        /// </summary>
        /// <remarks>
        /// **Applies to**: S1 pricing tier.
        ///
        /// The Get Data for Points API provides elevation data for one or more points.
        /// A point is defined in lat,long coordinate format.
        ///
        /// Due to the URL character  length limit of 2048, it's not possible to pass
        /// more than 100 coordinates  as a pipeline delimited string in a URL GET
        /// request. If you intend to pass  more than 100 coordinates as a pipeline
        /// delimited string, use the [POST Data
        /// For
        /// Points](https://docs.microsoft.com/en-us/rest/api/maps/elevation/postdataforpoints).
        /// </remarks>
        /// <param name='points'>
        /// The string representation of a list of points. A point is defined in
        /// lon/lat WGS84 coordinate reference system format.  If multiple points are
        /// requested, each of the points in a list should be separated by the pipe
        /// ('|') character.  The maximum number of points that can be requested in a
        /// single request is 2,000. The resolution of the elevation  data will be the
        /// highest for a single point and will decrease if multiple points are spread
        /// further apart.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<PointsResult>> GetDataForPointsWithHttpMessagesAsync(IList<string> points, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (points == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "points");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("points", points);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetDataForPoints", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "elevation/point/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (points != null)
            {
                _queryParameters.Add(string.Format("points={0}", string.Join("|", points)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<PointsResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<PointsResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Query Elevation Data for Multiple Points
        /// </summary>
        /// <remarks>
        /// **Applies to**: S1 pricing tier.
        ///
        /// The Post Data for Points API provides elevation data for multiple points.
        /// A point is defined lon/lat coordinate format. Use the POST endpoint only
        /// if you intend to pass multiple points in the request. If you intend to pass
        /// a single coordinate into the API, use the [GET Data For Points
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/elevation/getdataforpoints).
        /// </remarks>
        /// <param name='pointsRequestBody'>
        /// The string representation of a list of points. A point is defined in
        /// lon/lat WGS84 coordinate reference system format.  Each points in a list
        /// should be separated by the pipe ('|') character. The number of points that
        /// can be requested in  a POST request ranges from 2 to 2,000. The resolution
        /// of the elevation data will be the highest for a single point  and will
        /// decrease if multiple points are spread further apart.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<PointsResult>> PostDataForPointsWithHttpMessagesAsync(IList<CoordinatesPairAbbreviated> pointsRequestBody, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (pointsRequestBody == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "pointsRequestBody");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("pointsRequestBody", pointsRequestBody);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "PostDataForPoints", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "elevation/point/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(pointsRequestBody != null)
            {
                _requestContent = Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(pointsRequestBody, Client.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<PointsResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<PointsResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get Elevation Data Along a Polyline
        /// </summary>
        /// <remarks>
        /// **Applies to**: S1 pricing tier.
        ///
        /// The Get Data for Polyline API provides elevation data along a polyline.
        ///
        /// A polyline is defined by  passing in between 2 and N endpoint coordinates
        /// separated by a pipe ('|') character. In addition  to passing in endpoints,
        /// customers can specify the number of sample points that will be used to
        /// divide  polyline into equally spaced segments. Elevation data at both start
        /// and endpoints and equally spaced  points along the polyline will be
        /// returned.
        ///
        /// A line between two endpoints is a straight Cartesian line, the  shortest
        /// line between those two points in the coordinate reference system. Note that
        /// the point is  chosen based on Euclidean distance and may markedly differ
        /// from the geodesic path along the curved  surface of the reference
        /// ellipsoid.
        /// </remarks>
        /// <param name='lines'>
        /// The string representation of a polyline path. A polyline is defined by
        /// endpoint coordinates,  with each endpoint separated by a pipe ('|')
        /// character. The polyline should be defined in the  following format:
        /// `[longitude_point1, latitude_point1 | longitude_point2, latitude_point2,
        /// ...,  longitude_pointN, latitude_pointN]`.
        ///
        /// The longitude and latitude values refer to the World Geodetic  System
        /// (WGS84) coordinate reference system. The resolution of the data used to
        /// compute the  elevation depends on the distance between the endpoints.
        /// </param>
        /// <param name='samples'>
        /// The samples parameter specifies the number of equally spaced points at
        /// which elevation values  should be provided along a polyline path. The
        /// number of samples should range from 2 to 2,000. Default value is 10.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<LinesResult>> GetDataForPolylineWithHttpMessagesAsync(IList<string> lines, int? samples = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (lines == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "lines");
            }
            if (samples > 2000)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "samples", 2000);
            }
            if (samples < 2)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "samples", 2);
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("lines", lines);
                tracingParameters.Add("samples", samples);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetDataForPolyline", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "elevation/line/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (lines != null)
            {
                _queryParameters.Add(string.Format("lines={0}", string.Join("|", lines)));
            }
            if (samples != null)
            {
                _queryParameters.Add(string.Format("samples={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(samples, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<LinesResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<LinesResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Query Elevation Data Along a Polyline
        /// </summary>
        /// <remarks>
        /// **Applies to**: S1 pricing tier.
        ///
        /// The Post Data for Polyline API provides elevation data along a polyline. A
        /// polyline is defined by  passing in between 2 and N endpoint coordinates
        /// separated by a pipe ('|') character. In addition  to passing in endpoints,
        /// customers can specify the number of sample points that will be used to
        /// divide  polyline into equally spaced segments.
        ///
        /// Elevation data at both start and end points and equally spaced  points
        /// along the polyline will be returned. A line between two endpoints is a
        /// straight Cartesian line, the  shortest line between those two points in the
        /// coordinate reference system. Note that the point is  chosen based on
        /// Euclidean distance and may markedly differ from the geodesic path along the
        /// curved  surface of the reference ellipsoid.
        /// </remarks>
        /// <param name='linesRequestBody'>
        /// The string representation of a polyline path. A polyline is defined by
        /// endpoint coordinates,  with each endpoint separated by a pipe ('|')
        /// character. The polyline should be defined in the  following format:
        /// `[longitude_point1, latitude_point1 | longitude_point2, latitude_point2,
        /// ...,  longitude_pointN, latitude_pointN]`. The longitude and latitude
        /// values refer to the World Geodetic  System (WGS84) coordinate reference
        /// system. The resolution of the data used to compute the  elevation will
        /// depend on the distance between the endpoints.
        /// </param>
        /// <param name='samples'>
        /// The samples parameter specifies the number of equally spaced points at
        /// which elevation values  should be provided along a polyline path. The
        /// number of samples should range from 2 to 2,000. Default value is 10.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<LinesResult>> PostDataForPolylineWithHttpMessagesAsync(IList<CoordinatesPairAbbreviated> linesRequestBody, int? samples = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (linesRequestBody == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "linesRequestBody");
            }
            if (samples > 2000)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "samples", 2000);
            }
            if (samples < 2)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "samples", 2);
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("linesRequestBody", linesRequestBody);
                tracingParameters.Add("samples", samples);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "PostDataForPolyline", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "elevation/line/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (samples != null)
            {
                _queryParameters.Add(string.Format("samples={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(samples, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(linesRequestBody != null)
            {
                _requestContent = Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(linesRequestBody, Client.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<LinesResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<LinesResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get Elevation Data at Equally Spaced Locations Within a Bounding Box
        /// </summary>
        /// <remarks>
        /// **Applies to**: S1 pricing tier.
        ///
        /// The Get Data for Bounding Box API provides elevation data at equally spaced
        /// locations within a bounding box. A bounding box is defined by the
        /// coordinates for two corners (southwest, northeast) and then subsequently
        /// divided into rows and columns.
        ///
        /// Elevations are returned for the vertices of the grid created by the rows
        /// and  columns. Up to 2,000 elevations can be returned in a single request.
        /// The returned elevation values are ordered,  starting at the southwest
        /// corner, and then proceeding west to east along the row. At the end of the
        /// row,  it moves north to the next row, and repeats the process until it
        /// reaches the far northeast corner.
        /// </remarks>
        /// <param name='bounds'>
        /// The string that represents the rectangular area of a bounding box. The
        /// bounds parameter is defined by the 4 bounding box coordinates, with WGS84
        /// longitude and latitude of the southwest corner followed by  WGS84 longitude
        /// and latitude of the northeast corner. The string is presented in the
        /// following  format: `[SouthwestCorner_Longitude, SouthwestCorner_Latitude,
        /// NortheastCorner_Longitude,  NortheastCorner_Latitude]`.
        /// </param>
        /// <param name='rows'>
        /// Specifies the number of rows to use to divide the bounding box area into a
        /// grid. The number of vertices  in the grid should be less than 2,000.
        /// </param>
        /// <param name='columns'>
        /// Specifies the number of columns to use to divide the bounding box area into
        /// a grid. The number of vertices  in the grid should be less than 2,000.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<BoundingBoxResult>> GetDataForBoundingBoxWithHttpMessagesAsync(IList<string> bounds, int rows, int columns, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (bounds == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "bounds");
            }
            if (rows > 1000)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "rows", 1000);
            }
            if (rows < 2)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "rows", 2);
            }
            if (columns > 1000)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "columns", 1000);
            }
            if (columns < 2)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "columns", 2);
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("bounds", bounds);
                tracingParameters.Add("rows", rows);
                tracingParameters.Add("columns", columns);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetDataForBoundingBox", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "elevation/lattice/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (bounds != null)
            {
                _queryParameters.Add(string.Format("bounds={0}", System.Uri.EscapeDataString(string.Join(",", bounds))));
            }
            _queryParameters.Add(string.Format("rows={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(rows, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("columns={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(columns, Client.SerializationSettings).Trim('"'))));
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<BoundingBoxResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<BoundingBoxResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
