// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.IO;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Maps.Traffic.Models;

namespace Azure.Maps.Traffic
{
    internal partial class TrafficRestClient
    {
        private Geography? geography;
        private string xMsClientId;
        private string apiVersion;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of TrafficRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="geography"> This parameter specifies where the Azure Maps Creator resource is located.  Valid values are us and eu. </param>
        /// <param name="xMsClientId"> Specifies which account is intended for usage in conjunction with the Azure AD security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Azure AD security in Azure Maps see the following [articles](https://aka.ms/amauthdetails) for guidance. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public TrafficRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Geography? geography = default, string xMsClientId = null, string apiVersion = "1.0")
        {
            geography ??= Geography.Us;
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            this.geography = geography;
            this.xMsClientId = xMsClientId;
            this.apiVersion = apiVersion;
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateGetTrafficFlowTileRequest(TileFormat format, TrafficFlowTileStyle style, int zoom, int xTileIndex, int yTileIndex, int? thickness)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/traffic/flow/tile/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("style", style.ToString(), true);
            uri.AppendQuery("zoom", zoom, true);
            uri.AppendQuery("x", xTileIndex, true);
            uri.AppendQuery("y", yTileIndex, true);
            if (thickness != null)
            {
                uri.AppendQuery("thickness", thickness.Value, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json, image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile");
            return message;
        }

        /// <summary>
        /// __Traffic Flow Tile__
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// The Azure Flow Tile API serves 256 x 256 pixel tiles showing traffic flow. All tiles use the same grid system. Because the traffic tiles use transparent images, they can be layered on top of map tiles to create a compound  display. The Flow tiles use colors to indicate either the speed of traffic on different road segments, or the difference between that speed and the free-flow speed on the road segment in question.
        /// </summary>
        /// <param name="format"> Desired format of the response. Possible values are png &amp; pbf. </param>
        /// <param name="style"> &lt;p&gt;The style to be used to render the tile.&lt;/p&gt;. </param>
        /// <param name="zoom">
        /// Zoom level for the desired tile. For _raster_ tiles, value must be in the range: 0-22 (inclusive). For _vector_ tiles, value must be in the range: 0-22 (inclusive).
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="xTileIndex">
        /// X coordinate of the tile on zoom grid. Value must be in the range [0, 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        /// 
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="yTileIndex">
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0, 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        /// 
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="thickness"> The value of the width of the line representing traffic. This value is a multiplier and the accepted values range from 1 - 20. The default value is 10. This parameter is not valid when format is pbf. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<Stream, TrafficGetTrafficFlowTileHeaders>> GetTrafficFlowTileAsync(TileFormat format, TrafficFlowTileStyle style, int zoom, int xTileIndex, int yTileIndex, int? thickness = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetTrafficFlowTileRequest(format, style, zoom, xTileIndex, yTileIndex, thickness);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TrafficGetTrafficFlowTileHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// __Traffic Flow Tile__
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// The Azure Flow Tile API serves 256 x 256 pixel tiles showing traffic flow. All tiles use the same grid system. Because the traffic tiles use transparent images, they can be layered on top of map tiles to create a compound  display. The Flow tiles use colors to indicate either the speed of traffic on different road segments, or the difference between that speed and the free-flow speed on the road segment in question.
        /// </summary>
        /// <param name="format"> Desired format of the response. Possible values are png &amp; pbf. </param>
        /// <param name="style"> &lt;p&gt;The style to be used to render the tile.&lt;/p&gt;. </param>
        /// <param name="zoom">
        /// Zoom level for the desired tile. For _raster_ tiles, value must be in the range: 0-22 (inclusive). For _vector_ tiles, value must be in the range: 0-22 (inclusive).
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="xTileIndex">
        /// X coordinate of the tile on zoom grid. Value must be in the range [0, 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        /// 
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="yTileIndex">
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0, 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        /// 
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="thickness"> The value of the width of the line representing traffic. This value is a multiplier and the accepted values range from 1 - 20. The default value is 10. This parameter is not valid when format is pbf. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<Stream, TrafficGetTrafficFlowTileHeaders> GetTrafficFlowTile(TileFormat format, TrafficFlowTileStyle style, int zoom, int xTileIndex, int yTileIndex, int? thickness = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetTrafficFlowTileRequest(format, style, zoom, xTileIndex, yTileIndex, thickness);
            _pipeline.Send(message, cancellationToken);
            var headers = new TrafficGetTrafficFlowTileHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetTrafficFlowSegmentRequest(TextFormat format, TrafficFlowSegmentStyle style, int zoom, string query, SpeedUnit? unit, int? thickness, bool? openLr)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/traffic/flow/segment/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("style", style.ToString(), true);
            uri.AppendQuery("zoom", zoom, true);
            uri.AppendQuery("query", query, true);
            if (unit != null)
            {
                uri.AppendQuery("unit", unit.Value.ToString(), true);
            }
            if (thickness != null)
            {
                uri.AppendQuery("thickness", thickness.Value, true);
            }
            if (openLr != null)
            {
                uri.AppendQuery("openLr", openLr.Value, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// __Traffic Flow Segment__
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// This service provides information about the speeds and travel times of the road fragment closest to the given coordinates. It is designed to work alongside the Flow layer of the Render Service to support clickable  flow data visualizations. With this API, the client side can connect any place in the map with flow data on the  closest road and present it to the user.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="style"> The style to be used to render the tile. Valid values are absolute which returns colors reflecting the absolute speed measured, relative which returns the speed relative to free-flow, Relative-delay which displays relative speeds only where they are different from the freeflow speeds. </param>
        /// <param name="zoom">
        /// Zoom level for the desired tile. Zoom value must be in the range: 0-22 (inclusive).
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="query"> Coordinates of the point close to the road segment. They have to be comma-separated and calculated using EPSG4326 projection. </param>
        /// <param name="unit"> Unit of speed in KMPH or MPH. </param>
        /// <param name="thickness"> The value of the width of the line representing traffic. This value is a multiplier and the accepted values range from 1 - 20. The default value is 10. </param>
        /// <param name="openLr"> Boolean on whether the response should include OpenLR code. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public async Task<Response<TrafficFlowSegmentResult>> GetTrafficFlowSegmentAsync(TextFormat format, TrafficFlowSegmentStyle style, int zoom, string query, SpeedUnit? unit = null, int? thickness = null, bool? openLr = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetTrafficFlowSegmentRequest(format, style, zoom, query, unit, thickness, openLr);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TrafficFlowSegmentResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = TrafficFlowSegmentResult.DeserializeTrafficFlowSegmentResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// __Traffic Flow Segment__
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// This service provides information about the speeds and travel times of the road fragment closest to the given coordinates. It is designed to work alongside the Flow layer of the Render Service to support clickable  flow data visualizations. With this API, the client side can connect any place in the map with flow data on the  closest road and present it to the user.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="style"> The style to be used to render the tile. Valid values are absolute which returns colors reflecting the absolute speed measured, relative which returns the speed relative to free-flow, Relative-delay which displays relative speeds only where they are different from the freeflow speeds. </param>
        /// <param name="zoom">
        /// Zoom level for the desired tile. Zoom value must be in the range: 0-22 (inclusive).
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="query"> Coordinates of the point close to the road segment. They have to be comma-separated and calculated using EPSG4326 projection. </param>
        /// <param name="unit"> Unit of speed in KMPH or MPH. </param>
        /// <param name="thickness"> The value of the width of the line representing traffic. This value is a multiplier and the accepted values range from 1 - 20. The default value is 10. </param>
        /// <param name="openLr"> Boolean on whether the response should include OpenLR code. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public Response<TrafficFlowSegmentResult> GetTrafficFlowSegment(TextFormat format, TrafficFlowSegmentStyle style, int zoom, string query, SpeedUnit? unit = null, int? thickness = null, bool? openLr = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetTrafficFlowSegmentRequest(format, style, zoom, query, unit, thickness, openLr);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TrafficFlowSegmentResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = TrafficFlowSegmentResult.DeserializeTrafficFlowSegmentResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetTrafficIncidentTileRequest(TileFormat format, TrafficIncidentTileStyle style, int zoom, int xTileIndex, int yTileIndex, string trafficState)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/traffic/incident/tile/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("style", style.ToString(), true);
            uri.AppendQuery("zoom", zoom, true);
            uri.AppendQuery("x", xTileIndex, true);
            uri.AppendQuery("y", yTileIndex, true);
            if (trafficState != null)
            {
                uri.AppendQuery("t", trafficState, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json, image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile");
            return message;
        }

        /// <summary>
        /// __Traffic Incident Tile__
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// This service serves 256 x 256 pixel tiles showing traffic incidents. All tiles use the same grid system. Because the traffic tiles use transparent images, they can be layered on top of map tiles to create a compound display. Traffic tiles render graphics to indicate traffic on the roads in the specified area.
        /// </summary>
        /// <param name="format"> Desired format of the response. Possible values are png &amp; pbf. </param>
        /// <param name="style"> The style to be used to render the tile. This parameter is not valid when format is pbf. </param>
        /// <param name="zoom">
        /// Zoom level for the desired tile. For _raster_ tiles, value must be in the range: 0-22 (inclusive). For _vector_ tiles, value must be in the range: 0-22 (inclusive).
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="xTileIndex">
        /// X coordinate of the tile on zoom grid. Value must be in the range [0, 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        /// 
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="yTileIndex">
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0, 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        /// 
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="trafficState"> Reference value for the state of traffic at a particular time, obtained from the Viewport API call, trafficModelId attribute in trafficState field. It is updated every minute, and is valid for two minutes before it times out. Use -1 to  get the most recent traffic information. Default: most recent traffic information. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<ResponseWithHeaders<Stream, TrafficGetTrafficIncidentTileHeaders>> GetTrafficIncidentTileAsync(TileFormat format, TrafficIncidentTileStyle style, int zoom, int xTileIndex, int yTileIndex, string trafficState = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetTrafficIncidentTileRequest(format, style, zoom, xTileIndex, yTileIndex, trafficState);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new TrafficGetTrafficIncidentTileHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// __Traffic Incident Tile__
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// This service serves 256 x 256 pixel tiles showing traffic incidents. All tiles use the same grid system. Because the traffic tiles use transparent images, they can be layered on top of map tiles to create a compound display. Traffic tiles render graphics to indicate traffic on the roads in the specified area.
        /// </summary>
        /// <param name="format"> Desired format of the response. Possible values are png &amp; pbf. </param>
        /// <param name="style"> The style to be used to render the tile. This parameter is not valid when format is pbf. </param>
        /// <param name="zoom">
        /// Zoom level for the desired tile. For _raster_ tiles, value must be in the range: 0-22 (inclusive). For _vector_ tiles, value must be in the range: 0-22 (inclusive).
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="xTileIndex">
        /// X coordinate of the tile on zoom grid. Value must be in the range [0, 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        /// 
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="yTileIndex">
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0, 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        /// 
        /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
        /// </param>
        /// <param name="trafficState"> Reference value for the state of traffic at a particular time, obtained from the Viewport API call, trafficModelId attribute in trafficState field. It is updated every minute, and is valid for two minutes before it times out. Use -1 to  get the most recent traffic information. Default: most recent traffic information. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public ResponseWithHeaders<Stream, TrafficGetTrafficIncidentTileHeaders> GetTrafficIncidentTile(TileFormat format, TrafficIncidentTileStyle style, int zoom, int xTileIndex, int yTileIndex, string trafficState = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetTrafficIncidentTileRequest(format, style, zoom, xTileIndex, yTileIndex, trafficState);
            _pipeline.Send(message, cancellationToken);
            var headers = new TrafficGetTrafficIncidentTileHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        var value = message.ExtractResponseContent();
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetTrafficIncidentDetailRequest(TextFormat format, TrafficIncidentDetailStyle style, string boundingbox, int boundingZoom, string trafficmodelid, string language, ProjectionStandard? projection, IncidentGeometryType? geometries, bool? expandCluster, bool? originalPosition)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/traffic/incident/detail/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("style", style.ToString(), true);
            uri.AppendQuery("boundingbox", boundingbox, true);
            uri.AppendQuery("boundingZoom", boundingZoom, true);
            uri.AppendQuery("trafficmodelid", trafficmodelid, true);
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (projection != null)
            {
                uri.AppendQuery("projection", projection.Value.ToString(), true);
            }
            if (geometries != null)
            {
                uri.AppendQuery("geometries", geometries.Value.ToString(), true);
            }
            if (expandCluster != null)
            {
                uri.AppendQuery("expandCluster", expandCluster.Value, true);
            }
            if (originalPosition != null)
            {
                uri.AppendQuery("originalPosition", originalPosition.Value, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// __Traffic Incident Detail__
        /// 
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// This API provides information on traffic incidents inside a given bounding box, based on the current Traffic  Model ID. The Traffic Model ID is available to grant synchronization of data between calls and API&apos;s. The  Traffic Model ID is a key value for determining the currency of traffic incidents. It is updated every minute,  and is valid for two minutes before it times out. It is used in rendering  [incident tiles](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile). It can be  obtained from the [Viewport API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport).
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="style"> The style that will be used to render the tile in Traffic [Incident Tile API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile).  This will have an effect on the coordinates of traffic incidents in the reply. </param>
        /// <param name="boundingbox"> The `boundingbox` is represented by two value pairs describing it&apos;s corners (first pair for lower left corner and second for upper right). The pairs can either be specified using any of the `projection`&apos;s specified below (e.g., _minY,minX,maxY,maxX_) or by two latitude-longitude pairs (e.g., _minLat,minLon,maxLat,maxLon_).&lt;br&gt;&lt;br&gt;NOTE: If latitude/longitude pairs are used, then the `projection` parameter must be set to &quot;EPSG4326&quot;. </param>
        /// <param name="boundingZoom"> Zoom level for desired tile. 0 to 22 for raster tiles, 0 through 22 for vector tiles. </param>
        /// <param name="trafficmodelid"> Number referencing traffic model. This can be obtained from the [Viewport API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport). It is updated every minute, and is valid for two minutes before it times out. If the wrong Traffic Model ID is specified, the correct one will be returned by the interface. A value of -1 will always invoke the most recent traffic model. </param>
        /// <param name="language">
        /// [ISO 639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the output language. Supported languages are ar, ca, cs, da, de, el, en, en-GB, en-US, es, et, fi, fr, he, hu, id, in*, it, lt, lv, nb, nl, no, pl, pt, ro, ru, sk, sv, th, tr, zh.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details. When invalid language code is provided response is returned in English. When incident cause or description does not have translation, English description is returned.
        /// </param>
        /// <param name="projection"> The projection used to specify the coordinates in the request and response. [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) (default) or [EPSG4326](http://spatialreference.org/ref/epsg/4326/). </param>
        /// <param name="geometries"> The type of vector geometry added to incidents (returned in the &lt;v&gt; element of the response). </param>
        /// <param name="expandCluster"> Boolean to indicate whether to list all traffic incidents in a cluster separately. </param>
        /// <param name="originalPosition"> Boolean on whether to return the original position of the incident (&lt;op&gt;) as well as the one shifted to the beginning of the traffic tube (&lt;op&gt;). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="boundingbox"/> or <paramref name="trafficmodelid"/> is null. </exception>
        public async Task<Response<TrafficIncidentDetailResult>> GetTrafficIncidentDetailAsync(TextFormat format, TrafficIncidentDetailStyle style, string boundingbox, int boundingZoom, string trafficmodelid, string language = null, ProjectionStandard? projection = null, IncidentGeometryType? geometries = null, bool? expandCluster = null, bool? originalPosition = null, CancellationToken cancellationToken = default)
        {
            if (boundingbox == null)
            {
                throw new ArgumentNullException(nameof(boundingbox));
            }
            if (trafficmodelid == null)
            {
                throw new ArgumentNullException(nameof(trafficmodelid));
            }

            using var message = CreateGetTrafficIncidentDetailRequest(format, style, boundingbox, boundingZoom, trafficmodelid, language, projection, geometries, expandCluster, originalPosition);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TrafficIncidentDetailResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = TrafficIncidentDetailResult.DeserializeTrafficIncidentDetailResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// __Traffic Incident Detail__
        /// 
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// This API provides information on traffic incidents inside a given bounding box, based on the current Traffic  Model ID. The Traffic Model ID is available to grant synchronization of data between calls and API&apos;s. The  Traffic Model ID is a key value for determining the currency of traffic incidents. It is updated every minute,  and is valid for two minutes before it times out. It is used in rendering  [incident tiles](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile). It can be  obtained from the [Viewport API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport).
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="style"> The style that will be used to render the tile in Traffic [Incident Tile API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile).  This will have an effect on the coordinates of traffic incidents in the reply. </param>
        /// <param name="boundingbox"> The `boundingbox` is represented by two value pairs describing it&apos;s corners (first pair for lower left corner and second for upper right). The pairs can either be specified using any of the `projection`&apos;s specified below (e.g., _minY,minX,maxY,maxX_) or by two latitude-longitude pairs (e.g., _minLat,minLon,maxLat,maxLon_).&lt;br&gt;&lt;br&gt;NOTE: If latitude/longitude pairs are used, then the `projection` parameter must be set to &quot;EPSG4326&quot;. </param>
        /// <param name="boundingZoom"> Zoom level for desired tile. 0 to 22 for raster tiles, 0 through 22 for vector tiles. </param>
        /// <param name="trafficmodelid"> Number referencing traffic model. This can be obtained from the [Viewport API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport). It is updated every minute, and is valid for two minutes before it times out. If the wrong Traffic Model ID is specified, the correct one will be returned by the interface. A value of -1 will always invoke the most recent traffic model. </param>
        /// <param name="language">
        /// [ISO 639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the output language. Supported languages are ar, ca, cs, da, de, el, en, en-GB, en-US, es, et, fi, fr, he, hu, id, in*, it, lt, lv, nb, nl, no, pl, pt, ro, ru, sk, sv, th, tr, zh.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details. When invalid language code is provided response is returned in English. When incident cause or description does not have translation, English description is returned.
        /// </param>
        /// <param name="projection"> The projection used to specify the coordinates in the request and response. [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) (default) or [EPSG4326](http://spatialreference.org/ref/epsg/4326/). </param>
        /// <param name="geometries"> The type of vector geometry added to incidents (returned in the &lt;v&gt; element of the response). </param>
        /// <param name="expandCluster"> Boolean to indicate whether to list all traffic incidents in a cluster separately. </param>
        /// <param name="originalPosition"> Boolean on whether to return the original position of the incident (&lt;op&gt;) as well as the one shifted to the beginning of the traffic tube (&lt;op&gt;). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="boundingbox"/> or <paramref name="trafficmodelid"/> is null. </exception>
        public Response<TrafficIncidentDetailResult> GetTrafficIncidentDetail(TextFormat format, TrafficIncidentDetailStyle style, string boundingbox, int boundingZoom, string trafficmodelid, string language = null, ProjectionStandard? projection = null, IncidentGeometryType? geometries = null, bool? expandCluster = null, bool? originalPosition = null, CancellationToken cancellationToken = default)
        {
            if (boundingbox == null)
            {
                throw new ArgumentNullException(nameof(boundingbox));
            }
            if (trafficmodelid == null)
            {
                throw new ArgumentNullException(nameof(trafficmodelid));
            }

            using var message = CreateGetTrafficIncidentDetailRequest(format, style, boundingbox, boundingZoom, trafficmodelid, language, projection, geometries, expandCluster, originalPosition);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TrafficIncidentDetailResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = TrafficIncidentDetailResult.DeserializeTrafficIncidentDetailResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetTrafficIncidentViewportRequest(TextFormat format, string boundingbox, int boundingzoom, string overviewbox, int overviewzoom, bool? copyright)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/traffic/incident/viewport/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("boundingbox", boundingbox, true);
            uri.AppendQuery("boundingzoom", boundingzoom, true);
            uri.AppendQuery("overviewbox", overviewbox, true);
            uri.AppendQuery("overviewzoom", overviewzoom, true);
            if (copyright != null)
            {
                uri.AppendQuery("copyright", copyright.Value, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// __Traffic Incident Viewport__
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// This API returns legal and technical information for the viewport described in the request. It should be called  by client applications whenever the viewport changes (for instance, through zooming, panning, going to a  location, or displaying a route). The request should contain the bounding box and zoom level of the viewport  whose information is needed. The return will contain map version information, as well as the current Traffic  Model ID and copyright IDs. The Traffic Model ID returned by the Viewport Description is used by other APIs to  retrieve last traffic information for further processing.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="boundingbox"> Bounding box of the map viewport in [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) projection. The `boundingbox` is represented by two value pairs describing it&apos;s corners (first pair for lower left corner and second for upper right). All values should be separated by commas (e.g., _minY,minX,maxY,maxX_). The maximum size of the bounding box that can be passed is dependent on the requested zoom level. The width and height cannot exceed 4092 pixels when rendered on the given zoom level.&lt;br&gt;&lt;br&gt;NOTE: Bounding boxes that cross the 180° meridian require special treatment. For such boxes, the eastern _maxX_ value will be negative, and thus less than the _minX_ value west of the 180° meridian. To address that, the value 40075016.6855874 should be added to the true _maxX_ value before it is passed in the request. </param>
        /// <param name="boundingzoom"> Zoom level of the map viewport. Used to determine whether the view can be zoomed in. </param>
        /// <param name="overviewbox"> Bounding box of the overview map in [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) projection.&lt;br&gt;&lt;br&gt;Used in case the overview box/mini map has different copyright data than the main map. If there is no mini map, the same coordinates as `boundingBox` is used. </param>
        /// <param name="overviewzoom"> Zoom level of the overview map. If there is no mini map, use the same zoom level as boundingZoom. </param>
        /// <param name="copyright"> Determines what copyright information to return. When true the copyright text is returned; when false only the copyright index is returned. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="boundingbox"/> or <paramref name="overviewbox"/> is null. </exception>
        public async Task<Response<TrafficIncidentViewportResult>> GetTrafficIncidentViewportAsync(TextFormat format, string boundingbox, int boundingzoom, string overviewbox, int overviewzoom, bool? copyright = null, CancellationToken cancellationToken = default)
        {
            if (boundingbox == null)
            {
                throw new ArgumentNullException(nameof(boundingbox));
            }
            if (overviewbox == null)
            {
                throw new ArgumentNullException(nameof(overviewbox));
            }

            using var message = CreateGetTrafficIncidentViewportRequest(format, boundingbox, boundingzoom, overviewbox, overviewzoom, copyright);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TrafficIncidentViewportResult value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = TrafficIncidentViewportResult.DeserializeTrafficIncidentViewportResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// __Traffic Incident Viewport__
        /// 
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// This API returns legal and technical information for the viewport described in the request. It should be called  by client applications whenever the viewport changes (for instance, through zooming, panning, going to a  location, or displaying a route). The request should contain the bounding box and zoom level of the viewport  whose information is needed. The return will contain map version information, as well as the current Traffic  Model ID and copyright IDs. The Traffic Model ID returned by the Viewport Description is used by other APIs to  retrieve last traffic information for further processing.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="boundingbox"> Bounding box of the map viewport in [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) projection. The `boundingbox` is represented by two value pairs describing it&apos;s corners (first pair for lower left corner and second for upper right). All values should be separated by commas (e.g., _minY,minX,maxY,maxX_). The maximum size of the bounding box that can be passed is dependent on the requested zoom level. The width and height cannot exceed 4092 pixels when rendered on the given zoom level.&lt;br&gt;&lt;br&gt;NOTE: Bounding boxes that cross the 180° meridian require special treatment. For such boxes, the eastern _maxX_ value will be negative, and thus less than the _minX_ value west of the 180° meridian. To address that, the value 40075016.6855874 should be added to the true _maxX_ value before it is passed in the request. </param>
        /// <param name="boundingzoom"> Zoom level of the map viewport. Used to determine whether the view can be zoomed in. </param>
        /// <param name="overviewbox"> Bounding box of the overview map in [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) projection.&lt;br&gt;&lt;br&gt;Used in case the overview box/mini map has different copyright data than the main map. If there is no mini map, the same coordinates as `boundingBox` is used. </param>
        /// <param name="overviewzoom"> Zoom level of the overview map. If there is no mini map, use the same zoom level as boundingZoom. </param>
        /// <param name="copyright"> Determines what copyright information to return. When true the copyright text is returned; when false only the copyright index is returned. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="boundingbox"/> or <paramref name="overviewbox"/> is null. </exception>
        public Response<TrafficIncidentViewportResult> GetTrafficIncidentViewport(TextFormat format, string boundingbox, int boundingzoom, string overviewbox, int overviewzoom, bool? copyright = null, CancellationToken cancellationToken = default)
        {
            if (boundingbox == null)
            {
                throw new ArgumentNullException(nameof(boundingbox));
            }
            if (overviewbox == null)
            {
                throw new ArgumentNullException(nameof(overviewbox));
            }

            using var message = CreateGetTrafficIncidentViewportRequest(format, boundingbox, boundingzoom, overviewbox, overviewzoom, copyright);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        TrafficIncidentViewportResult value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = TrafficIncidentViewportResult.DeserializeTrafficIncidentViewportResult(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
