// <auto-generated>
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Azure.Maps.Traffic
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// TrafficOperations operations.
    /// </summary>
    public partial class TrafficOperations : IServiceOperations<TrafficClient>, ITrafficOperations
    {
        /// <summary>
        /// Initializes a new instance of the TrafficOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public TrafficOperations(TrafficClient client)
        {
            if (client == null)
            {
                throw new System.ArgumentNullException("client");
            }
            Client = client;
        }

        /// <summary>
        /// Gets a reference to the TrafficClient
        /// </summary>
        public TrafficClient Client { get; private set; }

        /// <summary>
        /// __Traffic Flow Tile__
        ///
        ///
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        /// The Azure Flow Tile API serves 256 x 256 pixel tiles showing traffic flow.
        /// All tiles use the same grid system. Because the traffic tiles use
        /// transparent images, they can be layered on top of map tiles to create a
        /// compound  display. The Flow tiles use colors to indicate either the speed
        /// of traffic on different road segments, or the difference between that speed
        /// and the free-flow speed on the road segment in question.
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Possible values are png &amp; pbf. Possible
        /// values include: 'png', 'pbf'
        /// </param>
        /// <param name='style'>
        /// &lt;p&gt;The style to be used to render the tile.&lt;/p&gt;. Possible
        /// values include: 'absolute', 'relative', 'relative-delay',
        /// 'reduced-sensitivity'
        /// </param>
        /// <param name='zoom'>
        /// Zoom level for the desired tile. For _raster_ tiles, value must be in the
        /// range: 0-22 (inclusive). For _vector_ tiles, value must be in the range:
        /// 0-22 (inclusive).
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='xTileIndex'>
        /// X coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='yTileIndex'>
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='thickness'>
        /// The value of the width of the line representing traffic. This value is a
        /// multiplier and the accepted values range from 1 - 20. The default value is
        /// 10. This parameter is not valid when format is pbf.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<Stream,TrafficGetTrafficFlowTileHeaders>> GetTrafficFlowTileWithHttpMessagesAsync(string format, string style, int zoom, int xTileIndex, int yTileIndex, int? thickness = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            if (style == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "style");
            }
            if (thickness > 20)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "thickness", 20);
            }
            if (thickness < 1)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "thickness", 1);
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("style", style);
                tracingParameters.Add("zoom", zoom);
                tracingParameters.Add("xTileIndex", xTileIndex);
                tracingParameters.Add("yTileIndex", yTileIndex);
                tracingParameters.Add("thickness", thickness);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetTrafficFlowTile", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "traffic/flow/tile/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (style != null)
            {
                _queryParameters.Add(string.Format("style={0}", System.Uri.EscapeDataString(style)));
            }
            _queryParameters.Add(string.Format("zoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(zoom, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("x={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(xTileIndex, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("y={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(yTileIndex, Client.SerializationSettings).Trim('"'))));
            if (thickness != null)
            {
                _queryParameters.Add(string.Format("thickness={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(thickness, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<Stream,TrafficGetTrafficFlowTileHeaders>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _result.Body = await _httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false);
            }
            try
            {
                _result.Headers = _httpResponse.GetHeadersAsJson().ToObject<TrafficGetTrafficFlowTileHeaders>(JsonSerializer.Create(Client.DeserializationSettings));
            }
            catch (JsonException ex)
            {
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw new SerializationException("Unable to deserialize the headers.", _httpResponse.GetHeadersAsJson().ToString(), ex);
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// __Traffic Flow Segment__
        ///
        ///
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        /// This service provides information about the speeds and travel times of the
        /// road fragment closest to the given coordinates. It is designed to work
        /// alongside the Flow layer of the Render Service to support clickable  flow
        /// data visualizations. With this API, the client side can connect any place
        /// in the map with flow data on the  closest road and present it to the user.
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Value can be either _json_ or _xml_.
        /// Possible values include: 'json', 'xml'
        /// </param>
        /// <param name='style'>
        /// The style to be used to render the tile. Valid values are absolute which
        /// returns colors reflecting the absolute speed measured, relative which
        /// returns the speed relative to free-flow, Relative-delay which displays
        /// relative speeds only where they are different from the freeflow speeds.
        /// Possible values include: 'absolute', 'relative', 'relative-delay'
        /// </param>
        /// <param name='zoom'>
        /// Zoom level for the desired tile. Zoom value must be in the range: 0-22
        /// (inclusive).
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='query'>
        /// Coordinates of the point close to the road segment. They have to be
        /// comma-separated and calculated using EPSG4326 projection.
        /// </param>
        /// <param name='unit'>
        /// Unit of speed in KMPH or MPH. Possible values include: 'KMPH', 'MPH'
        /// </param>
        /// <param name='thickness'>
        /// The value of the width of the line representing traffic. This value is a
        /// multiplier and the accepted values range from 1 - 20. The default value is
        /// 10.
        /// </param>
        /// <param name='openLr'>
        /// Boolean on whether the response should include OpenLR code
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<TrafficFlowSegmentResult>> GetTrafficFlowSegmentWithHttpMessagesAsync(string format, string style, int zoom, string query, string unit = default(string), int? thickness = default(int?), bool? openLr = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            if (style == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "style");
            }
            if (query == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "query");
            }
            if (thickness > 20)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "thickness", 20);
            }
            if (thickness < 1)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "thickness", 1);
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("style", style);
                tracingParameters.Add("zoom", zoom);
                tracingParameters.Add("query", query);
                tracingParameters.Add("unit", unit);
                tracingParameters.Add("thickness", thickness);
                tracingParameters.Add("openLr", openLr);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetTrafficFlowSegment", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "traffic/flow/segment/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (style != null)
            {
                _queryParameters.Add(string.Format("style={0}", System.Uri.EscapeDataString(style)));
            }
            _queryParameters.Add(string.Format("zoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(zoom, Client.SerializationSettings).Trim('"'))));
            if (query != null)
            {
                _queryParameters.Add(string.Format("query={0}", System.Uri.EscapeDataString(query)));
            }
            if (unit != null)
            {
                _queryParameters.Add(string.Format("unit={0}", System.Uri.EscapeDataString(unit)));
            }
            if (thickness != null)
            {
                _queryParameters.Add(string.Format("thickness={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(thickness, Client.SerializationSettings).Trim('"'))));
            }
            if (openLr != null)
            {
                _queryParameters.Add(string.Format("openLr={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(openLr, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<TrafficFlowSegmentResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<TrafficFlowSegmentResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// __Traffic Incident Tile__
        ///
        ///
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        /// This service serves 256 x 256 pixel tiles showing traffic incidents. All
        /// tiles use the same grid system. Because the traffic tiles use transparent
        /// images, they can be layered on top of map tiles to create a compound
        /// display. Traffic tiles render graphics to indicate traffic on the roads in
        /// the specified area.
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Possible values are png &amp; pbf. Possible
        /// values include: 'png', 'pbf'
        /// </param>
        /// <param name='style'>
        /// The style to be used to render the tile. This parameter is not valid when
        /// format is pbf. Possible values include: 's1', 's2', 's3', 'night'
        /// </param>
        /// <param name='zoom'>
        /// Zoom level for the desired tile. For _raster_ tiles, value must be in the
        /// range: 0-22 (inclusive). For _vector_ tiles, value must be in the range:
        /// 0-22 (inclusive).
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='xTileIndex'>
        /// X coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='yTileIndex'>
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='trafficState'>
        /// Reference value for the state of traffic at a particular time, obtained
        /// from the Viewport API call, trafficModelId attribute in trafficState field.
        /// It is updated every minute, and is valid for two minutes before it times
        /// out. Use -1 to  get the most recent traffic information. Default: most
        /// recent traffic information.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<Stream,TrafficGetTrafficIncidentTileHeaders>> GetTrafficIncidentTileWithHttpMessagesAsync(string format, string style, int zoom, int xTileIndex, int yTileIndex, string trafficState = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            if (style == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "style");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("style", style);
                tracingParameters.Add("zoom", zoom);
                tracingParameters.Add("xTileIndex", xTileIndex);
                tracingParameters.Add("yTileIndex", yTileIndex);
                tracingParameters.Add("trafficState", trafficState);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetTrafficIncidentTile", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "traffic/incident/tile/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (style != null)
            {
                _queryParameters.Add(string.Format("style={0}", System.Uri.EscapeDataString(style)));
            }
            _queryParameters.Add(string.Format("zoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(zoom, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("x={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(xTileIndex, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("y={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(yTileIndex, Client.SerializationSettings).Trim('"'))));
            if (trafficState != null)
            {
                _queryParameters.Add(string.Format("t={0}", System.Uri.EscapeDataString(trafficState)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<Stream,TrafficGetTrafficIncidentTileHeaders>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _result.Body = await _httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false);
            }
            try
            {
                _result.Headers = _httpResponse.GetHeadersAsJson().ToObject<TrafficGetTrafficIncidentTileHeaders>(JsonSerializer.Create(Client.DeserializationSettings));
            }
            catch (JsonException ex)
            {
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw new SerializationException("Unable to deserialize the headers.", _httpResponse.GetHeadersAsJson().ToString(), ex);
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// __Traffic Incident Detail__
        ///
        ///
        ///
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        /// This API provides information on traffic incidents inside a given bounding
        /// box, based on the current Traffic  Model ID. The Traffic Model ID is
        /// available to grant synchronization of data between calls and API's. The
        /// Traffic Model ID is a key value for determining the currency of traffic
        /// incidents. It is updated every minute,  and is valid for two minutes before
        /// it times out. It is used in rendering  [incident
        /// tiles](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile).
        /// It can be  obtained from the [Viewport
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport).
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Value can be either _json_ or _xml_.
        /// Possible values include: 'json', 'xml'
        /// </param>
        /// <param name='style'>
        /// The style that will be used to render the tile in Traffic [Incident Tile
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile).
        /// This will have an effect on the coordinates of traffic incidents in the
        /// reply. Possible values include: 's1', 's2', 's3', 'night'
        /// </param>
        /// <param name='boundingbox'>
        /// The `boundingbox` is represented by two value pairs describing it's corners
        /// (first pair for lower left corner and second for upper right). The pairs
        /// can either be specified using any of the `projection`'s specified below
        /// (e.g., _minY,minX,maxY,maxX_) or by two latitude-longitude pairs (e.g.,
        /// _minLat,minLon,maxLat,maxLon_).&lt;br&gt;&lt;br&gt;NOTE: If
        /// latitude/longitude pairs are used, then the `projection` parameter must be
        /// set to "EPSG4326".
        /// </param>
        /// <param name='boundingZoom'>
        /// Zoom level for desired tile. 0 to 22 for raster tiles, 0 through 22 for
        /// vector tiles
        /// </param>
        /// <param name='trafficmodelid'>
        /// Number referencing traffic model. This can be obtained from the [Viewport
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport).
        /// It is updated every minute, and is valid for two minutes before it times
        /// out. If the wrong Traffic Model ID is specified, the correct one will be
        /// returned by the interface. A value of -1 will always invoke the most recent
        /// traffic model
        /// </param>
        /// <param name='language'>
        /// [ISO 639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for
        /// the output language. Supported languages are ar, ca, cs, da, de, el, en,
        /// en-GB, en-US, es, et, fi, fr, he, hu, id, in*, it, lt, lv, nb, nl, no, pl,
        /// pt, ro, ru, sk, sv, th, tr, zh.
        ///
        /// Please refer to [Supported
        /// Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        /// for details. When invalid language code is provided response is returned in
        /// English. When incident cause or description does not have translation,
        /// English description is returned.
        /// </param>
        /// <param name='projection'>
        /// The projection used to specify the coordinates in the request and response.
        /// [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html)
        /// (default) or [EPSG4326](http://spatialreference.org/ref/epsg/4326/).
        /// Possible values include: 'EPSG900913', 'EPSG4326'
        /// </param>
        /// <param name='geometries'>
        /// The type of vector geometry added to incidents (returned in the &lt;v&gt;
        /// element of the response). Possible values include: 'original', 'shifted'
        /// </param>
        /// <param name='expandCluster'>
        /// Boolean to indicate whether to list all traffic incidents in a cluster
        /// separately
        /// </param>
        /// <param name='originalPosition'>
        /// Boolean on whether to return the original position of the incident
        /// (&lt;op&gt;) as well as the one shifted to the beginning of the traffic
        /// tube (&lt;op&gt;)
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<TrafficIncidentDetailResult>> GetTrafficIncidentDetailWithHttpMessagesAsync(string format, string style, string boundingbox, int boundingZoom, string trafficmodelid, string language = default(string), string projection = default(string), string geometries = default(string), bool? expandCluster = default(bool?), bool? originalPosition = default(bool?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            if (style == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "style");
            }
            if (boundingbox == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "boundingbox");
            }
            if (boundingZoom > 22)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "boundingZoom", 22);
            }
            if (boundingZoom < 0)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "boundingZoom", 0);
            }
            if (trafficmodelid == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "trafficmodelid");
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("style", style);
                tracingParameters.Add("boundingbox", boundingbox);
                tracingParameters.Add("boundingZoom", boundingZoom);
                tracingParameters.Add("trafficmodelid", trafficmodelid);
                tracingParameters.Add("language", language);
                tracingParameters.Add("projection", projection);
                tracingParameters.Add("geometries", geometries);
                tracingParameters.Add("expandCluster", expandCluster);
                tracingParameters.Add("originalPosition", originalPosition);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetTrafficIncidentDetail", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "traffic/incident/detail/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (style != null)
            {
                _queryParameters.Add(string.Format("style={0}", System.Uri.EscapeDataString(style)));
            }
            if (boundingbox != null)
            {
                _queryParameters.Add(string.Format("boundingbox={0}", System.Uri.EscapeDataString(boundingbox)));
            }
            _queryParameters.Add(string.Format("boundingZoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(boundingZoom, Client.SerializationSettings).Trim('"'))));
            if (trafficmodelid != null)
            {
                _queryParameters.Add(string.Format("trafficmodelid={0}", System.Uri.EscapeDataString(trafficmodelid)));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (projection != null)
            {
                _queryParameters.Add(string.Format("projection={0}", System.Uri.EscapeDataString(projection)));
            }
            if (geometries != null)
            {
                _queryParameters.Add(string.Format("geometries={0}", System.Uri.EscapeDataString(geometries)));
            }
            if (expandCluster != null)
            {
                _queryParameters.Add(string.Format("expandCluster={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(expandCluster, Client.SerializationSettings).Trim('"'))));
            }
            if (originalPosition != null)
            {
                _queryParameters.Add(string.Format("originalPosition={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(originalPosition, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<TrafficIncidentDetailResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<TrafficIncidentDetailResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// __Traffic Incident Viewport__
        ///
        ///
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        /// This API returns legal and technical information for the viewport described
        /// in the request. It should be called  by client applications whenever the
        /// viewport changes (for instance, through zooming, panning, going to a
        /// location, or displaying a route). The request should contain the bounding
        /// box and zoom level of the viewport  whose information is needed. The return
        /// will contain map version information, as well as the current Traffic  Model
        /// ID and copyright IDs. The Traffic Model ID returned by the Viewport
        /// Description is used by other APIs to  retrieve last traffic information for
        /// further processing.
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Value can be either _json_ or _xml_.
        /// Possible values include: 'json', 'xml'
        /// </param>
        /// <param name='boundingbox'>
        /// Bounding box of the map viewport in
        /// [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html)
        /// projection. The `boundingbox` is represented by two value pairs describing
        /// it's corners (first pair for lower left corner and second for upper right).
        /// All values should be separated by commas (e.g., _minY,minX,maxY,maxX_). The
        /// maximum size of the bounding box that can be passed is dependent on the
        /// requested zoom level. The width and height cannot exceed 4092 pixels when
        /// rendered on the given zoom level.&lt;br&gt;&lt;br&gt;NOTE: Bounding boxes
        /// that cross the 180 meridian require special treatment. For such boxes, the
        /// eastern _maxX_ value will be negative, and thus less than the _minX_ value
        /// west of the 180 meridian. To address that, the value 40075016.6855874
        /// should be added to the true _maxX_ value before it is passed in the
        /// request.
        /// </param>
        /// <param name='boundingzoom'>
        /// Zoom level of the map viewport. Used to determine whether the view can be
        /// zoomed in.
        /// </param>
        /// <param name='overviewbox'>
        /// Bounding box of the overview map in
        /// [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html)
        /// projection.&lt;br&gt;&lt;br&gt;Used in case the overview box/mini map has
        /// different copyright data than the main map. If there is no mini map, the
        /// same coordinates as `boundingBox` is used.
        /// </param>
        /// <param name='overviewzoom'>
        /// Zoom level of the overview map. If there is no mini map, use the same zoom
        /// level as boundingZoom.
        /// </param>
        /// <param name='copyright'>
        /// Determines what copyright information to return. When true the copyright
        /// text is returned; when false only the copyright index is returned.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<TrafficIncidentViewportResult>> GetTrafficIncidentViewportWithHttpMessagesAsync(string format, string boundingbox, int boundingzoom, string overviewbox, int overviewzoom, bool? copyright = true, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            if (boundingbox == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "boundingbox");
            }
            if (boundingzoom > 22)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "boundingzoom", 22);
            }
            if (boundingzoom < 0)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "boundingzoom", 0);
            }
            if (overviewbox == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "overviewbox");
            }
            if (overviewzoom > 22)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "overviewzoom", 22);
            }
            if (overviewzoom < 0)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "overviewzoom", 0);
            }
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("boundingbox", boundingbox);
                tracingParameters.Add("boundingzoom", boundingzoom);
                tracingParameters.Add("overviewbox", overviewbox);
                tracingParameters.Add("overviewzoom", overviewzoom);
                tracingParameters.Add("copyright", copyright);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetTrafficIncidentViewport", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "traffic/incident/viewport/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (boundingbox != null)
            {
                _queryParameters.Add(string.Format("boundingbox={0}", System.Uri.EscapeDataString(boundingbox)));
            }
            _queryParameters.Add(string.Format("boundingzoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(boundingzoom, Client.SerializationSettings).Trim('"'))));
            if (overviewbox != null)
            {
                _queryParameters.Add(string.Format("overviewbox={0}", System.Uri.EscapeDataString(overviewbox)));
            }
            _queryParameters.Add(string.Format("overviewzoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(overviewzoom, Client.SerializationSettings).Trim('"'))));
            if (copyright != null)
            {
                _queryParameters.Add(string.Format("copyright={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(copyright, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<TrafficIncidentViewportResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<TrafficIncidentViewportResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
