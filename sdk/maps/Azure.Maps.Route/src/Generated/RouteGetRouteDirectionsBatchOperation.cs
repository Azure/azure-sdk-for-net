// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Maps.Route.Models;

namespace Azure.Maps.Route
{
    /// <summary>
    /// ### Download Asynchronous Batch Results
    /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
    /// 
    /// ```
    /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
    /// ```
    /// Here&apos;s the typical sequence of operations for downloading the batch results:
    /// 1. Client sends a `GET` request using the _download URL_.
    /// 2. The server will respond with one of the following:
    /// 
    ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
    /// 
    ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
    /// 
    /// 
    /// 
    /// ### Batch Response Model
    /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
    /// 
    ///   - [`RouteDirectionsResponse`](https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#routedirectionsresponse) - If the query completed successfully.
    /// 
    ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
    /// 
    /// 
    /// Here&apos;s a sample Batch Response with 1 _successful_ and 1 _failed_ result:
    /// 
    /// 
    /// ```json
    /// {
    ///     &quot;summary&quot;: {
    ///         &quot;successfulRequests&quot;: 1,
    ///         &quot;totalRequests&quot;: 2
    ///     },
    ///     &quot;batchItems&quot;: [
    ///         {
    ///             &quot;statusCode&quot;: 200,
    ///             &quot;response&quot;: {
    ///                 &quot;routes&quot;: [
    ///                     {
    ///                         &quot;summary&quot;: {
    ///                             &quot;lengthInMeters&quot;: 1758,
    ///                             &quot;travelTimeInSeconds&quot;: 387,
    ///                             &quot;trafficDelayInSeconds&quot;: 0,
    ///                             &quot;departureTime&quot;: &quot;2018-07-17T00:49:56+00:00&quot;,
    ///                             &quot;arrivalTime&quot;: &quot;2018-07-17T00:56:22+00:00&quot;
    ///                         },
    ///                         &quot;legs&quot;: [
    ///                             {
    ///                                 &quot;summary&quot;: {
    ///                                     &quot;lengthInMeters&quot;: 1758,
    ///                                     &quot;travelTimeInSeconds&quot;: 387,
    ///                                     &quot;trafficDelayInSeconds&quot;: 0,
    ///                                     &quot;departureTime&quot;: &quot;2018-07-17T00:49:56+00:00&quot;,
    ///                                     &quot;arrivalTime&quot;: &quot;2018-07-17T00:56:22+00:00&quot;
    ///                                 },
    ///                                 &quot;points&quot;: [
    ///                                     {
    ///                                         &quot;latitude&quot;: 47.62094,
    ///                                         &quot;longitude&quot;: -122.34892
    ///                                     },
    ///                                     {
    ///                                         &quot;latitude&quot;: 47.62094,
    ///                                         &quot;longitude&quot;: -122.3485
    ///                                     },
    ///                                     {
    ///                                         &quot;latitude&quot;: 47.62095,
    ///                                         &quot;longitude&quot;: -122.3476
    ///                                     }
    ///                                 ]
    ///                             }
    ///                         ],
    ///                         &quot;sections&quot;: [
    ///                             {
    ///                                 &quot;startPointIndex&quot;: 0,
    ///                                 &quot;endPointIndex&quot;: 40,
    ///                                 &quot;sectionType&quot;: &quot;TRAVEL_MODE&quot;,
    ///                                 &quot;travelMode&quot;: &quot;bicycle&quot;
    ///                             }
    ///                         ]
    ///                     }
    ///                 ]
    ///             }
    ///         },
    ///         {
    ///             &quot;statusCode&quot;: 400,
    ///             &quot;response&quot;:
    ///             {
    ///                 &quot;error&quot;:
    ///                 {
    ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
    ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
    ///                 }
    ///             }
    ///         }
    ///     ]
    /// }
    /// ```.
    /// </summary>
    public partial class RouteGetRouteDirectionsBatchOperation : Operation<RouteDirectionsBatchResponse>, IOperationSource<RouteDirectionsBatchResponse>
    {
        private readonly OperationInternals<RouteDirectionsBatchResponse> _operation;

        /// <summary> Initializes a new instance of RouteGetRouteDirectionsBatchOperation for mocking. </summary>
        protected RouteGetRouteDirectionsBatchOperation()
        {
        }

        internal RouteGetRouteDirectionsBatchOperation(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response)
        {
            _operation = new OperationInternals<RouteDirectionsBatchResponse>(this, clientDiagnostics, pipeline, request, response, OperationFinalStateVia.OriginalUri, "RouteGetRouteDirectionsBatchOperation");
        }

        /// <inheritdoc />
        public override string Id => _operation.Id;

        /// <inheritdoc />
        public override RouteDirectionsBatchResponse Value => _operation.Value;

        /// <inheritdoc />
        public override bool HasCompleted => _operation.HasCompleted;

        /// <inheritdoc />
        public override bool HasValue => _operation.HasValue;

        /// <inheritdoc />
        public override Response GetRawResponse() => _operation.GetRawResponse();

        /// <inheritdoc />
        public override Response UpdateStatus(CancellationToken cancellationToken = default) => _operation.UpdateStatus(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default) => _operation.UpdateStatusAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<RouteDirectionsBatchResponse>> WaitForCompletionAsync(CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<RouteDirectionsBatchResponse>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(pollingInterval, cancellationToken);

        RouteDirectionsBatchResponse IOperationSource<RouteDirectionsBatchResponse>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            using var document = JsonDocument.Parse(response.ContentStream);
            return RouteDirectionsBatchResponse.DeserializeRouteDirectionsBatchResponse(document.RootElement);
        }

        async ValueTask<RouteDirectionsBatchResponse> IOperationSource<RouteDirectionsBatchResponse>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            return RouteDirectionsBatchResponse.DeserializeRouteDirectionsBatchResponse(document.RootElement);
        }
    }
}
