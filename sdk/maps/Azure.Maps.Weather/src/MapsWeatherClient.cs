// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using Azure.Core;
using Azure.Core.GeoJson;
using Azure.Core.Pipeline;
using Azure.Maps.Common;
using Azure.Maps.Weather.Models;

namespace Azure.Maps.Weather
{
    // Data plane generated client.
    /// <summary> The Weather service client. </summary>
    public partial class MapsWeatherClient
    {
        private const string AuthorizationHeader = "subscription-key";
        // private readonly AzureKeyCredential _keyCredential;
        private static readonly string[] AuthorizationScopes = new string[] { "https://atlas.microsoft.com/.default" };
        // private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        // private readonly Uri _endpoint;
        // private readonly string _clientId;
        // private readonly string _apiVersion;


        internal WeatherRestClient restClient { get; }
        /// <summary> The _clientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics _clientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of MapsWeatherClient. </summary>
        protected MapsWeatherClient()
        {
            _clientDiagnostics = null;
            _pipeline = null;
            restClient = null;
        }

        /// <summary> Initializes a new instance of MapsWeatherClient. </summary>
        /// <param name="credential"> Shared key credential used to authenticate to an Azure Maps Render Service. </param>
        public MapsWeatherClient(AzureKeyCredential credential)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = new Uri("https://atlas.microsoft.com");
            var options = new MapsWeatherClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _pipeline = HttpPipelineBuilder.Build(options, new AzureKeyCredentialPolicy(credential, "subscription-key"));
            restClient = new WeatherRestClient(_clientDiagnostics, _pipeline, endpoint, null, options.Version);
        }

        /// <summary> Initializes a new instance of MapsWeatherClient. </summary>
        /// <param name="credential"> Shared key credential used to authenticate to an Azure Maps Render Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        public MapsWeatherClient(AzureKeyCredential credential, MapsWeatherClientOptions options)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = options.Endpoint ?? new Uri("https://atlas.microsoft.com");
            options ??= new MapsWeatherClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _pipeline = HttpPipelineBuilder.Build(options, new AzureKeyCredentialPolicy(credential, "subscription-key"));
            restClient = new WeatherRestClient(_clientDiagnostics, _pipeline, endpoint, null, options.Version);
        }

        /// <summary> Initializes a new instance of MapsWeatherClient. </summary>
        /// <param name="credential"> A credential used to authenticate to an Azure Maps Render Service. </param>
        /// <param name="clientId"> Specifies which account is intended for usage in conjunction with the Microsoft Entra ID security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Microsoft Entra ID security in Azure Maps see the following <see href="https://aka.ms/amauthdetails">articles</see> for guidance. </param>
        public MapsWeatherClient(TokenCredential credential, string clientId)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = new Uri("https://atlas.microsoft.com");
            var options = new MapsWeatherClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            string[] scopes = { "https://atlas.microsoft.com/.default" };
            _pipeline = HttpPipelineBuilder.Build(options, new BearerTokenAuthenticationPolicy(credential, scopes), new AzureKeyCredentialPolicy(new AzureKeyCredential(clientId), "x-ms-client-id"));
            restClient = new WeatherRestClient(_clientDiagnostics, _pipeline, endpoint, clientId, options.Version);
        }

        /// <summary> Initializes a new instance of MapsWeatherClient. </summary>
        /// <param name="credential"> A credential used to authenticate to an Azure Maps Render Service. </param>
        /// <param name="clientId"> Specifies which account is intended for usage in conjunction with the Microsoft Entra ID security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Microsoft Entra ID security in Azure Maps see the following <see href="https://aka.ms/amauthdetails">articles</see> for guidance. </param>
        /// <param name="options"> The options for configuring the client. </param>
        public MapsWeatherClient(TokenCredential credential, string clientId, MapsWeatherClientOptions options)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = options.Endpoint ?? new Uri("https://atlas.microsoft.com");
            options ??= new MapsWeatherClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            string[] scopes = { "https://atlas.microsoft.com/.default" };
            _pipeline = HttpPipelineBuilder.Build(options, new BearerTokenAuthenticationPolicy(credential, scopes), new AzureKeyCredentialPolicy(new AzureKeyCredential(clientId), "x-ms-client-id"));
            restClient = new WeatherRestClient(_clientDiagnostics, _pipeline, endpoint, clientId, options.Version);
        }

        /// <summary> Initializes a new instance of MapsWeatherClient. </summary>
        /// <param name="credential"> The Shared Access Signature credential used to connect to Azure. This signature
        /// can be constructed using the <see cref="AzureSasCredential"/>.</param>
        public MapsWeatherClient(AzureSasCredential credential)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = new Uri("https://atlas.microsoft.com");
            var options = new MapsWeatherClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _pipeline = HttpPipelineBuilder.Build(options, new MapsSasCredentialPolicy(credential));
            restClient = new WeatherRestClient(_clientDiagnostics, _pipeline, endpoint, null, options.Version);
        }

        /// <summary> Initializes a new instance of MapsWeatherClient. </summary>
        /// <param name="credential"> The Shared Access Signature credential used to connect to Azure. This signature
        /// can be constructed using the <see cref="AzureSasCredential"/>.</param>
        /// <param name="options"> The options for configuring the client. </param>
        public MapsWeatherClient(AzureSasCredential credential, MapsWeatherClientOptions options)
        {
            Argument.AssertNotNull(credential, nameof(credential));

            var endpoint = options.Endpoint;
            options ??= new MapsWeatherClientOptions();
            _clientDiagnostics = new ClientDiagnostics(options);
            _pipeline = HttpPipelineBuilder.Build(options, new MapsSasCredentialPolicy(credential));
            restClient = new WeatherRestClient(_clientDiagnostics, _pipeline, endpoint, null, options.Version);
        }

        /// <summary> Initializes a new instance of MapsWeatherClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="clientId"> Specifies which account is intended for usage in conjunction with the Microsoft Entra ID security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Microsoft Entra ID security in Azure Maps see the following <see href="https://aka.ms/amauthdetails">articles</see> for guidance. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="clientDiagnostics"/> or <paramref name="pipeline"/> is null. </exception>
        internal MapsWeatherClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Uri endpoint = null, string clientId = null, MapsWeatherClientOptions.ServiceVersion apiVersion = MapsWeatherClientOptions.LatestVersion)
        {
            var options = new MapsWeatherClientOptions(apiVersion);
            restClient = new WeatherRestClient(clientDiagnostics, pipeline, endpoint, clientId, options.Version);
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        /// <summary>
        /// [Protocol Method] Use to get a detailed hourly weather forecast for up to 24 hours or a daily forecast for up to 10 days.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="duration">
        /// Time frame of the returned weather forecast. By default, the forecast data for next hour will be returned. Available values are
        ///   * `1` - Return forecast data for the next hour. Default value.
        ///   * `12` - Return hourly forecast for next 12 hours.
        ///   * `24` - Return hourly forecast for next 24 hours.
        ///   * `72` - Return hourly forecast for next 72 hours (3 days).
        ///   * `120` - Return hourly forecast for next 120 hours (5 days). Only available in S1 SKU.
        ///   * `240` - Return hourly forecast for next 240 hours (10 days). Only available in S1 SKU.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<HourlyForecastResult>> GetHourlyForecastAsync(string format, GeoPosition coordinates, string unit, int? duration, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetHourlyForecast");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetHourlyForecastAsync(format, coord, unit, duration, language, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a detailed hourly weather forecast for up to 24 hours or a daily forecast for up to 10 days.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="duration">
        /// Time frame of the returned weather forecast. By default, the forecast data for next hour will be returned. Available values are
        ///   * `1` - Return forecast data for the next hour. Default value.
        ///   * `12` - Return hourly forecast for next 12 hours.
        ///   * `24` - Return hourly forecast for next 24 hours.
        ///   * `72` - Return hourly forecast for next 72 hours (3 days).
        ///   * `120` - Return hourly forecast for next 120 hours (5 days). Only available in S1 SKU.
        ///   * `240` - Return hourly forecast for next 240 hours (10 days). Only available in S1 SKU.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<HourlyForecastResult> GetHourlyForecast(string format, GeoPosition coordinates, string unit, int? duration, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetHourlyForecast");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetHourlyForecast(format, coord, unit, duration, language, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a minute-by-minute forecast for the next 120 minutes in intervals of 1, 5 and 15 minutes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="interval">
        /// Specifies time interval in minutes for the returned weather forecast. Supported values are
        ///   * `1` -  Retrieve forecast for 1-minute intervals. Returned by default.
        ///   * `5` - Retrieve forecasts for 5-minute intervals.
        ///   * `15` - Retrieve forecasts for 15-minute intervals.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<MinuteForecastResult>> GetMinuteForecastAsync(string format, GeoPosition coordinates, int? interval, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetMinuteForecast");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetMinuteForecastAsync(format, coord, interval, language, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a minute-by-minute forecast for the next 120 minutes in intervals of 1, 5 and 15 minutes.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="interval">
        /// Specifies time interval in minutes for the returned weather forecast. Supported values are
        ///   * `1` -  Retrieve forecast for 1-minute intervals. Returned by default.
        ///   * `5` - Retrieve forecasts for 5-minute intervals.
        ///   * `15` - Retrieve forecasts for 15-minute intervals.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<MinuteForecastResult> GetMinuteForecast(string format, GeoPosition coordinates, int? interval, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetMinuteForecast");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetMinuteForecast(format, coord, interval, language, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a Quarter-Day Forecast for the next 1, 5, 10, or 15 days.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="duration">
        /// Specifies for how many days the quester-day forecast responses are returned. Supported values are:
        ///   * `1` - Return forecast data for the next day. Returned by default.
        ///   * `5` - Return forecast data for the next 5 days.
        ///   * `10` - Return forecast data for next 10 days.
        ///   * `15` - Return forecast data for the next 15 days.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<QuarterDayForecastResult>> GetQuarterDayForecastAsync(string format, GeoPosition coordinates, string unit, int? duration, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetQuarterDayForecast");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetQuarterDayForecastAsync(format, coord, unit, duration, language, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a Quarter-Day Forecast for the next 1, 5, 10, or 15 days.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="duration">
        /// Specifies for how many days the quester-day forecast responses are returned. Supported values are:
        ///   * `1` - Return forecast data for the next day. Returned by default.
        ///   * `5` - Return forecast data for the next 5 days.
        ///   * `10` - Return forecast data for next 10 days.
        ///   * `15` - Return forecast data for the next 15 days.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<QuarterDayForecastResult> GetQuarterDayForecast(string format, GeoPosition coordinates, string unit, int? duration, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetQuarterDayForecast");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetQuarterDayForecast(format, coord, unit, duration, language, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get current weather conditions.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="details">
        /// Return full details for the current conditions. Available values are
        ///   * `true` - Returns full details. By default all details are returned.
        ///   * `false` - Returns a truncated version of the current condition data, which includes observation date time, weather phrase, icon code, precipitation indicator flag, and temperature.
        /// </param>
        /// <param name="duration">
        /// Time frame of the returned weather conditions. By default, the most current weather conditions will be returned. Default value is 0. Supported values are:
        ///    * `0` - Return the most current weather conditions.
        ///    * `6` - Return weather conditions from past 6 hours.
        ///    * `24` - Return weather conditions from past 24 hours.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<CurrentConditionsResult>> GetCurrentConditionsAsync(string format, GeoPosition coordinates, string unit, string details, int? duration, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetCurrentConditions");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetCurrentConditionsAsync(format, coord, unit, details, duration, language, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get current weather conditions.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="details">
        /// Return full details for the current conditions. Available values are
        ///   * `true` - Returns full details. By default all details are returned.
        ///   * `false` - Returns a truncated version of the current condition data, which includes observation date time, weather phrase, icon code, precipitation indicator flag, and temperature.
        /// </param>
        /// <param name="duration">
        /// Time frame of the returned weather conditions. By default, the most current weather conditions will be returned. Default value is 0. Supported values are:
        ///    * `0` - Return the most current weather conditions.
        ///    * `6` - Return weather conditions from past 6 hours.
        ///    * `24` - Return weather conditions from past 24 hours.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<CurrentConditionsResult> GetCurrentConditions(string format, GeoPosition coordinates, string unit, string details, int? duration, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetCurrentConditions");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetCurrentConditions(format, coord, unit, details, duration, language, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a daily detailed weather forecast for the next 1, 5, 10, 15, 25, or 45 days.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="duration">
        /// Specifies for how many days the daily forecast responses are returned. Available values are
        ///   * `1` - Return forecast data for the next day. Returned by default.
        ///   * `5` - Return forecast data for the next 5 days.
        ///   * `10` - Return forecast data for the next 10 days.
        ///   * `25` - Return forecast data for the next 25 days. Only available in S1 SKU.
        ///   * `45` - Return forecast data for the next 45 days. Only available in S1 SKU.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<DailyForecastResult>> GetDailyForecastAsync(string format, GeoPosition coordinates, string unit, int? duration, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyForecast");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetDailyForecastAsync(format, coord, unit, duration, language, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a daily detailed weather forecast for the next 1, 5, 10, 15, 25, or 45 days.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="duration">
        /// Specifies for how many days the daily forecast responses are returned. Available values are
        ///   * `1` - Return forecast data for the next day. Returned by default.
        ///   * `5` - Return forecast data for the next 5 days.
        ///   * `10` - Return forecast data for the next 10 days.
        ///   * `25` - Return forecast data for the next 25 days. Only available in S1 SKU.
        ///   * `45` - Return forecast data for the next 45 days. Only available in S1 SKU.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<DailyForecastResult> GetDailyForecast(string format, GeoPosition coordinates, string unit, int? duration, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyForecast");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetDailyForecast(format, coord, unit, duration, language, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a locationally precise, up-to-the-minute forecast that includes weather hazard assessments and notifications along a route.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="query">
        /// Coordinates through which the route is calculated, separated by colon (:) and entered in chronological order. A minimum of two waypoints is required. A single API call may contain up to 60 waypoints.
        /// A waypoint indicates location, ETA, and optional heading: latitude,longitude,ETA,heading, where
        ///   * `Latitude` - Latitude coordinate in decimal degrees.
        ///   * `Longitude` - Longitude coordinate in decimal degrees.
        ///   * `ETA (estimated time of arrival)` - The number of minutes from the present time that it will take for the vehicle to reach the waypoint. Allowed range is from 0.0 to 120.0 minutes.
        ///   * `Heading` - An optional value indicating the vehicle heading as it passes the waypoint. Expressed in clockwise degrees relative to true north. This is issued to calculate sun glare as a driving hazard. Allowed range is from 0.0 to 360.0 degrees. If not provided, a heading will automatically be derived based on the position of neighboring waypoints.
        ///
        /// It is recommended to stay within, or close to, the distance that can be traveled within 120-mins or shortly after. This way a more accurate assessment can be provided for the trip and prevent isolated events not being captured between waypoints.  Information can and should be updated along the route (especially for trips greater than 2 hours) to continuously pull new waypoints moving forward, but also to ensure that forecast information for content such as precipitation type and intensity is accurate as storms develop and dissipate over time.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="query"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<WeatherAlongRouteResult>> GetWeatherAlongRouteAsync(string format, string query, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(query, nameof(query));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetWeatherAlongRoute");
            scope.Start();
            try
            {
                return await restClient.GetWeatherAlongRouteAsync(format, query, language, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a locationally precise, up-to-the-minute forecast that includes weather hazard assessments and notifications along a route.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="query">
        /// Coordinates through which the route is calculated, separated by colon (:) and entered in chronological order. A minimum of two waypoints is required. A single API call may contain up to 60 waypoints.
        /// A waypoint indicates location, ETA, and optional heading: latitude,longitude,ETA,heading, where
        ///   * `Latitude` - Latitude coordinate in decimal degrees.
        ///   * `Longitude` - Longitude coordinate in decimal degrees.
        ///   * `ETA (estimated time of arrival)` - The number of minutes from the present time that it will take for the vehicle to reach the waypoint. Allowed range is from 0.0 to 120.0 minutes.
        ///   * `Heading` - An optional value indicating the vehicle heading as it passes the waypoint. Expressed in clockwise degrees relative to true north. This is issued to calculate sun glare as a driving hazard. Allowed range is from 0.0 to 360.0 degrees. If not provided, a heading will automatically be derived based on the position of neighboring waypoints.
        ///
        /// It is recommended to stay within, or close to, the distance that can be traveled within 120-mins or shortly after. This way a more accurate assessment can be provided for the trip and prevent isolated events not being captured between waypoints.  Information can and should be updated along the route (especially for trips greater than 2 hours) to continuously pull new waypoints moving forward, but also to ensure that forecast information for content such as precipitation type and intensity is accurate as storms develop and dissipate over time.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="query"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<WeatherAlongRouteResult> GetWeatherAlongRoute(string format, string query, string language, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(query, nameof(query));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetWeatherAlongRoute");
            scope.Start();
            try
            {
                return restClient.GetWeatherAlongRoute(format, query, language, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get information about severe weather conditions such as hurricanes, thunderstorms, flooding, lightning, heat waves or forest fires for a given location.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="details">
        /// Return full details for the severe weather alerts. Available values are
        ///   * `true` - Returns full details. By default all details are returned.
        ///   * `false` - Returns a truncated version of the alerts data, which excludes the area-specific full description of alert details (`alertDetails`).
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<SevereWeatherAlertsResult>> GetSevereWeatherAlertsAsync(string format, GeoPosition coordinates, string language, string details, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetSevereWeatherAlerts");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetSevereWeatherAlertsAsync(format, coord, language, details, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get information about severe weather conditions such as hurricanes, thunderstorms, flooding, lightning, heat waves or forest fires for a given location.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="details">
        /// Return full details for the severe weather alerts. Available values are
        ///   * `true` - Returns full details. By default all details are returned.
        ///   * `false` - Returns a truncated version of the alerts data, which excludes the area-specific full description of alert details (`alertDetails`).
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<SevereWeatherAlertsResult> GetSevereWeatherAlerts(string format, GeoPosition coordinates, string language, string details, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetSevereWeatherAlerts");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetSevereWeatherAlerts(format, coord, language, details, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use when you want to know if the weather conditions are optimal for a specific activity such as outdoor sporting activities, construction, or farming (results includes soil moisture information).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="duration">
        /// Specifies for how many days the daily indices are returned. By default, the indices data for the current day will be returned. When requesting future indices data, the current day is included in the response as day 1. Available values are
        ///   * `1` - Return daily index data for the current day. Default value.
        ///   * `5` - Return 5 days of daily index data starting from the current day.
        ///   * `10` - Return 10 days of daily index data starting from the current day.
        ///   * `15` - Return 15 days of daily index data starting from the current day.
        /// </param>
        /// <param name="indexId"> Numeric index identifier that can be used for restricting returned results to the corresponding index type. Cannot be paired with `indexGroupId`. Please refer to [Weather services in Azure Maps](/azure/azure-maps/weather-services-concepts#index-ids-and-index-groups-ids) for details and to see the supported indices. </param>
        /// <param name="indexGroupId"> Numeric index group identifier that can be used for restricting returned results to the corresponding subset of indices (index group). Cannot be paired with `indexId`. Please refer to [Weather services in Azure Maps](/azure/azure-maps/weather-services-concepts#index-ids-and-index-groups-ids) for details and to see the supported index groups. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<DailyIndicesResult>> GetDailyIndicesAsync(string format, GeoPosition coordinates, string language, int? duration, int? indexId, int? indexGroupId, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyIndices");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetDailyIndicesAsync(format, coord, language, duration, indexId, indexGroupId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use when you want to know if the weather conditions are optimal for a specific activity such as outdoor sporting activities, construction, or farming (results includes soil moisture information).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="duration">
        /// Specifies for how many days the daily indices are returned. By default, the indices data for the current day will be returned. When requesting future indices data, the current day is included in the response as day 1. Available values are
        ///   * `1` - Return daily index data for the current day. Default value.
        ///   * `5` - Return 5 days of daily index data starting from the current day.
        ///   * `10` - Return 10 days of daily index data starting from the current day.
        ///   * `15` - Return 15 days of daily index data starting from the current day.
        /// </param>
        /// <param name="indexId"> Numeric index identifier that can be used for restricting returned results to the corresponding index type. Cannot be paired with `indexGroupId`. Please refer to [Weather services in Azure Maps](/azure/azure-maps/weather-services-concepts#index-ids-and-index-groups-ids) for details and to see the supported indices. </param>
        /// <param name="indexGroupId"> Numeric index group identifier that can be used for restricting returned results to the corresponding subset of indices (index group). Cannot be paired with `indexId`. Please refer to [Weather services in Azure Maps](/azure/azure-maps/weather-services-concepts#index-ids-and-index-groups-ids) for details and to see the supported index groups. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<DailyIndicesResult> GetDailyIndices(string format, GeoPosition coordinates, string language, int? duration, int? indexId, int? indexGroupId, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyIndices");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetDailyIndices(format, coord, language, duration, indexId, indexGroupId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a list of the active tropical storms issued by national weather forecasting agencies.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<ActiveStormResult>> GetTropicalStormActiveAsync(string format, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetTropicalStormActive");
            scope.Start();
            try
            {
                return await restClient.GetTropicalStormActiveAsync(format, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a list of the active tropical storms issued by national weather forecasting agencies.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<ActiveStormResult> GetTropicalStormActive(string format, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetTropicalStormActive");
            scope.Start();
            try
            {
                return restClient.GetTropicalStormActive(format, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a list of storms issued by national weather forecasting agencies.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="year"> Year of the cyclone(s). </param>
        /// <param name="basinId"> Basin identifier. Allowed values: "AL" | "EP" | "SI" | "NI" | "CP" | "NP" | "SP". </param>
        /// <param name="governmentStormId"> Government storm Id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<StormSearchResult>> GetTropicalStormSearchAsync(string format, int year, string basinId, int? governmentStormId, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.SearchTropicalStorm");
            scope.Start();
            try
            {
                return await restClient.SearchTropicalStormAsync(format, year, basinId, governmentStormId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a list of storms issued by national weather forecasting agencies.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="year"> Year of the cyclone(s). </param>
        /// <param name="basinId"> Basin identifier. Allowed values: "AL" | "EP" | "SI" | "NI" | "CP" | "NP" | "SP". </param>
        /// <param name="governmentStormId"> Government storm Id. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<StormSearchResult> GetTropicalStormSearch(string format, int year, string basinId, int? governmentStormId, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.SearchTropicalStorm");
            scope.Start();
            try
            {
                return restClient.SearchTropicalStorm(format, year, basinId, governmentStormId, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a list of tropical storms forecasted by national weather forecasting agencies.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="year"> Year of the cyclone(s). </param>
        /// <param name="basinId"> Basin identifier. Allowed values: "AL" | "EP" | "SI" | "NI" | "CP" | "NP" | "SP". </param>
        /// <param name="governmentStormId"> Government storm Id. </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="includeDetails"> When true, wind radii summary data is included in the response. </param>
        /// <param name="includeGeometricDetails"> When true, wind radii summary data and geoJSON details are included in the response. </param>
        /// <param name="includeWindowGeometry"> When true, window geometry data (geoJSON) is included in the response. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="basinId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<StormForecastResult>> GetTropicalStormForecastAsync(string format, int year, string basinId, int governmentStormId, string unit, bool? includeDetails, bool? includeGeometricDetails, bool? includeWindowGeometry, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(basinId, nameof(basinId));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetTropicalStormForecast");
            scope.Start();
            try
            {
                return await restClient.GetTropicalStormForecastAsync(format, year, basinId, governmentStormId, unit, includeDetails, includeGeometricDetails, includeWindowGeometry, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get a list of tropical storms forecasted by national weather forecasting agencies.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="year"> Year of the cyclone(s). </param>
        /// <param name="basinId"> Basin identifier. Allowed values: "AL" | "EP" | "SI" | "NI" | "CP" | "NP" | "SP". </param>
        /// <param name="governmentStormId"> Government storm Id. </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="includeDetails"> When true, wind radii summary data is included in the response. </param>
        /// <param name="includeGeometricDetails"> When true, wind radii summary data and geoJSON details are included in the response. </param>
        /// <param name="includeWindowGeometry"> When true, window geometry data (geoJSON) is included in the response. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="basinId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<StormForecastResult> GetTropicalStormForecast(string format, int year, string basinId, int governmentStormId, string unit, bool? includeDetails, bool? includeGeometricDetails, bool? includeWindowGeometry, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(basinId, nameof(basinId));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetTropicalStormForecast");
            scope.Start();
            try
            {
                return restClient.GetTropicalStormForecast(format, year, basinId, governmentStormId, unit, includeDetails, includeGeometricDetails, includeWindowGeometry, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get the location of tropical storms from individual national weather forecasting agencies.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="year"> Year of the cyclone(s). </param>
        /// <param name="basinId"> Basin identifier. Allowed values: "AL" | "EP" | "SI" | "NI" | "CP" | "NP" | "SP". </param>
        /// <param name="governmentStormId"> Government storm Id. </param>
        /// <param name="includeDetails"> When true, wind radii summary data is included in the response. </param>
        /// <param name="includeGeometricDetails"> When true, wind radii summary data and geoJSON details are included in the response. </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="includeCurrentStorm"> When true, return the current storm location. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="basinId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<StormLocationsResult>> GetTropicalStormLocationsAsync(string format, int year, string basinId, int governmentStormId, bool? includeDetails, bool? includeGeometricDetails, string unit, bool? includeCurrentStorm, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(basinId, nameof(basinId));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetTropicalStormLocations");
            scope.Start();
            try
            {
                return await restClient.GetTropicalStormLocationsAsync(format, year, basinId, governmentStormId, includeDetails, includeGeometricDetails, unit, includeCurrentStorm, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get the location of tropical storms from individual national weather forecasting agencies.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="year"> Year of the cyclone(s). </param>
        /// <param name="basinId"> Basin identifier. Allowed values: "AL" | "EP" | "SI" | "NI" | "CP" | "NP" | "SP". </param>
        /// <param name="governmentStormId"> Government storm Id. </param>
        /// <param name="includeDetails"> When true, wind radii summary data is included in the response. </param>
        /// <param name="includeGeometricDetails"> When true, wind radii summary data and geoJSON details are included in the response. </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="includeCurrentStorm"> When true, return the current storm location. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="basinId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<StormLocationsResult> GetTropicalStormLocations(string format, int year, string basinId, int governmentStormId, bool? includeDetails, bool? includeGeometricDetails, string unit, bool? includeCurrentStorm, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(basinId, nameof(basinId));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetTropicalStormLocations");
            scope.Start();
            try
            {
                return restClient.GetTropicalStormLocations(format, year, basinId, governmentStormId, includeDetails, includeGeometricDetails, unit, includeCurrentStorm, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get current air quality information that includes potential risks and suggested precautions.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="includePollutantDetails"> Boolean value that returns detailed information about each pollutant. By default is True. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<AirQualityResult>> GetCurrentAirQualityAsync(string format, GeoPosition coordinates, string language, bool? includePollutantDetails, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetCurrentAirQuality");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetCurrentAirQualityAsync(format, coord, language, includePollutantDetails, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get current air quality information that includes potential risks and suggested precautions.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="includePollutantDetails"> Boolean value that returns detailed information about each pollutant. By default is True. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<AirQualityResult> GetCurrentAirQuality(string format, GeoPosition coordinates, string language, bool? includePollutantDetails, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetCurrentAirQuality");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetCurrentAirQuality(format, coord, language, includePollutantDetails, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get daily air quality forecasts for the next one to seven days that include pollutant levels, potential risks and suggested precautions.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="duration"> Specifies for how many days from now we would like to know about the air quality. Available values are 1, 2, 3, 4, 5, 6, and 7. Default value is 1. Allowed values: "1" | "2" | "3" | "4" | "5" | "6" | "7". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<DailyAirQualityForecastResult>> GetAirQualityDailyForecastsAsync(string format, GeoPosition coordinates, string language, int? duration, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetAirQualityDailyForecasts");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetAirQualityDailyForecastsAsync(format, coord, language, duration, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get daily air quality forecasts for the next one to seven days that include pollutant levels, potential risks and suggested precautions.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="duration"> Specifies for how many days from now we would like to know about the air quality. Available values are 1, 2, 3, 4, 5, 6, and 7. Default value is 1. Allowed values: "1" | "2" | "3" | "4" | "5" | "6" | "7". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<DailyAirQualityForecastResult> GetAirQualityDailyForecasts(string format, GeoPosition coordinates, string language, int? duration, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetAirQualityDailyForecasts");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetAirQualityDailyForecasts(format, coord, language, duration, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get hourly air quality forecasts for the next one to 96 hours that include pollutant levels, potential risks and suggested precautions.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="duration"> Specifies for how many hours from now we would like to know about the air quality. Available values are 1, 12, 24, 48, 72, 96. Default value is 1 hour. Allowed values: "1" | "12" | "24" | "48" | "72" | "96". </param>
        /// <param name="includePollutantDetails"> Boolean value that returns detailed information about each pollutant. By default is True. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<AirQualityResult>> GetAirQualityHourlyForecastsAsync(string format, GeoPosition coordinates, string language, int? duration, bool? includePollutantDetails, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetAirQualityHourlyForecasts");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetAirQualityHourlyForecastsAsync(format, coord, language, duration, includePollutantDetails, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get hourly air quality forecasts for the next one to 96 hours that include pollutant levels, potential risks and suggested precautions.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="duration"> Specifies for how many hours from now we would like to know about the air quality. Available values are 1, 12, 24, 48, 72, 96. Default value is 1 hour. Allowed values: "1" | "12" | "24" | "48" | "72" | "96". </param>
        /// <param name="includePollutantDetails"> Boolean value that returns detailed information about each pollutant. By default is True. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<AirQualityResult> GetAirQualityHourlyForecasts(string format, GeoPosition coordinates, string language, int? duration, bool? includePollutantDetails, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetAirQualityHourlyForecasts");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetAirQualityHourlyForecasts(format, coord, language, duration, includePollutantDetails, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get climatology data such as past daily actual observed temperatures, precipitation, snowfall and snow depth.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="startDate"> Start date in ISO 8601 format, for example, 2019-10-27. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="endDate"> End date in ISO 8601 format, for example, 2019-10-28. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<DailyHistoricalActualsResult>> GetDailyHistoricalActualsAsync(string format, GeoPosition coordinates, DateTimeOffset startDate, DateTimeOffset endDate, string unit, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyHistoricalActuals");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetDailyHistoricalActualsAsync(format, coord, startDate, endDate, unit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get climatology data such as past daily actual observed temperatures, precipitation, snowfall and snow depth.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="startDate"> Start date in ISO 8601 format, for example, 2019-10-27. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="endDate"> End date in ISO 8601 format, for example, 2019-10-28. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<DailyHistoricalActualsResult> GetDailyHistoricalActuals(string format, GeoPosition coordinates, DateTimeOffset startDate, DateTimeOffset endDate, string unit, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyHistoricalActuals");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetDailyHistoricalActuals(format, coord, startDate, endDate, unit, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get climatology data such as past daily record temperatures, precipitation and snowfall at a given location.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="startDate"> Start date in ISO 8601 format, for example, 2019-10-27. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="endDate"> End date in ISO 8601 format, for example, 2019-10-28. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<DailyHistoricalRecordsResult>> GetDailyHistoricalRecordsAsync(string format, GeoPosition coordinates, DateTimeOffset startDate, DateTimeOffset endDate, string unit, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyHistoricalRecords");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetDailyHistoricalRecordsAsync(format, coord, startDate, endDate, unit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get climatology data such as past daily record temperatures, precipitation and snowfall at a given location.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="startDate"> Start date in ISO 8601 format, for example, 2019-10-27. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="endDate"> End date in ISO 8601 format, for example, 2019-10-28. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<DailyHistoricalRecordsResult> GetDailyHistoricalRecords(string format, GeoPosition coordinates, DateTimeOffset startDate, DateTimeOffset endDate, string unit, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyHistoricalRecords");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetDailyHistoricalRecords(format, coord, startDate, endDate, unit, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get climatology data such as past daily normal temperatures, precipitation and cooling/heating degree day information for a given location.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="startDate"> Start date in ISO 8601 format, for example, 2019-10-27. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="endDate"> End date in ISO 8601 format, for example, 2019-10-28. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response<DailyHistoricalNormalsResult>> GetDailyHistoricalNormalsAsync(string format, GeoPosition coordinates, DateTimeOffset startDate, DateTimeOffset endDate, string unit, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyHistoricalNormals");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return await restClient.GetDailyHistoricalNormalsAsync(format, coord, startDate, endDate, unit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Use to get climatology data such as past daily normal temperatures, precipitation and cooling/heating degree day information for a given location.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. The default value is "json". Allowed values: "json". </param>
        /// <param name="coordinates">
        /// The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        ///
        /// Weather information is generally available for locations on land, bodies of water surrounded by land, and areas of the ocean that are within approximately 50 nautical miles of a coastline.
        /// </param>
        /// <param name="startDate"> Start date in ISO 8601 format, for example, 2019-10-27. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="endDate"> End date in ISO 8601 format, for example, 2019-10-28. The date range supported is 1 to 31 calendar days, so be sure to specify a startDate and endDate that does not exceed a maximum of 31 days (i.e.: startDate=2012-01-01&amp;endDate=2012-01-31). </param>
        /// <param name="unit"> Specifies to return the data in either metric units or imperial units. Default value is metric. Allowed values: "metric" | "imperial". </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> or <paramref name="coordinates"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="format"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response<DailyHistoricalNormalsResult> GetDailyHistoricalNormals(string format, GeoPosition coordinates, DateTimeOffset startDate, DateTimeOffset endDate, string unit, CancellationToken cancellationToken = default)
        {
            Common.Argument.AssertNotNullOrEmpty(format, nameof(format));
            Common.Argument.AssertNotNull(coordinates, nameof(coordinates));

            using var scope = _clientDiagnostics.CreateScope("WeatherClient.GetDailyHistoricalNormals");
            scope.Start();
            try
            {
                var coord = new[]
                {
                    Convert.ToDouble(coordinates.Latitude, CultureInfo.InvariantCulture.NumberFormat),
                    Convert.ToDouble(coordinates.Longitude, CultureInfo.InvariantCulture.NumberFormat)
                };
                return restClient.GetDailyHistoricalNormals(format, coord, startDate, endDate, unit, cancellationToken);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // internal HttpMessage CreateGetHourlyForecastRequest(string format, IEnumerable<double> coordinates, string unit, int? duration, string language, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/forecast/hourly/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (unit != null)
        //     {
        //         uri.AppendQuery("unit", unit, true);
        //     }
        //     if (duration != null)
        //     {
        //         uri.AppendQuery("duration", duration.Value, true);
        //     }
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetMinuteForecastRequest(string format, IEnumerable<double> coordinates, int? interval, string language, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/forecast/minute/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (interval != null)
        //     {
        //         uri.AppendQuery("interval", interval.Value, true);
        //     }
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetQuarterDayForecastRequest(string format, IEnumerable<double> coordinates, string unit, int? duration, string language, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/forecast/quarterDay/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (unit != null)
        //     {
        //         uri.AppendQuery("unit", unit, true);
        //     }
        //     if (duration != null)
        //     {
        //         uri.AppendQuery("duration", duration.Value, true);
        //     }
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetCurrentConditionsRequest(string format, IEnumerable<double> coordinates, string unit, string details, int? duration, string language, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/currentConditions/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (unit != null)
        //     {
        //         uri.AppendQuery("unit", unit, true);
        //     }
        //     if (details != null)
        //     {
        //         uri.AppendQuery("details", details, true);
        //     }
        //     if (duration != null)
        //     {
        //         uri.AppendQuery("duration", duration.Value, true);
        //     }
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetDailyForecastRequest(string format, IEnumerable<double> coordinates, string unit, int? duration, string language, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/forecast/daily/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (unit != null)
        //     {
        //         uri.AppendQuery("unit", unit, true);
        //     }
        //     if (duration != null)
        //     {
        //         uri.AppendQuery("duration", duration.Value, true);
        //     }
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetWeatherAlongRouteRequest(string format, string query, string language, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/route/", false);
        //     uri.AppendPath(format, true);
        //     uri.AppendQuery("query", query, true);
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetSevereWeatherAlertsRequest(string format, IEnumerable<double> coordinates, string language, string details, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/severe/alerts/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     if (details != null)
        //     {
        //         uri.AppendQuery("details", details, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetDailyIndicesRequest(string format, IEnumerable<double> coordinates, string language, int? duration, int? indexId, int? indexGroupId, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/indices/daily/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     if (duration != null)
        //     {
        //         uri.AppendQuery("duration", duration.Value, true);
        //     }
        //     if (indexId != null)
        //     {
        //         uri.AppendQuery("indexId", indexId.Value, true);
        //     }
        //     if (indexGroupId != null)
        //     {
        //         uri.AppendQuery("indexGroupId", indexGroupId.Value, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetTropicalStormActiveRequest(string format, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/tropical/storms/active/", false);
        //     uri.AppendPath(format, true);
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateSearchTropicalStormRequest(string format, int year, string basinId, int? governmentStormId, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/tropical/storms/", false);
        //     uri.AppendPath(format, true);
        //     uri.AppendQuery("year", year, true);
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (basinId != null)
        //     {
        //         uri.AppendQuery("basinId", basinId, true);
        //     }
        //     if (governmentStormId != null)
        //     {
        //         uri.AppendQuery("govId", governmentStormId.Value, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetTropicalStormForecastRequest(string format, int year, string basinId, int governmentStormId, string unit, bool? includeDetails, bool? includeGeometricDetails, bool? includeWindowGeometry, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/tropical/storms/forecasts/", false);
        //     uri.AppendPath(format, true);
        //     uri.AppendQuery("year", year, true);
        //     uri.AppendQuery("basinId", basinId, true);
        //     uri.AppendQuery("govId", governmentStormId, true);
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (unit != null)
        //     {
        //         uri.AppendQuery("unit", unit, true);
        //     }
        //     if (includeDetails != null)
        //     {
        //         uri.AppendQuery("details", includeDetails.Value, true);
        //     }
        //     if (includeGeometricDetails != null)
        //     {
        //         uri.AppendQuery("radiiGeometry", includeGeometricDetails.Value, true);
        //     }
        //     if (includeWindowGeometry != null)
        //     {
        //         uri.AppendQuery("windowGeometry", includeWindowGeometry.Value, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetTropicalStormLocationsRequest(string format, int year, string basinId, int governmentStormId, bool? includeDetails, bool? includeGeometricDetails, string unit, bool? includeCurrentStorm, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/tropical/storms/locations/", false);
        //     uri.AppendPath(format, true);
        //     uri.AppendQuery("year", year, true);
        //     uri.AppendQuery("basinId", basinId, true);
        //     uri.AppendQuery("govId", governmentStormId, true);
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (includeDetails != null)
        //     {
        //         uri.AppendQuery("details", includeDetails.Value, true);
        //     }
        //     if (includeGeometricDetails != null)
        //     {
        //         uri.AppendQuery("radiiGeometry", includeGeometricDetails.Value, true);
        //     }
        //     if (unit != null)
        //     {
        //         uri.AppendQuery("unit", unit, true);
        //     }
        //     if (includeCurrentStorm != null)
        //     {
        //         uri.AppendQuery("current", includeCurrentStorm.Value, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetCurrentAirQualityRequest(string format, IEnumerable<double> coordinates, string language, bool? includePollutantDetails, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/airQuality/current/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     if (includePollutantDetails != null)
        //     {
        //         uri.AppendQuery("pollutants", includePollutantDetails.Value, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetAirQualityDailyForecastsRequest(string format, IEnumerable<double> coordinates, string language, int? duration, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/airQuality/forecasts/daily/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     if (duration != null)
        //     {
        //         uri.AppendQuery("duration", duration.Value, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetAirQualityHourlyForecastsRequest(string format, IEnumerable<double> coordinates, string language, int? duration, bool? includePollutantDetails, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/airQuality/forecasts/hourly/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (language != null)
        //     {
        //         uri.AppendQuery("language", language, true);
        //     }
        //     if (duration != null)
        //     {
        //         uri.AppendQuery("duration", duration.Value, true);
        //     }
        //     if (includePollutantDetails != null)
        //     {
        //         uri.AppendQuery("pollutants", includePollutantDetails.Value, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetDailyHistoricalActualsRequest(string format, IEnumerable<double> coordinates, DateTimeOffset startDate, DateTimeOffset endDate, string unit, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/historical/actuals/daily/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("startDate", startDate, "D", true);
        //     uri.AppendQuery("endDate", endDate, "D", true);
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (unit != null)
        //     {
        //         uri.AppendQuery("unit", unit, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetDailyHistoricalRecordsRequest(string format, IEnumerable<double> coordinates, DateTimeOffset startDate, DateTimeOffset endDate, string unit, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/historical/records/daily/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("startDate", startDate, "D", true);
        //     uri.AppendQuery("endDate", endDate, "D", true);
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (unit != null)
        //     {
        //         uri.AppendQuery("unit", unit, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // internal HttpMessage CreateGetDailyHistoricalNormalsRequest(string format, IEnumerable<double> coordinates, DateTimeOffset startDate, DateTimeOffset endDate, string unit, RequestContext context)
        // {
        //     var message = _pipeline.CreateMessage(context, ResponseClassifier200);
        //     var request = message.Request;
        //     request.Method = RequestMethod.Get;
        //     var uri = new RawRequestUriBuilder();
        //     uri.Reset(_endpoint);
        //     uri.AppendPath("/weather/historical/normals/daily/", false);
        //     uri.AppendPath(format, true);
        //     if (coordinates != null && !(coordinates is Common.ChangeTrackingList<double> changeTrackingList && changeTrackingList.IsUndefined))
        //     {
        //         uri.AppendQueryDelimited("query", coordinates, ",", true);
        //     }
        //     uri.AppendQuery("startDate", startDate, "D", true);
        //     uri.AppendQuery("endDate", endDate, "D", true);
        //     uri.AppendQuery("api-version", _apiVersion, true);
        //     if (unit != null)
        //     {
        //         uri.AppendQuery("unit", unit, true);
        //     }
        //     request.Uri = uri;
        //     request.Headers.Add("Accept", "application/json");
        //     if (_clientId != null)
        //     {
        //         request.Headers.Add("x-ms-client-id", _clientId);
        //     }
        //     return message;
        // }

        // private static ResponseClassifier _responseClassifier200;
        // private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
    }
}
