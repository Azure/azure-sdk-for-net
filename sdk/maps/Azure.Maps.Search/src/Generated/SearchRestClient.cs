// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Maps.Search.Models;

namespace Azure.Maps.Search
{
    internal partial class SearchRestClient
    {
        private Geography? geography;
        private string xMsClientId;
        private string apiVersion;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of SearchRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="geography"> This parameter specifies where the Azure Maps Creator resource is located.  Valid values are us and eu. </param>
        /// <param name="xMsClientId"> Specifies which account is intended for usage in conjunction with the Azure AD security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Azure AD security in Azure Maps see the following [articles](https://aka.ms/amauthdetails) for guidance. </param>
        /// <param name="apiVersion"> Api Version. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="apiVersion"/> is null. </exception>
        public SearchRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Geography? geography = default, string xMsClientId = null, string apiVersion = "1.0")
        {
            geography ??= Geography.Us;
            if (apiVersion == null)
            {
                throw new ArgumentNullException(nameof(apiVersion));
            }

            this.geography = geography;
            this.xMsClientId = xMsClientId;
            this.apiVersion = apiVersion;
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateGetSearchPolygonRequest(ResponseFormat format, IEnumerable<string> geometries)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/polygon/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQueryDelimited("geometries", geometries, ",", true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Get Polygon**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// The Get Polygon service allows you to request the geometry data such as a city or country  outline for a set of entities, previously retrieved from an Online Search request in GeoJSON format. The geometry  ID is returned in the dataSources object under &quot;geometry&quot; and &quot;id&quot; in either a Search Address or Search Fuzzy call.
        /// 
        /// Please note that any geometry ID retrieved from an Online Search endpoint has a limited lifetime. The client  should not store geometry IDs in persistent storage for later referral, as the stability of these identifiers is  not guaranteed for a long period of time. It is expected that a request to the Polygon method is made within a  few minutes of the request to the Online Search method that provided the ID. The service allows for batch  requests up to 20 identifiers.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="geometries"> Comma separated list of geometry UUIDs, previously retrieved from an Online Search request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="geometries"/> is null. </exception>
        public async Task<Response<SearchPolygonResponse>> GetSearchPolygonAsync(ResponseFormat format, IEnumerable<string> geometries, CancellationToken cancellationToken = default)
        {
            if (geometries == null)
            {
                throw new ArgumentNullException(nameof(geometries));
            }

            using var message = CreateGetSearchPolygonRequest(format, geometries);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchPolygonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchPolygonResponse.DeserializeSearchPolygonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Get Polygon**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// The Get Polygon service allows you to request the geometry data such as a city or country  outline for a set of entities, previously retrieved from an Online Search request in GeoJSON format. The geometry  ID is returned in the dataSources object under &quot;geometry&quot; and &quot;id&quot; in either a Search Address or Search Fuzzy call.
        /// 
        /// Please note that any geometry ID retrieved from an Online Search endpoint has a limited lifetime. The client  should not store geometry IDs in persistent storage for later referral, as the stability of these identifiers is  not guaranteed for a long period of time. It is expected that a request to the Polygon method is made within a  few minutes of the request to the Online Search method that provided the ID. The service allows for batch  requests up to 20 identifiers.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="geometries"> Comma separated list of geometry UUIDs, previously retrieved from an Online Search request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="geometries"/> is null. </exception>
        public Response<SearchPolygonResponse> GetSearchPolygon(ResponseFormat format, IEnumerable<string> geometries, CancellationToken cancellationToken = default)
        {
            if (geometries == null)
            {
                throw new ArgumentNullException(nameof(geometries));
            }

            using var message = CreateGetSearchPolygonRequest(format, geometries);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchPolygonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchPolygonResponse.DeserializeSearchPolygonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchFuzzyRequest(TextFormat format, string query, bool? typeahead, int? limit, int? ofs, IEnumerable<int> categorySet, IEnumerable<string> countrySet, float? lat, float? lon, float? radius, string topLeft, string btmRight, string language, string extendedPostalCodesFor, int? minFuzzyLevel, int? maxFuzzyLevel, IEnumerable<SearchIndexSet> idxSet, IEnumerable<string> brandSet, IEnumerable<ConnectorSet> connectorSet, string view, OpeningHours? openingHours)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/fuzzy/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("query", query, true);
            if (typeahead != null)
            {
                uri.AppendQuery("typeahead", typeahead.Value, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (ofs != null)
            {
                uri.AppendQuery("ofs", ofs.Value, true);
            }
            if (categorySet != null)
            {
                uri.AppendQueryDelimited("categorySet", categorySet, ",", true);
            }
            if (countrySet != null)
            {
                uri.AppendQueryDelimited("countrySet", countrySet, ",", true);
            }
            if (lat != null)
            {
                uri.AppendQuery("lat", lat.Value, true);
            }
            if (lon != null)
            {
                uri.AppendQuery("lon", lon.Value, true);
            }
            if (radius != null)
            {
                uri.AppendQuery("radius", radius.Value, true);
            }
            if (topLeft != null)
            {
                uri.AppendQuery("topLeft", topLeft, true);
            }
            if (btmRight != null)
            {
                uri.AppendQuery("btmRight", btmRight, true);
            }
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (extendedPostalCodesFor != null)
            {
                uri.AppendQuery("extendedPostalCodesFor", extendedPostalCodesFor, true);
            }
            if (minFuzzyLevel != null)
            {
                uri.AppendQuery("minFuzzyLevel", minFuzzyLevel.Value, true);
            }
            if (maxFuzzyLevel != null)
            {
                uri.AppendQuery("maxFuzzyLevel", maxFuzzyLevel.Value, true);
            }
            if (idxSet != null)
            {
                uri.AppendQueryDelimited("idxSet", idxSet, ",", true);
            }
            if (brandSet != null)
            {
                uri.AppendQueryDelimited("brandSet", brandSet, ",", true);
            }
            if (connectorSet != null)
            {
                uri.AppendQueryDelimited("connectorSet", connectorSet, ",", true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            if (openingHours != null)
            {
                uri.AppendQuery("openingHours", openingHours.Value.ToString(), true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// 
        /// **Free Form Search**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// The basic default API is Free Form Search which handles the most fuzzy of inputs handling any combination of address or POI tokens. This search API is the canonical &apos;single line search&apos;. The Free Form Search API is a seamless combination of POI search and geocoding. The API can also be weighted with a contextual position (lat./lon. pair), or fully constrained by a coordinate and radius, or it can be executed more generally without any geo biasing anchor point.&lt;br&gt;&lt;br&gt;We strongly advise you to use the &apos;countrySet&apos; parameter to specify only the countries for which your application needs coverage, as the default behavior will be to search the entire world, potentially returning unnecessary results.&lt;br&gt;&lt;br&gt; E.g.: `countrySet`=US,FR &lt;br&gt;&lt;br&gt;Please see [Search Coverage](https://docs.microsoft.com/azure/location-based-services/geocoding-coverage) for a complete list of all the supported countries.&lt;br&gt;&lt;br&gt;Most Search queries default to `maxFuzzyLevel`=2 to gain performance and also reduce unusual results. This new default can be overridden as needed per request by passing in the query param `maxFuzzyLevel`=3 or 4.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The applicable query string (e.g., &quot;seattle&quot;, &quot;pizza&quot;). Can _also_ be specified as a comma separated string composed by latitude followed by longitude (e.g., &quot;47.641268, -122.125679&quot;). Must be properly URL encoded. </param>
        /// <param name="typeahead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="topLeft"> Top left position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="btmRight"> Bottom right position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="minFuzzyLevel">
        /// Minimum fuzziness level to be used. Default: 1, minimum: 1 and maximum: 4
        /// 
        /// * Level 1 has no spell checking.
        /// 
        /// * Level 2 uses normal n-gram spell checking. For example, query &quot;restrant&quot; can be matched to &quot;restaurant.&quot;
        /// 
        /// * Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell checking is for &quot;rstrnt&quot; to &quot;restaurant&quot; matching. Shingle spell checking is for &quot;mountainview&quot; to &quot;mountain view&quot; matching.
        /// 
        /// * Level 4 doesn’t add any more spell checking functions.
        /// 
        /// 
        /// 
        /// The search engine will start looking for a match on the level defined by minFuzzyLevel, and will stop searching at the level specified by maxFuzzyLevel.
        /// </param>
        /// <param name="maxFuzzyLevel">
        /// Maximum fuzziness level to be used. Default: 2, minimum: 1 and maximum: 4
        /// 
        /// * Level 1 has no spell checking.
        /// 
        /// * Level 2 uses normal n-gram spell checking. For example, query &quot;restrant&quot; can be matched to &quot;restaurant.&quot;
        /// 
        /// * Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell checking is for &quot;rstrnt&quot; to &quot;restaurant&quot; matching. Shingle spell checking is for &quot;mountainview&quot; to &quot;mountain view&quot; matching.
        /// 
        /// * Level 4 doesn’t add any more spell checking functions.
        /// 
        /// 
        /// 
        /// The search engine will start looking for a match on the level defined by minFuzzyLevel, and will stop searching at the level specified by maxFuzzyLevel.
        /// </param>
        /// <param name="idxSet"> A comma separated list of indexes which should be utilized for the search. Item order does not matter. Available indexes are: Addr = Address range interpolation, Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross Streets (intersections). </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public async Task<Response<SearchCommonResponse>> GetSearchFuzzyAsync(TextFormat format, string query, bool? typeahead = null, int? limit = null, int? ofs = null, IEnumerable<int> categorySet = null, IEnumerable<string> countrySet = null, float? lat = null, float? lon = null, float? radius = null, string topLeft = null, string btmRight = null, string language = null, string extendedPostalCodesFor = null, int? minFuzzyLevel = null, int? maxFuzzyLevel = null, IEnumerable<SearchIndexSet> idxSet = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchFuzzyRequest(format, query, typeahead, limit, ofs, categorySet, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, minFuzzyLevel, maxFuzzyLevel, idxSet, brandSet, connectorSet, view, openingHours);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// 
        /// **Free Form Search**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// The basic default API is Free Form Search which handles the most fuzzy of inputs handling any combination of address or POI tokens. This search API is the canonical &apos;single line search&apos;. The Free Form Search API is a seamless combination of POI search and geocoding. The API can also be weighted with a contextual position (lat./lon. pair), or fully constrained by a coordinate and radius, or it can be executed more generally without any geo biasing anchor point.&lt;br&gt;&lt;br&gt;We strongly advise you to use the &apos;countrySet&apos; parameter to specify only the countries for which your application needs coverage, as the default behavior will be to search the entire world, potentially returning unnecessary results.&lt;br&gt;&lt;br&gt; E.g.: `countrySet`=US,FR &lt;br&gt;&lt;br&gt;Please see [Search Coverage](https://docs.microsoft.com/azure/location-based-services/geocoding-coverage) for a complete list of all the supported countries.&lt;br&gt;&lt;br&gt;Most Search queries default to `maxFuzzyLevel`=2 to gain performance and also reduce unusual results. This new default can be overridden as needed per request by passing in the query param `maxFuzzyLevel`=3 or 4.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The applicable query string (e.g., &quot;seattle&quot;, &quot;pizza&quot;). Can _also_ be specified as a comma separated string composed by latitude followed by longitude (e.g., &quot;47.641268, -122.125679&quot;). Must be properly URL encoded. </param>
        /// <param name="typeahead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="topLeft"> Top left position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="btmRight"> Bottom right position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="minFuzzyLevel">
        /// Minimum fuzziness level to be used. Default: 1, minimum: 1 and maximum: 4
        /// 
        /// * Level 1 has no spell checking.
        /// 
        /// * Level 2 uses normal n-gram spell checking. For example, query &quot;restrant&quot; can be matched to &quot;restaurant.&quot;
        /// 
        /// * Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell checking is for &quot;rstrnt&quot; to &quot;restaurant&quot; matching. Shingle spell checking is for &quot;mountainview&quot; to &quot;mountain view&quot; matching.
        /// 
        /// * Level 4 doesn’t add any more spell checking functions.
        /// 
        /// 
        /// 
        /// The search engine will start looking for a match on the level defined by minFuzzyLevel, and will stop searching at the level specified by maxFuzzyLevel.
        /// </param>
        /// <param name="maxFuzzyLevel">
        /// Maximum fuzziness level to be used. Default: 2, minimum: 1 and maximum: 4
        /// 
        /// * Level 1 has no spell checking.
        /// 
        /// * Level 2 uses normal n-gram spell checking. For example, query &quot;restrant&quot; can be matched to &quot;restaurant.&quot;
        /// 
        /// * Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell checking is for &quot;rstrnt&quot; to &quot;restaurant&quot; matching. Shingle spell checking is for &quot;mountainview&quot; to &quot;mountain view&quot; matching.
        /// 
        /// * Level 4 doesn’t add any more spell checking functions.
        /// 
        /// 
        /// 
        /// The search engine will start looking for a match on the level defined by minFuzzyLevel, and will stop searching at the level specified by maxFuzzyLevel.
        /// </param>
        /// <param name="idxSet"> A comma separated list of indexes which should be utilized for the search. Item order does not matter. Available indexes are: Addr = Address range interpolation, Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross Streets (intersections). </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public Response<SearchCommonResponse> GetSearchFuzzy(TextFormat format, string query, bool? typeahead = null, int? limit = null, int? ofs = null, IEnumerable<int> categorySet = null, IEnumerable<string> countrySet = null, float? lat = null, float? lon = null, float? radius = null, string topLeft = null, string btmRight = null, string language = null, string extendedPostalCodesFor = null, int? minFuzzyLevel = null, int? maxFuzzyLevel = null, IEnumerable<SearchIndexSet> idxSet = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchFuzzyRequest(format, query, typeahead, limit, ofs, categorySet, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, minFuzzyLevel, maxFuzzyLevel, idxSet, brandSet, connectorSet, view, openingHours);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchPOIRequest(TextFormat format, string query, bool? typeahead, int? limit, int? ofs, IEnumerable<int> categorySet, IEnumerable<string> countrySet, float? lat, float? lon, float? radius, string topLeft, string btmRight, string language, string extendedPostalCodesFor, IEnumerable<string> brandSet, IEnumerable<ConnectorSet> connectorSet, string view, OpeningHours? openingHours)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/poi/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("query", query, true);
            if (typeahead != null)
            {
                uri.AppendQuery("typeahead", typeahead.Value, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (ofs != null)
            {
                uri.AppendQuery("ofs", ofs.Value, true);
            }
            if (categorySet != null)
            {
                uri.AppendQueryDelimited("categorySet", categorySet, ",", true);
            }
            if (countrySet != null)
            {
                uri.AppendQueryDelimited("countrySet", countrySet, ",", true);
            }
            if (lat != null)
            {
                uri.AppendQuery("lat", lat.Value, true);
            }
            if (lon != null)
            {
                uri.AppendQuery("lon", lon.Value, true);
            }
            if (radius != null)
            {
                uri.AppendQuery("radius", radius.Value, true);
            }
            if (topLeft != null)
            {
                uri.AppendQuery("topLeft", topLeft, true);
            }
            if (btmRight != null)
            {
                uri.AppendQuery("btmRight", btmRight, true);
            }
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (extendedPostalCodesFor != null)
            {
                uri.AppendQuery("extendedPostalCodesFor", extendedPostalCodesFor, true);
            }
            if (brandSet != null)
            {
                uri.AppendQueryDelimited("brandSet", brandSet, ",", true);
            }
            if (connectorSet != null)
            {
                uri.AppendQueryDelimited("connectorSet", connectorSet, ",", true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            if (openingHours != null)
            {
                uri.AppendQuery("openingHours", openingHours.Value.ToString(), true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Get POI by Name**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// Points of Interest (POI) Search allows you to request POI results by name.  Search supports additional query parameters such as language and filtering results by area of interest driven by country or bounding box.  Endpoint will return only POI results matching the query string. Response includes POI details such as address, coordinate location and category.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The POI name to search for (e.g., &quot;statue of liberty&quot;, &quot;starbucks&quot;), must be properly URL encoded. </param>
        /// <param name="typeahead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="topLeft"> Top left position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="btmRight"> Bottom right position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **POI** = Points of Interest
        /// 
        /// Value should be **POI** or **None** to disable extended postal codes.
        /// 
        /// By default extended postal codes are included.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public async Task<Response<SearchCommonResponse>> GetSearchPOIAsync(TextFormat format, string query, bool? typeahead = null, int? limit = null, int? ofs = null, IEnumerable<int> categorySet = null, IEnumerable<string> countrySet = null, float? lat = null, float? lon = null, float? radius = null, string topLeft = null, string btmRight = null, string language = null, string extendedPostalCodesFor = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchPOIRequest(format, query, typeahead, limit, ofs, categorySet, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, brandSet, connectorSet, view, openingHours);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Get POI by Name**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// Points of Interest (POI) Search allows you to request POI results by name.  Search supports additional query parameters such as language and filtering results by area of interest driven by country or bounding box.  Endpoint will return only POI results matching the query string. Response includes POI details such as address, coordinate location and category.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The POI name to search for (e.g., &quot;statue of liberty&quot;, &quot;starbucks&quot;), must be properly URL encoded. </param>
        /// <param name="typeahead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="topLeft"> Top left position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="btmRight"> Bottom right position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **POI** = Points of Interest
        /// 
        /// Value should be **POI** or **None** to disable extended postal codes.
        /// 
        /// By default extended postal codes are included.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public Response<SearchCommonResponse> GetSearchPOI(TextFormat format, string query, bool? typeahead = null, int? limit = null, int? ofs = null, IEnumerable<int> categorySet = null, IEnumerable<string> countrySet = null, float? lat = null, float? lon = null, float? radius = null, string topLeft = null, string btmRight = null, string language = null, string extendedPostalCodesFor = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchPOIRequest(format, query, typeahead, limit, ofs, categorySet, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, brandSet, connectorSet, view, openingHours);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchNearbyRequest(TextFormat format, float lat, float lon, int? limit, int? ofs, IEnumerable<int> categorySet, IEnumerable<string> countrySet, float? radius, string language, string extendedPostalCodesFor, IEnumerable<string> brandSet, IEnumerable<ConnectorSet> connectorSet, string view)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/nearby/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("lat", lat, true);
            uri.AppendQuery("lon", lon, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (ofs != null)
            {
                uri.AppendQuery("ofs", ofs.Value, true);
            }
            if (categorySet != null)
            {
                uri.AppendQueryDelimited("categorySet", categorySet, ",", true);
            }
            if (countrySet != null)
            {
                uri.AppendQueryDelimited("countrySet", countrySet, ",", true);
            }
            if (radius != null)
            {
                uri.AppendQuery("radius", radius.Value, true);
            }
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (extendedPostalCodesFor != null)
            {
                uri.AppendQuery("extendedPostalCodesFor", extendedPostalCodesFor, true);
            }
            if (brandSet != null)
            {
                uri.AppendQueryDelimited("brandSet", brandSet, ",", true);
            }
            if (connectorSet != null)
            {
                uri.AppendQueryDelimited("connectorSet", connectorSet, ",", true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Nearby Search**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// If you have a use case for only retrieving POI results around a specific location, the nearby search method may be the right choice. This endpoint will only return POI results, and does not take in a search query parameter.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area, Min value is 1, Max Value is 50000. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<SearchCommonResponse>> GetSearchNearbyAsync(TextFormat format, float lat, float lon, int? limit = null, int? ofs = null, IEnumerable<int> categorySet = null, IEnumerable<string> countrySet = null, float? radius = null, string language = null, string extendedPostalCodesFor = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetSearchNearbyRequest(format, lat, lon, limit, ofs, categorySet, countrySet, radius, language, extendedPostalCodesFor, brandSet, connectorSet, view);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Nearby Search**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// If you have a use case for only retrieving POI results around a specific location, the nearby search method may be the right choice. This endpoint will only return POI results, and does not take in a search query parameter.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area, Min value is 1, Max Value is 50000. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<SearchCommonResponse> GetSearchNearby(TextFormat format, float lat, float lon, int? limit = null, int? ofs = null, IEnumerable<int> categorySet = null, IEnumerable<string> countrySet = null, float? radius = null, string language = null, string extendedPostalCodesFor = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetSearchNearbyRequest(format, lat, lon, limit, ofs, categorySet, countrySet, radius, language, extendedPostalCodesFor, brandSet, connectorSet, view);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchPOICategoryRequest(TextFormat format, string query, bool? typeahead, int? limit, int? ofs, IEnumerable<int> categorySet, IEnumerable<string> countrySet, float? lat, float? lon, float? radius, string topLeft, string btmRight, string language, string extendedPostalCodesFor, IEnumerable<string> brandSet, IEnumerable<ConnectorSet> connectorSet, string view, OpeningHours? openingHours)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/poi/category/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("query", query, true);
            if (typeahead != null)
            {
                uri.AppendQuery("typeahead", typeahead.Value, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (ofs != null)
            {
                uri.AppendQuery("ofs", ofs.Value, true);
            }
            if (categorySet != null)
            {
                uri.AppendQueryDelimited("categorySet", categorySet, ",", true);
            }
            if (countrySet != null)
            {
                uri.AppendQueryDelimited("countrySet", countrySet, ",", true);
            }
            if (lat != null)
            {
                uri.AppendQuery("lat", lat.Value, true);
            }
            if (lon != null)
            {
                uri.AppendQuery("lon", lon.Value, true);
            }
            if (radius != null)
            {
                uri.AppendQuery("radius", radius.Value, true);
            }
            if (topLeft != null)
            {
                uri.AppendQuery("topLeft", topLeft, true);
            }
            if (btmRight != null)
            {
                uri.AppendQuery("btmRight", btmRight, true);
            }
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (extendedPostalCodesFor != null)
            {
                uri.AppendQuery("extendedPostalCodesFor", extendedPostalCodesFor, true);
            }
            if (brandSet != null)
            {
                uri.AppendQueryDelimited("brandSet", brandSet, ",", true);
            }
            if (connectorSet != null)
            {
                uri.AppendQueryDelimited("connectorSet", connectorSet, ",", true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            if (openingHours != null)
            {
                uri.AppendQuery("openingHours", openingHours.Value.ToString(), true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Get POI by Category**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// Points of Interest (POI) Category Search allows you to request POI results from given category. Search allows to query POIs from one category at a time.  Endpoint will only return POI results which are categorized as specified.  Response includes POI details such as address, coordinate location and classification.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The POI category to search for (e.g., &quot;AIRPORT&quot;, &quot;RESTAURANT&quot;), must be properly URL encoded. Supported main categories can be requested by calling [Get Search POI Category Tree API](https://aka.ms/AzureMapsPOICategoryTree). List of available categories can also be found [here](https://docs.microsoft.com/azure/azure-maps/supported-search-categories). We recommend to use POI Search Category Tree API to request the supported categories. </param>
        /// <param name="typeahead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="topLeft"> Top left position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="btmRight"> Bottom right position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public async Task<Response<SearchCommonResponse>> GetSearchPOICategoryAsync(TextFormat format, string query, bool? typeahead = null, int? limit = null, int? ofs = null, IEnumerable<int> categorySet = null, IEnumerable<string> countrySet = null, float? lat = null, float? lon = null, float? radius = null, string topLeft = null, string btmRight = null, string language = null, string extendedPostalCodesFor = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchPOICategoryRequest(format, query, typeahead, limit, ofs, categorySet, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, brandSet, connectorSet, view, openingHours);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Get POI by Category**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// Points of Interest (POI) Category Search allows you to request POI results from given category. Search allows to query POIs from one category at a time.  Endpoint will only return POI results which are categorized as specified.  Response includes POI details such as address, coordinate location and classification.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The POI category to search for (e.g., &quot;AIRPORT&quot;, &quot;RESTAURANT&quot;), must be properly URL encoded. Supported main categories can be requested by calling [Get Search POI Category Tree API](https://aka.ms/AzureMapsPOICategoryTree). List of available categories can also be found [here](https://docs.microsoft.com/azure/azure-maps/supported-search-categories). We recommend to use POI Search Category Tree API to request the supported categories. </param>
        /// <param name="typeahead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="topLeft"> Top left position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="btmRight"> Bottom right position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public Response<SearchCommonResponse> GetSearchPOICategory(TextFormat format, string query, bool? typeahead = null, int? limit = null, int? ofs = null, IEnumerable<int> categorySet = null, IEnumerable<string> countrySet = null, float? lat = null, float? lon = null, float? radius = null, string topLeft = null, string btmRight = null, string language = null, string extendedPostalCodesFor = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchPOICategoryRequest(format, query, typeahead, limit, ofs, categorySet, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, brandSet, connectorSet, view, openingHours);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchPOICategoryTreePreviewRequest(ResponseFormat format, string language)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/poi/category/tree/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Get POI Category Tree**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// POI Category API provides a full list of supported Points of Interest (POI) categories and subcategories together with their translations and synonyms. The returned content can be used to provide more meaningful results through other Search Service APIs, like [Get Search POI](https://docs.microsoft.com/rest/api/maps/search/getsearchpoi).
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, except NGT and NGT-Latn. Language tag is case insensitive. When data in specified language is not available for a specific field, default language is used (English).
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<SearchPoiCategoryTreeResponse>> GetSearchPOICategoryTreePreviewAsync(ResponseFormat format, string language = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetSearchPOICategoryTreePreviewRequest(format, language);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchPoiCategoryTreeResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchPoiCategoryTreeResponse.DeserializeSearchPoiCategoryTreeResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Get POI Category Tree**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// POI Category API provides a full list of supported Points of Interest (POI) categories and subcategories together with their translations and synonyms. The returned content can be used to provide more meaningful results through other Search Service APIs, like [Get Search POI](https://docs.microsoft.com/rest/api/maps/search/getsearchpoi).
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, except NGT and NGT-Latn. Language tag is case insensitive. When data in specified language is not available for a specific field, default language is used (English).
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<SearchPoiCategoryTreeResponse> GetSearchPOICategoryTreePreview(ResponseFormat format, string language = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetSearchPOICategoryTreePreviewRequest(format, language);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchPoiCategoryTreeResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchPoiCategoryTreeResponse.DeserializeSearchPoiCategoryTreeResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchAddressRequest(TextFormat format, string query, bool? typeahead, int? limit, int? ofs, IEnumerable<string> countrySet, float? lat, float? lon, float? radius, string topLeft, string btmRight, string language, string extendedPostalCodesFor, string view)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("query", query, true);
            if (typeahead != null)
            {
                uri.AppendQuery("typeahead", typeahead.Value, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (ofs != null)
            {
                uri.AppendQuery("ofs", ofs.Value, true);
            }
            if (countrySet != null)
            {
                uri.AppendQueryDelimited("countrySet", countrySet, ",", true);
            }
            if (lat != null)
            {
                uri.AppendQuery("lat", lat.Value, true);
            }
            if (lon != null)
            {
                uri.AppendQuery("lon", lon.Value, true);
            }
            if (radius != null)
            {
                uri.AppendQuery("radius", radius.Value, true);
            }
            if (topLeft != null)
            {
                uri.AppendQuery("topLeft", topLeft, true);
            }
            if (btmRight != null)
            {
                uri.AppendQuery("btmRight", btmRight, true);
            }
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (extendedPostalCodesFor != null)
            {
                uri.AppendQuery("extendedPostalCodesFor", extendedPostalCodesFor, true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Address Geocoding**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// In many cases, the complete search service might be too much, for instance if you are only interested in traditional geocoding. Search can also be accessed for address look up exclusively. The geocoding is performed by hitting the geocode endpoint with just the address or partial address in question. The geocoding search index will be queried for everything above the street level data. No POIs will be returned. Note that the geocoder is very tolerant of typos and incomplete addresses. It will also handle everything from exact street addresses or street or intersections as well as higher level geographies such as city centers, counties, states etc.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The address to search for (e.g., &quot;1 Microsoft way, Redmond, WA&quot;), must be properly URL encoded. </param>
        /// <param name="typeahead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="topLeft"> Top left position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="btmRight"> Bottom right position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public async Task<Response<SearchCommonResponse>> GetSearchAddressAsync(TextFormat format, string query, bool? typeahead = null, int? limit = null, int? ofs = null, IEnumerable<string> countrySet = null, float? lat = null, float? lon = null, float? radius = null, string topLeft = null, string btmRight = null, string language = null, string extendedPostalCodesFor = null, string view = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchAddressRequest(format, query, typeahead, limit, ofs, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, view);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Address Geocoding**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// In many cases, the complete search service might be too much, for instance if you are only interested in traditional geocoding. Search can also be accessed for address look up exclusively. The geocoding is performed by hitting the geocode endpoint with just the address or partial address in question. The geocoding search index will be queried for everything above the street level data. No POIs will be returned. Note that the geocoder is very tolerant of typos and incomplete addresses. It will also handle everything from exact street addresses or street or intersections as well as higher level geographies such as city centers, counties, states etc.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The address to search for (e.g., &quot;1 Microsoft way, Redmond, WA&quot;), must be properly URL encoded. </param>
        /// <param name="typeahead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="countrySet"> Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries. </param>
        /// <param name="lat"> Latitude where results should be biased. E.g. 37.337. </param>
        /// <param name="lon"> Longitude where results should be biased. E.g. -121.89. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="topLeft"> Top left position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="btmRight"> Bottom right position of the bounding box. E.g. 37.553,-122.453. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public Response<SearchCommonResponse> GetSearchAddress(TextFormat format, string query, bool? typeahead = null, int? limit = null, int? ofs = null, IEnumerable<string> countrySet = null, float? lat = null, float? lon = null, float? radius = null, string topLeft = null, string btmRight = null, string language = null, string extendedPostalCodesFor = null, string view = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchAddressRequest(format, query, typeahead, limit, ofs, countrySet, lat, lon, radius, topLeft, btmRight, language, extendedPostalCodesFor, view);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchAddressReverseRequest(TextFormat format, string query, string language, bool? returnSpeedLimit, float? heading, float? radius, string number, bool? returnRoadUse, string roadUse, bool? allowFreeformNewline, bool? returnMatchType, EntityType? entityType, string view)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/reverse/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("query", query, true);
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (returnSpeedLimit != null)
            {
                uri.AppendQuery("returnSpeedLimit", returnSpeedLimit.Value, true);
            }
            if (heading != null)
            {
                uri.AppendQuery("heading", heading.Value, true);
            }
            if (radius != null)
            {
                uri.AppendQuery("radius", radius.Value, true);
            }
            if (number != null)
            {
                uri.AppendQuery("number", number, true);
            }
            if (returnRoadUse != null)
            {
                uri.AppendQuery("returnRoadUse", returnRoadUse.Value, true);
            }
            if (roadUse != null)
            {
                uri.AppendQuery("roadUse", roadUse, true);
            }
            if (allowFreeformNewline != null)
            {
                uri.AppendQuery("allowFreeformNewline", allowFreeformNewline.Value, true);
            }
            if (returnMatchType != null)
            {
                uri.AppendQuery("returnMatchType", returnMatchType.Value, true);
            }
            if (entityType != null)
            {
                uri.AppendQuery("entityType", entityType.Value.ToString(), true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Reverse Geocode to an Address**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// There may be times when you need to translate a  coordinate (example: 37.786505, -122.3862) into a human understandable street address. Most often  this is needed in tracking applications where you  receive a GPS feed from the device or asset and  wish to know what address where the coordinate is  located. This endpoint will return address  information for a given coordinate.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. &quot;47.641268,-122.125679&quot;. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="returnSpeedLimit"> Boolean. To enable return of the posted speed limit. </param>
        /// <param name="heading"> The directional heading of the vehicle in degrees, for travel along a segment of roadway. 0 is North, 90 is East and so on, values range from -360 to 360. The precision can include upto one decimal place. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="number"> If a number is sent in along with the request, the response may include the side of the street (Left/Right) and also an offset position for that number. </param>
        /// <param name="returnRoadUse"> Boolean. To enable return of the road use array for reverse geocodes at street level. </param>
        /// <param name="roadUse"> To restrict reverse geocodes to a certain type of road use. The road use array for reverse geocodes can be one or more of LimitedAccess, Arterial, Terminal, Ramp, Rotary, LocalStreet. </param>
        /// <param name="allowFreeformNewline">
        /// Format of newlines in the formatted address.
        /// 
        /// If true, the address will contain newlines.
        /// If false, newlines will be converted to commas.
        /// </param>
        /// <param name="returnMatchType"> Include information on the type of match the geocoder achieved in the response. </param>
        /// <param name="entityType">
        /// Specifies the level of filtering performed on geographies. Narrows the search for specified geography entity types, e.g. return only municipality. The resulting response will contain the geography ID as well as the entity type matched. If you provide more than one entity as a comma separated list, endpoint will return the &apos;smallest entity available&apos;. Returned Geometry ID can be used to get the geometry of that geography via [Get Search Polygon](https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon) API. The following parameters are ignored when entityType is set:
        /// 
        /// * heading
        /// * number
        /// * returnRoadUse
        /// * returnSpeedLimit
        /// * roadUse
        /// * returnMatchType.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public async Task<Response<SearchAddressReverseResponse>> GetSearchAddressReverseAsync(TextFormat format, string query, string language = null, bool? returnSpeedLimit = null, float? heading = null, float? radius = null, string number = null, bool? returnRoadUse = null, string roadUse = null, bool? allowFreeformNewline = null, bool? returnMatchType = null, EntityType? entityType = null, string view = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchAddressReverseRequest(format, query, language, returnSpeedLimit, heading, radius, number, returnRoadUse, roadUse, allowFreeformNewline, returnMatchType, entityType, view);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchAddressReverseResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchAddressReverseResponse.DeserializeSearchAddressReverseResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Reverse Geocode to an Address**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// There may be times when you need to translate a  coordinate (example: 37.786505, -122.3862) into a human understandable street address. Most often  this is needed in tracking applications where you  receive a GPS feed from the device or asset and  wish to know what address where the coordinate is  located. This endpoint will return address  information for a given coordinate.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. &quot;47.641268,-122.125679&quot;. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="returnSpeedLimit"> Boolean. To enable return of the posted speed limit. </param>
        /// <param name="heading"> The directional heading of the vehicle in degrees, for travel along a segment of roadway. 0 is North, 90 is East and so on, values range from -360 to 360. The precision can include upto one decimal place. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="number"> If a number is sent in along with the request, the response may include the side of the street (Left/Right) and also an offset position for that number. </param>
        /// <param name="returnRoadUse"> Boolean. To enable return of the road use array for reverse geocodes at street level. </param>
        /// <param name="roadUse"> To restrict reverse geocodes to a certain type of road use. The road use array for reverse geocodes can be one or more of LimitedAccess, Arterial, Terminal, Ramp, Rotary, LocalStreet. </param>
        /// <param name="allowFreeformNewline">
        /// Format of newlines in the formatted address.
        /// 
        /// If true, the address will contain newlines.
        /// If false, newlines will be converted to commas.
        /// </param>
        /// <param name="returnMatchType"> Include information on the type of match the geocoder achieved in the response. </param>
        /// <param name="entityType">
        /// Specifies the level of filtering performed on geographies. Narrows the search for specified geography entity types, e.g. return only municipality. The resulting response will contain the geography ID as well as the entity type matched. If you provide more than one entity as a comma separated list, endpoint will return the &apos;smallest entity available&apos;. Returned Geometry ID can be used to get the geometry of that geography via [Get Search Polygon](https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon) API. The following parameters are ignored when entityType is set:
        /// 
        /// * heading
        /// * number
        /// * returnRoadUse
        /// * returnSpeedLimit
        /// * roadUse
        /// * returnMatchType.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public Response<SearchAddressReverseResponse> GetSearchAddressReverse(TextFormat format, string query, string language = null, bool? returnSpeedLimit = null, float? heading = null, float? radius = null, string number = null, bool? returnRoadUse = null, string roadUse = null, bool? allowFreeformNewline = null, bool? returnMatchType = null, EntityType? entityType = null, string view = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchAddressReverseRequest(format, query, language, returnSpeedLimit, heading, radius, number, returnRoadUse, roadUse, allowFreeformNewline, returnMatchType, entityType, view);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchAddressReverseResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchAddressReverseResponse.DeserializeSearchAddressReverseResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchAddressReverseCrossStreetRequest(TextFormat format, string query, int? limit, float? heading, float? radius, string language, string view)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/reverse/crossStreet/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("query", query, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (heading != null)
            {
                uri.AppendQuery("heading", heading.Value, true);
            }
            if (radius != null)
            {
                uri.AppendQuery("radius", radius.Value, true);
            }
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Reverse Geocode to a Cross Street**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// There may be times when you need to translate a  coordinate (example: 37.786505, -122.3862) into a human understandable cross street. Most often this  is needed in tracking applications where you  receive a GPS feed from the device or asset and wish to know what address where the coordinate is  located.
        /// This endpoint will return cross street information  for a given coordinate.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. &quot;47.641268,-122.125679&quot;. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="heading"> The directional heading of the vehicle in degrees, for travel along a segment of roadway. 0 is North, 90 is East and so on, values range from -360 to 360. The precision can include upto one decimal place. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public async Task<Response<SearchAddressReverseCrossStreetResponse>> GetSearchAddressReverseCrossStreetAsync(TextFormat format, string query, int? limit = null, float? heading = null, float? radius = null, string language = null, string view = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchAddressReverseCrossStreetRequest(format, query, limit, heading, radius, language, view);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchAddressReverseCrossStreetResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchAddressReverseCrossStreetResponse.DeserializeSearchAddressReverseCrossStreetResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Reverse Geocode to a Cross Street**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// There may be times when you need to translate a  coordinate (example: 37.786505, -122.3862) into a human understandable cross street. Most often this  is needed in tracking applications where you  receive a GPS feed from the device or asset and wish to know what address where the coordinate is  located.
        /// This endpoint will return cross street information  for a given coordinate.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. &quot;47.641268,-122.125679&quot;. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="heading"> The directional heading of the vehicle in degrees, for travel along a segment of roadway. 0 is North, 90 is East and so on, values range from -360 to 360. The precision can include upto one decimal place. </param>
        /// <param name="radius"> The radius in meters to for the results to be constrained to the defined area. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public Response<SearchAddressReverseCrossStreetResponse> GetSearchAddressReverseCrossStreet(TextFormat format, string query, int? limit = null, float? heading = null, float? radius = null, string language = null, string view = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetSearchAddressReverseCrossStreetRequest(format, query, limit, heading, radius, language, view);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchAddressReverseCrossStreetResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchAddressReverseCrossStreetResponse.DeserializeSearchAddressReverseCrossStreetResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchAddressStructuredRequest(TextFormat format, string language, string countryCode, int? limit, int? ofs, string streetNumber, string streetName, string crossStreet, string municipality, string municipalitySubdivision, string countryTertiarySubdivision, string countrySecondarySubdivision, string countrySubdivision, string postalCode, string extendedPostalCodesFor, string view)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/structured/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (countryCode != null)
            {
                uri.AppendQuery("countryCode", countryCode, true);
            }
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (ofs != null)
            {
                uri.AppendQuery("ofs", ofs.Value, true);
            }
            if (streetNumber != null)
            {
                uri.AppendQuery("streetNumber", streetNumber, true);
            }
            if (streetName != null)
            {
                uri.AppendQuery("streetName", streetName, true);
            }
            if (crossStreet != null)
            {
                uri.AppendQuery("crossStreet", crossStreet, true);
            }
            if (municipality != null)
            {
                uri.AppendQuery("municipality", municipality, true);
            }
            if (municipalitySubdivision != null)
            {
                uri.AppendQuery("municipalitySubdivision", municipalitySubdivision, true);
            }
            if (countryTertiarySubdivision != null)
            {
                uri.AppendQuery("countryTertiarySubdivision", countryTertiarySubdivision, true);
            }
            if (countrySecondarySubdivision != null)
            {
                uri.AppendQuery("countrySecondarySubdivision", countrySecondarySubdivision, true);
            }
            if (countrySubdivision != null)
            {
                uri.AppendQuery("countrySubdivision", countrySubdivision, true);
            }
            if (postalCode != null)
            {
                uri.AppendQuery("postalCode", postalCode, true);
            }
            if (extendedPostalCodesFor != null)
            {
                uri.AppendQuery("extendedPostalCodesFor", extendedPostalCodesFor, true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Structured Address Geocoding**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// Azure Address Geocoding can also be accessed for  structured address look up exclusively. The geocoding search index will be queried for everything above the  street level data. No POIs will be returned. Note that the geocoder is very tolerant of typos and incomplete  addresses. It will also handle everything from exact  street addresses or street or intersections as well as higher level geographies such as city centers,  counties, states etc.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="countryCode"> The 2 or 3 letter [ISO3166-1](https://www.iso.org/iso-3166-country-codes.html) country code portion of an address. E.g. US. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="streetNumber"> The street number portion of an address. </param>
        /// <param name="streetName"> The street name portion of an address. </param>
        /// <param name="crossStreet"> The cross street name for the structured address. </param>
        /// <param name="municipality"> The municipality portion of an address. </param>
        /// <param name="municipalitySubdivision"> The municipality subdivision (sub/super city) for the structured address. </param>
        /// <param name="countryTertiarySubdivision"> The named area for the structured address. </param>
        /// <param name="countrySecondarySubdivision"> The county for the structured address. </param>
        /// <param name="countrySubdivision"> The country subdivision portion of an address. </param>
        /// <param name="postalCode"> The postal code portion of an address. </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public async Task<Response<SearchCommonResponse>> GetSearchAddressStructuredAsync(TextFormat format, string language = null, string countryCode = null, int? limit = null, int? ofs = null, string streetNumber = null, string streetName = null, string crossStreet = null, string municipality = null, string municipalitySubdivision = null, string countryTertiarySubdivision = null, string countrySecondarySubdivision = null, string countrySubdivision = null, string postalCode = null, string extendedPostalCodesFor = null, string view = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetSearchAddressStructuredRequest(format, language, countryCode, limit, ofs, streetNumber, streetName, crossStreet, municipality, municipalitySubdivision, countryTertiarySubdivision, countrySecondarySubdivision, countrySubdivision, postalCode, extendedPostalCodesFor, view);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Structured Address Geocoding**
        /// 
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// Azure Address Geocoding can also be accessed for  structured address look up exclusively. The geocoding search index will be queried for everything above the  street level data. No POIs will be returned. Note that the geocoder is very tolerant of typos and incomplete  addresses. It will also handle everything from exact  street addresses or street or intersections as well as higher level geographies such as city centers,  counties, states etc.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="countryCode"> The 2 or 3 letter [ISO3166-1](https://www.iso.org/iso-3166-country-codes.html) country code portion of an address. E.g. US. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="ofs"> Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900. </param>
        /// <param name="streetNumber"> The street number portion of an address. </param>
        /// <param name="streetName"> The street name portion of an address. </param>
        /// <param name="crossStreet"> The cross street name for the structured address. </param>
        /// <param name="municipality"> The municipality portion of an address. </param>
        /// <param name="municipalitySubdivision"> The municipality subdivision (sub/super city) for the structured address. </param>
        /// <param name="countryTertiarySubdivision"> The named area for the structured address. </param>
        /// <param name="countrySecondarySubdivision"> The county for the structured address. </param>
        /// <param name="countrySubdivision"> The country subdivision portion of an address. </param>
        /// <param name="postalCode"> The postal code portion of an address. </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public Response<SearchCommonResponse> GetSearchAddressStructured(TextFormat format, string language = null, string countryCode = null, int? limit = null, int? ofs = null, string streetNumber = null, string streetName = null, string crossStreet = null, string municipality = null, string municipalitySubdivision = null, string countryTertiarySubdivision = null, string countrySecondarySubdivision = null, string countrySubdivision = null, string postalCode = null, string extendedPostalCodesFor = null, string view = null, CancellationToken cancellationToken = default)
        {
            using var message = CreateGetSearchAddressStructuredRequest(format, language, countryCode, limit, ofs, streetNumber, streetName, crossStreet, municipality, municipalitySubdivision, countryTertiarySubdivision, countrySecondarySubdivision, countrySubdivision, postalCode, extendedPostalCodesFor, view);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostSearchInsideGeometryRequest(TextFormat format, string query, SearchInsideGeometryRequestBody searchInsideGeometryRequestBody, int? limit, string language, IEnumerable<int> categorySet, string extendedPostalCodesFor, IEnumerable<SearchIndexSet> idxSet, string view, OpeningHours? openingHours)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/geometry/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("query", query, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (language != null)
            {
                uri.AppendQuery("language", language, true);
            }
            if (categorySet != null)
            {
                uri.AppendQueryDelimited("categorySet", categorySet, ",", true);
            }
            if (extendedPostalCodesFor != null)
            {
                uri.AppendQuery("extendedPostalCodesFor", extendedPostalCodesFor, true);
            }
            if (idxSet != null)
            {
                uri.AppendQueryDelimited("idxSet", idxSet, ",", true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            if (openingHours != null)
            {
                uri.AppendQuery("openingHours", openingHours.Value.ToString(), true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(searchInsideGeometryRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// The Search Geometry endpoint allows you to perform a free form search inside a single geometry or many of them. The search results that fall inside the geometry/geometries will be returned.&lt;br&gt;&lt;br&gt;To send the geometry you will use a `POST` request where the request body will contain the `geometry` object represented as a `GeoJSON` type and the `Content-Type` header will be set to `application/json`. The geographical features to be searched can be modeled as Polygon and/or Circle geometries represented using any one of the following `GeoJSON` types:&lt;ul&gt;&lt;li&gt;**GeoJSON FeatureCollection** &lt;br&gt;The `geometry` can be represented as a `GeoJSON FeatureCollection` object. This is the recommended option if the geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of 50 `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle with the following conditions:&lt;ul style=&quot;list-style-type:none&quot;&gt;&lt;li&gt;A `Feature` object for the Polygon geometry can have a max of 50 coordinates and it&apos;s properties must be empty.&lt;/li&gt;&lt;li&gt;A `Feature` object for the Circle geometry is composed of a _center_ represented using a `GeoJSON Point` type and a _radius_ value (in meters) which must be specified in the object&apos;s properties along with the _subType_ property whose value should be &apos;Circle&apos;.&lt;/li&gt;&lt;/ul&gt;&lt;br&gt; Please see the Examples section below for a sample `FeatureCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON GeometryCollection**&lt;br&gt;The `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the recommended option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a max of 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `GeometryCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON Polygon**&lt;br&gt;The `geometry` can be represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry contains a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `Polygon` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;.&lt;br&gt;&lt;br&gt;.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The POI name to search for (e.g., &quot;statue of liberty&quot;, &quot;starbucks&quot;, &quot;pizza&quot;). Must be properly URL encoded. </param>
        /// <param name="searchInsideGeometryRequestBody"> This represents the geometry for one or more geographical features (parks, state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946) for details. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="idxSet"> A comma separated list of indexes which should be utilized for the search. Item order does not matter. Available indexes are: Addr = Address range interpolation, Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross Streets (intersections). </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> or <paramref name="searchInsideGeometryRequestBody"/> is null. </exception>
        public async Task<Response<SearchCommonResponse>> PostSearchInsideGeometryAsync(TextFormat format, string query, SearchInsideGeometryRequestBody searchInsideGeometryRequestBody, int? limit = null, string language = null, IEnumerable<int> categorySet = null, string extendedPostalCodesFor = null, IEnumerable<SearchIndexSet> idxSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }
            if (searchInsideGeometryRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchInsideGeometryRequestBody));
            }

            using var message = CreatePostSearchInsideGeometryRequest(format, query, searchInsideGeometryRequestBody, limit, language, categorySet, extendedPostalCodesFor, idxSet, view, openingHours);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// The Search Geometry endpoint allows you to perform a free form search inside a single geometry or many of them. The search results that fall inside the geometry/geometries will be returned.&lt;br&gt;&lt;br&gt;To send the geometry you will use a `POST` request where the request body will contain the `geometry` object represented as a `GeoJSON` type and the `Content-Type` header will be set to `application/json`. The geographical features to be searched can be modeled as Polygon and/or Circle geometries represented using any one of the following `GeoJSON` types:&lt;ul&gt;&lt;li&gt;**GeoJSON FeatureCollection** &lt;br&gt;The `geometry` can be represented as a `GeoJSON FeatureCollection` object. This is the recommended option if the geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of 50 `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle with the following conditions:&lt;ul style=&quot;list-style-type:none&quot;&gt;&lt;li&gt;A `Feature` object for the Polygon geometry can have a max of 50 coordinates and it&apos;s properties must be empty.&lt;/li&gt;&lt;li&gt;A `Feature` object for the Circle geometry is composed of a _center_ represented using a `GeoJSON Point` type and a _radius_ value (in meters) which must be specified in the object&apos;s properties along with the _subType_ property whose value should be &apos;Circle&apos;.&lt;/li&gt;&lt;/ul&gt;&lt;br&gt; Please see the Examples section below for a sample `FeatureCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON GeometryCollection**&lt;br&gt;The `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the recommended option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a max of 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `GeometryCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON Polygon**&lt;br&gt;The `geometry` can be represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry contains a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `Polygon` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;.&lt;br&gt;&lt;br&gt;.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The POI name to search for (e.g., &quot;statue of liberty&quot;, &quot;starbucks&quot;, &quot;pizza&quot;). Must be properly URL encoded. </param>
        /// <param name="searchInsideGeometryRequestBody"> This represents the geometry for one or more geographical features (parks, state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946) for details. </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100. </param>
        /// <param name="language">
        /// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language is not available for a specific field, default language is used.
        /// 
        /// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
        /// </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="extendedPostalCodesFor">
        /// Indexes for which extended postal codes should be included in the results.
        /// 
        /// Available indexes are:
        /// 
        ///  **Addr** = Address ranges
        /// 
        ///  **Geo** = Geographies
        /// 
        ///  **PAD** = Point Addresses
        /// 
        ///  **POI** = Points of Interest
        /// 
        ///  **Str** = Streets
        /// 
        ///  **XStr** = Cross Streets (intersections)
        /// 
        /// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
        /// 
        /// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to be explicitly requested when needed.
        /// 
        /// Usage examples:
        /// 
        ///  extendedPostalCodesFor=POI
        /// 
        ///  extendedPostalCodesFor=PAD,Addr,POI
        /// 
        ///  extendedPostalCodesFor=None
        /// 
        /// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
        /// </param>
        /// <param name="idxSet"> A comma separated list of indexes which should be utilized for the search. Item order does not matter. Available indexes are: Addr = Address range interpolation, Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross Streets (intersections). </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> or <paramref name="searchInsideGeometryRequestBody"/> is null. </exception>
        public Response<SearchCommonResponse> PostSearchInsideGeometry(TextFormat format, string query, SearchInsideGeometryRequestBody searchInsideGeometryRequestBody, int? limit = null, string language = null, IEnumerable<int> categorySet = null, string extendedPostalCodesFor = null, IEnumerable<SearchIndexSet> idxSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }
            if (searchInsideGeometryRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchInsideGeometryRequestBody));
            }

            using var message = CreatePostSearchInsideGeometryRequest(format, query, searchInsideGeometryRequestBody, limit, language, categorySet, extendedPostalCodesFor, idxSet, view, openingHours);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostSearchAlongRouteRequest(TextFormat format, string query, int maxDetourTime, SearchAlongRouteRequestBody searchAlongRouteRequestBody, IEnumerable<int> categorySet, int? limit, IEnumerable<string> brandSet, IEnumerable<ConnectorSet> connectorSet, string view, OpeningHours? openingHours)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/alongRoute/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            uri.AppendQuery("query", query, true);
            if (categorySet != null)
            {
                uri.AppendQueryDelimited("categorySet", categorySet, ",", true);
            }
            uri.AppendQuery("maxDetourTime", maxDetourTime, true);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (brandSet != null)
            {
                uri.AppendQueryDelimited("brandSet", brandSet, ",", true);
            }
            if (connectorSet != null)
            {
                uri.AppendQueryDelimited("connectorSet", connectorSet, ",", true);
            }
            if (view != null)
            {
                uri.AppendQuery("view", view, true);
            }
            if (openingHours != null)
            {
                uri.AppendQuery("openingHours", openingHours.Value.ToString(), true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(searchAlongRouteRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// The Search Along Route endpoint allows you to perform a fuzzy search for POIs along a specified route. This search is constrained by specifying the `maxDetourTime` limiting measure.&lt;br&gt;&lt;br&gt;To send the route-points you will use a `POST` request where the request body will contain the `route` object represented as a `GeoJSON LineString` type and the `Content-Type` header will be set to `application/json`. Each route-point in `route` is represented as a `GeoJSON Position` type i.e. an array where the _longitude_ value is followed by the _latitude_ value and the _altitude_ value is ignored. The `route` should contain at least 2 route-points.&lt;br&gt;&lt;br&gt;It is possible that original route will be altered, some of it&apos;s points may be skipped. If the route that passes through the found point is faster than the original one, the `detourTime` value in the response is negative.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The POI name to search for (e.g., &quot;statue of liberty&quot;, &quot;starbucks&quot;, &quot;pizza&quot;). Must be properly URL encoded. </param>
        /// <param name="maxDetourTime"> Maximum detour time of the point of interest in seconds. Max value is 3600 seconds. </param>
        /// <param name="searchAlongRouteRequestBody"> This represents the route to search along and should be a valid `GeoJSON LineString` type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.4) for details. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default value is 10. Max value is 20. </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> or <paramref name="searchAlongRouteRequestBody"/> is null. </exception>
        public async Task<Response<SearchCommonResponse>> PostSearchAlongRouteAsync(TextFormat format, string query, int maxDetourTime, SearchAlongRouteRequestBody searchAlongRouteRequestBody, IEnumerable<int> categorySet = null, int? limit = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }
            if (searchAlongRouteRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAlongRouteRequestBody));
            }

            using var message = CreatePostSearchAlongRouteRequest(format, query, maxDetourTime, searchAlongRouteRequestBody, categorySet, limit, brandSet, connectorSet, view, openingHours);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        /// 
        /// 
        /// The Search Along Route endpoint allows you to perform a fuzzy search for POIs along a specified route. This search is constrained by specifying the `maxDetourTime` limiting measure.&lt;br&gt;&lt;br&gt;To send the route-points you will use a `POST` request where the request body will contain the `route` object represented as a `GeoJSON LineString` type and the `Content-Type` header will be set to `application/json`. Each route-point in `route` is represented as a `GeoJSON Position` type i.e. an array where the _longitude_ value is followed by the _latitude_ value and the _altitude_ value is ignored. The `route` should contain at least 2 route-points.&lt;br&gt;&lt;br&gt;It is possible that original route will be altered, some of it&apos;s points may be skipped. If the route that passes through the found point is faster than the original one, the `detourTime` value in the response is negative.
        /// </summary>
        /// <param name="format"> Desired format of the response. Value can be either _json_ or _xml_. </param>
        /// <param name="query"> The POI name to search for (e.g., &quot;statue of liberty&quot;, &quot;starbucks&quot;, &quot;pizza&quot;). Must be properly URL encoded. </param>
        /// <param name="maxDetourTime"> Maximum detour time of the point of interest in seconds. Max value is 3600 seconds. </param>
        /// <param name="searchAlongRouteRequestBody"> This represents the route to search along and should be a valid `GeoJSON LineString` type. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.1.4) for details. </param>
        /// <param name="categorySet">
        /// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter. When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The list of supported categories can be discovered using  [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
        /// 
        /// * **categorySet=7315** (Search Points of Interest from category Restaurant)
        /// 
        /// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant).
        /// </param>
        /// <param name="limit"> Maximum number of responses that will be returned. Default value is 10. Max value is 20. </param>
        /// <param name="brandSet">
        /// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a &quot;,&quot; in their name should be put into quotes.
        /// 
        /// Usage examples:
        /// 
        ///  brandSet=Foo
        /// 
        ///  brandSet=Foo,Bar
        /// 
        ///  brandSet=&quot;A,B,C Comma&quot;,Bar.
        /// </param>
        /// <param name="connectorSet">
        /// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types. Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
        /// 
        /// Available connector types are:
        ///   * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard Voltage and standard Amperage. See also: [Plug &amp; socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
        ///   * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
        ///   * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
        ///   * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
        ///   * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
        ///   * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination with up to 240V single phase or up to 420V three phase infrastructure.
        ///   * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is also known as the TEPCO&apos;s connector. It supports fast DC charging.
        ///   * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination of the standard, the color and the fact that is a single phase connector. The connector usually has the &quot;P+N+E, 6h&quot; configuration.
        ///   * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
        ///   * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla&apos;s proprietary connector, sometimes referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
        /// 
        /// Usage examples:
        /// 
        ///  connectorSet=IEC62196Type2CableAttached
        ///  connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached.
        /// </param>
        /// <param name="view">
        /// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including  borders and labels displayed on the map. The View parameter (also referred to as “user region parameter”) will show the  correct maps for that country/region. By default, the View parameter is set to “Unified” even if you haven’t defined it in  the request. It is your responsibility to determine the location of your users, and then set the View parameter correctly  for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the IP  address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those  regarding mapping, of the country where maps, images and other data and third party content that you are authorized to  access via Azure Maps is made available. Example: view=IN.
        /// 
        /// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
        /// </param>
        /// <param name="openingHours">
        /// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
        /// Supported value: nextSevenDays.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> or <paramref name="searchAlongRouteRequestBody"/> is null. </exception>
        public Response<SearchCommonResponse> PostSearchAlongRoute(TextFormat format, string query, int maxDetourTime, SearchAlongRouteRequestBody searchAlongRouteRequestBody, IEnumerable<int> categorySet = null, int? limit = null, IEnumerable<string> brandSet = null, IEnumerable<ConnectorSet> connectorSet = null, string view = null, OpeningHours? openingHours = null, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }
            if (searchAlongRouteRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAlongRouteRequestBody));
            }

            using var message = CreatePostSearchAlongRouteRequest(format, query, maxDetourTime, searchAlongRouteRequestBody, categorySet, limit, brandSet, connectorSet, view, openingHours);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchCommonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchCommonResponse.DeserializeSearchCommonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostSearchFuzzyBatchSyncRequest(ResponseFormat format, BatchRequestBody searchFuzzyBatchRequestBody)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/fuzzy/batch/sync/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(searchFuzzyBatchRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Search Fuzzy Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Fuzzy API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy) using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search fuzzy_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search fuzzy_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=atm&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&amp;limit=5&quot;},
        ///         {&quot;query&quot;: &quot;?query=Statue Of Liberty&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=Starbucks&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Space Needle&quot;},
        ///         {&quot;query&quot;: &quot;?query=pizza&amp;limit=10&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search fuzzy_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search fuzzy_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters). The string values in the _search fuzzy_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;atm&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;ATM at Wells Fargo&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;3240 157th Ave NE, Redmond, WA 98052&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;statue of liberty&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;Statue of Liberty&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;New York, NY 10004&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchFuzzyBatchRequestBody"> The list of search fuzzy queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchFuzzyBatchRequestBody"/> is null. </exception>
        public async Task<Response<SearchFuzzyBatchResponse>> PostSearchFuzzyBatchSyncAsync(ResponseFormat format, BatchRequestBody searchFuzzyBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchFuzzyBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchFuzzyBatchRequestBody));
            }

            using var message = CreatePostSearchFuzzyBatchSyncRequest(format, searchFuzzyBatchRequestBody);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchFuzzyBatchResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchFuzzyBatchResponse.DeserializeSearchFuzzyBatchResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Fuzzy Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Fuzzy API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy) using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search fuzzy_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search fuzzy_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=atm&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&amp;limit=5&quot;},
        ///         {&quot;query&quot;: &quot;?query=Statue Of Liberty&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=Starbucks&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Space Needle&quot;},
        ///         {&quot;query&quot;: &quot;?query=pizza&amp;limit=10&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search fuzzy_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search fuzzy_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters). The string values in the _search fuzzy_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;atm&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;ATM at Wells Fargo&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;3240 157th Ave NE, Redmond, WA 98052&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;statue of liberty&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;Statue of Liberty&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;New York, NY 10004&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchFuzzyBatchRequestBody"> The list of search fuzzy queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchFuzzyBatchRequestBody"/> is null. </exception>
        public Response<SearchFuzzyBatchResponse> PostSearchFuzzyBatchSync(ResponseFormat format, BatchRequestBody searchFuzzyBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchFuzzyBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchFuzzyBatchRequestBody));
            }

            using var message = CreatePostSearchFuzzyBatchSyncRequest(format, searchFuzzyBatchRequestBody);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchFuzzyBatchResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchFuzzyBatchResponse.DeserializeSearchFuzzyBatchResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostSearchFuzzyBatchRequest(ResponseFormat format, BatchRequestBody searchFuzzyBatchRequestBody)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/fuzzy/batch/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(searchFuzzyBatchRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Search Fuzzy Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Fuzzy API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy) using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search fuzzy_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search fuzzy_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=atm&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&amp;limit=5&quot;},
        ///         {&quot;query&quot;: &quot;?query=Statue Of Liberty&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=Starbucks&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Space Needle&quot;},
        ///         {&quot;query&quot;: &quot;?query=pizza&amp;limit=10&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search fuzzy_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search fuzzy_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters). The string values in the _search fuzzy_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;atm&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;ATM at Wells Fargo&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;3240 157th Ave NE, Redmond, WA 98052&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;statue of liberty&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;Statue of Liberty&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;New York, NY 10004&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchFuzzyBatchRequestBody"> The list of search fuzzy queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchFuzzyBatchRequestBody"/> is null. </exception>
        public async Task<ResponseWithHeaders<SearchPostSearchFuzzyBatchHeaders>> PostSearchFuzzyBatchAsync(ResponseFormat format, BatchRequestBody searchFuzzyBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchFuzzyBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchFuzzyBatchRequestBody));
            }

            using var message = CreatePostSearchFuzzyBatchRequest(format, searchFuzzyBatchRequestBody);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new SearchPostSearchFuzzyBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Fuzzy Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Fuzzy API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy) using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search fuzzy_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search fuzzy_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=atm&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&amp;limit=5&quot;},
        ///         {&quot;query&quot;: &quot;?query=Statue Of Liberty&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=Starbucks&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Space Needle&quot;},
        ///         {&quot;query&quot;: &quot;?query=pizza&amp;limit=10&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search fuzzy_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search fuzzy_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters). The string values in the _search fuzzy_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;atm&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;ATM at Wells Fargo&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;3240 157th Ave NE, Redmond, WA 98052&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;statue of liberty&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;Statue of Liberty&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;New York, NY 10004&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchFuzzyBatchRequestBody"> The list of search fuzzy queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchFuzzyBatchRequestBody"/> is null. </exception>
        public ResponseWithHeaders<SearchPostSearchFuzzyBatchHeaders> PostSearchFuzzyBatch(ResponseFormat format, BatchRequestBody searchFuzzyBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchFuzzyBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchFuzzyBatchRequestBody));
            }

            using var message = CreatePostSearchFuzzyBatchRequest(format, searchFuzzyBatchRequestBody);
            _pipeline.Send(message, cancellationToken);
            var headers = new SearchPostSearchFuzzyBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchFuzzyBatchRequest(string format)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/fuzzy/batch/", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Search Fuzzy Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Fuzzy API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy) using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search fuzzy_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search fuzzy_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=atm&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&amp;limit=5&quot;},
        ///         {&quot;query&quot;: &quot;?query=Statue Of Liberty&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=Starbucks&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Space Needle&quot;},
        ///         {&quot;query&quot;: &quot;?query=pizza&amp;limit=10&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search fuzzy_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search fuzzy_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters). The string values in the _search fuzzy_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;atm&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;ATM at Wells Fargo&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;3240 157th Ave NE, Redmond, WA 98052&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;statue of liberty&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;Statue of Liberty&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;New York, NY 10004&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Batch id for querying the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        public async Task<ResponseWithHeaders<SearchGetSearchFuzzyBatchHeaders>> GetSearchFuzzyBatchAsync(string format, CancellationToken cancellationToken = default)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            using var message = CreateGetSearchFuzzyBatchRequest(format);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new SearchGetSearchFuzzyBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Fuzzy Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Fuzzy API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy) using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search fuzzy_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search fuzzy_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=atm&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&amp;limit=5&quot;},
        ///         {&quot;query&quot;: &quot;?query=Statue Of Liberty&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=Starbucks&amp;lat=47.639769&amp;lon=-122.128362&amp;radius=5000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Space Needle&quot;},
        ///         {&quot;query&quot;: &quot;?query=pizza&amp;limit=10&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search fuzzy_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search fuzzy_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters). The string values in the _search fuzzy_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;atm&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;ATM at Wells Fargo&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;3240 157th Ave NE, Redmond, WA 98052&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;statue of liberty&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;type&quot;: &quot;POI&quot;,
        ///                         &quot;poi&quot;: {
        ///                             &quot;name&quot;: &quot;Statue of Liberty&quot;
        ///                         },
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States Of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;New York, NY 10004&quot;
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Batch id for querying the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        public ResponseWithHeaders<SearchGetSearchFuzzyBatchHeaders> GetSearchFuzzyBatch(string format, CancellationToken cancellationToken = default)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            using var message = CreateGetSearchFuzzyBatchRequest(format);
            _pipeline.Send(message, cancellationToken);
            var headers = new SearchGetSearchFuzzyBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostSearchAddressBatchSyncRequest(ResponseFormat format, BatchRequestBody searchAddressBatchRequestBody)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/batch/sync/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(searchAddressBatchRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Search Address Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress) using just a single API call. You can call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=400 Broad St, Seattle, WA 98109&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=One, Microsoft Way, Redmond, WA 98052&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=350 5th Ave, New York, NY 10118&amp;limit=1&quot;},
        ///         {&quot;query&quot;: &quot;?query=Pike Pl, Seattle, WA 98101&amp;lat=47.610970&amp;lon=-122.342469&amp;radius=1000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France&amp;limit=1&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters). The string values in the _search address_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;one microsoft way redmond wa 98052&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.63989,
        ///                             &quot;lon&quot;: -122.12509
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;pike pl seattle wa 98101&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.60963,
        ///                             &quot;lon&quot;: -122.34215
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchAddressBatchRequestBody"> The list of address geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchAddressBatchRequestBody"/> is null. </exception>
        public async Task<Response<SearchAddressBatchResponse>> PostSearchAddressBatchSyncAsync(ResponseFormat format, BatchRequestBody searchAddressBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchAddressBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAddressBatchRequestBody));
            }

            using var message = CreatePostSearchAddressBatchSyncRequest(format, searchAddressBatchRequestBody);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchAddressBatchResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchAddressBatchResponse.DeserializeSearchAddressBatchResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Address Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress) using just a single API call. You can call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=400 Broad St, Seattle, WA 98109&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=One, Microsoft Way, Redmond, WA 98052&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=350 5th Ave, New York, NY 10118&amp;limit=1&quot;},
        ///         {&quot;query&quot;: &quot;?query=Pike Pl, Seattle, WA 98101&amp;lat=47.610970&amp;lon=-122.342469&amp;radius=1000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France&amp;limit=1&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters). The string values in the _search address_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;one microsoft way redmond wa 98052&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.63989,
        ///                             &quot;lon&quot;: -122.12509
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;pike pl seattle wa 98101&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.60963,
        ///                             &quot;lon&quot;: -122.34215
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchAddressBatchRequestBody"> The list of address geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchAddressBatchRequestBody"/> is null. </exception>
        public Response<SearchAddressBatchResponse> PostSearchAddressBatchSync(ResponseFormat format, BatchRequestBody searchAddressBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchAddressBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAddressBatchRequestBody));
            }

            using var message = CreatePostSearchAddressBatchSyncRequest(format, searchAddressBatchRequestBody);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchAddressBatchResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchAddressBatchResponse.DeserializeSearchAddressBatchResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostSearchAddressBatchRequest(ResponseFormat format, BatchRequestBody searchAddressBatchRequestBody)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/batch/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(searchAddressBatchRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Search Address Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress) using just a single API call. You can call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=400 Broad St, Seattle, WA 98109&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=One, Microsoft Way, Redmond, WA 98052&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=350 5th Ave, New York, NY 10118&amp;limit=1&quot;},
        ///         {&quot;query&quot;: &quot;?query=Pike Pl, Seattle, WA 98101&amp;lat=47.610970&amp;lon=-122.342469&amp;radius=1000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France&amp;limit=1&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters). The string values in the _search address_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;one microsoft way redmond wa 98052&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.63989,
        ///                             &quot;lon&quot;: -122.12509
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;pike pl seattle wa 98101&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.60963,
        ///                             &quot;lon&quot;: -122.34215
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchAddressBatchRequestBody"> The list of address geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchAddressBatchRequestBody"/> is null. </exception>
        public async Task<ResponseWithHeaders<SearchPostSearchAddressBatchHeaders>> PostSearchAddressBatchAsync(ResponseFormat format, BatchRequestBody searchAddressBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchAddressBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAddressBatchRequestBody));
            }

            using var message = CreatePostSearchAddressBatchRequest(format, searchAddressBatchRequestBody);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new SearchPostSearchAddressBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Address Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress) using just a single API call. You can call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=400 Broad St, Seattle, WA 98109&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=One, Microsoft Way, Redmond, WA 98052&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=350 5th Ave, New York, NY 10118&amp;limit=1&quot;},
        ///         {&quot;query&quot;: &quot;?query=Pike Pl, Seattle, WA 98101&amp;lat=47.610970&amp;lon=-122.342469&amp;radius=1000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France&amp;limit=1&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters). The string values in the _search address_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;one microsoft way redmond wa 98052&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.63989,
        ///                             &quot;lon&quot;: -122.12509
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;pike pl seattle wa 98101&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.60963,
        ///                             &quot;lon&quot;: -122.34215
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchAddressBatchRequestBody"> The list of address geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchAddressBatchRequestBody"/> is null. </exception>
        public ResponseWithHeaders<SearchPostSearchAddressBatchHeaders> PostSearchAddressBatch(ResponseFormat format, BatchRequestBody searchAddressBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchAddressBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAddressBatchRequestBody));
            }

            using var message = CreatePostSearchAddressBatchRequest(format, searchAddressBatchRequestBody);
            _pipeline.Send(message, cancellationToken);
            var headers = new SearchPostSearchAddressBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchAddressBatchRequest(string format)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/batch/", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Search Address Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress) using just a single API call. You can call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=400 Broad St, Seattle, WA 98109&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=One, Microsoft Way, Redmond, WA 98052&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=350 5th Ave, New York, NY 10118&amp;limit=1&quot;},
        ///         {&quot;query&quot;: &quot;?query=Pike Pl, Seattle, WA 98101&amp;lat=47.610970&amp;lon=-122.342469&amp;radius=1000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France&amp;limit=1&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters). The string values in the _search address_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;one microsoft way redmond wa 98052&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.63989,
        ///                             &quot;lon&quot;: -122.12509
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;pike pl seattle wa 98101&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.60963,
        ///                             &quot;lon&quot;: -122.34215
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Batch id for querying the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        public async Task<ResponseWithHeaders<SearchGetSearchAddressBatchHeaders>> GetSearchAddressBatchAsync(string format, CancellationToken cancellationToken = default)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            using var message = CreateGetSearchAddressBatchRequest(format);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new SearchGetSearchAddressBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Address Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress) using just a single API call. You can call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=400 Broad St, Seattle, WA 98109&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=One, Microsoft Way, Redmond, WA 98052&amp;limit=3&quot;},
        ///         {&quot;query&quot;: &quot;?query=350 5th Ave, New York, NY 10118&amp;limit=1&quot;},
        ///         {&quot;query&quot;: &quot;?query=Pike Pl, Seattle, WA 98101&amp;lat=47.610970&amp;lon=-122.342469&amp;radius=1000&quot;},
        ///         {&quot;query&quot;: &quot;?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris, France&amp;limit=1&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters). The string values in the _search address_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchCommonResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;one microsoft way redmond wa 98052&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.63989,
        ///                             &quot;lon&quot;: -122.12509
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;query&quot;: &quot;pike pl seattle wa 98101&quot;
        ///                 },
        ///                 &quot;results&quot;: [
        ///                     {
        ///                         &quot;position&quot;: {
        ///                             &quot;lat&quot;: 47.60963,
        ///                             &quot;lon&quot;: -122.34215
        ///                         }
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Batch id for querying the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        public ResponseWithHeaders<SearchGetSearchAddressBatchHeaders> GetSearchAddressBatch(string format, CancellationToken cancellationToken = default)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            using var message = CreateGetSearchAddressBatchRequest(format);
            _pipeline.Send(message, cancellationToken);
            var headers = new SearchGetSearchAddressBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostSearchAddressReverseBatchSyncRequest(ResponseFormat format, BatchRequestBody searchAddressReverseBatchRequestBody)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/reverse/batch/sync/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(searchAddressReverseBatchRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Search Address Reverse Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address Reverse API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse) using just a single API call. You can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address reverse_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address reverse_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=48.858561,2.294911&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.639765,-122.127896&amp;radius=5000&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.621028,-122.348170&quot;},
        ///         {&quot;query&quot;: &quot;?query=43.722990,10.396695&quot;},
        ///         {&quot;query&quot;: &quot;?query=40.750958,-73.982336&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address reverse_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address reverse_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters). The string values in the _search address reverse_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchAddressReverseResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 11
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;France&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;Avenue Anatole France, 75007 Paris&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;48.858490,2.294820&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 1
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;157th Pl NE, Redmond WA 98052&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;47.640470,-122.129430&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchAddressReverseBatchRequestBody"> The list of reverse geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchAddressReverseBatchRequestBody"/> is null. </exception>
        public async Task<Response<SearchAddressReverseBatchResponse>> PostSearchAddressReverseBatchSyncAsync(ResponseFormat format, BatchRequestBody searchAddressReverseBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchAddressReverseBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAddressReverseBatchRequestBody));
            }

            using var message = CreatePostSearchAddressReverseBatchSyncRequest(format, searchAddressReverseBatchRequestBody);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchAddressReverseBatchResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = SearchAddressReverseBatchResponse.DeserializeSearchAddressReverseBatchResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Address Reverse Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address Reverse API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse) using just a single API call. You can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address reverse_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address reverse_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=48.858561,2.294911&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.639765,-122.127896&amp;radius=5000&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.621028,-122.348170&quot;},
        ///         {&quot;query&quot;: &quot;?query=43.722990,10.396695&quot;},
        ///         {&quot;query&quot;: &quot;?query=40.750958,-73.982336&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address reverse_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address reverse_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters). The string values in the _search address reverse_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchAddressReverseResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 11
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;France&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;Avenue Anatole France, 75007 Paris&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;48.858490,2.294820&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 1
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;157th Pl NE, Redmond WA 98052&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;47.640470,-122.129430&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchAddressReverseBatchRequestBody"> The list of reverse geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchAddressReverseBatchRequestBody"/> is null. </exception>
        public Response<SearchAddressReverseBatchResponse> PostSearchAddressReverseBatchSync(ResponseFormat format, BatchRequestBody searchAddressReverseBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchAddressReverseBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAddressReverseBatchRequestBody));
            }

            using var message = CreatePostSearchAddressReverseBatchSyncRequest(format, searchAddressReverseBatchRequestBody);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        SearchAddressReverseBatchResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = SearchAddressReverseBatchResponse.DeserializeSearchAddressReverseBatchResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostSearchAddressReverseBatchRequest(ResponseFormat format, BatchRequestBody searchAddressReverseBatchRequestBody)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/reverse/batch/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(searchAddressReverseBatchRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Search Address Reverse Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address Reverse API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse) using just a single API call. You can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address reverse_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address reverse_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=48.858561,2.294911&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.639765,-122.127896&amp;radius=5000&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.621028,-122.348170&quot;},
        ///         {&quot;query&quot;: &quot;?query=43.722990,10.396695&quot;},
        ///         {&quot;query&quot;: &quot;?query=40.750958,-73.982336&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address reverse_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address reverse_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters). The string values in the _search address reverse_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchAddressReverseResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 11
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;France&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;Avenue Anatole France, 75007 Paris&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;48.858490,2.294820&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 1
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;157th Pl NE, Redmond WA 98052&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;47.640470,-122.129430&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchAddressReverseBatchRequestBody"> The list of reverse geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchAddressReverseBatchRequestBody"/> is null. </exception>
        public async Task<ResponseWithHeaders<SearchPostSearchAddressReverseBatchHeaders>> PostSearchAddressReverseBatchAsync(ResponseFormat format, BatchRequestBody searchAddressReverseBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchAddressReverseBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAddressReverseBatchRequestBody));
            }

            using var message = CreatePostSearchAddressReverseBatchRequest(format, searchAddressReverseBatchRequestBody);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new SearchPostSearchAddressReverseBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Address Reverse Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address Reverse API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse) using just a single API call. You can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address reverse_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address reverse_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=48.858561,2.294911&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.639765,-122.127896&amp;radius=5000&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.621028,-122.348170&quot;},
        ///         {&quot;query&quot;: &quot;?query=43.722990,10.396695&quot;},
        ///         {&quot;query&quot;: &quot;?query=40.750958,-73.982336&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address reverse_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address reverse_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters). The string values in the _search address reverse_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchAddressReverseResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 11
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;France&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;Avenue Anatole France, 75007 Paris&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;48.858490,2.294820&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 1
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;157th Pl NE, Redmond WA 98052&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;47.640470,-122.129430&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="searchAddressReverseBatchRequestBody"> The list of reverse geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="searchAddressReverseBatchRequestBody"/> is null. </exception>
        public ResponseWithHeaders<SearchPostSearchAddressReverseBatchHeaders> PostSearchAddressReverseBatch(ResponseFormat format, BatchRequestBody searchAddressReverseBatchRequestBody, CancellationToken cancellationToken = default)
        {
            if (searchAddressReverseBatchRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchAddressReverseBatchRequestBody));
            }

            using var message = CreatePostSearchAddressReverseBatchRequest(format, searchAddressReverseBatchRequestBody);
            _pipeline.Send(message, cancellationToken);
            var headers = new SearchPostSearchAddressReverseBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetSearchAddressReverseBatchRequest(string format)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/search/address/reverse/batch/", false);
            uri.AppendPath(format, true);
            uri.AppendQuery("api-version", apiVersion, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Search Address Reverse Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address Reverse API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse) using just a single API call. You can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address reverse_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address reverse_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=48.858561,2.294911&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.639765,-122.127896&amp;radius=5000&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.621028,-122.348170&quot;},
        ///         {&quot;query&quot;: &quot;?query=43.722990,10.396695&quot;},
        ///         {&quot;query&quot;: &quot;?query=40.750958,-73.982336&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address reverse_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address reverse_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters). The string values in the _search address reverse_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchAddressReverseResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 11
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;France&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;Avenue Anatole France, 75007 Paris&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;48.858490,2.294820&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 1
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;157th Pl NE, Redmond WA 98052&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;47.640470,-122.129430&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Batch id for querying the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        public async Task<ResponseWithHeaders<SearchGetSearchAddressReverseBatchHeaders>> GetSearchAddressReverseBatchAsync(string format, CancellationToken cancellationToken = default)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            using var message = CreateGetSearchAddressReverseBatchRequest(format);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new SearchGetSearchAddressReverseBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Address Reverse Batch API**
        /// 
        /// 
        /// **Applies to**: S1 pricing tier.
        /// 
        /// 
        /// 
        /// The Search Address Batch API sends batches of queries to [Search Address Reverse API](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse) using just a single API call. You can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
        /// ### Submit Synchronous Batch Request
        /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
        /// ```
        /// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// ### Submit Asynchronous Batch Request
        /// The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
        /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
        /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        /// - The number of batch items is limited to **10,000** for this API.
        /// 
        /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
        /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
        /// 
        /// Please note that asynchronous batch request is a long-running request. Here&apos;s a typical sequence of operations:
        /// 1. Client sends a Search Address Batch `POST` request to Azure Maps
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request has been accepted.
        /// 
        ///     &gt; HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
        /// 
        /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
        ///     This status URI looks like following:
        /// 
        /// ```
        ///     GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
        /// 
        /// ### POST Body for Batch Request
        /// To send the _search address reverse_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here&apos;s a sample request body containing 5 _search address reverse_ queries:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;batchItems&quot;: [
        ///         {&quot;query&quot;: &quot;?query=48.858561,2.294911&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.639765,-122.127896&amp;radius=5000&amp;limit=2&quot;},
        ///         {&quot;query&quot;: &quot;?query=47.621028,-122.348170&quot;},
        ///         {&quot;query&quot;: &quot;?query=43.722990,10.396695&quot;},
        ///         {&quot;query&quot;: &quot;?query=40.750958,-73.982336&quot;}
        ///     ]
        /// }
        /// ```
        /// 
        /// A _search address reverse_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _search address reverse_ [URI parameters](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters). The string values in the _search address reverse_ query must be properly escaped (e.g. &quot; character should be escaped with \\ ) and it should also be properly URL-encoded.
        /// 
        /// 
        /// The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
        /// 
        /// 
        /// ### Download Asynchronous Batch Results
        /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
        /// 
        /// ```
        /// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&amp;subscription-key={subscription-key}
        /// ```
        /// Here&apos;s the typical sequence of operations for downloading the batch results:
        /// 1. Client sends a `GET` request using the _download URL_.
        /// 2. The server will respond with one of the following:
        /// 
        ///     &gt; HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
        /// 
        ///     &gt; HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
        /// 
        /// 
        /// 
        /// ### Batch Response Model
        /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
        /// 
        ///   - [`SearchAddressReverseResponse`](https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse) - If the query completed successfully.
        /// 
        ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
        /// 
        /// 
        /// Here&apos;s a sample Batch Response with 2 _successful_ and 1 _failed_ result:
        /// 
        /// 
        /// ```json
        /// {
        ///     &quot;summary&quot;: {
        ///         &quot;successfulRequests&quot;: 2,
        ///         &quot;totalRequests&quot;: 3
        ///     },
        ///     &quot;batchItems&quot;: [
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 11
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;France&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;Avenue Anatole France, 75007 Paris&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;48.858490,2.294820&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 200,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;summary&quot;: {
        ///                     &quot;queryTime&quot;: 1
        ///                 },
        ///                 &quot;addresses&quot;: [
        ///                     {
        ///                         &quot;address&quot;: {
        ///                             &quot;country&quot;: &quot;United States of America&quot;,
        ///                             &quot;freeformAddress&quot;: &quot;157th Pl NE, Redmond WA 98052&quot;
        ///                         },
        ///                         &quot;position&quot;: &quot;47.640470,-122.129430&quot;
        ///                     }
        ///                 ]
        ///             }
        ///         },
        ///         {
        ///             &quot;statusCode&quot;: 400,
        ///             &quot;response&quot;:
        ///             {
        ///                 &quot;error&quot;:
        ///                 {
        ///                     &quot;code&quot;: &quot;400 BadRequest&quot;,
        ///                     &quot;message&quot;: &quot;Bad request: one or more parameters were incorrectly specified or are mutually exclusive.&quot;
        ///                 }
        ///             }
        ///         }
        ///     ]
        /// }
        /// ```.
        /// </summary>
        /// <param name="format"> Batch id for querying the operation. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="format"/> is null. </exception>
        public ResponseWithHeaders<SearchGetSearchAddressReverseBatchHeaders> GetSearchAddressReverseBatch(string format, CancellationToken cancellationToken = default)
        {
            if (format == null)
            {
                throw new ArgumentNullException(nameof(format));
            }

            using var message = CreateGetSearchAddressReverseBatchRequest(format);
            _pipeline.Send(message, cancellationToken);
            var headers = new SearchGetSearchAddressReverseBatchHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                case 202:
                    return ResponseWithHeaders.FromValue(headers, message.Response);
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
