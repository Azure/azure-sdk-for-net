// <auto-generated>
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Azure.Maps.Render
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// RenderOperations operations.
    /// </summary>
    public partial class RenderOperations : IServiceOperations<RenderClient>, IRenderOperations
    {
        /// <summary>
        /// Initializes a new instance of the RenderOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public RenderOperations(RenderClient client)
        {
            if (client == null)
            {
                throw new System.ArgumentNullException("client");
            }
            Client = client;
        }

        /// <summary>
        /// Gets a reference to the RenderClient
        /// </summary>
        public RenderClient Client { get; private set; }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        ///
        /// The static image service renders a user-defined, rectangular image
        /// containing a map section using a zoom level from 0 to 20. The static image
        /// service renders a user-defined, rectangular image containing a map section
        /// using a zoom level from 0 to 20. The supported resolution range for the map
        /// image is from 1x1 to 8192x8192. If you are deciding when to use the static
        /// image service over the map tile service, you may want to consider how you
        /// would like to interact with the rendered map. If the map contents will be
        /// relatively unchanging, a static map is a good choice. If you want to
        /// support a lot of zooming, panning and changing of the map content, the map
        /// tile service would be a better choice.
        ///
        /// Service also provides Image Composition functionality to get a static image
        /// back with additional data like; pushpins and geometry overlays with
        /// following S0 and S1 capabilities.
        ///
        /// In S0 you can:
        /// - Render up to 5 pushpins specified in the request
        /// - Provide one custom image for the pins referenced in the request
        /// - Add labels to the pushpins
        ///
        /// In S1 you can:
        /// - Render pushpins through [Azure Maps Data
        /// Service](https://aka.ms/AzureMapsMapDataService)
        /// - Specify multiple pushpin styles
        /// - Provide custom pushpin images stored in [Azure Maps Data
        /// Service](https://aka.ms/AzureMapsMapDataService)
        /// - Render circle, polyline and polygon geometry types.
        /// - Render of supported GeoJSON geometry types uploaded through [Azure Maps
        /// Data Service](https://aka.ms/AzureMapsMapDataService)
        ///
        /// Please see
        /// [How-to-Guide](https://aka.ms/AzureMapsHowToGuideImageCompositor) for
        /// detailed examples.
        ///
        /// _Note_ : Either **center** or **bbox** parameter must be supplied to the
        /// API.
        /// &lt;br&gt;&lt;br&gt;
        /// The supported Lat and Lon ranges when using the **bbox** parameter, are as
        /// follows:
        /// &lt;br&gt;&lt;br&gt;
        ///
        /// |Zoom Level | Max Lon Range   | Max Lat Range|
        /// |:----------|:----------------|:-------------|
        /// |0          | 360.0           | 170.0        |
        /// |1          | 360.0           | 170.0        |
        /// |2          | 360.0           | 170.0        |
        /// |3          | 360.0           | 170.0        |
        /// |4          | 360.0           | 170.0        |
        /// |5          | 180.0           | 85.0         |
        /// |6          | 90.0            | 42.5         |
        /// |7          | 45.0            | 21.25        |
        /// |8          | 22.5            | 10.625       |
        /// |9          | 11.25           | 5.3125       |
        /// |10         | 5.625           | 2.62625      |
        /// |11         | 2.8125          | 1.328125     |
        /// |12         | 1.40625         | 0.6640625    |
        /// |13         | 0.703125        | 0.33203125   |
        /// |14         | 0.3515625       | 0.166015625  |
        /// |15         | 0.17578125      | 0.0830078125 |
        /// |16         | 0.087890625     | 0.0415039063 |
        /// |17         | 0.0439453125    | 0.0207519531 |
        /// |18         | 0.0219726563    | 0.0103759766 |
        /// |19         | 0.0109863281    | 0.0051879883 |
        /// |20         | 0.0054931641    | 0.0025939941 |
        /// </summary>
        /// <param name='layer'>
        /// Map layer requested. If layer is set to labels or hybrid, the format should
        /// be png. Possible values include: 'basic', 'hybrid', 'labels'
        /// </param>
        /// <param name='style'>
        /// Map style to be returned. Possible values are main and dark. Possible
        /// values include: 'main', 'dark'
        /// </param>
        /// <param name='zoom'>
        /// Desired zoom level of the map. Zoom value must be in the range: 0-20
        /// (inclusive). Default value is 12.&lt;br&gt;&lt;br&gt;Please see [Zoom
        /// Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='center'>
        /// Coordinates of the center point. Format: 'lon,lat'. Projection used
        /// - EPSG:3857. Longitude range: -180 to 180. Latitude range: -85 to 85.
        ///
        /// Note: Either center or bbox are required parameters. They are
        /// mutually exclusive.
        /// </param>
        /// <param name='bbox'>
        /// Bounding box. Projection used - EPSG:3857. Format : 'minLon, minLat,
        /// maxLon, maxLat'.
        ///
        /// Note: Either bbox or center are required
        /// parameters. They are mutually exclusive. It shouldn’t be used with
        /// height or width.
        ///
        /// The maximum allowed ranges for Lat and Lon are defined for each zoom level
        /// in the table at the top of this page.
        /// </param>
        /// <param name='height'>
        /// Height of the resulting image in pixels. Range is 1 to 8192. Default
        /// is 512. It shouldn’t be used with bbox.
        /// </param>
        /// <param name='width'>
        /// Width of the resulting image in pixels. Range is 1 to 8192. Default is 512.
        /// It shouldn’t be used with bbox.
        /// </param>
        /// <param name='language'>
        /// Language in which search results should be returned. Should be one of
        /// supported IETF language tags, case insensitive. When data in specified
        /// language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported
        /// Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='view'>
        /// The View parameter specifies which set of geopolitically disputed content
        /// is returned via Azure Maps services, including  borders and labels
        /// displayed on the map. The View parameter (also referred to as “user region
        /// parameter”) will show the  correct maps for that country/region. By
        /// default, the View parameter is set to “Unified” even if you haven’t defined
        /// it in  the request. It is your responsibility to determine the location of
        /// your users, and then set the View parameter correctly  for that location.
        /// Alternatively, you have the option to set ‘View=Auto’, which will return
        /// the map data based on the IP  address of the request. The View parameter in
        /// Azure Maps must be used in compliance with applicable laws, including those
        /// regarding mapping, of the country where maps, images and other data and
        /// third party content that you are authorized to  access via Azure Maps is
        /// made available. Example: view=IN.
        ///
        /// Please refer to [Supported
        /// Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see
        /// the available Views.
        /// </param>
        /// <param name='pins'>
        /// Pushpin style and instances. Use this parameter to optionally add pushpins
        /// to the image.
        /// The pushpin style describes the appearance of the pushpins, and the
        /// instances specify
        /// the coordinates of the pushpins and optional labels for each pin. (Be sure
        /// to properly URL-encode values of this
        /// parameter since it will contain reserved characters such as pipes and
        /// punctuation.)
        ///
        /// The Azure Maps account S0 SKU only supports a single instance of the pins
        /// parameter. Other SKUs
        /// allow multiple instances of the pins parameter to specify multiple pin
        /// styles.
        ///
        /// To render a pushpin at latitude 45°N and longitude 122°W using the default
        /// built-in pushpin style, add the
        /// querystring parameter
        ///
        /// `pins=default||-122 45`
        ///
        /// Note that the longitude comes before the latitude.
        /// After URL encoding this will look like
        ///
        /// `pins=default%7C%7C-122+45`
        ///
        /// All of the examples here show the pins
        /// parameter without URL encoding, for clarity.
        ///
        /// To render a pin at multiple locations, separate each location with a pipe
        /// character. For example, use
        ///
        /// `pins=default||-122 45|-119.5 43.2|-121.67 47.12`
        ///
        /// The S0 Azure Maps account SKU only allows five pushpins. Other account SKUs
        /// do not have this limitation.
        ///
        /// ### Style Modifiers
        ///
        /// You can modify the appearance of the pins by adding style modifiers. These
        /// are added after the style but before
        /// the locations and labels. Style modifiers each have a two-letter name.
        /// These abbreviated names are used to help
        /// reduce the length of the URL.
        ///
        /// To change the color of the pushpin, use the 'co' style modifier and specify
        /// the color using the HTML/CSS RGB color
        /// format which is a six-digit hexadecimal number (the three-digit form is not
        /// supported). For example, to use
        /// a deep pink color which you would specify as #FF1493 in CSS, use
        ///
        /// `pins=default|coFF1493||-122 45`
        ///
        /// ### Pushpin Labels
        ///
        /// To add a label to the pins, put the label in single quotes just before the
        /// coordinates. For example, to label
        /// three pins with the values '1', '2', and '3', use
        ///
        /// `pins=default||'1'-122 45|'2'-119.5 43.2|'3'-121.67 47.12`
        ///
        /// There is a built in pushpin style called 'none' that does not display a
        /// pushpin image. You can use this if
        /// you want to display labels without any pin image. For example,
        ///
        /// `pins=none||'A'-122 45|'B'-119.5 43.2`
        ///
        /// To change the color of the pushpin labels, use the 'lc' label color style
        /// modifier. For example, to use pink
        /// pushpins with black labels, use
        ///
        /// `pins=default|coFF1493|lc000000||-122 45`
        ///
        /// To change the size of the labels, use the 'ls' label size style modifier.
        /// The label size represents the approximate
        /// height of the label text in pixels. For example, to increase the label size
        /// to 12, use
        ///
        /// `pins=default|ls12||'A'-122 45|'B'-119 43`
        ///
        /// The labels are centered at the pushpin 'label anchor.' The anchor location
        /// is predefined for built-in pushpins and
        /// is at the top center of custom pushpins (see below). To override the label
        /// anchor, using the 'la' style modifier
        /// and provide X and Y pixel coordinates for the anchor. These coordinates are
        /// relative to the top left corner of the
        /// pushpin image. Positive X values move the anchor to the right, and positive
        /// Y values move the anchor down. For example,
        /// to position the label anchor 10 pixels right and 4 pixels above the top
        /// left corner of the pushpin image,
        /// use
        ///
        /// `pins=default|la10 -4||'A'-122 45|'B'-119 43`
        ///
        /// ### Custom Pushpins
        ///
        /// To use a custom pushpin image, use the word 'custom' as the pin style name,
        /// and then specify a URL after the
        /// location and label information. Use two pipe characters to indicate that
        /// you're done specifying locations and are
        /// starting the URL. For example,
        ///
        /// `pins=custom||-122 45||http://contoso.com/pushpins/red.png`
        ///
        /// After URL encoding, this would look like
        ///
        /// `pins=custom%7C%7C-122+45%7C%7Chttp%3A%2F%2Fcontoso.com%2Fpushpins%2Fred.png`
        ///
        /// By default, custom pushpin images are drawn centered at the pin
        /// coordinates. This usually isn't ideal as it obscures
        /// the location that you're trying to highlight. To override the anchor
        /// location of the pin image, use the 'an'
        /// style modifier. This uses the same format as the 'la' label anchor style
        /// modifier. For example, if your custom
        /// pin image has the tip of the pin at the top left corner of the image, you
        /// can set the anchor to that spot by
        /// using
        ///
        /// `pins=custom|an0 0||-122 45||http://contoso.com/pushpins/red.png`
        ///
        /// Note: If you use the 'co' color modifier with a custom pushpin image, the
        /// specified color will replace the RGB
        /// channels of the pixels in the image but will leave the alpha (opacity)
        /// channel unchanged. This would usually
        /// only be done with a solid-color custom image.
        ///
        /// ### Getting Pushpins from Azure Maps Data Storage
        ///
        /// For all Azure Maps account SKUs other than S0,
        /// the pushpin image and location information can be obtained from Azure Maps
        /// Data Storage. After uploading a pushpin image
        /// or a GeoJSON document containing pin locations, the Data Storage service
        /// returns a Unique Data ID (UDID) that you can use
        /// to reference the data in the pins parameter.
        ///
        /// To use a custom pushpin image from Azure Maps Data Storage, specify the
        /// UDID prefixed by 'udid-' as the name of the
        /// pushpin style. For example,
        ///
        /// `pins=udid-fe22c504-3a81-4fcd-adc6-a3507ce866c1||-122 45`
        ///
        /// To use the point geometry from an uploaded GeoJSON document as the pin
        /// locations, specify the UDID in the locations
        /// section of the pins parameter. For example,
        ///
        /// `pins=default||udid-29dc105a-dee7-409f-a3f9-22b066ae4713`
        ///
        /// Note that
        /// only point and multipoint geometry, points and multipoints from geometry
        /// collections, and point geometry from features
        /// will be used. Linestring and polygon geometry will be ignored. If the point
        /// comes from a feature and the feature
        /// has a string property called "label", the value of that property will be
        /// used as the label for the pin.
        ///
        /// You can mix pin locations from Data Storage and pin locations specified in
        /// the pins parameter. Any of the pipe-delimited
        /// pin locations can be a longitude and latitude or a UDID. For example,
        ///
        /// `pins=default||-122 45|udid-29dc105a-dee7-409f-a3f9-22b066ae4713|-119 43`
        ///
        /// ### Scale, Rotation, and Opacity
        ///
        /// You can make pushpins and their labels larger or smaller by using the 'sc'
        /// scale style modifier. This is a
        /// value greater than zero. A value of 1 is the standard scale. Values larger
        /// than 1 will make the pins larger, and
        /// values smaller than 1 will make them smaller. For example, to draw the
        /// pushpins 50% larger than normal, use
        ///
        /// `pins=default|sc1.5||-122 45`
        ///
        /// You can rotate pushpins and their labels by using the 'ro' rotation style
        /// modifier. This is a number of degrees
        /// of clockwise rotation. Use a negative number to rotate counter-clockwise.
        /// For example, to rotate the pushpins
        /// 90 degrees clockwise and double their size, use
        ///
        /// `pins=default|ro90|sc2||-122 45`
        ///
        /// You can make pushpins and their labels partially transparent by specifying
        /// the 'al' alpha style modifier.
        /// This is a number between 0 and 1 indicating the opacity of the pushpins.
        /// Zero makes them completely transparent
        /// (and not visible) and 1 makes them completely opaque (which is the
        /// default). For example, to make pushpins
        /// and their labels only 67% opaque, use
        ///
        /// `pins=default|al.67||-122 45`
        ///
        /// ### Style Modifier Summary
        ///
        /// Modifier  | Description     | Range
        /// :--------:|-----------------|------------------
        /// al        | Alpha (opacity) | 0 to 1
        /// an        | Pin anchor      | *
        /// co        | Pin color       | 000000 to FFFFFF
        /// la        | Label anchor    | *
        /// lc        | Label color     | 000000 to FFFFFF
        /// ls        | Label size      | Greater than 0
        /// ro        | Rotation        | -360 to 360
        /// sc        | Scale           | Greater than 0
        ///
        /// * X and Y coordinates can be anywhere within pin image or a margin around
        /// it.
        /// The margin size is the minimum of the pin width and height.
        /// </param>
        /// <param name='path'>
        /// Path style and locations. Use this parameter to optionally add lines,
        /// polygons or circles to the image.
        /// The path style describes the appearance of the line and fill. (Be sure to
        /// properly URL-encode values of this
        /// parameter since it will contain reserved characters such as pipes and
        /// punctuation.)
        ///
        /// Path parameter is supported in Azure Maps account SKU starting with S1.
        /// Multiple instances of the path parameter
        /// allow to specify multiple geometries with their styles. Number of
        /// parameters per request is limited to 10 and
        /// number of locations is limited to 100 per path.
        ///
        /// To render a circle with radius 100 meters and center point at latitude 45°N
        /// and longitude 122°W using the default style, add the
        /// querystring parameter
        ///
        /// `path=ra100||-122 45`
        ///
        /// Note that the longitude comes before the latitude.
        /// After URL encoding this will look like
        ///
        /// `path=ra100%7C%7C-122+45`
        ///
        /// All of the examples here show the path parameter without URL encoding, for
        /// clarity.
        ///
        /// To render a line, separate each location with a pipe character. For
        /// example, use
        ///
        /// `path=||-122 45|-119.5 43.2|-121.67 47.12`
        ///
        /// To render a polygon, last location must be equal to the start location. For
        /// example, use
        ///
        /// `path=||-122 45|-119.5 43.2|-121.67 47.12|-122 45`
        ///
        /// Longitude and latitude values for locations of lines and polygons can be in
        /// the range from -360 to 360 to allow for rendering of geometries crossing
        /// the anti-meridian.
        ///
        /// ### Style Modifiers
        ///
        /// You can modify the appearance of the path by adding style modifiers. These
        /// are added before the locations.
        /// Style modifiers each have a two-letter name. These abbreviated names are
        /// used to help reduce the length
        /// of the URL.
        ///
        /// To change the color of the outline, use the 'lc' style modifier and specify
        /// the color using the HTML/CSS RGB color
        /// format which is a six-digit hexadecimal number (the three-digit form is not
        /// supported). For example, to use
        /// a deep pink color which you would specify as #FF1493 in CSS, use
        ///
        /// `path=lcFF1493||-122 45|-119.5 43.2`
        ///
        /// Multiple style modifiers may be combined together to create a more complex
        /// visual style.
        ///
        /// `lc0000FF|lw3|la0.60|fa0.50||-122.2 47.6|-122.2 47.7|-122.3 47.7|-122.3
        /// 47.6|-122.2 47.6`
        ///
        /// ### Getting Path locations from Azure Maps Data Storage
        ///
        /// For all Azure Maps account SKUs other than S0, the path location
        /// information can be obtained from Azure Maps Data Storage.
        /// After uploading a GeoJSON document containing path locations, the Data
        /// Storage service returns a Unique Data ID (UDID) that you can use
        /// to reference the data in the path parameter.
        ///
        /// To use the point geometry from an uploaded GeoJSON document as the path
        /// locations, specify the UDID in the locations
        /// section of the path parameter. For example,
        ///
        /// `path=||udid-29dc105a-dee7-409f-a3f9-22b066ae4713`
        ///
        /// Note the it is not allowed to mix path locations from Data Storage with
        /// locations specified in the path parameter.
        ///
        /// ### Style Modifier Summary
        ///
        /// Modifier  | Description            | Range
        /// :--------:|------------------------|------------------
        /// lc        | Line color             | 000000 to FFFFFF
        /// fc        | Fill color             | 000000 to FFFFFF
        /// la        | Line alpha (opacity)   | 0 to 1
        /// fa        | Fill alpha (opacity)   | 0 to 1
        /// lw        | Line width             | Greater than 0
        /// ra        | Circle radius (meters) | Greater than 0
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<Stream,RenderGetMapStaticImageHeaders>> GetMapStaticImageWithHttpMessagesAsync(string layer = default(string), string style = default(string), int? zoom = default(int?), string center = default(string), string bbox = default(string), int? height = default(int?), int? width = default(int?), string language = default(string), string view = default(string), IList<string> pins = default(IList<string>), IList<string> path = default(IList<string>), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (zoom > 20)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "zoom", 20);
            }
            if (zoom < 0)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "zoom", 0);
            }
            if (height > 8192)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "height", 8192);
            }
            if (height < 1)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "height", 1);
            }
            if (width > 8192)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "width", 8192);
            }
            if (width < 1)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "width", 1);
            }
            string apiVersion = "1.0";
            string format = "png";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("layer", layer);
                tracingParameters.Add("style", style);
                tracingParameters.Add("zoom", zoom);
                tracingParameters.Add("center", center);
                tracingParameters.Add("bbox", bbox);
                tracingParameters.Add("height", height);
                tracingParameters.Add("width", width);
                tracingParameters.Add("language", language);
                tracingParameters.Add("view", view);
                tracingParameters.Add("pins", pins);
                tracingParameters.Add("path", path);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetMapStaticImage", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "map/static/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (layer != null)
            {
                _queryParameters.Add(string.Format("layer={0}", System.Uri.EscapeDataString(layer)));
            }
            if (style != null)
            {
                _queryParameters.Add(string.Format("style={0}", System.Uri.EscapeDataString(style)));
            }
            if (zoom != null)
            {
                _queryParameters.Add(string.Format("zoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(zoom, Client.SerializationSettings).Trim('"'))));
            }
            if (center != null)
            {
                _queryParameters.Add(string.Format("center={0}", System.Uri.EscapeDataString(center)));
            }
            if (bbox != null)
            {
                _queryParameters.Add(string.Format("bbox={0}", System.Uri.EscapeDataString(bbox)));
            }
            if (height != null)
            {
                _queryParameters.Add(string.Format("height={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(height, Client.SerializationSettings).Trim('"'))));
            }
            if (width != null)
            {
                _queryParameters.Add(string.Format("width={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(width, Client.SerializationSettings).Trim('"'))));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (view != null)
            {
                _queryParameters.Add(string.Format("view={0}", System.Uri.EscapeDataString(view)));
            }
            if (pins != null)
            {
                if (pins.Count == 0)
                {
                    _queryParameters.Add(string.Format("pins={0}", System.Uri.EscapeDataString(string.Empty)));
                }
                else
                {
                    foreach (var _item in pins)
                    {
                        _queryParameters.Add(string.Format("pins={0}", System.Uri.EscapeDataString("" + _item)));
                    }
                }
            }
            if (path != null)
            {
                if (path.Count == 0)
                {
                    _queryParameters.Add(string.Format("path={0}", System.Uri.EscapeDataString(string.Empty)));
                }
                else
                {
                    foreach (var _item in path)
                    {
                        _queryParameters.Add(string.Format("path={0}", System.Uri.EscapeDataString("" + _item)));
                    }
                }
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<Stream,RenderGetMapStaticImageHeaders>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _result.Body = await _httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false);
            }
            try
            {
                _result.Headers = _httpResponse.GetHeadersAsJson().ToObject<RenderGetMapStaticImageHeaders>(JsonSerializer.Create(Client.DeserializationSettings));
            }
            catch (JsonException ex)
            {
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw new SerializationException("Unable to deserialize the headers.", _httpResponse.GetHeadersAsJson().ToString(), ex);
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        ///
        /// Fetches map tiles in vector or raster format typically to be integrated
        /// into a new map control or SDK. By default, Azure uses vector map tiles for
        /// its web map control (see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid))
        ///
        /// **Note**: Weather tiles are only available via [Get Map Tile V2
        /// API](https://aka.ms/AzureMapsWeatherTiles). We recommend to start to use
        /// the new [Get Map Tile V2 API](https://aka.ms/GetMapTileV2).
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Possible values are png &amp; pbf. Possible
        /// values include: 'png', 'pbf'
        /// </param>
        /// <param name='layer'>
        /// Map layer requested. Possible values are basic, hybrid, labels and terra.
        /// Possible values include: 'basic', 'hybrid', 'labels', 'terra'
        /// </param>
        /// <param name='style'>
        /// Map style to be returned. Possible values are main, dark, and
        /// shaded_relief. Possible values include: 'main', 'dark', 'shaded_relief'
        /// </param>
        /// <param name='zoom'>
        /// Zoom level for the desired tile. For _raster_ tiles, value must be in the
        /// range: 0-18 (inclusive). Terra raster tiles, values must be in the range
        /// 0-6 (inclusive). For _vector_ tiles, value must be in the range: 0-22
        /// (inclusive).
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='xTileIndex'>
        /// X coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='yTileIndex'>
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='tileSize'>
        /// The size of the returned map tile in pixels. Possible values include:
        /// '256', '512'
        /// </param>
        /// <param name='language'>
        /// Language in which search results should be returned. Should be one of
        /// supported IETF language tags, case insensitive. When data in specified
        /// language is not available for a specific field, default language is used.
        ///
        /// Please refer to [Supported
        /// Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='view'>
        /// The View parameter specifies which set of geopolitically disputed content
        /// is returned via Azure Maps services, including  borders and labels
        /// displayed on the map. The View parameter (also referred to as “user region
        /// parameter”) will show the  correct maps for that country/region. By
        /// default, the View parameter is set to “Unified” even if you haven’t defined
        /// it in  the request. It is your responsibility to determine the location of
        /// your users, and then set the View parameter correctly  for that location.
        /// Alternatively, you have the option to set ‘View=Auto’, which will return
        /// the map data based on the IP  address of the request. The View parameter in
        /// Azure Maps must be used in compliance with applicable laws, including those
        /// regarding mapping, of the country where maps, images and other data and
        /// third party content that you are authorized to  access via Azure Maps is
        /// made available. Example: view=IN.
        ///
        /// Please refer to [Supported
        /// Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see
        /// the available Views.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<Stream,RenderGetMapTileHeaders>> GetMapTileWithHttpMessagesAsync(string format, string layer, string style, int zoom, int xTileIndex, int yTileIndex, string tileSize = default(string), string language = default(string), string view = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            if (layer == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "layer");
            }
            if (style == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "style");
            }
            string apiVersion = "1.0";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("layer", layer);
                tracingParameters.Add("style", style);
                tracingParameters.Add("zoom", zoom);
                tracingParameters.Add("xTileIndex", xTileIndex);
                tracingParameters.Add("yTileIndex", yTileIndex);
                tracingParameters.Add("tileSize", tileSize);
                tracingParameters.Add("language", language);
                tracingParameters.Add("view", view);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetMapTile", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "map/tile/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (layer != null)
            {
                _queryParameters.Add(string.Format("layer={0}", System.Uri.EscapeDataString(layer)));
            }
            if (style != null)
            {
                _queryParameters.Add(string.Format("style={0}", System.Uri.EscapeDataString(style)));
            }
            _queryParameters.Add(string.Format("zoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(zoom, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("x={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(xTileIndex, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("y={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(yTileIndex, Client.SerializationSettings).Trim('"'))));
            if (tileSize != null)
            {
                _queryParameters.Add(string.Format("tileSize={0}", System.Uri.EscapeDataString(tileSize)));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (view != null)
            {
                _queryParameters.Add(string.Format("view={0}", System.Uri.EscapeDataString(view)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<Stream,RenderGetMapTileHeaders>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _result.Body = await _httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false);
            }
            try
            {
                _result.Headers = _httpResponse.GetHeadersAsJson().ToObject<RenderGetMapTileHeaders>(JsonSerializer.Create(Client.DeserializationSettings));
            }
            catch (JsonException ex)
            {
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw new SerializationException("Unable to deserialize the headers.", _httpResponse.GetHeadersAsJson().ToString(), ex);
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        ///
        /// Fetches state tiles in vector format typically to be integrated into indoor
        /// maps module of map control or SDK. The map control will call this API after
        /// user turns on dynamic styling (see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid))
        /// </summary>
        /// <param name='zoom'>
        /// Zoom level for the desired tile. Zoom value must be in the range: 0-20
        /// (inclusive).
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='xTileIndex'>
        /// X coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='yTileIndex'>
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='statesetId'>
        /// The stateset id.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<Stream,RenderGetMapStateTilePreviewHeaders>> GetMapStateTilePreviewWithHttpMessagesAsync(int zoom, int xTileIndex, int yTileIndex, string statesetId, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (statesetId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "statesetId");
            }
            string apiVersion = "1.0";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("zoom", zoom);
                tracingParameters.Add("xTileIndex", xTileIndex);
                tracingParameters.Add("yTileIndex", yTileIndex);
                tracingParameters.Add("statesetId", statesetId);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetMapStateTilePreview", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "map/statetile";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            _queryParameters.Add(string.Format("zoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(zoom, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("x={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(xTileIndex, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("y={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(yTileIndex, Client.SerializationSettings).Trim('"'))));
            if (statesetId != null)
            {
                _queryParameters.Add(string.Format("statesetId={0}", System.Uri.EscapeDataString(statesetId)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<Stream,RenderGetMapStateTilePreviewHeaders>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _result.Body = await _httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false);
            }
            try
            {
                _result.Headers = _httpResponse.GetHeadersAsJson().ToObject<RenderGetMapStateTilePreviewHeaders>(JsonSerializer.Create(Client.DeserializationSettings));
            }
            catch (JsonException ex)
            {
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw new SerializationException("Unable to deserialize the headers.", _httpResponse.GetHeadersAsJson().ToString(), ex);
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        ///
        ///
        /// Copyrights API is designed to serve copyright information for Render Tile
        /// service. In addition to basic copyright for the whole map, API is serving
        /// specific groups of copyrights for some countries.
        ///
        /// As an alternative to copyrights for map request, one can receive captions
        /// for displaying the map provider information on the map.
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Value can be either _json_ or _xml_.
        /// Possible values include: 'json', 'xml'
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GetCopyrightCaptionResult>> GetCopyrightCaptionWithHttpMessagesAsync(string format, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            string apiVersion = "1.0";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetCopyrightCaption", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "map/copyright/caption/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GetCopyrightCaptionResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<GetCopyrightCaptionResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to:** S1 pricing tier.
        ///
        ///
        /// This service returns a map image tile with size 256x256, given the x and y
        /// coordinates and zoom
        /// level. Zoom level ranges from 1 to 19. The current available style value is
        /// 'satellite' which provides satellite
        /// imagery alone.
        ///
        ///
        /// **Note**: We recommend to start to use the new [Get Map Tile V2
        /// API](https://aka.ms/GetMapTileV2).
        /// </summary>
        /// <param name='zoom'>
        /// Zoom level for the desired tile. Zoom value must be in the range: 1-19
        /// (inclusive).
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='xTileIndex'>
        /// X coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='yTileIndex'>
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<Stream,RenderGetMapImageryTileHeaders>> GetMapImageryTileWithHttpMessagesAsync(int zoom, int xTileIndex, int yTileIndex, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            string apiVersion = "1.0";
            string format = "png";
            string style = "satellite";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("style", style);
                tracingParameters.Add("zoom", zoom);
                tracingParameters.Add("xTileIndex", xTileIndex);
                tracingParameters.Add("yTileIndex", yTileIndex);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetMapImageryTile", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "map/imagery/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (style != null)
            {
                _queryParameters.Add(string.Format("style={0}", System.Uri.EscapeDataString(style)));
            }
            _queryParameters.Add(string.Format("zoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(zoom, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("x={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(xTileIndex, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("y={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(yTileIndex, Client.SerializationSettings).Trim('"'))));
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<Stream,RenderGetMapImageryTileHeaders>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _result.Body = await _httpResponse.Content.ReadAsStreamAsync().ConfigureAwait(false);
            }
            try
            {
                _result.Headers = _httpResponse.GetHeadersAsJson().ToObject<RenderGetMapImageryTileHeaders>(JsonSerializer.Create(Client.DeserializationSettings));
            }
            catch (JsonException ex)
            {
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw new SerializationException("Unable to deserialize the headers.", _httpResponse.GetHeadersAsJson().ToString(), ex);
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        ///
        /// Returns copyright information for a given bounding box. Bounding-box
        /// requests should specify the minimum and maximum longitude and latitude
        /// (EPSG-3857) coordinates
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Value can be either _json_ or _xml_.
        /// Possible values include: 'json', 'xml'
        /// </param>
        /// <param name='mincoordinates'>
        /// Minimum coordinates of bounding box in latitude longitude coordinate
        /// system. E.g. 52.41064,4.84228
        /// </param>
        /// <param name='maxcoordinates'>
        /// Maximum coordinates of bounding box in latitude longitude coordinate
        /// system. E.g. 52.41064,4.84228
        /// </param>
        /// <param name='text'>
        /// Yes/no value to exclude textual data from response. Only images and country
        /// names will be in response. Possible values include: 'yes', 'no'
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GetCopyrightFromBoundingBoxResult>> GetCopyrightFromBoundingBoxWithHttpMessagesAsync(string format, string mincoordinates, string maxcoordinates, string text = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            if (mincoordinates == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "mincoordinates");
            }
            if (maxcoordinates == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "maxcoordinates");
            }
            string apiVersion = "1.0";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("mincoordinates", mincoordinates);
                tracingParameters.Add("maxcoordinates", maxcoordinates);
                tracingParameters.Add("text", text);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetCopyrightFromBoundingBox", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "map/copyright/bounding/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (mincoordinates != null)
            {
                _queryParameters.Add(string.Format("mincoordinates={0}", System.Uri.EscapeDataString(mincoordinates)));
            }
            if (maxcoordinates != null)
            {
                _queryParameters.Add(string.Format("maxcoordinates={0}", System.Uri.EscapeDataString(maxcoordinates)));
            }
            if (text != null)
            {
                _queryParameters.Add(string.Format("text={0}", System.Uri.EscapeDataString(text)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GetCopyrightFromBoundingBoxResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<GetCopyrightFromBoundingBoxResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        ///
        ///
        /// Copyrights API is designed to serve copyright information for Render Tile
        /// service. In addition to basic copyright for the whole map, API is serving
        /// specific groups of copyrights for some countries.
        /// Returns the copyright information for a given tile. To obtain the copyright
        /// information for a particular tile, the request should specify the tile's
        /// zoom level and x and y coordinates (see: Zoom Levels and Tile Grid).
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Value can be either _json_ or _xml_.
        /// Possible values include: 'json', 'xml'
        /// </param>
        /// <param name='zoom'>
        /// Zoom level for the desired tile. Zoom value must be in the range: 0-18
        /// (inclusive).
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='xTileIndex'>
        /// X coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='yTileIndex'>
        /// Y coordinate of the tile on zoom grid. Value must be in the range [0,
        /// 2&lt;sup&gt;`zoom`&lt;/sup&gt; -1].
        ///
        /// Please see [Zoom Levels and Tile
        /// Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid)
        /// for details.
        /// </param>
        /// <param name='text'>
        /// Yes/no value to exclude textual data from response. Only images and country
        /// names will be in response. Possible values include: 'yes', 'no'
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GetCopyrightForTileResult>> GetCopyrightForTileWithHttpMessagesAsync(string format, int zoom, int xTileIndex, int yTileIndex, string text = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            string apiVersion = "1.0";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("zoom", zoom);
                tracingParameters.Add("xTileIndex", xTileIndex);
                tracingParameters.Add("yTileIndex", yTileIndex);
                tracingParameters.Add("text", text);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetCopyrightForTile", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "map/copyright/tile/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            _queryParameters.Add(string.Format("zoom={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(zoom, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("x={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(xTileIndex, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("y={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(yTileIndex, Client.SerializationSettings).Trim('"'))));
            if (text != null)
            {
                _queryParameters.Add(string.Format("text={0}", System.Uri.EscapeDataString(text)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GetCopyrightForTileResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<GetCopyrightForTileResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S0 and S1 pricing tiers.
        ///
        ///
        /// Copyrights API is designed to serve copyright information for Render Tile
        /// service. In addition to basic copyright for the whole map, API is serving
        /// specific groups of copyrights for some countries.
        /// Returns the copyright information for the world. To obtain the default
        /// copyright information for the whole world, do not specify a tile or
        /// bounding box.
        /// </summary>
        /// <param name='format'>
        /// Desired format of the response. Value can be either _json_ or _xml_.
        /// Possible values include: 'json', 'xml'
        /// </param>
        /// <param name='text'>
        /// Yes/no value to exclude textual data from response. Only images and country
        /// names will be in response. Possible values include: 'yes', 'no'
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GetCopyrightForWorldResult>> GetCopyrightForWorldWithHttpMessagesAsync(string format, string text = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (format == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "format");
            }
            string apiVersion = "1.0";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("text", text);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetCopyrightForWorld", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "map/copyright/world/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (text != null)
            {
                _queryParameters.Add(string.Format("text={0}", System.Uri.EscapeDataString(text)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GetCopyrightForWorldResult>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<GetCopyrightForWorldResult>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
