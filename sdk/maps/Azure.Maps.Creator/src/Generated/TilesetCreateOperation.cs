// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Maps.Creator.Models;

namespace Azure.Maps.Creator
{
    /// <summary>
    /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
    /// 
    /// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. [This](https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps) article introduces concepts and tools that apply to Azure Maps Creator.
    /// 
    ///  [This](https://docs.microsoft.com/en-us/azure/azure-maps/creator-indoor-maps) article introduces concepts and tools that apply to Azure Maps Creator.
    /// 
    /// The Tileset Create API allows the caller to create a tileset from a dataset. A tileset contains a set of tiles that can be consumed
    /// from the [Get Map Tile](/rest/api/maps/render/getmaptile) to retrieve custom tiles. To make a dataset, use the
    /// [DataSet Create API](/rest/api/maps/dataset/createpreview).
    /// 
    /// ## Submit Create Request
    /// 
    /// To create your tileset you will make a `POST` request with an empty body. The `datasetId` query parameter will be
    /// used as the source of the tileset data.
    /// 
    /// The Create Tileset API is a
    /// [long-running request](https://aka.ms/am-creator-lrt-v2).
    /// </summary>
    public partial class TilesetCreateOperation : Operation<LongRunningOperationResult>, IOperationSource<LongRunningOperationResult>
    {
        private readonly OperationInternals<LongRunningOperationResult> _operation;

        /// <summary> Initializes a new instance of TilesetCreateOperation for mocking. </summary>
        protected TilesetCreateOperation()
        {
        }

        internal TilesetCreateOperation(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response)
        {
            _operation = new OperationInternals<LongRunningOperationResult>(this, clientDiagnostics, pipeline, request, response, OperationFinalStateVia.Location, "TilesetCreateOperation");
        }

        /// <inheritdoc />
        public override string Id => _operation.Id;

        /// <inheritdoc />
        public override LongRunningOperationResult Value => _operation.Value;

        /// <inheritdoc />
        public override bool HasCompleted => _operation.HasCompleted;

        /// <inheritdoc />
        public override bool HasValue => _operation.HasValue;

        /// <inheritdoc />
        public override Response GetRawResponse() => _operation.GetRawResponse();

        /// <inheritdoc />
        public override Response UpdateStatus(CancellationToken cancellationToken = default) => _operation.UpdateStatus(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default) => _operation.UpdateStatusAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<LongRunningOperationResult>> WaitForCompletionAsync(CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<LongRunningOperationResult>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(pollingInterval, cancellationToken);

        LongRunningOperationResult IOperationSource<LongRunningOperationResult>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            using var document = JsonDocument.Parse(response.ContentStream);
            return LongRunningOperationResult.DeserializeLongRunningOperationResult(document.RootElement);
        }

        async ValueTask<LongRunningOperationResult> IOperationSource<LongRunningOperationResult>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            return LongRunningOperationResult.DeserializeLongRunningOperationResult(document.RootElement);
        }
    }
}
