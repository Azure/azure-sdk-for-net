// <auto-generated>
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Azure.Maps.Creator
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// Spatial operations.
    /// </summary>
    public partial class Spatial : IServiceOperations<CreatorClient>, ISpatial
    {
        /// <summary>
        /// Initializes a new instance of the Spatial class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public Spatial(CreatorClient client)
        {
            if (client == null)
            {
                throw new System.ArgumentNullException("client");
            }
            Client = client;
        }

        /// <summary>
        /// Gets a reference to the CreatorClient
        /// </summary>
        public CreatorClient Client { get; private set; }

        /// <summary>
        /// **Search Geofence Get API**
        ///
        /// **Applies to:** S1 Pricing tier.
        ///
        /// The Geofence Get API allows you to retrieve the proximity of a coordinate
        /// to a
        /// geofence that has been uploaded to the Data service. You can use the
        /// [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) to
        /// upload
        /// a geofence or set of fences. See [Geofencing GeoJSON
        /// data](https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson)
        /// for more details on the geofence data format. To query the proximity of a
        /// coordinate, you supply the location of the object you are tracking as well
        /// as the ID for the fence or set of fences, and the response will contain
        /// information about
        /// the distance from the outer edge of the geofence. A negative value
        /// signifies that the
        /// coordinate is inside of the fence while a positive value means that it is
        /// outside of the
        /// fence.&lt;br&gt;&lt;br&gt;This API can be used for a variety of scenarios
        /// that include things like asset
        /// tracking, fleet management, or setting up alerts for moving objects.
        ///
        /// The API supports [integration with Event
        /// Grid](https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration).
        /// The isAsync parameter is used to enable integration with Event Grid
        /// (disabled by default).
        /// To test this API, you can upload the sample data from Post Geofence API
        /// examples(Request Body) via Data Upload API and replace the [udid] from the
        /// sample request below with the udid returned by Data Upload API.
        ///
        ///
        /// ### Geofencing InnerError code
        ///
        /// In geofencing response error contract, `innererror` is  an object
        /// containing service specific information about the error. `code` is a
        /// property in `innererror` which can map to a specific geofencing error type.
        /// The table belows shows the code mapping between all the known client error
        /// type to the corresponding geofencing error `message`.
        ///
        /// innererror.code | error.message
        /// ---------------------------- | --------------------------------------
        /// NullDeviceId  | Device Id should not be null.
        /// NullUdid	  | Udid should not be null.
        /// UdidWrongFormat| Udid should be acquired from user data ingestion API.
        /// InvalidUserTime| Usertime is invalid.
        /// InvalidSearchBuffer| Searchbuffer is invalid.
        /// InvalidSearchRange| The value range of searchbuffer should be from 0 to 500
        /// meters.
        /// InvalidLatLon| Lat and/or lon parameters are invalid.
        /// InvalidIsAsyncValue| The IsAsync parameter is invalid.
        /// InvalidModeValue| The mode parameter invalid.
        /// InvalidJson| Geofencing data is not a valid json file.
        /// NotSupportedGeoJson| Geofencing data can't be read as a Feature or
        /// FeatureCollections.
        /// InvalidGeoJson| Geofencing data is invalid.
        /// NoUserDataWithAccountOrSubscription| Can't find user geofencing data with
        /// provided account-id and/or subscription-id.
        /// NoUserDataWithUdid|	Can't find user geofencing data with provided udid.
        /// </summary>
        /// <param name='deviceId'>
        /// ID of the device
        /// </param>
        /// <param name='udid'>
        /// The unique id returned from [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview)
        /// after uploading a valid GeoJSON FeatureCollection object. Please refer to
        /// [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details.
        /// All the feature's  properties should contain `geometryId`, which is used
        /// for identifying the geometry and is case-sensitive.
        /// </param>
        /// <param name='latitude'>
        /// The latitude of the location being passed.  Example: 48.36.
        /// </param>
        /// <param name='longitude'>
        /// The longitude of the location being passed.  Example: -124.63.
        /// </param>
        /// <param name='z'>
        /// The sea level in meter of the location being passed. If this parameter is
        /// presented, 2D extrusion is used. Example: 200.
        /// </param>
        /// <param name='userTime'>
        /// The user request time. If not presented in the request, the default value
        /// is DateTime.Now.
        /// </param>
        /// <param name='searchBuffer'>
        /// The radius of the buffer around the geofence in meters that defines how far
        /// to search inside and outside the border of the fence against the coordinate
        /// that was provided when calculating the result.  The minimum value is 0, and
        /// the maximum is 500.  The default value is 50.
        /// </param>
        /// <param name='isAsync'>
        /// If true, the request will use async event mechanism; if false, the request
        /// will be synchronized and do not trigger any event. The default value is
        /// false.
        /// </param>
        /// <param name='mode'>
        /// Mode of the geofencing async event mechanism. Possible values include:
        /// 'All', 'EnterAndExit'
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GeofenceResponse,SpatialGetGeofenceHeaders>> GetGeofenceWithHttpMessagesAsync(string deviceId, string udid, double latitude, double longitude, double? z = default(double?), System.DateTime? userTime = default(System.DateTime?), double? searchBuffer = default(double?), bool? isAsync = default(bool?), string mode = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (deviceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "deviceId");
            }
            if (udid == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "udid");
            }
            if (searchBuffer > 500)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "searchBuffer", 500);
            }
            if (searchBuffer < 0)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "searchBuffer", 0);
            }
            string apiVersion = "1.0";
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("deviceId", deviceId);
                tracingParameters.Add("udid", udid);
                tracingParameters.Add("latitude", latitude);
                tracingParameters.Add("longitude", longitude);
                tracingParameters.Add("z", z);
                tracingParameters.Add("userTime", userTime);
                tracingParameters.Add("searchBuffer", searchBuffer);
                tracingParameters.Add("isAsync", isAsync);
                tracingParameters.Add("mode", mode);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetGeofence", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "spatial/geofence/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (deviceId != null)
            {
                _queryParameters.Add(string.Format("deviceId={0}", System.Uri.EscapeDataString(deviceId)));
            }
            if (udid != null)
            {
                _queryParameters.Add(string.Format("udid={0}", System.Uri.EscapeDataString(udid)));
            }
            _queryParameters.Add(string.Format("lat={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(latitude, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("lon={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(longitude, Client.SerializationSettings).Trim('"'))));
            if (z != null)
            {
                _queryParameters.Add(string.Format("z={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(z, Client.SerializationSettings).Trim('"'))));
            }
            if (userTime != null)
            {
                _queryParameters.Add(string.Format("userTime={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(userTime, Client.SerializationSettings).Trim('"'))));
            }
            if (searchBuffer != null)
            {
                _queryParameters.Add(string.Format("searchBuffer={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(searchBuffer, Client.SerializationSettings).Trim('"'))));
            }
            if (isAsync != null)
            {
                _queryParameters.Add(string.Format("isAsync={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(isAsync, Client.SerializationSettings).Trim('"'))));
            }
            if (mode != null)
            {
                _queryParameters.Add(string.Format("mode={0}", System.Uri.EscapeDataString(mode)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GeofenceResponse,SpatialGetGeofenceHeaders>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<GeofenceResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            try
            {
                _result.Headers = _httpResponse.GetHeadersAsJson().ToObject<SpatialGetGeofenceHeaders>(JsonSerializer.Create(Client.DeserializationSettings));
            }
            catch (JsonException ex)
            {
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw new SerializationException("Unable to deserialize the headers.", _httpResponse.GetHeadersAsJson().ToString(), ex);
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Search Geofence Post API**
        /// **Applies to:** S1 Pricing tier.
        /// The Geofence Post API allows you to retrieve the proximity of a coordinate
        /// to a  provided geofence or set of fences. With POST call, you do not have
        /// to upload the fence data in advance, instead you supply the location of the
        /// object you are tracking in query parameters as well as the fence or set of
        /// fences data in post request body. See [Geofencing GeoJSON
        /// data](https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson)
        /// for more details on the geofence data format. The response will contain
        /// information about the distance from the outer edge of the geofence. A
        /// negative value signifies that the  coordinate is inside of the fence while
        /// a positive value means that it is outside of the
        /// fence.&lt;br&gt;&lt;br&gt;This API can be used for a variety of scenarios
        /// that include things like asset  tracking, fleet management, or setting up
        /// alerts for moving objects.
        ///
        /// The API supports [integration with Event
        /// Grid](https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration).
        /// The isAsync parameter is used to enable integration with Event Grid
        /// (disabled by default).
        /// </summary>
        /// <param name='deviceId'>
        /// ID of the device
        /// </param>
        /// <param name='latitude'>
        /// The latitude of the location being passed.  Example: 48.36.
        /// </param>
        /// <param name='longitude'>
        /// The longitude of the location being passed.  Example: -124.63.
        /// </param>
        /// <param name='searchGeofenceRequestBody'>
        /// The geofencing GeoJSON data.
        /// </param>
        /// <param name='z'>
        /// The sea level in meter of the location being passed. If this parameter is
        /// presented, 2D extrusion geofencing is applied. Example: 200.
        /// </param>
        /// <param name='userTime'>
        /// The user request time. If not presented in the request, the default value
        /// is DateTime.UtcNow.
        /// </param>
        /// <param name='searchBuffer'>
        /// The radius of the buffer around the geofence in meters that defines how far
        /// to search inside and outside the border of the fence against the coordinate
        /// that was provided when calculating the result.  The minimum value is 0, and
        /// the maximum is 500.  The default value is 50.
        /// </param>
        /// <param name='isAsync'>
        /// If true, the request will use async event mechanism; if false, the request
        /// will be synchronized and do not trigger any event. The default value is
        /// false.
        /// </param>
        /// <param name='mode'>
        /// Mode of the geofencing async event mechanism. Possible values include:
        /// 'All', 'EnterAndExit'
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GeofenceResponse,SpatialPostGeofenceHeaders>> PostGeofenceWithHttpMessagesAsync(string deviceId, double latitude, double longitude, GeoJsonFeatureCollection searchGeofenceRequestBody, double? z = default(double?), System.DateTime? userTime = default(System.DateTime?), double? searchBuffer = default(double?), bool? isAsync = default(bool?), string mode = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (deviceId == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "deviceId");
            }
            if (searchBuffer > 500)
            {
                throw new ValidationException(ValidationRules.InclusiveMaximum, "searchBuffer", 500);
            }
            if (searchBuffer < 0)
            {
                throw new ValidationException(ValidationRules.InclusiveMinimum, "searchBuffer", 0);
            }
            if (searchGeofenceRequestBody == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "searchGeofenceRequestBody");
            }
            if (searchGeofenceRequestBody != null)
            {
                searchGeofenceRequestBody.Validate();
            }
            string apiVersion = "1.0";
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("deviceId", deviceId);
                tracingParameters.Add("latitude", latitude);
                tracingParameters.Add("longitude", longitude);
                tracingParameters.Add("z", z);
                tracingParameters.Add("userTime", userTime);
                tracingParameters.Add("searchBuffer", searchBuffer);
                tracingParameters.Add("isAsync", isAsync);
                tracingParameters.Add("mode", mode);
                tracingParameters.Add("searchGeofenceRequestBody", searchGeofenceRequestBody);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "PostGeofence", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "spatial/geofence/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (deviceId != null)
            {
                _queryParameters.Add(string.Format("deviceId={0}", System.Uri.EscapeDataString(deviceId)));
            }
            _queryParameters.Add(string.Format("lat={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(latitude, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("lon={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(longitude, Client.SerializationSettings).Trim('"'))));
            if (z != null)
            {
                _queryParameters.Add(string.Format("z={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(z, Client.SerializationSettings).Trim('"'))));
            }
            if (userTime != null)
            {
                _queryParameters.Add(string.Format("userTime={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(userTime, Client.SerializationSettings).Trim('"'))));
            }
            if (searchBuffer != null)
            {
                _queryParameters.Add(string.Format("searchBuffer={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(searchBuffer, Client.SerializationSettings).Trim('"'))));
            }
            if (isAsync != null)
            {
                _queryParameters.Add(string.Format("isAsync={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(isAsync, Client.SerializationSettings).Trim('"'))));
            }
            if (mode != null)
            {
                _queryParameters.Add(string.Format("mode={0}", System.Uri.EscapeDataString(mode)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(searchGeofenceRequestBody != null)
            {
                _requestContent = Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(searchGeofenceRequestBody, Client.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GeofenceResponse,SpatialPostGeofenceHeaders>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<GeofenceResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            try
            {
                _result.Headers = _httpResponse.GetHeadersAsJson().ToObject<SpatialPostGeofenceHeaders>(JsonSerializer.Create(Client.DeserializationSettings));
            }
            catch (JsonException ex)
            {
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw new SerializationException("Unable to deserialize the headers.", _httpResponse.GetHeadersAsJson().ToString(), ex);
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        ///
        /// This API returns a FeatureCollection where each Feature is a buffer around
        /// the corresponding indexed Feature of the input. The buffer could be either
        /// on the outside or the inside of the provided Feature, depending on the
        /// distance provided in the input. There must be either one distance provided
        /// per Feature in the FeatureCollection  input, or if only one distance is
        /// provided, then that distance is applied to every Feature in the collection.
        /// The positive (or negative) buffer of a geometry is defined as the Minkowski
        /// sum (or difference) of the geometry with a circle of radius equal to the
        /// absolute value of the buffer distance. The buffer API always returns a
        /// polygonal result. The negative or zero-distance buffer of lines and points
        /// is always an empty polygon. The input may contain a collection of Point,
        /// MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString.
        /// GeometryCollection will be ignored if provided.
        /// </summary>
        /// <param name='bufferRequestBody'>
        /// The FeatureCollection and the list of distances (one per feature or one for
        /// all features).
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<BufferResponse>> PostBufferWithHttpMessagesAsync(BufferRequestBody bufferRequestBody, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (bufferRequestBody == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "bufferRequestBody");
            }
            if (bufferRequestBody != null)
            {
                bufferRequestBody.Validate();
            }
            string apiVersion = "1.0";
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("bufferRequestBody", bufferRequestBody);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "PostBuffer", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "spatial/buffer/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(bufferRequestBody != null)
            {
                _requestContent = Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(bufferRequestBody, Client.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<BufferResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<BufferResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        ///
        /// This API returns a FeatureCollection where each Feature is a buffer around
        /// the corresponding indexed Feature of the input. The buffer could be either
        /// on the outside or the inside of the provided Feature, depending on the
        /// distance provided in the input. There must be either one distance provided
        /// per Feature in the FeatureCollection  input, or if only one distance is
        /// provided, then that distance is applied to every Feature in the collection.
        /// The positive (or negative) buffer of a geometry is defined as the Minkowski
        /// sum (or difference) of the geometry with a circle of radius equal to the
        /// absolute value of the buffer distance. The buffer API always returns a
        /// polygonal result. The negative or zero-distance buffer of lines and points
        /// is always an empty polygon. The input features are provided by a GeoJSON
        /// file which is uploaded via [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and
        /// referenced by a unique udid. The GeoJSON file may contain a collection of
        /// Point, MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString.
        /// GeometryCollection will be ignored if provided.
        ///
        /// To test this API, you can upload the sample data from [Post Buffer
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postbuffer#examples)
        /// examples(Request Body without distances array) via [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and
        /// replace the [udid] from the [sample request
        /// below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getbuffer#examples)
        /// with the udid returned by Data Upload API.
        /// </summary>
        /// <param name='udid'>
        /// The unique id returned from [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview)
        /// after uploading a valid GeoJSON FeatureCollection object.  Please refer to
        /// [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details.
        /// All the feature's properties should contain `geometryId`, which is used for
        /// identifying the geometry and is case-sensitive.
        /// </param>
        /// <param name='distances'>
        /// The list of distances (one per feature or one for all features), delimited
        /// by semicolons. For example, 12.34;-56.78. Positive distance will generate a
        /// buffer outside of the feature, whereas negative distance will generate a
        /// buffer inside of the feature. If the negative distance larger than the
        /// geometry itself, an empty polygon will be returned.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<BufferResponse>> GetBufferWithHttpMessagesAsync(string udid, string distances, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (udid == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "udid");
            }
            if (distances == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "distances");
            }
            string apiVersion = "1.0";
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("udid", udid);
                tracingParameters.Add("distances", distances);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetBuffer", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "spatial/buffer/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (udid != null)
            {
                _queryParameters.Add(string.Format("udid={0}", System.Uri.EscapeDataString(udid)));
            }
            if (distances != null)
            {
                _queryParameters.Add(string.Format("distances={0}", System.Uri.EscapeDataString(distances)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<BufferResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<BufferResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        ///
        /// This API returns the closest point between a base point and a given set of
        /// target points. The set of target points is provided by user data in post
        /// request body. The user data may only contain a collection of Point
        /// geometry. MultiPoint or other geometries will be ignored if provided. The
        /// algorithm does not take into account routing or traffic. The maximum number
        /// of points accepted is 100,000. Information returned includes closest point
        /// latitude, longitude, and distance in meters from the closest point.
        /// </summary>
        /// <param name='latitude'>
        /// The latitude of the location being passed.  Example: 48.36.
        /// </param>
        /// <param name='longitude'>
        /// The longitude of the location being passed.  Example: -124.63.
        /// </param>
        /// <param name='closestPointRequestBody'>
        /// The FeatureCollection of Point geometries from which closest point to
        /// source point should be determined. All the feature's properties should
        /// contain `geometryId`, which is used for identifying the geometry and is
        /// case-sensitive.
        /// </param>
        /// <param name='numberOfClosestPoints'>
        /// The number of closest points expected from response. Default: 1, minimum: 1
        /// and maximum: 50
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<ClosestPointResponse>> PostClosestPointWithHttpMessagesAsync(double latitude, double longitude, GeoJsonFeatureCollection closestPointRequestBody, int? numberOfClosestPoints = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (closestPointRequestBody == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "closestPointRequestBody");
            }
            if (closestPointRequestBody != null)
            {
                closestPointRequestBody.Validate();
            }
            string apiVersion = "1.0";
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("latitude", latitude);
                tracingParameters.Add("longitude", longitude);
                tracingParameters.Add("numberOfClosestPoints", numberOfClosestPoints);
                tracingParameters.Add("closestPointRequestBody", closestPointRequestBody);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "PostClosestPoint", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "spatial/closestPoint/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            _queryParameters.Add(string.Format("lat={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(latitude, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("lon={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(longitude, Client.SerializationSettings).Trim('"'))));
            if (numberOfClosestPoints != null)
            {
                _queryParameters.Add(string.Format("numberOfClosestPoints={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(numberOfClosestPoints, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(closestPointRequestBody != null)
            {
                _requestContent = Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(closestPointRequestBody, Client.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<ClosestPointResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ClosestPointResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        ///
        /// This API returns the closest point between a base point and a given set of
        /// points in the user uploaded data set identified by udid. The set of target
        /// points is provided by a GeoJSON file which is uploaded via [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and
        /// referenced by a unique udid. The GeoJSON file may only contain a collection
        /// of Point geometry. MultiPoint or other geometries will be ignored if
        /// provided. The maximum number of points accepted is 100,000. The algorithm
        /// does not take into account routing or traffic. Information returned
        /// includes closest point latitude, longitude, and distance in meters from the
        /// closest point.
        ///
        /// To test this API, you can upload the sample data from [Post Closest Point
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postclosestpoint#examples)
        /// examples(Request Body) via [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and
        /// replace the [udid] from the [sample request
        /// below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getclosestpoint#examples)
        /// with the udid returned by Data Upload API.
        /// </summary>
        /// <param name='udid'>
        /// The unique id returned from [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview)
        /// after uploading a valid GeoJSON FeatureCollection object.  Please refer to
        /// [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details.
        /// All the feature's properties should contain `geometryId`, which is used for
        /// identifying the geometry and is case-sensitive.
        /// </param>
        /// <param name='latitude'>
        /// The latitude of the location being passed.  Example: 48.36.
        /// </param>
        /// <param name='longitude'>
        /// The longitude of the location being passed.  Example: -124.63.
        /// </param>
        /// <param name='numberOfClosestPoints'>
        /// The number of closest points expected from response. Default: 1, minimum: 1
        /// and maximum: 50
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<ClosestPointResponse>> GetClosestPointWithHttpMessagesAsync(string udid, double latitude, double longitude, int? numberOfClosestPoints = default(int?), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (udid == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "udid");
            }
            string apiVersion = "1.0";
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("udid", udid);
                tracingParameters.Add("latitude", latitude);
                tracingParameters.Add("longitude", longitude);
                tracingParameters.Add("numberOfClosestPoints", numberOfClosestPoints);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetClosestPoint", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "spatial/closestPoint/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (udid != null)
            {
                _queryParameters.Add(string.Format("udid={0}", System.Uri.EscapeDataString(udid)));
            }
            _queryParameters.Add(string.Format("lat={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(latitude, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("lon={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(longitude, Client.SerializationSettings).Trim('"'))));
            if (numberOfClosestPoints != null)
            {
                _queryParameters.Add(string.Format("numberOfClosestPoints={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(numberOfClosestPoints, Client.SerializationSettings).Trim('"'))));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<ClosestPointResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ClosestPointResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        ///
        /// This API returns a boolean value indicating whether a point is inside a set
        /// of polygons. The user data may contain Polygon and MultiPolygon geometries,
        /// other geometries will be ignored if provided. If the point is inside or on
        /// the boundary of one of these polygons, the value returned is true. In all
        /// other cases, the value returned is false. When the point is inside multiple
        /// polygons, the result will give intersecting geometries section to show all
        /// valid geometries (referenced by geometryId) in user data. The maximum
        /// number of vertices accepted to form a Polygon is 10,000.
        /// </summary>
        /// <param name='latitude'>
        /// The latitude of the location being passed.  Example: 48.36.
        /// </param>
        /// <param name='longitude'>
        /// The longitude of the location being passed.  Example: -124.63.
        /// </param>
        /// <param name='pointInPolygonRequestBody'>
        /// A FeatureCollection with a set of Polygon/MultiPolygon geometries. The
        /// maximum number of vertices accepted to form a Polygon is 10,000. All the
        /// feature's properties should contain `geometryId`, which is used for
        /// identifying the geometry and is case-sensitive.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<PointInPolygonResponse>> PostPointInPolygonWithHttpMessagesAsync(double latitude, double longitude, GeoJsonFeatureCollection pointInPolygonRequestBody, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (pointInPolygonRequestBody == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "pointInPolygonRequestBody");
            }
            if (pointInPolygonRequestBody != null)
            {
                pointInPolygonRequestBody.Validate();
            }
            string apiVersion = "1.0";
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("latitude", latitude);
                tracingParameters.Add("longitude", longitude);
                tracingParameters.Add("pointInPolygonRequestBody", pointInPolygonRequestBody);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "PostPointInPolygon", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "spatial/pointInPolygon/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            _queryParameters.Add(string.Format("lat={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(latitude, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("lon={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(longitude, Client.SerializationSettings).Trim('"'))));
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            if(pointInPolygonRequestBody != null)
            {
                _requestContent = Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(pointInPolygonRequestBody, Client.SerializationSettings);
                _httpRequest.Content = new StringContent(_requestContent, System.Text.Encoding.UTF8);
                _httpRequest.Content.Headers.ContentType =System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json; charset=utf-8");
            }
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<PointInPolygonResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<PointInPolygonResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        ///
        /// This API returns a boolean value indicating whether a point is inside a set
        /// of polygons. The set of polygons is provided by a GeoJSON file which is
        /// uploaded via [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and
        /// referenced by a unique udid. The GeoJSON file may contain Polygon and
        /// MultiPolygon geometries, other geometries will be ignored if provided. If
        /// the point is inside or on the boundary of one of these polygons, the value
        /// returned is true. In all other cases, the value returned is false. When the
        /// point is inside multiple polygons, the result will give intersecting
        /// geometries section to show all valid geometries(referenced by geometryId)
        /// in user data. The maximum number of vertices accepted to form a Polygon is
        /// 10,000.
        ///
        ///
        /// To test this API, you can upload the sample data from [Post Point In
        /// Polygon
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postpointinpolygon#examples)
        /// examples(Request Body) via [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and
        /// replace the [udid] from the [sample request
        /// below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getpointinpolygon#examples)
        /// with the udid returned by Data Upload API.
        /// </summary>
        /// <param name='udid'>
        /// The unique id returned from [Data Upload
        /// API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview)
        /// after uploading a valid GeoJSON FeatureCollection object.  Please refer to
        /// [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details.
        /// All the feature's properties should contain `geometryId`, which is used for
        /// identifying the geometry and is case-sensitive.
        /// </param>
        /// <param name='latitude'>
        /// The latitude of the location being passed.  Example: 48.36.
        /// </param>
        /// <param name='longitude'>
        /// The longitude of the location being passed.  Example: -124.63.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<PointInPolygonResponse>> GetPointInPolygonWithHttpMessagesAsync(string udid, double latitude, double longitude, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (udid == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "udid");
            }
            string apiVersion = "1.0";
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("udid", udid);
                tracingParameters.Add("latitude", latitude);
                tracingParameters.Add("longitude", longitude);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetPointInPolygon", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "spatial/pointInPolygon/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (udid != null)
            {
                _queryParameters.Add(string.Format("udid={0}", System.Uri.EscapeDataString(udid)));
            }
            _queryParameters.Add(string.Format("lat={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(latitude, Client.SerializationSettings).Trim('"'))));
            _queryParameters.Add(string.Format("lon={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(longitude, Client.SerializationSettings).Trim('"'))));
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<PointInPolygonResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<PointInPolygonResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        ///
        /// This API will return the great-circle or shortest distance between two
        /// points on the surface of a sphere, measured along the surface of the
        /// sphere.  This differs from calculating a straight line through the sphere's
        /// interior. This method is helpful for estimating travel distances for
        /// airplanes by calculating the shortest distance between airports.
        /// </summary>
        /// <param name='query'>
        /// The Coordinates through which the distance is calculated, delimited by a
        /// colon. Two coordinates are required.  The first one is the source point
        /// coordinate and the last is the target point coordinate. For example,
        /// 47.622942,122.316456:57.673988,127.121513
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<GreatCircleDistanceResponse>> GetGreatCircleDistanceWithHttpMessagesAsync(string query, Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (query == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "query");
            }
            string apiVersion = "1.0";
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("apiVersion", apiVersion);
                tracingParameters.Add("format", format);
                tracingParameters.Add("query", query);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetGreatCircleDistance", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "spatial/greatCircleDistance/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (apiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(apiVersion)));
            }
            if (query != null)
            {
                _queryParameters.Add(string.Format("query={0}", System.Uri.EscapeDataString(query)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<GreatCircleDistanceResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<GreatCircleDistanceResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
