// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Maps.Creator.Models;

namespace Azure.Maps.Creator
{
    /// <summary>
    /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
    /// 
    /// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. [This](https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps) article introduces concepts and tools that apply to Azure Maps Creator.
    /// 
    ///  This API allows the caller to create a dataset from data that was uploaded to the Azure Maps Data Service and converted using the Azure Maps Conversion Service.
    /// 
    /// You can use this API in a scenario like uploading a DWG zip package for a building, converting the zip package using the Azure Maps Conversion Service, and creating a dataset from the converted zip package. The created dataset can be used to create tilesets using the Azure Maps Tileset Service and can be queried via the Azure Maps WFS Service.
    /// 
    /// ### Submit Create Request
    /// 
    /// To create your dataset, you will use a `POST` request where the `conversionId` query parameter is an ID that represents the converted DWG zip package, the `datasetId` parameter will be the ID of a previously created dataset to append with the current dataset and, optionally, the `description` query parameter will contain a description (if description is not provided a default description will be given).
    /// 
    /// The Create API is a [long-running request](https://aka.ms/am-creator-lrt-v2).
    /// </summary>
    public partial class DatasetCreateOperation : Operation<LongRunningOperationResult>, IOperationSource<LongRunningOperationResult>
    {
        private readonly OperationInternals<LongRunningOperationResult> _operation;

        /// <summary> Initializes a new instance of DatasetCreateOperation for mocking. </summary>
        protected DatasetCreateOperation()
        {
        }

        internal DatasetCreateOperation(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response)
        {
            _operation = new OperationInternals<LongRunningOperationResult>(this, clientDiagnostics, pipeline, request, response, OperationFinalStateVia.Location, "DatasetCreateOperation");
        }

        /// <inheritdoc />
        public override string Id => _operation.Id;

        /// <inheritdoc />
        public override LongRunningOperationResult Value => _operation.Value;

        /// <inheritdoc />
        public override bool HasCompleted => _operation.HasCompleted;

        /// <inheritdoc />
        public override bool HasValue => _operation.HasValue;

        /// <inheritdoc />
        public override Response GetRawResponse() => _operation.GetRawResponse();

        /// <inheritdoc />
        public override Response UpdateStatus(CancellationToken cancellationToken = default) => _operation.UpdateStatus(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default) => _operation.UpdateStatusAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<LongRunningOperationResult>> WaitForCompletionAsync(CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<LongRunningOperationResult>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(pollingInterval, cancellationToken);

        LongRunningOperationResult IOperationSource<LongRunningOperationResult>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            using var document = JsonDocument.Parse(response.ContentStream);
            return LongRunningOperationResult.DeserializeLongRunningOperationResult(document.RootElement);
        }

        async ValueTask<LongRunningOperationResult> IOperationSource<LongRunningOperationResult>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            return LongRunningOperationResult.DeserializeLongRunningOperationResult(document.RootElement);
        }
    }
}
