// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Maps.Creator.Models;

namespace Azure.Maps.Creator
{
    internal partial class SpatialRestClient
    {
        private Geography? geography;
        private string xMsClientId;
        private ClientDiagnostics _clientDiagnostics;
        private HttpPipeline _pipeline;

        /// <summary> Initializes a new instance of SpatialRestClient. </summary>
        /// <param name="clientDiagnostics"> The handler for diagnostic messaging in the client. </param>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="geography"> This parameter specifies where the Azure Maps Creator resource is located.  Valid values are us and eu. </param>
        /// <param name="xMsClientId"> Specifies which account is intended for usage in conjunction with the Azure AD security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Azure AD security in Azure Maps see the following [articles](https://aka.ms/amauthdetails) for guidance. </param>
        public SpatialRestClient(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Geography? geography = default, string xMsClientId = null)
        {
            geography ??= Geography.Us;

            this.geography = geography;
            this.xMsClientId = xMsClientId;
            _clientDiagnostics = clientDiagnostics;
            _pipeline = pipeline;
        }

        internal HttpMessage CreateGetGeofenceRequest(ResponseFormat format, string deviceId, string udid, float latitude, float longitude, float? z, DateTimeOffset? userTime, float? searchBuffer, bool? isAsync, GeofenceMode? mode)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/spatial/geofence/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", "1.0", true);
            uri.AppendQuery("deviceId", deviceId, true);
            uri.AppendQuery("udid", udid, true);
            uri.AppendQuery("lat", latitude, true);
            uri.AppendQuery("lon", longitude, true);
            if (z != null)
            {
                uri.AppendQuery("z", z.Value, true);
            }
            if (userTime != null)
            {
                uri.AppendQuery("userTime", userTime.Value, "O", true);
            }
            if (searchBuffer != null)
            {
                uri.AppendQuery("searchBuffer", searchBuffer.Value, true);
            }
            if (isAsync != null)
            {
                uri.AppendQuery("isAsync", isAsync.Value, true);
            }
            if (mode != null)
            {
                uri.AppendQuery("mode", mode.Value.ToString(), true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Search Geofence Get API**
        /// 
        /// **Applies to:** S1 Pricing tier.
        /// 
        /// The Geofence Get API allows you to retrieve the proximity of a coordinate to a
        /// geofence that has been uploaded to the Data service. You can use the
        /// [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) to upload
        /// a geofence or set of fences. See [Geofencing GeoJSON data](https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson)
        /// for more details on the geofence data format. To query the proximity of a coordinate, you supply the location of the object you are tracking as well
        /// as the ID for the fence or set of fences, and the response will contain information about
        /// the distance from the outer edge of the geofence. A negative value signifies that the
        /// coordinate is inside of the fence while a positive value means that it is outside of the
        /// fence.&lt;br&gt;&lt;br&gt;This API can be used for a variety of scenarios that include things like asset
        /// tracking, fleet management, or setting up alerts for moving objects.
        /// 
        /// The API supports [integration with Event Grid](https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration). The isAsync parameter is used to enable integration with Event Grid (disabled by default).
        /// To test this API, you can upload the sample data from Post Geofence API examples(Request Body) via Data Upload API and replace the [udid] from the sample request below with the udid returned by Data Upload API.
        /// 
        /// 
        /// ### Geofencing InnerError code
        /// 
        /// In geofencing response error contract, `innererror` is  an object containing service specific information about the error. `code` is a property in `innererror` which can map to a specific geofencing error type. The table belows shows the code mapping between all the known client error type to the corresponding geofencing error `message`.
        /// 
        /// innererror.code | error.message
        /// ---------------------------- | --------------------------------------
        /// NullDeviceId  | Device Id should not be null.
        /// NullUdid	  | Udid should not be null.
        /// UdidWrongFormat| Udid should be acquired from user data ingestion API.
        /// InvalidUserTime| Usertime is invalid.
        /// InvalidSearchBuffer| Searchbuffer is invalid.
        /// InvalidSearchRange| The value range of searchbuffer should be from 0 to 500 meters.
        /// InvalidLatLon| Lat and/or lon parameters are invalid.
        /// InvalidIsAsyncValue| The IsAsync parameter is invalid.
        /// InvalidModeValue| The mode parameter invalid.
        /// InvalidJson| Geofencing data is not a valid json file.
        /// NotSupportedGeoJson| Geofencing data can&apos;t be read as a Feature or FeatureCollections.
        /// InvalidGeoJson| Geofencing data is invalid.
        /// NoUserDataWithAccountOrSubscription| Can&apos;t find user geofencing data with provided account-id and/or subscription-id.
        /// NoUserDataWithUdid|	Can&apos;t find user geofencing data with provided udid.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="deviceId"> ID of the device. </param>
        /// <param name="udid"> The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature&apos;s  properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="z"> The sea level in meter of the location being passed. If this parameter is presented, 2D extrusion is used. Example: 200. </param>
        /// <param name="userTime"> The user request time. If not presented in the request, the default value is DateTime.Now. </param>
        /// <param name="searchBuffer"> The radius of the buffer around the geofence in meters that defines how far to search inside and outside the border of the fence against the coordinate that was provided when calculating the result.  The minimum value is 0, and the maximum is 500.  The default value is 50. </param>
        /// <param name="isAsync"> If true, the request will use async event mechanism; if false, the request will be synchronized and do not trigger any event. The default value is false. </param>
        /// <param name="mode"> Mode of the geofencing async event mechanism. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="udid"/> is null. </exception>
        public async Task<ResponseWithHeaders<GeofenceResponse, SpatialGetGeofenceHeaders>> GetGeofenceAsync(ResponseFormat format, string deviceId, string udid, float latitude, float longitude, float? z = null, DateTimeOffset? userTime = null, float? searchBuffer = null, bool? isAsync = null, GeofenceMode? mode = null, CancellationToken cancellationToken = default)
        {
            if (deviceId == null)
            {
                throw new ArgumentNullException(nameof(deviceId));
            }
            if (udid == null)
            {
                throw new ArgumentNullException(nameof(udid));
            }

            using var message = CreateGetGeofenceRequest(format, deviceId, udid, latitude, longitude, z, userTime, searchBuffer, isAsync, mode);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new SpatialGetGeofenceHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        GeofenceResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = GeofenceResponse.DeserializeGeofenceResponse(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Geofence Get API**
        /// 
        /// **Applies to:** S1 Pricing tier.
        /// 
        /// The Geofence Get API allows you to retrieve the proximity of a coordinate to a
        /// geofence that has been uploaded to the Data service. You can use the
        /// [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) to upload
        /// a geofence or set of fences. See [Geofencing GeoJSON data](https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson)
        /// for more details on the geofence data format. To query the proximity of a coordinate, you supply the location of the object you are tracking as well
        /// as the ID for the fence or set of fences, and the response will contain information about
        /// the distance from the outer edge of the geofence. A negative value signifies that the
        /// coordinate is inside of the fence while a positive value means that it is outside of the
        /// fence.&lt;br&gt;&lt;br&gt;This API can be used for a variety of scenarios that include things like asset
        /// tracking, fleet management, or setting up alerts for moving objects.
        /// 
        /// The API supports [integration with Event Grid](https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration). The isAsync parameter is used to enable integration with Event Grid (disabled by default).
        /// To test this API, you can upload the sample data from Post Geofence API examples(Request Body) via Data Upload API and replace the [udid] from the sample request below with the udid returned by Data Upload API.
        /// 
        /// 
        /// ### Geofencing InnerError code
        /// 
        /// In geofencing response error contract, `innererror` is  an object containing service specific information about the error. `code` is a property in `innererror` which can map to a specific geofencing error type. The table belows shows the code mapping between all the known client error type to the corresponding geofencing error `message`.
        /// 
        /// innererror.code | error.message
        /// ---------------------------- | --------------------------------------
        /// NullDeviceId  | Device Id should not be null.
        /// NullUdid	  | Udid should not be null.
        /// UdidWrongFormat| Udid should be acquired from user data ingestion API.
        /// InvalidUserTime| Usertime is invalid.
        /// InvalidSearchBuffer| Searchbuffer is invalid.
        /// InvalidSearchRange| The value range of searchbuffer should be from 0 to 500 meters.
        /// InvalidLatLon| Lat and/or lon parameters are invalid.
        /// InvalidIsAsyncValue| The IsAsync parameter is invalid.
        /// InvalidModeValue| The mode parameter invalid.
        /// InvalidJson| Geofencing data is not a valid json file.
        /// NotSupportedGeoJson| Geofencing data can&apos;t be read as a Feature or FeatureCollections.
        /// InvalidGeoJson| Geofencing data is invalid.
        /// NoUserDataWithAccountOrSubscription| Can&apos;t find user geofencing data with provided account-id and/or subscription-id.
        /// NoUserDataWithUdid|	Can&apos;t find user geofencing data with provided udid.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="deviceId"> ID of the device. </param>
        /// <param name="udid"> The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object. Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature&apos;s  properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="z"> The sea level in meter of the location being passed. If this parameter is presented, 2D extrusion is used. Example: 200. </param>
        /// <param name="userTime"> The user request time. If not presented in the request, the default value is DateTime.Now. </param>
        /// <param name="searchBuffer"> The radius of the buffer around the geofence in meters that defines how far to search inside and outside the border of the fence against the coordinate that was provided when calculating the result.  The minimum value is 0, and the maximum is 500.  The default value is 50. </param>
        /// <param name="isAsync"> If true, the request will use async event mechanism; if false, the request will be synchronized and do not trigger any event. The default value is false. </param>
        /// <param name="mode"> Mode of the geofencing async event mechanism. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="udid"/> is null. </exception>
        public ResponseWithHeaders<GeofenceResponse, SpatialGetGeofenceHeaders> GetGeofence(ResponseFormat format, string deviceId, string udid, float latitude, float longitude, float? z = null, DateTimeOffset? userTime = null, float? searchBuffer = null, bool? isAsync = null, GeofenceMode? mode = null, CancellationToken cancellationToken = default)
        {
            if (deviceId == null)
            {
                throw new ArgumentNullException(nameof(deviceId));
            }
            if (udid == null)
            {
                throw new ArgumentNullException(nameof(udid));
            }

            using var message = CreateGetGeofenceRequest(format, deviceId, udid, latitude, longitude, z, userTime, searchBuffer, isAsync, mode);
            _pipeline.Send(message, cancellationToken);
            var headers = new SpatialGetGeofenceHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        GeofenceResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = GeofenceResponse.DeserializeGeofenceResponse(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostGeofenceRequest(ResponseFormat format, string deviceId, float latitude, float longitude, GeoJsonFeatureCollection searchGeofenceRequestBody, float? z, DateTimeOffset? userTime, float? searchBuffer, bool? isAsync, GeofenceMode? mode)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/spatial/geofence/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", "1.0", true);
            uri.AppendQuery("deviceId", deviceId, true);
            uri.AppendQuery("lat", latitude, true);
            uri.AppendQuery("lon", longitude, true);
            if (z != null)
            {
                uri.AppendQuery("z", z.Value, true);
            }
            if (userTime != null)
            {
                uri.AppendQuery("userTime", userTime.Value, "O", true);
            }
            if (searchBuffer != null)
            {
                uri.AppendQuery("searchBuffer", searchBuffer.Value, true);
            }
            if (isAsync != null)
            {
                uri.AppendQuery("isAsync", isAsync.Value, true);
            }
            if (mode != null)
            {
                uri.AppendQuery("mode", mode.Value.ToString(), true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(searchGeofenceRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Search Geofence Post API**
        /// **Applies to:** S1 Pricing tier.
        /// The Geofence Post API allows you to retrieve the proximity of a coordinate to a  provided geofence or set of fences. With POST call, you do not have to upload the fence data in advance, instead you supply the location of the object you are tracking in query parameters as well as the fence or set of fences data in post request body. See [Geofencing GeoJSON data](https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson) for more details on the geofence data format. The response will contain information about the distance from the outer edge of the geofence. A negative value signifies that the  coordinate is inside of the fence while a positive value means that it is outside of the fence.&lt;br&gt;&lt;br&gt;This API can be used for a variety of scenarios that include things like asset  tracking, fleet management, or setting up alerts for moving objects.
        /// 
        /// The API supports [integration with Event Grid](https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration).  The isAsync parameter is used to enable integration with Event Grid (disabled by default).
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="deviceId"> ID of the device. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="searchGeofenceRequestBody"> The geofencing GeoJSON data. </param>
        /// <param name="z"> The sea level in meter of the location being passed. If this parameter is presented, 2D extrusion geofencing is applied. Example: 200. </param>
        /// <param name="userTime"> The user request time. If not presented in the request, the default value is DateTime.UtcNow. </param>
        /// <param name="searchBuffer"> The radius of the buffer around the geofence in meters that defines how far to search inside and outside the border of the fence against the coordinate that was provided when calculating the result.  The minimum value is 0, and the maximum is 500.  The default value is 50. </param>
        /// <param name="isAsync"> If true, the request will use async event mechanism; if false, the request will be synchronized and do not trigger any event. The default value is false. </param>
        /// <param name="mode"> Mode of the geofencing async event mechanism. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="searchGeofenceRequestBody"/> is null. </exception>
        public async Task<ResponseWithHeaders<GeofenceResponse, SpatialPostGeofenceHeaders>> PostGeofenceAsync(ResponseFormat format, string deviceId, float latitude, float longitude, GeoJsonFeatureCollection searchGeofenceRequestBody, float? z = null, DateTimeOffset? userTime = null, float? searchBuffer = null, bool? isAsync = null, GeofenceMode? mode = null, CancellationToken cancellationToken = default)
        {
            if (deviceId == null)
            {
                throw new ArgumentNullException(nameof(deviceId));
            }
            if (searchGeofenceRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchGeofenceRequestBody));
            }

            using var message = CreatePostGeofenceRequest(format, deviceId, latitude, longitude, searchGeofenceRequestBody, z, userTime, searchBuffer, isAsync, mode);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            var headers = new SpatialPostGeofenceHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        GeofenceResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = GeofenceResponse.DeserializeGeofenceResponse(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Search Geofence Post API**
        /// **Applies to:** S1 Pricing tier.
        /// The Geofence Post API allows you to retrieve the proximity of a coordinate to a  provided geofence or set of fences. With POST call, you do not have to upload the fence data in advance, instead you supply the location of the object you are tracking in query parameters as well as the fence or set of fences data in post request body. See [Geofencing GeoJSON data](https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson) for more details on the geofence data format. The response will contain information about the distance from the outer edge of the geofence. A negative value signifies that the  coordinate is inside of the fence while a positive value means that it is outside of the fence.&lt;br&gt;&lt;br&gt;This API can be used for a variety of scenarios that include things like asset  tracking, fleet management, or setting up alerts for moving objects.
        /// 
        /// The API supports [integration with Event Grid](https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration).  The isAsync parameter is used to enable integration with Event Grid (disabled by default).
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="deviceId"> ID of the device. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="searchGeofenceRequestBody"> The geofencing GeoJSON data. </param>
        /// <param name="z"> The sea level in meter of the location being passed. If this parameter is presented, 2D extrusion geofencing is applied. Example: 200. </param>
        /// <param name="userTime"> The user request time. If not presented in the request, the default value is DateTime.UtcNow. </param>
        /// <param name="searchBuffer"> The radius of the buffer around the geofence in meters that defines how far to search inside and outside the border of the fence against the coordinate that was provided when calculating the result.  The minimum value is 0, and the maximum is 500.  The default value is 50. </param>
        /// <param name="isAsync"> If true, the request will use async event mechanism; if false, the request will be synchronized and do not trigger any event. The default value is false. </param>
        /// <param name="mode"> Mode of the geofencing async event mechanism. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="searchGeofenceRequestBody"/> is null. </exception>
        public ResponseWithHeaders<GeofenceResponse, SpatialPostGeofenceHeaders> PostGeofence(ResponseFormat format, string deviceId, float latitude, float longitude, GeoJsonFeatureCollection searchGeofenceRequestBody, float? z = null, DateTimeOffset? userTime = null, float? searchBuffer = null, bool? isAsync = null, GeofenceMode? mode = null, CancellationToken cancellationToken = default)
        {
            if (deviceId == null)
            {
                throw new ArgumentNullException(nameof(deviceId));
            }
            if (searchGeofenceRequestBody == null)
            {
                throw new ArgumentNullException(nameof(searchGeofenceRequestBody));
            }

            using var message = CreatePostGeofenceRequest(format, deviceId, latitude, longitude, searchGeofenceRequestBody, z, userTime, searchBuffer, isAsync, mode);
            _pipeline.Send(message, cancellationToken);
            var headers = new SpatialPostGeofenceHeaders(message.Response);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        GeofenceResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = GeofenceResponse.DeserializeGeofenceResponse(document.RootElement);
                        return ResponseWithHeaders.FromValue(value, headers, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostBufferRequest(ResponseFormat format, BufferRequestBody bufferRequestBody)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/spatial/buffer/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", "1.0", true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(bufferRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns a FeatureCollection where each Feature is a buffer around the corresponding indexed Feature of the input. The buffer could be either on the outside or the inside of the provided Feature, depending on the distance provided in the input. There must be either one distance provided per Feature in the FeatureCollection  input, or if only one distance is provided, then that distance is applied to every Feature in the collection. The positive (or negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry with a circle of radius equal to the absolute value of the buffer distance. The buffer API always returns a polygonal result. The negative or zero-distance buffer of lines and points is always an empty polygon. The input may contain a collection of Point, MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if provided.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="bufferRequestBody"> The FeatureCollection and the list of distances (one per feature or one for all features). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="bufferRequestBody"/> is null. </exception>
        public async Task<Response<BufferResponse>> PostBufferAsync(ResponseFormat format, BufferRequestBody bufferRequestBody, CancellationToken cancellationToken = default)
        {
            if (bufferRequestBody == null)
            {
                throw new ArgumentNullException(nameof(bufferRequestBody));
            }

            using var message = CreatePostBufferRequest(format, bufferRequestBody);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        BufferResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = BufferResponse.DeserializeBufferResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns a FeatureCollection where each Feature is a buffer around the corresponding indexed Feature of the input. The buffer could be either on the outside or the inside of the provided Feature, depending on the distance provided in the input. There must be either one distance provided per Feature in the FeatureCollection  input, or if only one distance is provided, then that distance is applied to every Feature in the collection. The positive (or negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry with a circle of radius equal to the absolute value of the buffer distance. The buffer API always returns a polygonal result. The negative or zero-distance buffer of lines and points is always an empty polygon. The input may contain a collection of Point, MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if provided.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="bufferRequestBody"> The FeatureCollection and the list of distances (one per feature or one for all features). </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="bufferRequestBody"/> is null. </exception>
        public Response<BufferResponse> PostBuffer(ResponseFormat format, BufferRequestBody bufferRequestBody, CancellationToken cancellationToken = default)
        {
            if (bufferRequestBody == null)
            {
                throw new ArgumentNullException(nameof(bufferRequestBody));
            }

            using var message = CreatePostBufferRequest(format, bufferRequestBody);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        BufferResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = BufferResponse.DeserializeBufferResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetBufferRequest(ResponseFormat format, string udid, string distances)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/spatial/buffer/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", "1.0", true);
            uri.AppendQuery("udid", udid, true);
            uri.AppendQuery("distances", distances, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns a FeatureCollection where each Feature is a buffer around the corresponding indexed Feature of the input. The buffer could be either on the outside or the inside of the provided Feature, depending on the distance provided in the input. There must be either one distance provided per Feature in the FeatureCollection  input, or if only one distance is provided, then that distance is applied to every Feature in the collection. The positive (or negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry with a circle of radius equal to the absolute value of the buffer distance. The buffer API always returns a polygonal result. The negative or zero-distance buffer of lines and points is always an empty polygon. The input features are provided by a GeoJSON file which is uploaded via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and referenced by a unique udid. The GeoJSON file may contain a collection of Point, MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if provided.
        /// 
        /// To test this API, you can upload the sample data from [Post Buffer API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postbuffer#examples) examples(Request Body without distances array) via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and replace the [udid] from the [sample request below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getbuffer#examples) with the udid returned by Data Upload API.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="udid"> The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object.  Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="distances"> The list of distances (one per feature or one for all features), delimited by semicolons. For example, 12.34;-56.78. Positive distance will generate a buffer outside of the feature, whereas negative distance will generate a buffer inside of the feature. If the negative distance larger than the geometry itself, an empty polygon will be returned. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="udid"/> or <paramref name="distances"/> is null. </exception>
        public async Task<Response<BufferResponse>> GetBufferAsync(ResponseFormat format, string udid, string distances, CancellationToken cancellationToken = default)
        {
            if (udid == null)
            {
                throw new ArgumentNullException(nameof(udid));
            }
            if (distances == null)
            {
                throw new ArgumentNullException(nameof(distances));
            }

            using var message = CreateGetBufferRequest(format, udid, distances);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        BufferResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = BufferResponse.DeserializeBufferResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns a FeatureCollection where each Feature is a buffer around the corresponding indexed Feature of the input. The buffer could be either on the outside or the inside of the provided Feature, depending on the distance provided in the input. There must be either one distance provided per Feature in the FeatureCollection  input, or if only one distance is provided, then that distance is applied to every Feature in the collection. The positive (or negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry with a circle of radius equal to the absolute value of the buffer distance. The buffer API always returns a polygonal result. The negative or zero-distance buffer of lines and points is always an empty polygon. The input features are provided by a GeoJSON file which is uploaded via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and referenced by a unique udid. The GeoJSON file may contain a collection of Point, MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if provided.
        /// 
        /// To test this API, you can upload the sample data from [Post Buffer API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postbuffer#examples) examples(Request Body without distances array) via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and replace the [udid] from the [sample request below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getbuffer#examples) with the udid returned by Data Upload API.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="udid"> The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object.  Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="distances"> The list of distances (one per feature or one for all features), delimited by semicolons. For example, 12.34;-56.78. Positive distance will generate a buffer outside of the feature, whereas negative distance will generate a buffer inside of the feature. If the negative distance larger than the geometry itself, an empty polygon will be returned. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="udid"/> or <paramref name="distances"/> is null. </exception>
        public Response<BufferResponse> GetBuffer(ResponseFormat format, string udid, string distances, CancellationToken cancellationToken = default)
        {
            if (udid == null)
            {
                throw new ArgumentNullException(nameof(udid));
            }
            if (distances == null)
            {
                throw new ArgumentNullException(nameof(distances));
            }

            using var message = CreateGetBufferRequest(format, udid, distances);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        BufferResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = BufferResponse.DeserializeBufferResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostClosestPointRequest(ResponseFormat format, float latitude, float longitude, GeoJsonFeatureCollection closestPointRequestBody, int? numberOfClosestPoints)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/spatial/closestPoint/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", "1.0", true);
            uri.AppendQuery("lat", latitude, true);
            uri.AppendQuery("lon", longitude, true);
            if (numberOfClosestPoints != null)
            {
                uri.AppendQuery("numberOfClosestPoints", numberOfClosestPoints.Value, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(closestPointRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns the closest point between a base point and a given set of target points. The set of target points is provided by user data in post request body. The user data may only contain a collection of Point geometry. MultiPoint or other geometries will be ignored if provided. The algorithm does not take into account routing or traffic. The maximum number of points accepted is 100,000. Information returned includes closest point latitude, longitude, and distance in meters from the closest point.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="closestPointRequestBody"> The FeatureCollection of Point geometries from which closest point to source point should be determined. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="numberOfClosestPoints"> The number of closest points expected from response. Default: 1, minimum: 1 and maximum: 50. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="closestPointRequestBody"/> is null. </exception>
        public async Task<Response<ClosestPointResponse>> PostClosestPointAsync(ResponseFormat format, float latitude, float longitude, GeoJsonFeatureCollection closestPointRequestBody, int? numberOfClosestPoints = null, CancellationToken cancellationToken = default)
        {
            if (closestPointRequestBody == null)
            {
                throw new ArgumentNullException(nameof(closestPointRequestBody));
            }

            using var message = CreatePostClosestPointRequest(format, latitude, longitude, closestPointRequestBody, numberOfClosestPoints);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ClosestPointResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ClosestPointResponse.DeserializeClosestPointResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns the closest point between a base point and a given set of target points. The set of target points is provided by user data in post request body. The user data may only contain a collection of Point geometry. MultiPoint or other geometries will be ignored if provided. The algorithm does not take into account routing or traffic. The maximum number of points accepted is 100,000. Information returned includes closest point latitude, longitude, and distance in meters from the closest point.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="closestPointRequestBody"> The FeatureCollection of Point geometries from which closest point to source point should be determined. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="numberOfClosestPoints"> The number of closest points expected from response. Default: 1, minimum: 1 and maximum: 50. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="closestPointRequestBody"/> is null. </exception>
        public Response<ClosestPointResponse> PostClosestPoint(ResponseFormat format, float latitude, float longitude, GeoJsonFeatureCollection closestPointRequestBody, int? numberOfClosestPoints = null, CancellationToken cancellationToken = default)
        {
            if (closestPointRequestBody == null)
            {
                throw new ArgumentNullException(nameof(closestPointRequestBody));
            }

            using var message = CreatePostClosestPointRequest(format, latitude, longitude, closestPointRequestBody, numberOfClosestPoints);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ClosestPointResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ClosestPointResponse.DeserializeClosestPointResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetClosestPointRequest(ResponseFormat format, string udid, float latitude, float longitude, int? numberOfClosestPoints)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/spatial/closestPoint/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", "1.0", true);
            uri.AppendQuery("udid", udid, true);
            uri.AppendQuery("lat", latitude, true);
            uri.AppendQuery("lon", longitude, true);
            if (numberOfClosestPoints != null)
            {
                uri.AppendQuery("numberOfClosestPoints", numberOfClosestPoints.Value, true);
            }
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns the closest point between a base point and a given set of points in the user uploaded data set identified by udid. The set of target points is provided by a GeoJSON file which is uploaded via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and referenced by a unique udid. The GeoJSON file may only contain a collection of Point geometry. MultiPoint or other geometries will be ignored if provided. The maximum number of points accepted is 100,000. The algorithm does not take into account routing or traffic. Information returned includes closest point latitude, longitude, and distance in meters from the closest point.
        /// 
        /// To test this API, you can upload the sample data from [Post Closest Point API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postclosestpoint#examples) examples(Request Body) via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and replace the [udid] from the [sample request below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getclosestpoint#examples) with the udid returned by Data Upload API.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="udid"> The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object.  Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="numberOfClosestPoints"> The number of closest points expected from response. Default: 1, minimum: 1 and maximum: 50. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="udid"/> is null. </exception>
        public async Task<Response<ClosestPointResponse>> GetClosestPointAsync(ResponseFormat format, string udid, float latitude, float longitude, int? numberOfClosestPoints = null, CancellationToken cancellationToken = default)
        {
            if (udid == null)
            {
                throw new ArgumentNullException(nameof(udid));
            }

            using var message = CreateGetClosestPointRequest(format, udid, latitude, longitude, numberOfClosestPoints);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ClosestPointResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = ClosestPointResponse.DeserializeClosestPointResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns the closest point between a base point and a given set of points in the user uploaded data set identified by udid. The set of target points is provided by a GeoJSON file which is uploaded via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and referenced by a unique udid. The GeoJSON file may only contain a collection of Point geometry. MultiPoint or other geometries will be ignored if provided. The maximum number of points accepted is 100,000. The algorithm does not take into account routing or traffic. Information returned includes closest point latitude, longitude, and distance in meters from the closest point.
        /// 
        /// To test this API, you can upload the sample data from [Post Closest Point API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postclosestpoint#examples) examples(Request Body) via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and replace the [udid] from the [sample request below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getclosestpoint#examples) with the udid returned by Data Upload API.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="udid"> The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object.  Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="numberOfClosestPoints"> The number of closest points expected from response. Default: 1, minimum: 1 and maximum: 50. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="udid"/> is null. </exception>
        public Response<ClosestPointResponse> GetClosestPoint(ResponseFormat format, string udid, float latitude, float longitude, int? numberOfClosestPoints = null, CancellationToken cancellationToken = default)
        {
            if (udid == null)
            {
                throw new ArgumentNullException(nameof(udid));
            }

            using var message = CreateGetClosestPointRequest(format, udid, latitude, longitude, numberOfClosestPoints);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        ClosestPointResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = ClosestPointResponse.DeserializeClosestPointResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreatePostPointInPolygonRequest(ResponseFormat format, float latitude, float longitude, GeoJsonFeatureCollection pointInPolygonRequestBody)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/spatial/pointInPolygon/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", "1.0", true);
            uri.AppendQuery("lat", latitude, true);
            uri.AppendQuery("lon", longitude, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            var content = new Utf8JsonRequestContent();
            content.JsonWriter.WriteObjectValue(pointInPolygonRequestBody);
            request.Content = content;
            return message;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns a boolean value indicating whether a point is inside a set of polygons. The user data may contain Polygon and MultiPolygon geometries, other geometries will be ignored if provided. If the point is inside or on the boundary of one of these polygons, the value returned is true. In all other cases, the value returned is false. When the point is inside multiple polygons, the result will give intersecting geometries section to show all valid geometries (referenced by geometryId) in user data. The maximum number of vertices accepted to form a Polygon is 10,000.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="pointInPolygonRequestBody"> A FeatureCollection with a set of Polygon/MultiPolygon geometries. The maximum number of vertices accepted to form a Polygon is 10,000. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pointInPolygonRequestBody"/> is null. </exception>
        public async Task<Response<PointInPolygonResponse>> PostPointInPolygonAsync(ResponseFormat format, float latitude, float longitude, GeoJsonFeatureCollection pointInPolygonRequestBody, CancellationToken cancellationToken = default)
        {
            if (pointInPolygonRequestBody == null)
            {
                throw new ArgumentNullException(nameof(pointInPolygonRequestBody));
            }

            using var message = CreatePostPointInPolygonRequest(format, latitude, longitude, pointInPolygonRequestBody);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PointInPolygonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PointInPolygonResponse.DeserializePointInPolygonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns a boolean value indicating whether a point is inside a set of polygons. The user data may contain Polygon and MultiPolygon geometries, other geometries will be ignored if provided. If the point is inside or on the boundary of one of these polygons, the value returned is true. In all other cases, the value returned is false. When the point is inside multiple polygons, the result will give intersecting geometries section to show all valid geometries (referenced by geometryId) in user data. The maximum number of vertices accepted to form a Polygon is 10,000.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="pointInPolygonRequestBody"> A FeatureCollection with a set of Polygon/MultiPolygon geometries. The maximum number of vertices accepted to form a Polygon is 10,000. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="pointInPolygonRequestBody"/> is null. </exception>
        public Response<PointInPolygonResponse> PostPointInPolygon(ResponseFormat format, float latitude, float longitude, GeoJsonFeatureCollection pointInPolygonRequestBody, CancellationToken cancellationToken = default)
        {
            if (pointInPolygonRequestBody == null)
            {
                throw new ArgumentNullException(nameof(pointInPolygonRequestBody));
            }

            using var message = CreatePostPointInPolygonRequest(format, latitude, longitude, pointInPolygonRequestBody);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PointInPolygonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PointInPolygonResponse.DeserializePointInPolygonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetPointInPolygonRequest(ResponseFormat format, string udid, float latitude, float longitude)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/spatial/pointInPolygon/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", "1.0", true);
            uri.AppendQuery("udid", udid, true);
            uri.AppendQuery("lat", latitude, true);
            uri.AppendQuery("lon", longitude, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns a boolean value indicating whether a point is inside a set of polygons. The set of polygons is provided by a GeoJSON file which is uploaded via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and referenced by a unique udid. The GeoJSON file may contain Polygon and MultiPolygon geometries, other geometries will be ignored if provided. If the point is inside or on the boundary of one of these polygons, the value returned is true. In all other cases, the value returned is false. When the point is inside multiple polygons, the result will give intersecting geometries section to show all valid geometries(referenced by geometryId) in user data. The maximum number of vertices accepted to form a Polygon is 10,000.
        /// 
        /// 
        /// To test this API, you can upload the sample data from [Post Point In Polygon API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postpointinpolygon#examples) examples(Request Body) via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and replace the [udid] from the [sample request below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getpointinpolygon#examples) with the udid returned by Data Upload API.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="udid"> The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object.  Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="udid"/> is null. </exception>
        public async Task<Response<PointInPolygonResponse>> GetPointInPolygonAsync(ResponseFormat format, string udid, float latitude, float longitude, CancellationToken cancellationToken = default)
        {
            if (udid == null)
            {
                throw new ArgumentNullException(nameof(udid));
            }

            using var message = CreateGetPointInPolygonRequest(format, udid, latitude, longitude);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PointInPolygonResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = PointInPolygonResponse.DeserializePointInPolygonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API returns a boolean value indicating whether a point is inside a set of polygons. The set of polygons is provided by a GeoJSON file which is uploaded via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and referenced by a unique udid. The GeoJSON file may contain Polygon and MultiPolygon geometries, other geometries will be ignored if provided. If the point is inside or on the boundary of one of these polygons, the value returned is true. In all other cases, the value returned is false. When the point is inside multiple polygons, the result will give intersecting geometries section to show all valid geometries(referenced by geometryId) in user data. The maximum number of vertices accepted to form a Polygon is 10,000.
        /// 
        /// 
        /// To test this API, you can upload the sample data from [Post Point In Polygon API](https://docs.microsoft.com/en-us/rest/api/maps/spatial/postpointinpolygon#examples) examples(Request Body) via [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) and replace the [udid] from the [sample request below](https://docs.microsoft.com/en-us/rest/api/maps/spatial/getpointinpolygon#examples) with the udid returned by Data Upload API.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="udid"> The unique id returned from [Data Upload API](https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview) after uploading a valid GeoJSON FeatureCollection object.  Please refer to [RFC 7946](https://tools.ietf.org/html/rfc7946#section-3.3) for details. All the feature&apos;s properties should contain `geometryId`, which is used for identifying the geometry and is case-sensitive. </param>
        /// <param name="latitude"> The latitude of the location being passed.  Example: 48.36. </param>
        /// <param name="longitude"> The longitude of the location being passed.  Example: -124.63. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="udid"/> is null. </exception>
        public Response<PointInPolygonResponse> GetPointInPolygon(ResponseFormat format, string udid, float latitude, float longitude, CancellationToken cancellationToken = default)
        {
            if (udid == null)
            {
                throw new ArgumentNullException(nameof(udid));
            }

            using var message = CreateGetPointInPolygonRequest(format, udid, latitude, longitude);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        PointInPolygonResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = PointInPolygonResponse.DeserializePointInPolygonResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }

        internal HttpMessage CreateGetGreatCircleDistanceRequest(ResponseFormat format, string query)
        {
            var message = _pipeline.CreateMessage();
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.AppendRaw(geography.Value, true);
            uri.AppendRaw(".atlas.microsoft.com", false);
            uri.AppendPath("/spatial/greatCircleDistance/", false);
            uri.AppendPath(format.ToString(), true);
            uri.AppendQuery("api-version", "1.0", true);
            uri.AppendQuery("query", query, true);
            request.Uri = uri;
            if (xMsClientId != null)
            {
                request.Headers.Add("x-ms-client-id", xMsClientId);
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API will return the great-circle or shortest distance between two points on the surface of a sphere, measured along the surface of the sphere.  This differs from calculating a straight line through the sphere&apos;s interior. This method is helpful for estimating travel distances for airplanes by calculating the shortest distance between airports.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="query"> The Coordinates through which the distance is calculated, delimited by a colon. Two coordinates are required.  The first one is the source point coordinate and the last is the target point coordinate. For example, 47.622942,122.316456:57.673988,127.121513. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public async Task<Response<GreatCircleDistanceResponse>> GetGreatCircleDistanceAsync(ResponseFormat format, string query, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetGreatCircleDistanceRequest(format, query);
            await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(false);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        GreatCircleDistanceResponse value = default;
                        using var document = await JsonDocument.ParseAsync(message.Response.ContentStream, default, cancellationToken).ConfigureAwait(false);
                        value = GreatCircleDistanceResponse.DeserializeGreatCircleDistanceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw await _clientDiagnostics.CreateRequestFailedExceptionAsync(message.Response).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// **Applies to**: S1 pricing tier.
        /// 
        /// This API will return the great-circle or shortest distance between two points on the surface of a sphere, measured along the surface of the sphere.  This differs from calculating a straight line through the sphere&apos;s interior. This method is helpful for estimating travel distances for airplanes by calculating the shortest distance between airports.
        /// </summary>
        /// <param name="format"> Desired format of the response. Only `json` format is supported. </param>
        /// <param name="query"> The Coordinates through which the distance is calculated, delimited by a colon. Two coordinates are required.  The first one is the source point coordinate and the last is the target point coordinate. For example, 47.622942,122.316456:57.673988,127.121513. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="query"/> is null. </exception>
        public Response<GreatCircleDistanceResponse> GetGreatCircleDistance(ResponseFormat format, string query, CancellationToken cancellationToken = default)
        {
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }

            using var message = CreateGetGreatCircleDistanceRequest(format, query);
            _pipeline.Send(message, cancellationToken);
            switch (message.Response.Status)
            {
                case 200:
                    {
                        GreatCircleDistanceResponse value = default;
                        using var document = JsonDocument.Parse(message.Response.ContentStream);
                        value = GreatCircleDistanceResponse.DeserializeGreatCircleDistanceResponse(document.RootElement);
                        return Response.FromValue(value, message.Response);
                    }
                default:
                    throw _clientDiagnostics.CreateRequestFailedException(message.Response);
            }
        }
    }
}
