// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Maps.Creator.Models;

namespace Azure.Maps.Creator
{
    /// <summary>
    /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
    /// 
    /// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. [This](https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps) article introduces concepts and tools that apply to Azure Maps Creator.
    /// 
    /// The Conversion API lets the caller import a set of DWG design files as a zipped [Drawing Package](https://aka.ms/am-drawing-package) into Azure Maps. The [Drawing Package](https://aka.ms/am-drawing-package) should first be uploaded using the [Azure Maps Data Service](https://docs.microsoft.com/rest/api/maps/data). Once uploaded, use the `udid` returned by the [Data Upload API](https://docs.microsoft.com/rest/api/maps/data/uploadpreview) to call this Conversion API.
    /// 
    /// ## Convert DWG package
    /// 
    /// The Conversion API performs a [long-running request](https://aka.ms/am-creator-lrt-v2).
    /// 
    /// ## Debug DWG package issues
    /// 
    /// 
    /// During the Conversion process, if there are any issues with the DWG package [errors and warnings](https://aka.ms/am-conversion-errors) are provided in the response along with a *diagnostic package* to visualize and diagnose these issues. In case any issues are encountered with your DWG package, the Conversion operation status process as detailed [here](https://aka.ms/am-creator-lrt-v2) returns the location of the *diagnostic package* that can be downloaded by the caller to help them visualize and diagnose these issues. The *diagnostic package* location can be found in the properties section of the conversion operation status response and looks like the following:
    /// 
    /// ```json
    /// {
    ///     &quot;properties&quot;: {
    ///         &quot;diagnosticPackageLocation&quot;: &quot;https://us.atlas.microsoft.com/mapdata/{DiagnosticPackageId}?api-version=1.0&quot;
    ///     }
    /// }
    /// ```
    /// 
    /// The *diagnostic package* can be downloaded by executing a `HTTP GET` request on the `diagnosticPackageLocation`.
    /// For more details on how to use the tool to visualize and diagnose all the errors and warnings see [Drawing Error Visualizer](https://aka.ms/am-drawing-errors-visualizer). &lt;br&gt;
    /// 
    /// A conversion operation will be marked as *success* if there are zero or more warnings but will be marked as *failed* if any errors are encountered.
    /// </summary>
    public partial class ConversionConvertOperation : Operation<LongRunningOperationResult>, IOperationSource<LongRunningOperationResult>
    {
        private readonly OperationInternals<LongRunningOperationResult> _operation;

        /// <summary> Initializes a new instance of ConversionConvertOperation for mocking. </summary>
        protected ConversionConvertOperation()
        {
        }

        internal ConversionConvertOperation(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response)
        {
            _operation = new OperationInternals<LongRunningOperationResult>(this, clientDiagnostics, pipeline, request, response, OperationFinalStateVia.Location, "ConversionConvertOperation");
        }

        /// <inheritdoc />
        public override string Id => _operation.Id;

        /// <inheritdoc />
        public override LongRunningOperationResult Value => _operation.Value;

        /// <inheritdoc />
        public override bool HasCompleted => _operation.HasCompleted;

        /// <inheritdoc />
        public override bool HasValue => _operation.HasValue;

        /// <inheritdoc />
        public override Response GetRawResponse() => _operation.GetRawResponse();

        /// <inheritdoc />
        public override Response UpdateStatus(CancellationToken cancellationToken = default) => _operation.UpdateStatus(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default) => _operation.UpdateStatusAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<LongRunningOperationResult>> WaitForCompletionAsync(CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<LongRunningOperationResult>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(pollingInterval, cancellationToken);

        LongRunningOperationResult IOperationSource<LongRunningOperationResult>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            using var document = JsonDocument.Parse(response.ContentStream);
            return LongRunningOperationResult.DeserializeLongRunningOperationResult(document.RootElement);
        }

        async ValueTask<LongRunningOperationResult> IOperationSource<LongRunningOperationResult>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            return LongRunningOperationResult.DeserializeLongRunningOperationResult(document.RootElement);
        }
    }
}
