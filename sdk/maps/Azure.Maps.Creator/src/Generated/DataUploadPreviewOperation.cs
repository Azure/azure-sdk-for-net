// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.Maps.Creator.Models;

namespace Azure.Maps.Creator
{
    /// <summary>
    /// **Applies to:** see pricing [tiers](https://aka.ms/AzureMapsPricingTier).
    /// 
    /// The Data Upload API allows the caller to upload data content to the Azure Maps service.
    /// You can use this API in a scenario like uploading a collection of Geofences in `GeoJSON`
    /// format, for use in our [Azure Maps Geofencing Service](https://docs.microsoft.com/rest/api/maps/spatial).
    /// 
    /// ## Submit Upload Request
    /// 
    /// To upload your content you will use a `POST` request. The request body will contain the data to upload. The
    /// `dataFormat` query parameter will contain the format for the data, the `dataSharingLevel` query parameter
    /// can contain the sharing level for the data. The `Content-Type` header will be set to the content type of the
    /// data.
    /// 
    /// For example, to upload a collection of geofences  in `GeoJSON` format, set the request body to the geofence
    /// content. Set the `dataFormat` query parameter to _geojson_, and set the `Content-Type` header to either one
    /// of the following media types:
    /// 
    /// - `application/json`
    /// - `application/vnd.geo+json`
    /// - `application/octet-stream`
    /// 
    /// Here&apos;s a sample request body for uploading a simple Geofence represented as a circle geometry using a center
    /// point and a radius. The sample below is in `GeoJSON`:
    /// 
    /// ```json
    /// {
    ///     &quot;type&quot;: &quot;FeatureCollection&quot;,
    ///     &quot;features&quot;: [{
    ///         &quot;type&quot;: &quot;Feature&quot;,
    ///         &quot;geometry&quot;: {
    ///             &quot;type&quot;: &quot;Point&quot;,
    ///             &quot;coordinates&quot;: [-122.126986, 47.639754]
    ///         },
    ///         &quot;properties&quot;: {
    ///             &quot;geometryId&quot;: &quot;001&quot;,
    ///             &quot;radius&quot;: 500
    ///         }
    ///     }]
    /// }
    /// ```
    /// 
    /// The Data Upload API performs a
    /// [long-running request](https://aka.ms/am-creator-lrt-v2).
    /// 
    /// ## Data Upload Limits
    /// 
    /// Please, be aware that currently every Azure Maps account has a [data storage limit](https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits).
    /// Once the storage limit is reached, all the new upload API calls will return a `409 Conflict` http error response.
    /// You can always use the [Data Delete API](https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview) to
    /// delete old/unused content and create space for new uploads.
    /// </summary>
    public partial class DataUploadPreviewOperation : Operation<LongRunningOperationResult>, IOperationSource<LongRunningOperationResult>
    {
        private readonly OperationInternals<LongRunningOperationResult> _operation;

        /// <summary> Initializes a new instance of DataUploadPreviewOperation for mocking. </summary>
        protected DataUploadPreviewOperation()
        {
        }

        internal DataUploadPreviewOperation(ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response)
        {
            _operation = new OperationInternals<LongRunningOperationResult>(this, clientDiagnostics, pipeline, request, response, OperationFinalStateVia.Location, "DataUploadPreviewOperation");
        }

        /// <inheritdoc />
        public override string Id => _operation.Id;

        /// <inheritdoc />
        public override LongRunningOperationResult Value => _operation.Value;

        /// <inheritdoc />
        public override bool HasCompleted => _operation.HasCompleted;

        /// <inheritdoc />
        public override bool HasValue => _operation.HasValue;

        /// <inheritdoc />
        public override Response GetRawResponse() => _operation.GetRawResponse();

        /// <inheritdoc />
        public override Response UpdateStatus(CancellationToken cancellationToken = default) => _operation.UpdateStatus(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default) => _operation.UpdateStatusAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<LongRunningOperationResult>> WaitForCompletionAsync(CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(cancellationToken);

        /// <inheritdoc />
        public override ValueTask<Response<LongRunningOperationResult>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default) => _operation.WaitForCompletionAsync(pollingInterval, cancellationToken);

        LongRunningOperationResult IOperationSource<LongRunningOperationResult>.CreateResult(Response response, CancellationToken cancellationToken)
        {
            using var document = JsonDocument.Parse(response.ContentStream);
            return LongRunningOperationResult.DeserializeLongRunningOperationResult(document.RootElement);
        }

        async ValueTask<LongRunningOperationResult> IOperationSource<LongRunningOperationResult>.CreateResultAsync(Response response, CancellationToken cancellationToken)
        {
            using var document = await JsonDocument.ParseAsync(response.ContentStream, default, cancellationToken).ConfigureAwait(false);
            return LongRunningOperationResult.DeserializeLongRunningOperationResult(document.RootElement);
        }
    }
}
