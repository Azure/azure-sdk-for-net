// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading.Tasks;
using Autorest.CSharp.Core;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace StreamAnalyticsManagementClient
{
    // Data plane generated client.
    /// <summary> The Outputs service client. </summary>
    public partial class OutputsClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "user_impersonation" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _subscriptionId;
        private readonly Uri _endpoint;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of OutputsClient for mocking. </summary>
        protected OutputsClient()
        {
        }

        /// <summary> Initializes a new instance of OutputsClient. </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public OutputsClient(string subscriptionId, TokenCredential credential) : this(new Uri("https://management.azure.com"), subscriptionId, credential, new StreamAnalyticsManagementClientOptions())
        {
        }

        /// <summary> Initializes a new instance of OutputsClient. </summary>
        /// <param name="endpoint"> server parameter. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/>, <paramref name="subscriptionId"/> or <paramref name="credential"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="subscriptionId"/> is an empty string, and was expected to be non-empty. </exception>
        public OutputsClient(Uri endpoint, string subscriptionId, TokenCredential credential, StreamAnalyticsManagementClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNullOrEmpty(subscriptionId, nameof(subscriptionId));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new StreamAnalyticsManagementClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _subscriptionId = subscriptionId;
            _endpoint = endpoint;
        }

        /// <summary>
        /// [Protocol Method] Creates an output or replaces an already existing output under an existing streaming job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/>, <paramref name="outputName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='CreateOrReplaceAsync(string,string,string,RequestContent,MatchConditions,RequestContext)']/*" />
        public virtual async Task<Response> CreateOrReplaceAsync(string resourceGroupName, string jobName, string outputName, RequestContent content, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.CreateOrReplace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceRequest(resourceGroupName, jobName, outputName, content, matchConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates an output or replaces an already existing output under an existing streaming job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="matchConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/>, <paramref name="outputName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='CreateOrReplace(string,string,string,RequestContent,MatchConditions,RequestContext)']/*" />
        public virtual Response CreateOrReplace(string resourceGroupName, string jobName, string outputName, RequestContent content, MatchConditions matchConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.CreateOrReplace");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrReplaceRequest(resourceGroupName, jobName, outputName, content, matchConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ifMatch"> The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwriting concurrent changes. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/>, <paramref name="outputName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='UpdateAsync(string,string,string,RequestContent,ETag?,RequestContext)']/*" />
        public virtual async Task<Response> UpdateAsync(string resourceGroupName, string jobName, string outputName, RequestContent content, ETag? ifMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(resourceGroupName, jobName, outputName, content, ifMatch, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates an existing output under an existing streaming job. This can be used to partially update (ie. update one or two properties) an output without affecting the rest the job or output definition.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="ifMatch"> The ETag of the output. Omit this value to always overwrite the current output. Specify the last-seen ETag value to prevent accidentally overwriting concurrent changes. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/>, <paramref name="outputName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='Update(string,string,string,RequestContent,ETag?,RequestContext)']/*" />
        public virtual Response Update(string resourceGroupName, string jobName, string outputName, RequestContent content, ETag? ifMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(resourceGroupName, jobName, outputName, content, ifMatch, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Deletes an output from the streaming job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='DeleteAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> DeleteAsync(string resourceGroupName, string jobName, string outputName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(resourceGroupName, jobName, outputName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Deletes an output from the streaming job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='Delete(string,string,string,RequestContext)']/*" />
        public virtual Response Delete(string resourceGroupName, string jobName, string outputName, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(resourceGroupName, jobName, outputName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets details about the specified output.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='GetOutputAsync(string,string,string,RequestContext)']/*" />
        public virtual async Task<Response> GetOutputAsync(string resourceGroupName, string jobName, string outputName, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.GetOutput");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetOutputRequest(resourceGroupName, jobName, outputName, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets details about the specified output.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='GetOutput(string,string,string,RequestContext)']/*" />
        public virtual Response GetOutput(string resourceGroupName, string jobName, string outputName, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.GetOutput");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetOutputRequest(resourceGroupName, jobName, outputName, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all of the outputs under the specified streaming job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="select"> The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or "*" to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/> or <paramref name="jobName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/> or <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='GetOutputsByStreamingJobAsync(string,string,string,RequestContext)']/*" />
        public virtual AsyncPageable<BinaryData> GetOutputsByStreamingJobAsync(string resourceGroupName, string jobName, string select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetOutputsByStreamingJobRequest(resourceGroupName, jobName, select, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetOutputsByStreamingJobNextPageRequest(nextLink, resourceGroupName, jobName, select, context);
            return GeneratorPageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "OutputsClient.GetOutputsByStreamingJob", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Lists all of the outputs under the specified streaming job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="select"> The $select OData query parameter. This is a comma-separated list of structural properties to include in the response, or "*" to include all properties. By default, all properties are returned except diagnostics. Currently only accepts '*' as a valid value. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/> or <paramref name="jobName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/> or <paramref name="jobName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='GetOutputsByStreamingJob(string,string,string,RequestContext)']/*" />
        public virtual Pageable<BinaryData> GetOutputsByStreamingJob(string resourceGroupName, string jobName, string select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));

            HttpMessage FirstPageRequest(int? pageSizeHint) => CreateGetOutputsByStreamingJobRequest(resourceGroupName, jobName, select, context);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => CreateGetOutputsByStreamingJobNextPageRequest(nextLink, resourceGroupName, jobName, select, context);
            return GeneratorPageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, e => BinaryData.FromString(e.GetRawText()), ClientDiagnostics, _pipeline, "OutputsClient.GetOutputsByStreamingJob", "value", "nextLink", context);
        }

        /// <summary>
        /// [Protocol Method] Tests whether an output’s datasource is reachable and usable by the Azure Stream Analytics service.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='TestAsync(WaitUntil,string,string,string,RequestContent,RequestContext)']/*" />
        public virtual async Task<Operation<BinaryData>> TestAsync(WaitUntil waitUntil, string resourceGroupName, string jobName, string outputName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.Test");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTestRequest(resourceGroupName, jobName, outputName, content, context);
                return await ProtocolOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "OutputsClient.Test", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Tests whether an output’s datasource is reachable and usable by the Azure Stream Analytics service.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="jobName"> The name of the streaming job. </param>
        /// <param name="outputName"> The name of the output. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="resourceGroupName"/>, <paramref name="jobName"/> or <paramref name="outputName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <include file="Docs/OutputsClient.xml" path="doc/members/member[@name='Test(WaitUntil,string,string,string,RequestContent,RequestContext)']/*" />
        public virtual Operation<BinaryData> Test(WaitUntil waitUntil, string resourceGroupName, string jobName, string outputName, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(resourceGroupName, nameof(resourceGroupName));
            Argument.AssertNotNullOrEmpty(jobName, nameof(jobName));
            Argument.AssertNotNullOrEmpty(outputName, nameof(outputName));

            using var scope = ClientDiagnostics.CreateScope("OutputsClient.Test");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTestRequest(resourceGroupName, jobName, outputName, content, context);
                return ProtocolOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "OutputsClient.Test", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateCreateOrReplaceRequest(string resourceGroupName, string jobName, string outputName, RequestContent content, MatchConditions matchConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourcegroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.StreamAnalytics/streamingjobs/", false);
            uri.AppendPath(jobName, true);
            uri.AppendPath("/outputs/", false);
            uri.AppendPath(outputName, true);
            uri.AppendQuery("api-version", "2021-10-01-preview", true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (matchConditions != null)
            {
                request.Headers.Add(matchConditions);
            }
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateUpdateRequest(string resourceGroupName, string jobName, string outputName, RequestContent content, ETag? ifMatch, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourcegroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.StreamAnalytics/streamingjobs/", false);
            uri.AppendPath(jobName, true);
            uri.AppendPath("/outputs/", false);
            uri.AppendPath(outputName, true);
            uri.AppendQuery("api-version", "2021-10-01-preview", true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ifMatch != null)
            {
                request.Headers.Add("If-Match", ifMatch.Value);
            }
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string resourceGroupName, string jobName, string outputName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourcegroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.StreamAnalytics/streamingjobs/", false);
            uri.AppendPath(jobName, true);
            uri.AppendPath("/outputs/", false);
            uri.AppendPath(outputName, true);
            uri.AppendQuery("api-version", "2021-10-01-preview", true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOutputRequest(string resourceGroupName, string jobName, string outputName, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourcegroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.StreamAnalytics/streamingjobs/", false);
            uri.AppendPath(jobName, true);
            uri.AppendPath("/outputs/", false);
            uri.AppendPath(outputName, true);
            uri.AppendQuery("api-version", "2021-10-01-preview", true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOutputsByStreamingJobRequest(string resourceGroupName, string jobName, string select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourcegroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.StreamAnalytics/streamingjobs/", false);
            uri.AppendPath(jobName, true);
            uri.AppendPath("/outputs", false);
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            uri.AppendQuery("api-version", "2021-10-01-preview", true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateTestRequest(string resourceGroupName, string jobName, string outputName, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/subscriptions/", false);
            uri.AppendPath(_subscriptionId, true);
            uri.AppendPath("/resourcegroups/", false);
            uri.AppendPath(resourceGroupName, true);
            uri.AppendPath("/providers/Microsoft.StreamAnalytics/streamingjobs/", false);
            uri.AppendPath(jobName, true);
            uri.AppendPath("/outputs/", false);
            uri.AppendPath(outputName, true);
            uri.AppendPath("/test", false);
            uri.AppendQuery("api-version", "2021-10-01-preview", true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetOutputsByStreamingJobNextPageRequest(string nextLink, string resourceGroupName, string jobName, string select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200201;
        private static ResponseClassifier ResponseClassifier200201 => _responseClassifier200201 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 201 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier200204;
        private static ResponseClassifier ResponseClassifier200204 => _responseClassifier200204 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 204 });
        private static ResponseClassifier _responseClassifier200202;
        private static ResponseClassifier ResponseClassifier200202 => _responseClassifier200202 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 202 });
    }
}
