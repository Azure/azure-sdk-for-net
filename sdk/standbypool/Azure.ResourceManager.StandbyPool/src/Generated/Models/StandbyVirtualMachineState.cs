// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;
using Azure.ResourceManager.StandbyPool;

namespace Azure.ResourceManager.StandbyPool.Models
{
    /// <summary> State of standby virtual machines. </summary>
    public readonly partial struct StandbyVirtualMachineState : IEquatable<StandbyVirtualMachineState>
    {
        private readonly string _value;
        /// <summary> The virtual machine is up and running. </summary>
        private const string RunningValue = "Running";
        /// <summary> The virtual machine has released the lease on the underlying hardware and is powered off. </summary>
        private const string DeallocatedValue = "Deallocated";
        /// <summary> The virtual machine has released the lease on the underlying hardware and is powered off. Memory contents of the VM are stored in the OS disk.  When started again, applications and processes that were previously running in your VM resume from the state prior to hibernation. </summary>
        private const string HibernatedValue = "Hibernated";

        /// <summary> Initializes a new instance of <see cref="StandbyVirtualMachineState"/>. </summary>
        /// <param name="value"> The value. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public StandbyVirtualMachineState(string value)
        {
            Argument.AssertNotNull(value, nameof(value));

            _value = value;
        }

        /// <summary> The virtual machine is up and running. </summary>
        public static StandbyVirtualMachineState Running { get; } = new StandbyVirtualMachineState(RunningValue);

        /// <summary> The virtual machine has released the lease on the underlying hardware and is powered off. </summary>
        public static StandbyVirtualMachineState Deallocated { get; } = new StandbyVirtualMachineState(DeallocatedValue);

        /// <summary> The virtual machine has released the lease on the underlying hardware and is powered off. Memory contents of the VM are stored in the OS disk.  When started again, applications and processes that were previously running in your VM resume from the state prior to hibernation. </summary>
        public static StandbyVirtualMachineState Hibernated { get; } = new StandbyVirtualMachineState(HibernatedValue);

        /// <summary> Determines if two <see cref="StandbyVirtualMachineState"/> values are the same. </summary>
        /// <param name="left"> The left value to compare. </param>
        /// <param name="right"> The right value to compare. </param>
        public static bool operator ==(StandbyVirtualMachineState left, StandbyVirtualMachineState right) => left.Equals(right);

        /// <summary> Determines if two <see cref="StandbyVirtualMachineState"/> values are not the same. </summary>
        /// <param name="left"> The left value to compare. </param>
        /// <param name="right"> The right value to compare. </param>
        public static bool operator !=(StandbyVirtualMachineState left, StandbyVirtualMachineState right) => !left.Equals(right);

        /// <summary> Converts a string to a <see cref="StandbyVirtualMachineState"/>. </summary>
        /// <param name="value"> The value. </param>
        public static implicit operator StandbyVirtualMachineState(string value) => new StandbyVirtualMachineState(value);

        /// <summary> Converts a string to a <see cref="StandbyVirtualMachineState"/>. </summary>
        /// <param name="value"> The value. </param>
        public static implicit operator StandbyVirtualMachineState?(string value) => value == null ? null : new StandbyVirtualMachineState(value);

        /// <inheritdoc/>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is StandbyVirtualMachineState other && Equals(other);

        /// <inheritdoc/>
        public bool Equals(StandbyVirtualMachineState other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc/>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;

        /// <inheritdoc/>
        public override string ToString() => _value;
    }
}
