// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Azure.ResourceManager;
using Azure.ResourceManager.ManagedNetworkFabric.Models;

namespace Azure.ResourceManager.ManagedNetworkFabric
{
    /// <summary> A class to add extension methods to TenantResource. </summary>
    internal partial class TenantResourceExtensionClient : ArmResource
    {
        private ClientDiagnostics _accessControlListsClientDiagnostics;
        private AccessControlListsRestOperations _accessControlListsRestClient;
        private ClientDiagnostics _internetGatewaysClientDiagnostics;
        private InternetGatewaysRestOperations _internetGatewaysRestClient;
        private ClientDiagnostics _internetGatewayRulesClientDiagnostics;
        private InternetGatewayRulesRestOperations _internetGatewayRulesRestClient;
        private ClientDiagnostics _ipCommunitiesClientDiagnostics;
        private IpCommunitiesRestOperations _ipCommunitiesRestClient;
        private ClientDiagnostics _ipExtendedCommunitiesClientDiagnostics;
        private IpExtendedCommunitiesRestOperations _ipExtendedCommunitiesRestClient;
        private ClientDiagnostics _ipPrefixesClientDiagnostics;
        private IpPrefixesRestOperations _ipPrefixesRestClient;
        private ClientDiagnostics _l2IsolationDomainsClientDiagnostics;
        private L2IsolationDomainsRestOperations _l2IsolationDomainsRestClient;
        private ClientDiagnostics _l3IsolationDomainsClientDiagnostics;
        private L3IsolationDomainsRestOperations _l3IsolationDomainsRestClient;
        private ClientDiagnostics _internalNetworksClientDiagnostics;
        private InternalNetworksRestOperations _internalNetworksRestClient;
        private ClientDiagnostics _externalNetworksClientDiagnostics;
        private ExternalNetworksRestOperations _externalNetworksRestClient;
        private ClientDiagnostics _neighborGroupsClientDiagnostics;
        private NeighborGroupsRestOperations _neighborGroupsRestClient;
        private ClientDiagnostics _networkDeviceSkusClientDiagnostics;
        private NetworkDeviceSkusRestOperations _networkDeviceSkusRestClient;
        private ClientDiagnostics _networkDevicesClientDiagnostics;
        private NetworkDevicesRestOperations _networkDevicesRestClient;
        private ClientDiagnostics _networkInterfacesClientDiagnostics;
        private NetworkInterfacesRestOperations _networkInterfacesRestClient;
        private ClientDiagnostics _networkFabricControllersClientDiagnostics;
        private NetworkFabricControllersRestOperations _networkFabricControllersRestClient;
        private ClientDiagnostics _networkFabricSkusClientDiagnostics;
        private NetworkFabricSkusRestOperations _networkFabricSkusRestClient;
        private ClientDiagnostics _networkFabricsClientDiagnostics;
        private NetworkFabricsRestOperations _networkFabricsRestClient;
        private ClientDiagnostics _networkToNetworkInterconnectsClientDiagnostics;
        private NetworkToNetworkInterconnectsRestOperations _networkToNetworkInterconnectsRestClient;
        private ClientDiagnostics _networkPacketBrokersClientDiagnostics;
        private NetworkPacketBrokersRestOperations _networkPacketBrokersRestClient;
        private ClientDiagnostics _networkRacksClientDiagnostics;
        private NetworkRacksRestOperations _networkRacksRestClient;
        private ClientDiagnostics _networkTapRulesClientDiagnostics;
        private NetworkTapRulesRestOperations _networkTapRulesRestClient;
        private ClientDiagnostics _networkTapsClientDiagnostics;
        private NetworkTapsRestOperations _networkTapsRestClient;
        private ClientDiagnostics _routePoliciesClientDiagnostics;
        private RoutePoliciesRestOperations _routePoliciesRestClient;

        /// <summary> Initializes a new instance of the <see cref="TenantResourceExtensionClient"/> class for mocking. </summary>
        protected TenantResourceExtensionClient()
        {
        }

        /// <summary> Initializes a new instance of the <see cref="TenantResourceExtensionClient"/> class. </summary>
        /// <param name="client"> The client parameters to use in these operations. </param>
        /// <param name="id"> The identifier of the resource that is the target of operations. </param>
        internal TenantResourceExtensionClient(ArmClient client, ResourceIdentifier id) : base(client, id)
        {
        }

        private ClientDiagnostics AccessControlListsClientDiagnostics => _accessControlListsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private AccessControlListsRestOperations AccessControlListsRestClient => _accessControlListsRestClient ??= new AccessControlListsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics InternetGatewaysClientDiagnostics => _internetGatewaysClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private InternetGatewaysRestOperations InternetGatewaysRestClient => _internetGatewaysRestClient ??= new InternetGatewaysRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics InternetGatewayRulesClientDiagnostics => _internetGatewayRulesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private InternetGatewayRulesRestOperations InternetGatewayRulesRestClient => _internetGatewayRulesRestClient ??= new InternetGatewayRulesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics IpCommunitiesClientDiagnostics => _ipCommunitiesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private IpCommunitiesRestOperations IpCommunitiesRestClient => _ipCommunitiesRestClient ??= new IpCommunitiesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics IpExtendedCommunitiesClientDiagnostics => _ipExtendedCommunitiesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private IpExtendedCommunitiesRestOperations IpExtendedCommunitiesRestClient => _ipExtendedCommunitiesRestClient ??= new IpExtendedCommunitiesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics IpPrefixesClientDiagnostics => _ipPrefixesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private IpPrefixesRestOperations IpPrefixesRestClient => _ipPrefixesRestClient ??= new IpPrefixesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics L2IsolationDomainsClientDiagnostics => _l2IsolationDomainsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private L2IsolationDomainsRestOperations L2IsolationDomainsRestClient => _l2IsolationDomainsRestClient ??= new L2IsolationDomainsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics L3IsolationDomainsClientDiagnostics => _l3IsolationDomainsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private L3IsolationDomainsRestOperations L3IsolationDomainsRestClient => _l3IsolationDomainsRestClient ??= new L3IsolationDomainsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics InternalNetworksClientDiagnostics => _internalNetworksClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private InternalNetworksRestOperations InternalNetworksRestClient => _internalNetworksRestClient ??= new InternalNetworksRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics ExternalNetworksClientDiagnostics => _externalNetworksClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private ExternalNetworksRestOperations ExternalNetworksRestClient => _externalNetworksRestClient ??= new ExternalNetworksRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NeighborGroupsClientDiagnostics => _neighborGroupsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NeighborGroupsRestOperations NeighborGroupsRestClient => _neighborGroupsRestClient ??= new NeighborGroupsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkDeviceSkusClientDiagnostics => _networkDeviceSkusClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkDeviceSkusRestOperations NetworkDeviceSkusRestClient => _networkDeviceSkusRestClient ??= new NetworkDeviceSkusRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkDevicesClientDiagnostics => _networkDevicesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkDevicesRestOperations NetworkDevicesRestClient => _networkDevicesRestClient ??= new NetworkDevicesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkInterfacesClientDiagnostics => _networkInterfacesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkInterfacesRestOperations NetworkInterfacesRestClient => _networkInterfacesRestClient ??= new NetworkInterfacesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkFabricControllersClientDiagnostics => _networkFabricControllersClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkFabricControllersRestOperations NetworkFabricControllersRestClient => _networkFabricControllersRestClient ??= new NetworkFabricControllersRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkFabricSkusClientDiagnostics => _networkFabricSkusClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkFabricSkusRestOperations NetworkFabricSkusRestClient => _networkFabricSkusRestClient ??= new NetworkFabricSkusRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkFabricsClientDiagnostics => _networkFabricsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkFabricsRestOperations NetworkFabricsRestClient => _networkFabricsRestClient ??= new NetworkFabricsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkToNetworkInterconnectsClientDiagnostics => _networkToNetworkInterconnectsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkToNetworkInterconnectsRestOperations NetworkToNetworkInterconnectsRestClient => _networkToNetworkInterconnectsRestClient ??= new NetworkToNetworkInterconnectsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkPacketBrokersClientDiagnostics => _networkPacketBrokersClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkPacketBrokersRestOperations NetworkPacketBrokersRestClient => _networkPacketBrokersRestClient ??= new NetworkPacketBrokersRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkRacksClientDiagnostics => _networkRacksClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkRacksRestOperations NetworkRacksRestClient => _networkRacksRestClient ??= new NetworkRacksRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkTapRulesClientDiagnostics => _networkTapRulesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkTapRulesRestOperations NetworkTapRulesRestClient => _networkTapRulesRestClient ??= new NetworkTapRulesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics NetworkTapsClientDiagnostics => _networkTapsClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private NetworkTapsRestOperations NetworkTapsRestClient => _networkTapsRestClient ??= new NetworkTapsRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);
        private ClientDiagnostics RoutePoliciesClientDiagnostics => _routePoliciesClientDiagnostics ??= new ClientDiagnostics("Azure.ResourceManager.ManagedNetworkFabric", ProviderConstants.DefaultProviderNamespace, Diagnostics);
        private RoutePoliciesRestOperations RoutePoliciesRestClient => _routePoliciesRestClient ??= new RoutePoliciesRestOperations(Pipeline, Diagnostics.ApplicationId, Endpoint);

        private string GetApiVersionOrNull(ResourceType resourceType)
        {
            TryGetApiVersion(resourceType, out string apiVersion);
            return apiVersion;
        }

        /// <summary>
        /// Implements Access Control List PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<AccessControlList>> CreateAccessControlListAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, AccessControlList body, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateAccessControlList");
            scope.Start();
            try
            {
                var response = await AccessControlListsRestClient.CreateAsync(subscriptionId, resourceGroupName, accessControlListName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<AccessControlList>(new AccessControlListOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, accessControlListName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Access Control List PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<AccessControlList> CreateAccessControlList(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, AccessControlList body, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateAccessControlList");
            scope.Start();
            try
            {
                var response = AccessControlListsRestClient.Create(subscriptionId, resourceGroupName, accessControlListName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<AccessControlList>(new AccessControlListOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, accessControlListName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Access Control List GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<AccessControlList>> GetAccessControlListAsync(Guid subscriptionId, string resourceGroupName, string accessControlListName, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetAccessControlList");
            scope.Start();
            try
            {
                var response = await AccessControlListsRestClient.GetAsync(subscriptionId, resourceGroupName, accessControlListName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Access Control List GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<AccessControlList> GetAccessControlList(Guid subscriptionId, string resourceGroupName, string accessControlListName, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetAccessControlList");
            scope.Start();
            try
            {
                var response = AccessControlListsRestClient.Get(subscriptionId, resourceGroupName, accessControlListName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Access Control List resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="patch"> Access Control List properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<AccessControlList>> UpdateAccessControlListAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, AccessControlListPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAccessControlList");
            scope.Start();
            try
            {
                var response = await AccessControlListsRestClient.UpdateAsync(subscriptionId, resourceGroupName, accessControlListName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<AccessControlList>(new AccessControlListOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, accessControlListName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Access Control List resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="patch"> Access Control List properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<AccessControlList> UpdateAccessControlList(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, AccessControlListPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAccessControlList");
            scope.Start();
            try
            {
                var response = AccessControlListsRestClient.Update(subscriptionId, resourceGroupName, accessControlListName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<AccessControlList>(new AccessControlListOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, accessControlListName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Access Control List DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteAccessControlListAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteAccessControlList");
            scope.Start();
            try
            {
                var response = await AccessControlListsRestClient.DeleteAsync(subscriptionId, resourceGroupName, accessControlListName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, accessControlListName).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Access Control List DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteAccessControlList(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteAccessControlList");
            scope.Start();
            try
            {
                var response = AccessControlListsRestClient.Delete(subscriptionId, resourceGroupName, accessControlListName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, accessControlListName).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements AccessControlLists list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="AccessControlList" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<AccessControlList> GetAccessControlListsByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => AccessControlListsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => AccessControlListsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, AccessControlList.DeserializeAccessControlList, AccessControlListsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetAccessControlListsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements AccessControlLists list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="AccessControlList" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<AccessControlList> GetAccessControlListsByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => AccessControlListsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => AccessControlListsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, AccessControlList.DeserializeAccessControlList, AccessControlListsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetAccessControlListsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements AccessControlLists list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/accessControlLists</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="AccessControlList" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<AccessControlList> GetAccessControlListsBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => AccessControlListsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => AccessControlListsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, AccessControlList.DeserializeAccessControlList, AccessControlListsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetAccessControlListsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements AccessControlLists list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/accessControlLists</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="AccessControlList" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<AccessControlList> GetAccessControlListsBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => AccessControlListsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => AccessControlListsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, AccessControlList.DeserializeAccessControlList, AccessControlListsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetAccessControlListsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateAdministrativeStateAccessControlListAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateAccessControlList");
            scope.Start();
            try
            {
                var response = await AccessControlListsRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, accessControlListName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, accessControlListName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateAdministrativeStateAccessControlList(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateAccessControlList");
            scope.Start();
            try
            {
                var response = AccessControlListsRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, accessControlListName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, accessControlListName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/resync</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Resync</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> ResyncAccessControlListAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ResyncAccessControlList");
            scope.Start();
            try
            {
                var response = await AccessControlListsRestClient.ResyncAsync(subscriptionId, resourceGroupName, accessControlListName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateResyncRequest(subscriptionId, resourceGroupName, accessControlListName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/resync</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_Resync</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> ResyncAccessControlList(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ResyncAccessControlList");
            scope.Start();
            try
            {
                var response = AccessControlListsRestClient.Resync(subscriptionId, resourceGroupName, accessControlListName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateResyncRequest(subscriptionId, resourceGroupName, accessControlListName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ValidateConfigurationResponse>> ValidateConfigurationAccessControlListAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationAccessControlList");
            scope.Start();
            try
            {
                var response = await AccessControlListsRestClient.ValidateConfigurationAsync(subscriptionId, resourceGroupName, accessControlListName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, accessControlListName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/accessControlLists/{accessControlListName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>AccessControlLists_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="accessControlListName"> Name of the Access Control List. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ValidateConfigurationResponse> ValidateConfigurationAccessControlList(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string accessControlListName, CancellationToken cancellationToken = default)
        {
            using var scope = AccessControlListsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationAccessControlList");
            scope.Start();
            try
            {
                var response = AccessControlListsRestClient.ValidateConfiguration(subscriptionId, resourceGroupName, accessControlListName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), AccessControlListsClientDiagnostics, Pipeline, AccessControlListsRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, accessControlListName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a Network Fabric Service Internet Gateway resource instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayName"> Name of the Internet Gateway. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<InternetGateway>> CreateInternetGatewayAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayName, InternetGateway body, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewaysClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateInternetGateway");
            scope.Start();
            try
            {
                var response = await InternetGatewaysRestClient.CreateAsync(subscriptionId, resourceGroupName, internetGatewayName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<InternetGateway>(new InternetGatewayOperationSource(), InternetGatewaysClientDiagnostics, Pipeline, InternetGatewaysRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, internetGatewayName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a Network Fabric Service Internet Gateway resource instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayName"> Name of the Internet Gateway. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<InternetGateway> CreateInternetGateway(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayName, InternetGateway body, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewaysClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateInternetGateway");
            scope.Start();
            try
            {
                var response = InternetGatewaysRestClient.Create(subscriptionId, resourceGroupName, internetGatewayName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<InternetGateway>(new InternetGatewayOperationSource(), InternetGatewaysClientDiagnostics, Pipeline, InternetGatewaysRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, internetGatewayName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Gateway GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayName"> Name of the Internet Gateway. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<InternetGateway>> GetInternetGatewayAsync(Guid subscriptionId, string resourceGroupName, string internetGatewayName, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewaysClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetInternetGateway");
            scope.Start();
            try
            {
                var response = await InternetGatewaysRestClient.GetAsync(subscriptionId, resourceGroupName, internetGatewayName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Gateway GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayName"> Name of the Internet Gateway. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<InternetGateway> GetInternetGateway(Guid subscriptionId, string resourceGroupName, string internetGatewayName, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewaysClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetInternetGateway");
            scope.Start();
            try
            {
                var response = InternetGatewaysRestClient.Get(subscriptionId, resourceGroupName, internetGatewayName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Execute patch on Network Fabric Service Internet Gateway.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayName"> Name of the Internet Gateway. </param>
        /// <param name="patch"> API to update certain properties of the L2 Isolation Domain resource.. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<InternetGateway>> UpdateInternetGatewayAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayName, InternetGatewayPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewaysClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateInternetGateway");
            scope.Start();
            try
            {
                var response = await InternetGatewaysRestClient.UpdateAsync(subscriptionId, resourceGroupName, internetGatewayName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<InternetGateway>(new InternetGatewayOperationSource(), InternetGatewaysClientDiagnostics, Pipeline, InternetGatewaysRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, internetGatewayName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Execute patch on Network Fabric Service Internet Gateway.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayName"> Name of the Internet Gateway. </param>
        /// <param name="patch"> API to update certain properties of the L2 Isolation Domain resource.. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<InternetGateway> UpdateInternetGateway(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayName, InternetGatewayPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewaysClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateInternetGateway");
            scope.Start();
            try
            {
                var response = InternetGatewaysRestClient.Update(subscriptionId, resourceGroupName, internetGatewayName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<InternetGateway>(new InternetGatewayOperationSource(), InternetGatewaysClientDiagnostics, Pipeline, InternetGatewaysRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, internetGatewayName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Execute a delete on Network Fabric Service Internet Gateway.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayName"> Name of the Internet Gateway. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteInternetGatewayAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayName, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewaysClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteInternetGateway");
            scope.Start();
            try
            {
                var response = await InternetGatewaysRestClient.DeleteAsync(subscriptionId, resourceGroupName, internetGatewayName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(InternetGatewaysClientDiagnostics, Pipeline, InternetGatewaysRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, internetGatewayName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Execute a delete on Network Fabric Service Internet Gateway.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways/{internetGatewayName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayName"> Name of the Internet Gateway. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteInternetGateway(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayName, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewaysClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteInternetGateway");
            scope.Start();
            try
            {
                var response = InternetGatewaysRestClient.Delete(subscriptionId, resourceGroupName, internetGatewayName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(InternetGatewaysClientDiagnostics, Pipeline, InternetGatewaysRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, internetGatewayName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Displays Internet Gateways list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="InternetGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<InternetGateway> GetInternetGatewaysByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternetGatewaysRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternetGatewaysRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, InternetGateway.DeserializeInternetGateway, InternetGatewaysClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternetGatewaysByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays Internet Gateways list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGateways</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="InternetGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<InternetGateway> GetInternetGatewaysByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternetGatewaysRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternetGatewaysRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, InternetGateway.DeserializeInternetGateway, InternetGatewaysClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternetGatewaysByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays Internet Gateways list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/internetGateways</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="InternetGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<InternetGateway> GetInternetGatewaysBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternetGatewaysRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternetGatewaysRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, InternetGateway.DeserializeInternetGateway, InternetGatewaysClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternetGatewaysBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays Internet Gateways list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/internetGateways</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGateways_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="InternetGateway" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<InternetGateway> GetInternetGatewaysBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternetGatewaysRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternetGatewaysRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, InternetGateway.DeserializeInternetGateway, InternetGatewaysClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternetGatewaysBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Creates an Internet Gateway rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayRuleName"> Name of the Internet Gateway rule. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<InternetGatewayRule>> CreateInternetGatewayRuleAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayRuleName, InternetGatewayRule body, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewayRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateInternetGatewayRule");
            scope.Start();
            try
            {
                var response = await InternetGatewayRulesRestClient.CreateAsync(subscriptionId, resourceGroupName, internetGatewayRuleName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<InternetGatewayRule>(new InternetGatewayRuleOperationSource(), InternetGatewayRulesClientDiagnostics, Pipeline, InternetGatewayRulesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, internetGatewayRuleName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates an Internet Gateway rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayRuleName"> Name of the Internet Gateway rule. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<InternetGatewayRule> CreateInternetGatewayRule(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayRuleName, InternetGatewayRule body, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewayRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateInternetGatewayRule");
            scope.Start();
            try
            {
                var response = InternetGatewayRulesRestClient.Create(subscriptionId, resourceGroupName, internetGatewayRuleName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<InternetGatewayRule>(new InternetGatewayRuleOperationSource(), InternetGatewayRulesClientDiagnostics, Pipeline, InternetGatewayRulesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, internetGatewayRuleName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets an Internet Gateway Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayRuleName"> Name of the Internet Gateway rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<InternetGatewayRule>> GetInternetGatewayRuleAsync(Guid subscriptionId, string resourceGroupName, string internetGatewayRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewayRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetInternetGatewayRule");
            scope.Start();
            try
            {
                var response = await InternetGatewayRulesRestClient.GetAsync(subscriptionId, resourceGroupName, internetGatewayRuleName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets an Internet Gateway Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayRuleName"> Name of the Internet Gateway rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<InternetGatewayRule> GetInternetGatewayRule(Guid subscriptionId, string resourceGroupName, string internetGatewayRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewayRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetInternetGatewayRule");
            scope.Start();
            try
            {
                var response = InternetGatewayRulesRestClient.Get(subscriptionId, resourceGroupName, internetGatewayRuleName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Internet Gateway Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayRuleName"> Name of the Internet Gateway rule. </param>
        /// <param name="patch"> Internet Gateway Rule properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<InternetGatewayRule>> UpdateInternetGatewayRuleAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayRuleName, InternetGatewayRulePatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewayRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateInternetGatewayRule");
            scope.Start();
            try
            {
                var response = await InternetGatewayRulesRestClient.UpdateAsync(subscriptionId, resourceGroupName, internetGatewayRuleName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<InternetGatewayRule>(new InternetGatewayRuleOperationSource(), InternetGatewayRulesClientDiagnostics, Pipeline, InternetGatewayRulesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, internetGatewayRuleName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Internet Gateway Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayRuleName"> Name of the Internet Gateway rule. </param>
        /// <param name="patch"> Internet Gateway Rule properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<InternetGatewayRule> UpdateInternetGatewayRule(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayRuleName, InternetGatewayRulePatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewayRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateInternetGatewayRule");
            scope.Start();
            try
            {
                var response = InternetGatewayRulesRestClient.Update(subscriptionId, resourceGroupName, internetGatewayRuleName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<InternetGatewayRule>(new InternetGatewayRuleOperationSource(), InternetGatewayRulesClientDiagnostics, Pipeline, InternetGatewayRulesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, internetGatewayRuleName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Internet Gateway Rules DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayRuleName"> Name of the Internet Gateway rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteInternetGatewayRuleAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewayRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteInternetGatewayRule");
            scope.Start();
            try
            {
                var response = await InternetGatewayRulesRestClient.DeleteAsync(subscriptionId, resourceGroupName, internetGatewayRuleName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(InternetGatewayRulesClientDiagnostics, Pipeline, InternetGatewayRulesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, internetGatewayRuleName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Internet Gateway Rules DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules/{internetGatewayRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="internetGatewayRuleName"> Name of the Internet Gateway rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteInternetGatewayRule(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string internetGatewayRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = InternetGatewayRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteInternetGatewayRule");
            scope.Start();
            try
            {
                var response = InternetGatewayRulesRestClient.Delete(subscriptionId, resourceGroupName, internetGatewayRuleName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(InternetGatewayRulesClientDiagnostics, Pipeline, InternetGatewayRulesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, internetGatewayRuleName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Internet Gateway Rules list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="InternetGatewayRule" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<InternetGatewayRule> GetInternetGatewayRulesByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternetGatewayRulesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternetGatewayRulesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, InternetGatewayRule.DeserializeInternetGatewayRule, InternetGatewayRulesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternetGatewayRulesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements Internet Gateway Rules list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="InternetGatewayRule" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<InternetGatewayRule> GetInternetGatewayRulesByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternetGatewayRulesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternetGatewayRulesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, InternetGatewayRule.DeserializeInternetGatewayRule, InternetGatewayRulesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternetGatewayRulesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all Internet Gateway rules in the given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="InternetGatewayRule" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<InternetGatewayRule> GetInternetGatewayRulesBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternetGatewayRulesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternetGatewayRulesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, InternetGatewayRule.DeserializeInternetGatewayRule, InternetGatewayRulesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternetGatewayRulesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all Internet Gateway rules in the given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/internetGatewayRules</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternetGatewayRules_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="InternetGatewayRule" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<InternetGatewayRule> GetInternetGatewayRulesBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternetGatewayRulesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternetGatewayRulesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, InternetGatewayRule.DeserializeInternetGatewayRule, InternetGatewayRulesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternetGatewayRulesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements an IP Community PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipCommunityName"> Name of the IP Community. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<IPCommunity>> CreateIpCommunityAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipCommunityName, IPCommunity body, CancellationToken cancellationToken = default)
        {
            using var scope = IpCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateIpCommunity");
            scope.Start();
            try
            {
                var response = await IpCommunitiesRestClient.CreateAsync(subscriptionId, resourceGroupName, ipCommunityName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<IPCommunity>(new IPCommunityOperationSource(), IpCommunitiesClientDiagnostics, Pipeline, IpCommunitiesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, ipCommunityName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements an IP Community PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipCommunityName"> Name of the IP Community. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<IPCommunity> CreateIpCommunity(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipCommunityName, IPCommunity body, CancellationToken cancellationToken = default)
        {
            using var scope = IpCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateIpCommunity");
            scope.Start();
            try
            {
                var response = IpCommunitiesRestClient.Create(subscriptionId, resourceGroupName, ipCommunityName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<IPCommunity>(new IPCommunityOperationSource(), IpCommunitiesClientDiagnostics, Pipeline, IpCommunitiesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, ipCommunityName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements an IP Community GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipCommunityName"> Name of the IP Community. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IPCommunity>> GetIpCommunityAsync(Guid subscriptionId, string resourceGroupName, string ipCommunityName, CancellationToken cancellationToken = default)
        {
            using var scope = IpCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetIpCommunity");
            scope.Start();
            try
            {
                var response = await IpCommunitiesRestClient.GetAsync(subscriptionId, resourceGroupName, ipCommunityName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements an IP Community GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipCommunityName"> Name of the IP Community. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IPCommunity> GetIpCommunity(Guid subscriptionId, string resourceGroupName, string ipCommunityName, CancellationToken cancellationToken = default)
        {
            using var scope = IpCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetIpCommunity");
            scope.Start();
            try
            {
                var response = IpCommunitiesRestClient.Get(subscriptionId, resourceGroupName, ipCommunityName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the IP Community resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipCommunityName"> Name of the IP Community. </param>
        /// <param name="patch"> IP Community properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<IPCommunity>> UpdateIpCommunityAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipCommunityName, IPCommunityPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = IpCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateIpCommunity");
            scope.Start();
            try
            {
                var response = await IpCommunitiesRestClient.UpdateAsync(subscriptionId, resourceGroupName, ipCommunityName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<IPCommunity>(new IPCommunityOperationSource(), IpCommunitiesClientDiagnostics, Pipeline, IpCommunitiesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, ipCommunityName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the IP Community resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipCommunityName"> Name of the IP Community. </param>
        /// <param name="patch"> IP Community properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<IPCommunity> UpdateIpCommunity(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipCommunityName, IPCommunityPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = IpCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateIpCommunity");
            scope.Start();
            try
            {
                var response = IpCommunitiesRestClient.Update(subscriptionId, resourceGroupName, ipCommunityName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<IPCommunity>(new IPCommunityOperationSource(), IpCommunitiesClientDiagnostics, Pipeline, IpCommunitiesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, ipCommunityName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Community DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipCommunityName"> Name of the IP Community. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteIpCommunityAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipCommunityName, CancellationToken cancellationToken = default)
        {
            using var scope = IpCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteIpCommunity");
            scope.Start();
            try
            {
                var response = await IpCommunitiesRestClient.DeleteAsync(subscriptionId, resourceGroupName, ipCommunityName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(IpCommunitiesClientDiagnostics, Pipeline, IpCommunitiesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, ipCommunityName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Community DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities/{ipCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipCommunityName"> Name of the IP Community. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteIpCommunity(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipCommunityName, CancellationToken cancellationToken = default)
        {
            using var scope = IpCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteIpCommunity");
            scope.Start();
            try
            {
                var response = IpCommunitiesRestClient.Delete(subscriptionId, resourceGroupName, ipCommunityName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(IpCommunitiesClientDiagnostics, Pipeline, IpCommunitiesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, ipCommunityName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Communities list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IPCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IPCommunity> GetIpCommunitiesByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpCommunitiesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpCommunitiesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, IPCommunity.DeserializeIPCommunity, IpCommunitiesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpCommunitiesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IP Communities list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipCommunities</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IPCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IPCommunity> GetIpCommunitiesByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpCommunitiesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpCommunitiesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, IPCommunity.DeserializeIPCommunity, IpCommunitiesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpCommunitiesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IP Communities list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipCommunities</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IPCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IPCommunity> GetIpCommunitiesBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpCommunitiesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpCommunitiesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, IPCommunity.DeserializeIPCommunity, IpCommunitiesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpCommunitiesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IP Communities list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipCommunities</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpCommunities_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IPCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IPCommunity> GetIpCommunitiesBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpCommunitiesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpCommunitiesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, IPCommunity.DeserializeIPCommunity, IpCommunitiesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpCommunitiesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IP Extended Community PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipExtendedCommunityName"> Name of the IP Extended Community. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<IPExtendedCommunity>> CreateIpExtendedCommunityAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipExtendedCommunityName, IPExtendedCommunity body, CancellationToken cancellationToken = default)
        {
            using var scope = IpExtendedCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateIpExtendedCommunity");
            scope.Start();
            try
            {
                var response = await IpExtendedCommunitiesRestClient.CreateAsync(subscriptionId, resourceGroupName, ipExtendedCommunityName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<IPExtendedCommunity>(new IPExtendedCommunityOperationSource(), IpExtendedCommunitiesClientDiagnostics, Pipeline, IpExtendedCommunitiesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, ipExtendedCommunityName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Extended Community PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipExtendedCommunityName"> Name of the IP Extended Community. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<IPExtendedCommunity> CreateIpExtendedCommunity(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipExtendedCommunityName, IPExtendedCommunity body, CancellationToken cancellationToken = default)
        {
            using var scope = IpExtendedCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateIpExtendedCommunity");
            scope.Start();
            try
            {
                var response = IpExtendedCommunitiesRestClient.Create(subscriptionId, resourceGroupName, ipExtendedCommunityName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<IPExtendedCommunity>(new IPExtendedCommunityOperationSource(), IpExtendedCommunitiesClientDiagnostics, Pipeline, IpExtendedCommunitiesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, ipExtendedCommunityName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Extended Community GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipExtendedCommunityName"> Name of the IP Extended Community. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IPExtendedCommunity>> GetIpExtendedCommunityAsync(Guid subscriptionId, string resourceGroupName, string ipExtendedCommunityName, CancellationToken cancellationToken = default)
        {
            using var scope = IpExtendedCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetIpExtendedCommunity");
            scope.Start();
            try
            {
                var response = await IpExtendedCommunitiesRestClient.GetAsync(subscriptionId, resourceGroupName, ipExtendedCommunityName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Extended Community GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipExtendedCommunityName"> Name of the IP Extended Community. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IPExtendedCommunity> GetIpExtendedCommunity(Guid subscriptionId, string resourceGroupName, string ipExtendedCommunityName, CancellationToken cancellationToken = default)
        {
            using var scope = IpExtendedCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetIpExtendedCommunity");
            scope.Start();
            try
            {
                var response = IpExtendedCommunitiesRestClient.Get(subscriptionId, resourceGroupName, ipExtendedCommunityName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the IP Extended Community resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipExtendedCommunityName"> Name of the IP Extended Community. </param>
        /// <param name="patch"> IP Extended Community properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<IPExtendedCommunity>> UpdateIpExtendedCommunityAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipExtendedCommunityName, IPExtendedCommunityPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = IpExtendedCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateIpExtendedCommunity");
            scope.Start();
            try
            {
                var response = await IpExtendedCommunitiesRestClient.UpdateAsync(subscriptionId, resourceGroupName, ipExtendedCommunityName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<IPExtendedCommunity>(new IPExtendedCommunityOperationSource(), IpExtendedCommunitiesClientDiagnostics, Pipeline, IpExtendedCommunitiesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, ipExtendedCommunityName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the IP Extended Community resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipExtendedCommunityName"> Name of the IP Extended Community. </param>
        /// <param name="patch"> IP Extended Community properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<IPExtendedCommunity> UpdateIpExtendedCommunity(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipExtendedCommunityName, IPExtendedCommunityPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = IpExtendedCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateIpExtendedCommunity");
            scope.Start();
            try
            {
                var response = IpExtendedCommunitiesRestClient.Update(subscriptionId, resourceGroupName, ipExtendedCommunityName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<IPExtendedCommunity>(new IPExtendedCommunityOperationSource(), IpExtendedCommunitiesClientDiagnostics, Pipeline, IpExtendedCommunitiesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, ipExtendedCommunityName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Extended Community DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipExtendedCommunityName"> Name of the IP Extended Community. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteIpExtendedCommunityAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipExtendedCommunityName, CancellationToken cancellationToken = default)
        {
            using var scope = IpExtendedCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteIpExtendedCommunity");
            scope.Start();
            try
            {
                var response = await IpExtendedCommunitiesRestClient.DeleteAsync(subscriptionId, resourceGroupName, ipExtendedCommunityName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(IpExtendedCommunitiesClientDiagnostics, Pipeline, IpExtendedCommunitiesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, ipExtendedCommunityName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Extended Community DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities/{ipExtendedCommunityName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipExtendedCommunityName"> Name of the IP Extended Community. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteIpExtendedCommunity(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipExtendedCommunityName, CancellationToken cancellationToken = default)
        {
            using var scope = IpExtendedCommunitiesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteIpExtendedCommunity");
            scope.Start();
            try
            {
                var response = IpExtendedCommunitiesRestClient.Delete(subscriptionId, resourceGroupName, ipExtendedCommunityName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(IpExtendedCommunitiesClientDiagnostics, Pipeline, IpExtendedCommunitiesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, ipExtendedCommunityName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IpExtendedCommunities list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IPExtendedCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IPExtendedCommunity> GetIpExtendedCommunitiesByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpExtendedCommunitiesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpExtendedCommunitiesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, IPExtendedCommunity.DeserializeIPExtendedCommunity, IpExtendedCommunitiesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpExtendedCommunitiesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IpExtendedCommunities list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IPExtendedCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IPExtendedCommunity> GetIpExtendedCommunitiesByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpExtendedCommunitiesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpExtendedCommunitiesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, IPExtendedCommunity.DeserializeIPExtendedCommunity, IpExtendedCommunitiesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpExtendedCommunitiesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IpExtendedCommunities list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IPExtendedCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IPExtendedCommunity> GetIpExtendedCommunitiesBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpExtendedCommunitiesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpExtendedCommunitiesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, IPExtendedCommunity.DeserializeIPExtendedCommunity, IpExtendedCommunitiesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpExtendedCommunitiesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IpExtendedCommunities list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipExtendedCommunities</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpExtendedCommunities_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IPExtendedCommunity" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IPExtendedCommunity> GetIpExtendedCommunitiesBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpExtendedCommunitiesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpExtendedCommunitiesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, IPExtendedCommunity.DeserializeIPExtendedCommunity, IpExtendedCommunitiesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpExtendedCommunitiesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IP Prefix PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipPrefixName"> Name of the IP Prefix. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<IPPrefix>> CreateIpPrefixAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipPrefixName, IPPrefix body, CancellationToken cancellationToken = default)
        {
            using var scope = IpPrefixesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateIpPrefix");
            scope.Start();
            try
            {
                var response = await IpPrefixesRestClient.CreateAsync(subscriptionId, resourceGroupName, ipPrefixName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<IPPrefix>(new IPPrefixOperationSource(), IpPrefixesClientDiagnostics, Pipeline, IpPrefixesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, ipPrefixName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Prefix PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipPrefixName"> Name of the IP Prefix. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<IPPrefix> CreateIpPrefix(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipPrefixName, IPPrefix body, CancellationToken cancellationToken = default)
        {
            using var scope = IpPrefixesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateIpPrefix");
            scope.Start();
            try
            {
                var response = IpPrefixesRestClient.Create(subscriptionId, resourceGroupName, ipPrefixName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<IPPrefix>(new IPPrefixOperationSource(), IpPrefixesClientDiagnostics, Pipeline, IpPrefixesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, ipPrefixName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Prefix GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipPrefixName"> Name of the IP Prefix. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<IPPrefix>> GetIpPrefixAsync(Guid subscriptionId, string resourceGroupName, string ipPrefixName, CancellationToken cancellationToken = default)
        {
            using var scope = IpPrefixesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetIpPrefix");
            scope.Start();
            try
            {
                var response = await IpPrefixesRestClient.GetAsync(subscriptionId, resourceGroupName, ipPrefixName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Prefix GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipPrefixName"> Name of the IP Prefix. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<IPPrefix> GetIpPrefix(Guid subscriptionId, string resourceGroupName, string ipPrefixName, CancellationToken cancellationToken = default)
        {
            using var scope = IpPrefixesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetIpPrefix");
            scope.Start();
            try
            {
                var response = IpPrefixesRestClient.Get(subscriptionId, resourceGroupName, ipPrefixName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the IP Prefix resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipPrefixName"> Name of the IP Prefix. </param>
        /// <param name="patch"> IP Prefix properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<IPPrefix>> UpdateIpPrefixAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipPrefixName, IPPrefixPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = IpPrefixesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateIpPrefix");
            scope.Start();
            try
            {
                var response = await IpPrefixesRestClient.UpdateAsync(subscriptionId, resourceGroupName, ipPrefixName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<IPPrefix>(new IPPrefixOperationSource(), IpPrefixesClientDiagnostics, Pipeline, IpPrefixesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, ipPrefixName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the IP Prefix resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipPrefixName"> Name of the IP Prefix. </param>
        /// <param name="patch"> IP Prefix properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<IPPrefix> UpdateIpPrefix(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipPrefixName, IPPrefixPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = IpPrefixesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateIpPrefix");
            scope.Start();
            try
            {
                var response = IpPrefixesRestClient.Update(subscriptionId, resourceGroupName, ipPrefixName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<IPPrefix>(new IPPrefixOperationSource(), IpPrefixesClientDiagnostics, Pipeline, IpPrefixesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, ipPrefixName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Prefix DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipPrefixName"> Name of the IP Prefix. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteIpPrefixAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipPrefixName, CancellationToken cancellationToken = default)
        {
            using var scope = IpPrefixesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteIpPrefix");
            scope.Start();
            try
            {
                var response = await IpPrefixesRestClient.DeleteAsync(subscriptionId, resourceGroupName, ipPrefixName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(IpPrefixesClientDiagnostics, Pipeline, IpPrefixesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, ipPrefixName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IP Prefix DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes/{ipPrefixName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="ipPrefixName"> Name of the IP Prefix. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteIpPrefix(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string ipPrefixName, CancellationToken cancellationToken = default)
        {
            using var scope = IpPrefixesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteIpPrefix");
            scope.Start();
            try
            {
                var response = IpPrefixesRestClient.Delete(subscriptionId, resourceGroupName, ipPrefixName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(IpPrefixesClientDiagnostics, Pipeline, IpPrefixesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, ipPrefixName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements IpPrefixes list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IPPrefix" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IPPrefix> GetIpPrefixesByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpPrefixesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpPrefixesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, IPPrefix.DeserializeIPPrefix, IpPrefixesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpPrefixesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IpPrefixes list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IPPrefix" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IPPrefix> GetIpPrefixesByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpPrefixesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpPrefixesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, IPPrefix.DeserializeIPPrefix, IpPrefixesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpPrefixesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IpPrefixes list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="IPPrefix" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<IPPrefix> GetIpPrefixesBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpPrefixesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpPrefixesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, IPPrefix.DeserializeIPPrefix, IpPrefixesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpPrefixesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements IpPrefixes list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/ipPrefixes</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>IpPrefixes_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="IPPrefix" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<IPPrefix> GetIpPrefixesBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => IpPrefixesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => IpPrefixesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, IPPrefix.DeserializeIPPrefix, IpPrefixesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetIpPrefixesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Creates layer 2 network connectivity between compute nodes within a rack and across racks.The configuration is applied on the devices only after the isolation domain is enabled.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<L2IsolationDomain>> CreateL2IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, L2IsolationDomain body, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateL2IsolationDomain");
            scope.Start();
            try
            {
                var response = await L2IsolationDomainsRestClient.CreateAsync(subscriptionId, resourceGroupName, l2IsolationDomainName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<L2IsolationDomain>(new L2IsolationDomainOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, l2IsolationDomainName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates layer 2 network connectivity between compute nodes within a rack and across racks.The configuration is applied on the devices only after the isolation domain is enabled.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<L2IsolationDomain> CreateL2IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, L2IsolationDomain body, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateL2IsolationDomain");
            scope.Start();
            try
            {
                var response = L2IsolationDomainsRestClient.Create(subscriptionId, resourceGroupName, l2IsolationDomainName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<L2IsolationDomain>(new L2IsolationDomainOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, l2IsolationDomainName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements L2 Isolation Domain GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<L2IsolationDomain>> GetL2IsolationDomainAsync(Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetL2IsolationDomain");
            scope.Start();
            try
            {
                var response = await L2IsolationDomainsRestClient.GetAsync(subscriptionId, resourceGroupName, l2IsolationDomainName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements L2 Isolation Domain GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<L2IsolationDomain> GetL2IsolationDomain(Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetL2IsolationDomain");
            scope.Start();
            try
            {
                var response = L2IsolationDomainsRestClient.Get(subscriptionId, resourceGroupName, l2IsolationDomainName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the L2 Isolation Domain resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="patch"> API to update certain properties of the L2 Isolation Domain resource.. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<L2IsolationDomain>> UpdateL2IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, L2IsolationDomainPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateL2IsolationDomain");
            scope.Start();
            try
            {
                var response = await L2IsolationDomainsRestClient.UpdateAsync(subscriptionId, resourceGroupName, l2IsolationDomainName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<L2IsolationDomain>(new L2IsolationDomainOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, l2IsolationDomainName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the L2 Isolation Domain resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="patch"> API to update certain properties of the L2 Isolation Domain resource.. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<L2IsolationDomain> UpdateL2IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, L2IsolationDomainPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateL2IsolationDomain");
            scope.Start();
            try
            {
                var response = L2IsolationDomainsRestClient.Update(subscriptionId, resourceGroupName, l2IsolationDomainName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<L2IsolationDomain>(new L2IsolationDomainOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, l2IsolationDomainName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes layer 2 connectivity between compute nodes by managed by named L2 Isolation name.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteL2IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteL2IsolationDomain");
            scope.Start();
            try
            {
                var response = await L2IsolationDomainsRestClient.DeleteAsync(subscriptionId, resourceGroupName, l2IsolationDomainName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, l2IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes layer 2 connectivity between compute nodes by managed by named L2 Isolation name.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteL2IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteL2IsolationDomain");
            scope.Start();
            try
            {
                var response = L2IsolationDomainsRestClient.Delete(subscriptionId, resourceGroupName, l2IsolationDomainName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, l2IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Enables isolation domain across the fabric or on specified racks.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_updateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForDeviceUpdate>> UpdateAdministrativeStateL2IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateL2IsolationDomain");
            scope.Start();
            try
            {
                var response = await L2IsolationDomainsRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, l2IsolationDomainName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, l2IsolationDomainName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Enables isolation domain across the fabric or on specified racks.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_updateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForDeviceUpdate> UpdateAdministrativeStateL2IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateL2IsolationDomain");
            scope.Start();
            try
            {
                var response = L2IsolationDomainsRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, l2IsolationDomainName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, l2IsolationDomainName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Validates the configuration of the resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ValidateConfigurationResponse>> ValidateConfigurationL2IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationL2IsolationDomain");
            scope.Start();
            try
            {
                var response = await L2IsolationDomainsRestClient.ValidateConfigurationAsync(subscriptionId, resourceGroupName, l2IsolationDomainName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, l2IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Validates the configuration of the resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ValidateConfigurationResponse> ValidateConfigurationL2IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationL2IsolationDomain");
            scope.Start();
            try
            {
                var response = L2IsolationDomainsRestClient.ValidateConfiguration(subscriptionId, resourceGroupName, l2IsolationDomainName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, l2IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Commits the configuration of the given resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/commitConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_CommitConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> CommitConfigurationL2IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CommitConfigurationL2IsolationDomain");
            scope.Start();
            try
            {
                var response = await L2IsolationDomainsRestClient.CommitConfigurationAsync(subscriptionId, resourceGroupName, l2IsolationDomainName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateCommitConfigurationRequest(subscriptionId, resourceGroupName, l2IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Commits the configuration of the given resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains/{l2IsolationDomainName}/commitConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_CommitConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l2IsolationDomainName"> Name of the L2 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> CommitConfigurationL2IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l2IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L2IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CommitConfigurationL2IsolationDomain");
            scope.Start();
            try
            {
                var response = L2IsolationDomainsRestClient.CommitConfiguration(subscriptionId, resourceGroupName, l2IsolationDomainName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), L2IsolationDomainsClientDiagnostics, Pipeline, L2IsolationDomainsRestClient.CreateCommitConfigurationRequest(subscriptionId, resourceGroupName, l2IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Displays L2IsolationDomains list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="L2IsolationDomain" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<L2IsolationDomain> GetL2IsolationDomainsByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => L2IsolationDomainsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => L2IsolationDomainsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, L2IsolationDomain.DeserializeL2IsolationDomain, L2IsolationDomainsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetL2IsolationDomainsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays L2IsolationDomains list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="L2IsolationDomain" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<L2IsolationDomain> GetL2IsolationDomainsByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => L2IsolationDomainsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => L2IsolationDomainsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, L2IsolationDomain.DeserializeL2IsolationDomain, L2IsolationDomainsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetL2IsolationDomainsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays L2IsolationDomains list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="L2IsolationDomain" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<L2IsolationDomain> GetL2IsolationDomainsBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => L2IsolationDomainsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => L2IsolationDomainsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, L2IsolationDomain.DeserializeL2IsolationDomain, L2IsolationDomainsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetL2IsolationDomainsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays L2IsolationDomains list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l2IsolationDomains</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L2IsolationDomains_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="L2IsolationDomain" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<L2IsolationDomain> GetL2IsolationDomainsBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => L2IsolationDomainsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => L2IsolationDomainsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, L2IsolationDomain.DeserializeL2IsolationDomain, L2IsolationDomainsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetL2IsolationDomainsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Create isolation domain resources for layer 3 connectivity between compute nodes and for communication with external services .This configuration is applied on the devices only after the creation of networks is completed and isolation domain is enabled.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<L3IsolationDomain>> CreateL3IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, L3IsolationDomain body, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateL3IsolationDomain");
            scope.Start();
            try
            {
                var response = await L3IsolationDomainsRestClient.CreateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<L3IsolationDomain>(new L3IsolationDomainOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create isolation domain resources for layer 3 connectivity between compute nodes and for communication with external services .This configuration is applied on the devices only after the creation of networks is completed and isolation domain is enabled.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<L3IsolationDomain> CreateL3IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, L3IsolationDomain body, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateL3IsolationDomain");
            scope.Start();
            try
            {
                var response = L3IsolationDomainsRestClient.Create(subscriptionId, resourceGroupName, l3IsolationDomainName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<L3IsolationDomain>(new L3IsolationDomainOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieves details of this L3 Isolation Domain.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<L3IsolationDomain>> GetL3IsolationDomainAsync(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetL3IsolationDomain");
            scope.Start();
            try
            {
                var response = await L3IsolationDomainsRestClient.GetAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieves details of this L3 Isolation Domain.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<L3IsolationDomain> GetL3IsolationDomain(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetL3IsolationDomain");
            scope.Start();
            try
            {
                var response = L3IsolationDomainsRestClient.Get(subscriptionId, resourceGroupName, l3IsolationDomainName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the L3 Isolation Domain resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="patch"> API to update certain properties of the L3 Isolation Domain resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<L3IsolationDomain>> UpdateL3IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, L3IsolationDomainPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateL3IsolationDomain");
            scope.Start();
            try
            {
                var response = await L3IsolationDomainsRestClient.UpdateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<L3IsolationDomain>(new L3IsolationDomainOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the L3 Isolation Domain resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="patch"> API to update certain properties of the L3 Isolation Domain resource. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<L3IsolationDomain> UpdateL3IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, L3IsolationDomainPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateL3IsolationDomain");
            scope.Start();
            try
            {
                var response = L3IsolationDomainsRestClient.Update(subscriptionId, resourceGroupName, l3IsolationDomainName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<L3IsolationDomain>(new L3IsolationDomainOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes layer 3 connectivity between compute nodes by managed by named L3 Isolation name.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteL3IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteL3IsolationDomain");
            scope.Start();
            try
            {
                var response = await L3IsolationDomainsRestClient.DeleteAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, l3IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes layer 3 connectivity between compute nodes by managed by named L3 Isolation name.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteL3IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteL3IsolationDomain");
            scope.Start();
            try
            {
                var response = L3IsolationDomainsRestClient.Delete(subscriptionId, resourceGroupName, l3IsolationDomainName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, l3IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Displays L3IsolationDomains list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="L3IsolationDomain" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<L3IsolationDomain> GetL3IsolationDomainsByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => L3IsolationDomainsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => L3IsolationDomainsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, L3IsolationDomain.DeserializeL3IsolationDomain, L3IsolationDomainsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetL3IsolationDomainsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays L3IsolationDomains list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="L3IsolationDomain" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<L3IsolationDomain> GetL3IsolationDomainsByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => L3IsolationDomainsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => L3IsolationDomainsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, L3IsolationDomain.DeserializeL3IsolationDomain, L3IsolationDomainsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetL3IsolationDomainsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays L3IsolationDomains list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="L3IsolationDomain" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<L3IsolationDomain> GetL3IsolationDomainsBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => L3IsolationDomainsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => L3IsolationDomainsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, L3IsolationDomain.DeserializeL3IsolationDomain, L3IsolationDomainsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetL3IsolationDomainsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays L3IsolationDomains list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="L3IsolationDomain" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<L3IsolationDomain> GetL3IsolationDomainsBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => L3IsolationDomainsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => L3IsolationDomainsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, L3IsolationDomain.DeserializeL3IsolationDomain, L3IsolationDomainsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetL3IsolationDomainsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Enables racks for this Isolation Domain.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_updateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForDeviceUpdate>> UpdateAdministrativeStateL3IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateL3IsolationDomain");
            scope.Start();
            try
            {
                var response = await L3IsolationDomainsRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Enables racks for this Isolation Domain.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_updateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForDeviceUpdate> UpdateAdministrativeStateL3IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateL3IsolationDomain");
            scope.Start();
            try
            {
                var response = L3IsolationDomainsRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, l3IsolationDomainName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Validates the configuration of the resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ValidateConfigurationResponse>> ValidateConfigurationL3IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationL3IsolationDomain");
            scope.Start();
            try
            {
                var response = await L3IsolationDomainsRestClient.ValidateConfigurationAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, l3IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Validates the configuration of the resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ValidateConfigurationResponse> ValidateConfigurationL3IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationL3IsolationDomain");
            scope.Start();
            try
            {
                var response = L3IsolationDomainsRestClient.ValidateConfiguration(subscriptionId, resourceGroupName, l3IsolationDomainName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, l3IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Commits the configuration of the given resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/commitConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_CommitConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> CommitConfigurationL3IsolationDomainAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CommitConfigurationL3IsolationDomain");
            scope.Start();
            try
            {
                var response = await L3IsolationDomainsRestClient.CommitConfigurationAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateCommitConfigurationRequest(subscriptionId, resourceGroupName, l3IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Commits the configuration of the given resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/commitConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>L3IsolationDomains_CommitConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> CommitConfigurationL3IsolationDomain(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            using var scope = L3IsolationDomainsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CommitConfigurationL3IsolationDomain");
            scope.Start();
            try
            {
                var response = L3IsolationDomainsRestClient.CommitConfiguration(subscriptionId, resourceGroupName, l3IsolationDomainName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), L3IsolationDomainsClientDiagnostics, Pipeline, L3IsolationDomainsRestClient.CreateCommitConfigurationRequest(subscriptionId, resourceGroupName, l3IsolationDomainName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates InternalNetwork PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<InternalNetwork>> CreateInternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, InternalNetwork body, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateInternalNetwork");
            scope.Start();
            try
            {
                var response = await InternalNetworksRestClient.CreateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<InternalNetwork>(new InternalNetworkOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates InternalNetwork PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<InternalNetwork> CreateInternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, InternalNetwork body, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateInternalNetwork");
            scope.Start();
            try
            {
                var response = InternalNetworksRestClient.Create(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<InternalNetwork>(new InternalNetworkOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets a InternalNetworks.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<InternalNetwork>> GetInternalNetworkAsync(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetInternalNetwork");
            scope.Start();
            try
            {
                var response = await InternalNetworksRestClient.GetAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets a InternalNetworks.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<InternalNetwork> GetInternalNetwork(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetInternalNetwork");
            scope.Start();
            try
            {
                var response = InternalNetworksRestClient.Get(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates a InternalNetworks.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="patch"> InternalNetwork properties to update. Only annotations are supported. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<InternalNetwork>> UpdateInternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, InternalNetworkPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateInternalNetwork");
            scope.Start();
            try
            {
                var response = await InternalNetworksRestClient.UpdateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<InternalNetwork>(new InternalNetworkOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates a InternalNetworks.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="patch"> InternalNetwork properties to update. Only annotations are supported. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<InternalNetwork> UpdateInternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, InternalNetworkPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateInternalNetwork");
            scope.Start();
            try
            {
                var response = InternalNetworksRestClient.Update(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<InternalNetwork>(new InternalNetworkOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements InternalNetworks DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteInternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteInternalNetwork");
            scope.Start();
            try
            {
                var response = await InternalNetworksRestClient.DeleteAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements InternalNetworks DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteInternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteInternalNetwork");
            scope.Start();
            try
            {
                var response = InternalNetworksRestClient.Delete(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Displays InternalNetworks list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_ListByL3IsolationDomain</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="InternalNetwork" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<InternalNetwork> GetInternalNetworksByL3IsolationDomainAsync(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternalNetworksRestClient.CreateListByL3IsolationDomainRequest(subscriptionId, resourceGroupName, l3IsolationDomainName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternalNetworksRestClient.CreateListByL3IsolationDomainNextPageRequest(nextLink, subscriptionId, resourceGroupName, l3IsolationDomainName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, InternalNetwork.DeserializeInternalNetwork, InternalNetworksClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternalNetworksByL3IsolationDomain", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays InternalNetworks list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_ListByL3IsolationDomain</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="InternalNetwork" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<InternalNetwork> GetInternalNetworksByL3IsolationDomain(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => InternalNetworksRestClient.CreateListByL3IsolationDomainRequest(subscriptionId, resourceGroupName, l3IsolationDomainName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => InternalNetworksRestClient.CreateListByL3IsolationDomainNextPageRequest(nextLink, subscriptionId, resourceGroupName, l3IsolationDomainName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, InternalNetwork.DeserializeInternalNetwork, InternalNetworksClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetInternalNetworksByL3IsolationDomain", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Update Administrative state of  InternalNetworks on resources referred by their resource ids.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateAdministrativeStateInternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateInternalNetwork");
            scope.Start();
            try
            {
                var response = await InternalNetworksRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update Administrative state of  InternalNetworks on resources referred by their resource ids.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateAdministrativeStateInternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateInternalNetwork");
            scope.Start();
            try
            {
                var response = InternalNetworksRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update BGP state for internalNetwork. Allowed only on edge devices.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBgpAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_UpdateBgpAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateBgpAdministrativeStateInternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateBgpAdministrativeStateInternalNetwork");
            scope.Start();
            try
            {
                var response = await InternalNetworksRestClient.UpdateBgpAdministrativeStateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateUpdateBgpAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update BGP state for internalNetwork. Allowed only on edge devices.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateBgpAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_UpdateBgpAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateBgpAdministrativeStateInternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateBgpAdministrativeStateInternalNetwork");
            scope.Start();
            try
            {
                var response = InternalNetworksRestClient.UpdateBgpAdministrativeState(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateUpdateBgpAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update Static Route BFD administrative state for internalNetwork.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_UpdateStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateStaticRouteBfdAdministrativeStateInternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateStaticRouteBfdAdministrativeStateInternalNetwork");
            scope.Start();
            try
            {
                var response = await InternalNetworksRestClient.UpdateStaticRouteBfdAdministrativeStateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateUpdateStaticRouteBfdAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update Static Route BFD administrative state for internalNetwork.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/internalNetworks/{internalNetworkName}/updateStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>InternalNetworks_UpdateStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="internalNetworkName"> Name of the Internal Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateStaticRouteBfdAdministrativeStateInternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string internalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = InternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateStaticRouteBfdAdministrativeStateInternalNetwork");
            scope.Start();
            try
            {
                var response = InternalNetworksRestClient.UpdateStaticRouteBfdAdministrativeState(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), InternalNetworksClientDiagnostics, Pipeline, InternalNetworksRestClient.CreateUpdateStaticRouteBfdAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, internalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates ExternalNetwork PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ExternalNetwork>> CreateExternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, ExternalNetwork body, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateExternalNetwork");
            scope.Start();
            try
            {
                var response = await ExternalNetworksRestClient.CreateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<ExternalNetwork>(new ExternalNetworkOperationSource(), ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates ExternalNetwork PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ExternalNetwork> CreateExternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, ExternalNetwork body, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateExternalNetwork");
            scope.Start();
            try
            {
                var response = ExternalNetworksRestClient.Create(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<ExternalNetwork>(new ExternalNetworkOperationSource(), ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements ExternalNetworks GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<ExternalNetwork>> GetExternalNetworkAsync(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetExternalNetwork");
            scope.Start();
            try
            {
                var response = await ExternalNetworksRestClient.GetAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements ExternalNetworks GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<ExternalNetwork> GetExternalNetwork(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetExternalNetwork");
            scope.Start();
            try
            {
                var response = ExternalNetworksRestClient.Get(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the ExternalNetworks resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="patch"> ExternalNetwork properties to update. Only annotations are supported. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ExternalNetwork>> UpdateExternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, ExternalNetworkPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateExternalNetwork");
            scope.Start();
            try
            {
                var response = await ExternalNetworksRestClient.UpdateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<ExternalNetwork>(new ExternalNetworkOperationSource(), ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the ExternalNetworks resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="patch"> ExternalNetwork properties to update. Only annotations are supported. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ExternalNetwork> UpdateExternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, ExternalNetworkPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateExternalNetwork");
            scope.Start();
            try
            {
                var response = ExternalNetworksRestClient.Update(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<ExternalNetwork>(new ExternalNetworkOperationSource(), ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements ExternalNetworks DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteExternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteExternalNetwork");
            scope.Start();
            try
            {
                var response = await ExternalNetworksRestClient.DeleteAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements ExternalNetworks DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteExternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteExternalNetwork");
            scope.Start();
            try
            {
                var response = ExternalNetworksRestClient.Delete(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements External Networks list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_ListByL3IsolationDomain</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="ExternalNetwork" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<ExternalNetwork> GetExternalNetworksByL3IsolationDomainAsync(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => ExternalNetworksRestClient.CreateListByL3IsolationDomainRequest(subscriptionId, resourceGroupName, l3IsolationDomainName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => ExternalNetworksRestClient.CreateListByL3IsolationDomainNextPageRequest(nextLink, subscriptionId, resourceGroupName, l3IsolationDomainName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, ExternalNetwork.DeserializeExternalNetwork, ExternalNetworksClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetExternalNetworksByL3IsolationDomain", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements External Networks list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_ListByL3IsolationDomain</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="ExternalNetwork" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<ExternalNetwork> GetExternalNetworksByL3IsolationDomain(Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => ExternalNetworksRestClient.CreateListByL3IsolationDomainRequest(subscriptionId, resourceGroupName, l3IsolationDomainName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => ExternalNetworksRestClient.CreateListByL3IsolationDomainNextPageRequest(nextLink, subscriptionId, resourceGroupName, l3IsolationDomainName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, ExternalNetwork.DeserializeExternalNetwork, ExternalNetworksClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetExternalNetworksByL3IsolationDomain", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Executes update operation to enable or disable administrative State for externalNetwork.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateAdministrativeStateExternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateExternalNetwork");
            scope.Start();
            try
            {
                var response = await ExternalNetworksRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Executes update operation to enable or disable administrative State for externalNetwork.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateAdministrativeStateExternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateExternalNetwork");
            scope.Start();
            try
            {
                var response = ExternalNetworksRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update Static Route BFD for external Network.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_UpdateStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateStaticRouteBfdAdministrativeStateExternalNetworkAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateStaticRouteBfdAdministrativeStateExternalNetwork");
            scope.Start();
            try
            {
                var response = await ExternalNetworksRestClient.UpdateStaticRouteBfdAdministrativeStateAsync(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateUpdateStaticRouteBfdAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update Static Route BFD for external Network.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/l3IsolationDomains/{l3IsolationDomainName}/externalNetworks/{externalNetworkName}/updateStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>ExternalNetworks_UpdateStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="l3IsolationDomainName"> Name of the L3 Isolation Domain. </param>
        /// <param name="externalNetworkName"> Name of the External Network. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateStaticRouteBfdAdministrativeStateExternalNetwork(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string l3IsolationDomainName, string externalNetworkName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = ExternalNetworksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateStaticRouteBfdAdministrativeStateExternalNetwork");
            scope.Start();
            try
            {
                var response = ExternalNetworksRestClient.UpdateStaticRouteBfdAdministrativeState(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), ExternalNetworksClientDiagnostics, Pipeline, ExternalNetworksRestClient.CreateUpdateStaticRouteBfdAdministrativeStateRequest(subscriptionId, resourceGroupName, l3IsolationDomainName, externalNetworkName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the Neighbor Group PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups/{neighborGroupName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="neighborGroupName"> Name of the Neighbor Group. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NeighborGroup>> CreateNeighborGroupAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string neighborGroupName, NeighborGroup body, CancellationToken cancellationToken = default)
        {
            using var scope = NeighborGroupsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNeighborGroup");
            scope.Start();
            try
            {
                var response = await NeighborGroupsRestClient.CreateAsync(subscriptionId, resourceGroupName, neighborGroupName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NeighborGroup>(new NeighborGroupOperationSource(), NeighborGroupsClientDiagnostics, Pipeline, NeighborGroupsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, neighborGroupName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the Neighbor Group PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups/{neighborGroupName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="neighborGroupName"> Name of the Neighbor Group. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NeighborGroup> CreateNeighborGroup(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string neighborGroupName, NeighborGroup body, CancellationToken cancellationToken = default)
        {
            using var scope = NeighborGroupsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNeighborGroup");
            scope.Start();
            try
            {
                var response = NeighborGroupsRestClient.Create(subscriptionId, resourceGroupName, neighborGroupName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NeighborGroup>(new NeighborGroupOperationSource(), NeighborGroupsClientDiagnostics, Pipeline, NeighborGroupsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, neighborGroupName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the Neighbor Group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups/{neighborGroupName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="neighborGroupName"> Name of the Neighbor Group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NeighborGroup>> GetNeighborGroupAsync(Guid subscriptionId, string resourceGroupName, string neighborGroupName, CancellationToken cancellationToken = default)
        {
            using var scope = NeighborGroupsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNeighborGroup");
            scope.Start();
            try
            {
                var response = await NeighborGroupsRestClient.GetAsync(subscriptionId, resourceGroupName, neighborGroupName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the Neighbor Group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups/{neighborGroupName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="neighborGroupName"> Name of the Neighbor Group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NeighborGroup> GetNeighborGroup(Guid subscriptionId, string resourceGroupName, string neighborGroupName, CancellationToken cancellationToken = default)
        {
            using var scope = NeighborGroupsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNeighborGroup");
            scope.Start();
            try
            {
                var response = NeighborGroupsRestClient.Get(subscriptionId, resourceGroupName, neighborGroupName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Neighbor Group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups/{neighborGroupName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="neighborGroupName"> Name of the Neighbor Group. </param>
        /// <param name="patch"> Neighbor Group properties to update. Only annotations are supported. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NeighborGroup>> UpdateNeighborGroupAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string neighborGroupName, NeighborGroupPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NeighborGroupsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNeighborGroup");
            scope.Start();
            try
            {
                var response = await NeighborGroupsRestClient.UpdateAsync(subscriptionId, resourceGroupName, neighborGroupName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NeighborGroup>(new NeighborGroupOperationSource(), NeighborGroupsClientDiagnostics, Pipeline, NeighborGroupsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, neighborGroupName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Neighbor Group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups/{neighborGroupName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="neighborGroupName"> Name of the Neighbor Group. </param>
        /// <param name="patch"> Neighbor Group properties to update. Only annotations are supported. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NeighborGroup> UpdateNeighborGroup(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string neighborGroupName, NeighborGroupPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NeighborGroupsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNeighborGroup");
            scope.Start();
            try
            {
                var response = NeighborGroupsRestClient.Update(subscriptionId, resourceGroupName, neighborGroupName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NeighborGroup>(new NeighborGroupOperationSource(), NeighborGroupsClientDiagnostics, Pipeline, NeighborGroupsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, neighborGroupName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Neighbor Group DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups/{neighborGroupName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="neighborGroupName"> Name of the Neighbor Group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNeighborGroupAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string neighborGroupName, CancellationToken cancellationToken = default)
        {
            using var scope = NeighborGroupsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNeighborGroup");
            scope.Start();
            try
            {
                var response = await NeighborGroupsRestClient.DeleteAsync(subscriptionId, resourceGroupName, neighborGroupName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NeighborGroupsClientDiagnostics, Pipeline, NeighborGroupsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, neighborGroupName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Neighbor Group DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups/{neighborGroupName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="neighborGroupName"> Name of the Neighbor Group. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNeighborGroup(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string neighborGroupName, CancellationToken cancellationToken = default)
        {
            using var scope = NeighborGroupsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNeighborGroup");
            scope.Start();
            try
            {
                var response = NeighborGroupsRestClient.Delete(subscriptionId, resourceGroupName, neighborGroupName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NeighborGroupsClientDiagnostics, Pipeline, NeighborGroupsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, neighborGroupName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Displays NeighborGroups list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NeighborGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NeighborGroup> GetNeighborGroupsByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NeighborGroupsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NeighborGroupsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NeighborGroup.DeserializeNeighborGroup, NeighborGroupsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNeighborGroupsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays NeighborGroups list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/neighborGroups</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NeighborGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NeighborGroup> GetNeighborGroupsByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NeighborGroupsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NeighborGroupsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NeighborGroup.DeserializeNeighborGroup, NeighborGroupsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNeighborGroupsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays NeighborGroups list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/neighborGroups</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NeighborGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NeighborGroup> GetNeighborGroupsBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NeighborGroupsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NeighborGroupsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NeighborGroup.DeserializeNeighborGroup, NeighborGroupsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNeighborGroupsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays NeighborGroups list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/neighborGroups</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NeighborGroups_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NeighborGroup" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NeighborGroup> GetNeighborGroupsBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NeighborGroupsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NeighborGroupsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NeighborGroup.DeserializeNeighborGroup, NeighborGroupsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNeighborGroupsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Get a Network Device SKU details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDeviceSkus/{networkDeviceSkuName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDeviceSkus_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="networkDeviceSkuName"> Name of the Network Device SKU. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkDeviceSku>> GetNetworkDeviceSkuAsync(Guid subscriptionId, string networkDeviceSkuName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDeviceSkusClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkDeviceSku");
            scope.Start();
            try
            {
                var response = await NetworkDeviceSkusRestClient.GetAsync(subscriptionId, networkDeviceSkuName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get a Network Device SKU details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDeviceSkus/{networkDeviceSkuName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDeviceSkus_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="networkDeviceSkuName"> Name of the Network Device SKU. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkDeviceSku> GetNetworkDeviceSku(Guid subscriptionId, string networkDeviceSkuName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDeviceSkusClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkDeviceSku");
            scope.Start();
            try
            {
                var response = NetworkDeviceSkusRestClient.Get(subscriptionId, networkDeviceSkuName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List Network Device SKUs for the given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDeviceSkus</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDeviceSkus_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkDeviceSku" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkDeviceSku> GetNetworkDeviceSkusBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkDeviceSkusRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkDeviceSkusRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkDeviceSku.DeserializeNetworkDeviceSku, NetworkDeviceSkusClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkDeviceSkusBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List Network Device SKUs for the given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDeviceSkus</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDeviceSkus_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkDeviceSku" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkDeviceSku> GetNetworkDeviceSkusBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkDeviceSkusRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkDeviceSkusRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkDeviceSku.DeserializeNetworkDeviceSku, NetworkDeviceSkusClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkDeviceSkusBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Create a Network Device resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkDevice>> CreateNetworkDeviceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, NetworkDevice body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkDevice");
            scope.Start();
            try
            {
                var response = await NetworkDevicesRestClient.CreateAsync(subscriptionId, resourceGroupName, networkDeviceName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkDevice>(new NetworkDeviceOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkDeviceName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Network Device resource
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkDevice> CreateNetworkDevice(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, NetworkDevice body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkDevice");
            scope.Start();
            try
            {
                var response = NetworkDevicesRestClient.Create(subscriptionId, resourceGroupName, networkDeviceName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkDevice>(new NetworkDeviceOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkDeviceName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the Network Device resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkDevice>> GetNetworkDeviceAsync(Guid subscriptionId, string resourceGroupName, string networkDeviceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkDevice");
            scope.Start();
            try
            {
                var response = await NetworkDevicesRestClient.GetAsync(subscriptionId, resourceGroupName, networkDeviceName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the Network Device resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkDevice> GetNetworkDevice(Guid subscriptionId, string resourceGroupName, string networkDeviceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkDevice");
            scope.Start();
            try
            {
                var response = NetworkDevicesRestClient.Get(subscriptionId, resourceGroupName, networkDeviceName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Device resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="content"> Network Device properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkDevice>> UpdateNetworkDeviceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, NetworkDevicePatchContent content, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkDevice");
            scope.Start();
            try
            {
                var response = await NetworkDevicesRestClient.UpdateAsync(subscriptionId, resourceGroupName, networkDeviceName, content, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkDevice>(new NetworkDeviceOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkDeviceName, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Device resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="content"> Network Device properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkDevice> UpdateNetworkDevice(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, NetworkDevicePatchContent content, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkDevice");
            scope.Start();
            try
            {
                var response = NetworkDevicesRestClient.Update(subscriptionId, resourceGroupName, networkDeviceName, content, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkDevice>(new NetworkDeviceOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkDeviceName, content).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete the Network Device resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNetworkDeviceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkDevice");
            scope.Start();
            try
            {
                var response = await NetworkDevicesRestClient.DeleteAsync(subscriptionId, resourceGroupName, networkDeviceName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkDeviceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete the Network Device resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNetworkDevice(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkDevice");
            scope.Start();
            try
            {
                var response = NetworkDevicesRestClient.Delete(subscriptionId, resourceGroupName, networkDeviceName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkDeviceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List all the Network Device resources in a given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkDevice" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkDevice> GetNetworkDevicesByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkDevicesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkDevicesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkDevice.DeserializeNetworkDevice, NetworkDevicesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkDevicesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Device resources in a given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkDevice" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkDevice> GetNetworkDevicesByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkDevicesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkDevicesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkDevice.DeserializeNetworkDevice, NetworkDevicesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkDevicesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Device resources in a given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDevices</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkDevice" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkDevice> GetNetworkDevicesBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkDevicesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkDevicesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkDevice.DeserializeNetworkDevice, NetworkDevicesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkDevicesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Device resources in a given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkDevices</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkDevice" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkDevice> GetNetworkDevicesBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkDevicesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkDevicesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkDevice.DeserializeNetworkDevice, NetworkDevicesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkDevicesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Reboot the Network Device.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Reboot</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> RebootNetworkDeviceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, RebootProperties body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.RebootNetworkDevice");
            scope.Start();
            try
            {
                var response = await NetworkDevicesRestClient.RebootAsync(subscriptionId, resourceGroupName, networkDeviceName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateRebootRequest(subscriptionId, resourceGroupName, networkDeviceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Reboot the Network Device.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/reboot</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Reboot</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> RebootNetworkDevice(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, RebootProperties body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.RebootNetworkDevice");
            scope.Start();
            try
            {
                var response = NetworkDevicesRestClient.Reboot(subscriptionId, resourceGroupName, networkDeviceName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateRebootRequest(subscriptionId, resourceGroupName, networkDeviceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Refreshes the configuration the Network Device.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/refreshConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_RefreshConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> RefreshConfigurationNetworkDeviceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.RefreshConfigurationNetworkDevice");
            scope.Start();
            try
            {
                var response = await NetworkDevicesRestClient.RefreshConfigurationAsync(subscriptionId, resourceGroupName, networkDeviceName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateRefreshConfigurationRequest(subscriptionId, resourceGroupName, networkDeviceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Refreshes the configuration the Network Device.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/refreshConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_RefreshConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> RefreshConfigurationNetworkDevice(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.RefreshConfigurationNetworkDevice");
            scope.Start();
            try
            {
                var response = NetworkDevicesRestClient.RefreshConfiguration(subscriptionId, resourceGroupName, networkDeviceName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateRefreshConfigurationRequest(subscriptionId, resourceGroupName, networkDeviceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Administrative state of the Network Device.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateAdministrativeStateNetworkDeviceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, UpdateDeviceAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkDevice");
            scope.Start();
            try
            {
                var response = await NetworkDevicesRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, networkDeviceName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkDeviceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Administrative state of the Network Device.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateAdministrativeStateNetworkDevice(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, UpdateDeviceAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkDevice");
            scope.Start();
            try
            {
                var response = NetworkDevicesRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, networkDeviceName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkDeviceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Upgrades the version of the Network Device.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/upgrade</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Upgrade</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpgradeNetworkDeviceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, UpdateVersion body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpgradeNetworkDevice");
            scope.Start();
            try
            {
                var response = await NetworkDevicesRestClient.UpgradeAsync(subscriptionId, resourceGroupName, networkDeviceName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateUpgradeRequest(subscriptionId, resourceGroupName, networkDeviceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Upgrades the version of the Network Device.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/upgrade</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkDevices_Upgrade</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpgradeNetworkDevice(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, UpdateVersion body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkDevicesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpgradeNetworkDevice");
            scope.Start();
            try
            {
                var response = NetworkDevicesRestClient.Upgrade(subscriptionId, resourceGroupName, networkDeviceName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkDevicesClientDiagnostics, Pipeline, NetworkDevicesRestClient.CreateUpgradeRequest(subscriptionId, resourceGroupName, networkDeviceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Network Interface resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkInterface>> CreateNetworkInterfaceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, NetworkInterface body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkInterface");
            scope.Start();
            try
            {
                var response = await NetworkInterfacesRestClient.CreateAsync(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkInterface>(new NetworkInterfaceOperationSource(), NetworkInterfacesClientDiagnostics, Pipeline, NetworkInterfacesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create a Network Interface resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkInterface> CreateNetworkInterface(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, NetworkInterface body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkInterface");
            scope.Start();
            try
            {
                var response = NetworkInterfacesRestClient.Create(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkInterface>(new NetworkInterfaceOperationSource(), NetworkInterfacesClientDiagnostics, Pipeline, NetworkInterfacesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the Network Interface resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkInterface>> GetNetworkInterfaceAsync(Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkInterface");
            scope.Start();
            try
            {
                var response = await NetworkInterfacesRestClient.GetAsync(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get the Network Interface resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkInterface> GetNetworkInterface(Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkInterface");
            scope.Start();
            try
            {
                var response = NetworkInterfacesRestClient.Get(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Interface resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="patch"> NetworkInterface properties to update. Only tags are supported. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkInterface>> UpdateNetworkInterfaceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, NetworkInterfacePatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkInterface");
            scope.Start();
            try
            {
                var response = await NetworkInterfacesRestClient.UpdateAsync(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkInterface>(new NetworkInterfaceOperationSource(), NetworkInterfacesClientDiagnostics, Pipeline, NetworkInterfacesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Interface resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="patch"> NetworkInterface properties to update. Only tags are supported. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkInterface> UpdateNetworkInterface(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, NetworkInterfacePatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkInterface");
            scope.Start();
            try
            {
                var response = NetworkInterfacesRestClient.Update(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkInterface>(new NetworkInterfaceOperationSource(), NetworkInterfacesClientDiagnostics, Pipeline, NetworkInterfacesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete the Network Interface resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNetworkInterfaceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkInterface");
            scope.Start();
            try
            {
                var response = await NetworkInterfacesRestClient.DeleteAsync(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NetworkInterfacesClientDiagnostics, Pipeline, NetworkInterfacesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete the Network Interface resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNetworkInterface(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkInterface");
            scope.Start();
            try
            {
                var response = NetworkInterfacesRestClient.Delete(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NetworkInterfacesClientDiagnostics, Pipeline, NetworkInterfacesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List all the Network Interface resources in a given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_ListByNetworkDevice</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkInterface" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkInterface> GetNetworkInterfacesByNetworkDeviceAsync(Guid subscriptionId, string resourceGroupName, string networkDeviceName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkInterfacesRestClient.CreateListByNetworkDeviceRequest(subscriptionId, resourceGroupName, networkDeviceName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkInterfacesRestClient.CreateListByNetworkDeviceNextPageRequest(nextLink, subscriptionId, resourceGroupName, networkDeviceName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkInterface.DeserializeNetworkInterface, NetworkInterfacesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkInterfacesByNetworkDevice", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Interface resources in a given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_ListByNetworkDevice</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkInterface" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkInterface> GetNetworkInterfacesByNetworkDevice(Guid subscriptionId, string resourceGroupName, string networkDeviceName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkInterfacesRestClient.CreateListByNetworkDeviceRequest(subscriptionId, resourceGroupName, networkDeviceName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkInterfacesRestClient.CreateListByNetworkDeviceNextPageRequest(nextLink, subscriptionId, resourceGroupName, networkDeviceName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkInterface.DeserializeNetworkInterface, NetworkInterfacesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkInterfacesByNetworkDevice", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Update the admin state of the Network Interface.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateAdministrativeStateNetworkInterfaceAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkInterface");
            scope.Start();
            try
            {
                var response = await NetworkInterfacesRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkInterfacesClientDiagnostics, Pipeline, NetworkInterfacesRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update the admin state of the Network Interface.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkDevices/{networkDeviceName}/networkInterfaces/{networkInterfaceName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkInterfaces_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkDeviceName"> Name of the Network Device. </param>
        /// <param name="networkInterfaceName"> Name of the Network Interface. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateAdministrativeStateNetworkInterface(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkDeviceName, string networkInterfaceName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkInterfacesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkInterface");
            scope.Start();
            try
            {
                var response = NetworkInterfacesRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkInterfacesClientDiagnostics, Pipeline, NetworkInterfacesRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkDeviceName, networkInterfaceName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a Network Fabric Controller.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricControllerName"> Name of the Network Fabric Controller. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkFabricController>> CreateNetworkFabricControllerAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricControllerName, NetworkFabricController body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricControllersClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkFabricController");
            scope.Start();
            try
            {
                var response = await NetworkFabricControllersRestClient.CreateAsync(subscriptionId, resourceGroupName, networkFabricControllerName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkFabricController>(new NetworkFabricControllerOperationSource(), NetworkFabricControllersClientDiagnostics, Pipeline, NetworkFabricControllersRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkFabricControllerName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a Network Fabric Controller.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricControllerName"> Name of the Network Fabric Controller. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkFabricController> CreateNetworkFabricController(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricControllerName, NetworkFabricController body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricControllersClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkFabricController");
            scope.Start();
            try
            {
                var response = NetworkFabricControllersRestClient.Create(subscriptionId, resourceGroupName, networkFabricControllerName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkFabricController>(new NetworkFabricControllerOperationSource(), NetworkFabricControllersClientDiagnostics, Pipeline, NetworkFabricControllersRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkFabricControllerName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Shows the provisioning status of Network Fabric Controller.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricControllerName"> Name of the Network Fabric Controller. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkFabricController>> GetNetworkFabricControllerAsync(Guid subscriptionId, string resourceGroupName, string networkFabricControllerName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricControllersClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkFabricController");
            scope.Start();
            try
            {
                var response = await NetworkFabricControllersRestClient.GetAsync(subscriptionId, resourceGroupName, networkFabricControllerName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Shows the provisioning status of Network Fabric Controller.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricControllerName"> Name of the Network Fabric Controller. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkFabricController> GetNetworkFabricController(Guid subscriptionId, string resourceGroupName, string networkFabricControllerName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricControllersClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkFabricController");
            scope.Start();
            try
            {
                var response = NetworkFabricControllersRestClient.Get(subscriptionId, resourceGroupName, networkFabricControllerName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates are currently not supported for the Network Fabric Controller resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricControllerName"> Name of the Network Fabric Controller. </param>
        /// <param name="patch"> Network Fabric Controller properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkFabricController>> UpdateNetworkFabricControllerAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricControllerName, NetworkFabricControllerPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricControllersClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkFabricController");
            scope.Start();
            try
            {
                var response = await NetworkFabricControllersRestClient.UpdateAsync(subscriptionId, resourceGroupName, networkFabricControllerName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkFabricController>(new NetworkFabricControllerOperationSource(), NetworkFabricControllersClientDiagnostics, Pipeline, NetworkFabricControllersRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkFabricControllerName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates are currently not supported for the Network Fabric Controller resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricControllerName"> Name of the Network Fabric Controller. </param>
        /// <param name="patch"> Network Fabric Controller properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkFabricController> UpdateNetworkFabricController(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricControllerName, NetworkFabricControllerPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricControllersClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkFabricController");
            scope.Start();
            try
            {
                var response = NetworkFabricControllersRestClient.Update(subscriptionId, resourceGroupName, networkFabricControllerName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkFabricController>(new NetworkFabricControllerOperationSource(), NetworkFabricControllersClientDiagnostics, Pipeline, NetworkFabricControllersRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkFabricControllerName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes the Network Fabric Controller resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricControllerName"> Name of the Network Fabric Controller. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNetworkFabricControllerAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricControllerName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricControllersClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkFabricController");
            scope.Start();
            try
            {
                var response = await NetworkFabricControllersRestClient.DeleteAsync(subscriptionId, resourceGroupName, networkFabricControllerName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NetworkFabricControllersClientDiagnostics, Pipeline, NetworkFabricControllersRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkFabricControllerName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes the Network Fabric Controller resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers/{networkFabricControllerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricControllerName"> Name of the Network Fabric Controller. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNetworkFabricController(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricControllerName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricControllersClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkFabricController");
            scope.Start();
            try
            {
                var response = NetworkFabricControllersRestClient.Delete(subscriptionId, resourceGroupName, networkFabricControllerName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NetworkFabricControllersClientDiagnostics, Pipeline, NetworkFabricControllersRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkFabricControllerName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Lists all the NetworkFabricControllers thats available in the resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkFabricController" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkFabricController> GetNetworkFabricControllersByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricControllersRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricControllersRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkFabricController.DeserializeNetworkFabricController, NetworkFabricControllersClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricControllersByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Lists all the NetworkFabricControllers thats available in the resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkFabricController" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkFabricController> GetNetworkFabricControllersByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricControllersRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricControllersRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkFabricController.DeserializeNetworkFabricController, NetworkFabricControllersClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricControllersByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Lists all the NetworkFabricControllers by subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkFabricController" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkFabricController> GetNetworkFabricControllersBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricControllersRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricControllersRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkFabricController.DeserializeNetworkFabricController, NetworkFabricControllersClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricControllersBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Lists all the NetworkFabricControllers by subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricControllers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricControllers_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkFabricController" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkFabricController> GetNetworkFabricControllersBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricControllersRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricControllersRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkFabricController.DeserializeNetworkFabricController, NetworkFabricControllersClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricControllersBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements Network Fabric SKU GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricSkus/{networkFabricSkuName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricSkus_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="networkFabricSkuName"> Name of the Network Fabric SKU. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkFabricSku>> GetNetworkFabricSkuAsync(Guid subscriptionId, string networkFabricSkuName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricSkusClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkFabricSku");
            scope.Start();
            try
            {
                var response = await NetworkFabricSkusRestClient.GetAsync(subscriptionId, networkFabricSkuName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Network Fabric SKU GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricSkus/{networkFabricSkuName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricSkus_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="networkFabricSkuName"> Name of the Network Fabric SKU. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkFabricSku> GetNetworkFabricSku(Guid subscriptionId, string networkFabricSkuName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricSkusClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkFabricSku");
            scope.Start();
            try
            {
                var response = NetworkFabricSkusRestClient.Get(subscriptionId, networkFabricSkuName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Network Fabric SKUs list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricSkus</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricSkus_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkFabricSku" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkFabricSku> GetNetworkFabricSkusBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricSkusRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricSkusRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkFabricSku.DeserializeNetworkFabricSku, NetworkFabricSkusClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricSkusBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements Network Fabric SKUs list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabricSkus</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabricSkus_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkFabricSku" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkFabricSku> GetNetworkFabricSkusBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricSkusRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricSkusRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkFabricSku.DeserializeNetworkFabricSku, NetworkFabricSkusClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricSkusBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Create Network Fabric resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkFabric>> CreateNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, NetworkFabric body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.CreateAsync(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkFabric>(new NetworkFabricOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create Network Fabric resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkFabric> CreateNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, NetworkFabric body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.Create(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkFabric>(new NetworkFabricOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Network Fabric resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkFabric>> GetNetworkFabricAsync(Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.GetAsync(subscriptionId, resourceGroupName, networkFabricName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Network Fabric resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkFabric> GetNetworkFabric(Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.Get(subscriptionId, resourceGroupName, networkFabricName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Fabric resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="patch"> Network Fabric properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkFabric>> UpdateNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, NetworkFabricPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.UpdateAsync(subscriptionId, resourceGroupName, networkFabricName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkFabric>(new NetworkFabricOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkFabricName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Fabric resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="patch"> Network Fabric properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkFabric> UpdateNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, NetworkFabricPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.Update(subscriptionId, resourceGroupName, networkFabricName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkFabric>(new NetworkFabricOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkFabricName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Network Fabric resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.DeleteAsync(subscriptionId, resourceGroupName, networkFabricName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Network Fabric resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.Delete(subscriptionId, resourceGroupName, networkFabricName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List all the Network Fabric resources in the given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkFabric" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkFabric> GetNetworkFabricsByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkFabric.DeserializeNetworkFabric, NetworkFabricsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Fabric resources in the given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkFabric" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkFabric> GetNetworkFabricsByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkFabric.DeserializeNetworkFabric, NetworkFabricsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Fabric resources in the given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabrics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkFabric" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkFabric> GetNetworkFabricsBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkFabric.DeserializeNetworkFabric, NetworkFabricsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Fabric resources in the given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkFabrics</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkFabric" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkFabric> GetNetworkFabricsBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkFabricsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkFabricsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkFabric.DeserializeNetworkFabric, NetworkFabricsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkFabricsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Provisions the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_provision</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForDeviceUpdate>> ProvisionNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ProvisionNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.ProvisionAsync(subscriptionId, resourceGroupName, networkFabricName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateProvisionRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Provisions the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/provision</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_provision</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForDeviceUpdate> ProvisionNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ProvisionNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.Provision(subscriptionId, resourceGroupName, networkFabricName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateProvisionRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deprovisions the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_deprovision</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForDeviceUpdate>> DeprovisionNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeprovisionNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.DeprovisionAsync(subscriptionId, resourceGroupName, networkFabricName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateDeprovisionRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deprovisions the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/deprovision</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_deprovision</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForDeviceUpdate> DeprovisionNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeprovisionNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.Deprovision(subscriptionId, resourceGroupName, networkFabricName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateDeprovisionRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Upgrades the version of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/upgrade</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_upgrade</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Network Fabric properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpgradeNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, UpdateVersion body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpgradeNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.UpgradeAsync(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateUpgradeRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Upgrades the version of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/upgrade</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_upgrade</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Network Fabric properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpgradeNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, UpdateVersion body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpgradeNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.Upgrade(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateUpgradeRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Refreshes the configuration of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/refreshConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_refreshConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> RefreshConfigurationNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.RefreshConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.RefreshConfigurationAsync(subscriptionId, resourceGroupName, networkFabricName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateRefreshConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Refreshes the configuration of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/refreshConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_refreshConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> RefreshConfigurationNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.RefreshConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.RefreshConfiguration(subscriptionId, resourceGroupName, networkFabricName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateRefreshConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Workload Management BFD Configuration of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateWorkloadManagementBfdConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_UpdateWorkloadManagementBfdConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateWorkloadManagementBfdConfigurationNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateWorkloadManagementBfdConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.UpdateWorkloadManagementBfdConfigurationAsync(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateUpdateWorkloadManagementBfdConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Workload Management BFD Configuration of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateWorkloadManagementBfdConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_UpdateWorkloadManagementBfdConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateWorkloadManagementBfdConfigurationNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateWorkloadManagementBfdConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.UpdateWorkloadManagementBfdConfiguration(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateUpdateWorkloadManagementBfdConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Infra Management BFD Configuration of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateInfraManagementBfdConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_UpdateInfraManagementBfdConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateInfraManagementBfdConfigurationNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateInfraManagementBfdConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.UpdateInfraManagementBfdConfigurationAsync(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateUpdateInfraManagementBfdConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Infra Management BFD Configuration of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/updateInfraManagementBfdConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_UpdateInfraManagementBfdConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateInfraManagementBfdConfigurationNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateInfraManagementBfdConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.UpdateInfraManagementBfdConfiguration(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateUpdateInfraManagementBfdConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Validates the configuration of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Validate configuration properties. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ValidateConfigurationResponse>> ValidateConfigurationNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, ValidateConfigurationProperties body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.ValidateConfigurationAsync(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Validates the configuration of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="body"> Validate configuration properties. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ValidateConfigurationResponse> ValidateConfigurationNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, ValidateConfigurationProperties body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.ValidateConfiguration(subscriptionId, resourceGroupName, networkFabricName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets Topology of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/getTopology</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_GetTopology</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ValidateConfigurationResponse>> GetTopologyNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetTopologyNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.GetTopologyAsync(subscriptionId, resourceGroupName, networkFabricName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateGetTopologyRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets Topology of the underlying resources in the given Network Fabric instance.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/getTopology</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_GetTopology</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ValidateConfigurationResponse> GetTopologyNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetTopologyNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.GetTopology(subscriptionId, resourceGroupName, networkFabricName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateGetTopologyRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Atomic update of the given Network Fabric instance. Sync update of NFA resources at Fabric level.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/commitConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_CommitConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> CommitConfigurationNetworkFabricAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CommitConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = await NetworkFabricsRestClient.CommitConfigurationAsync(subscriptionId, resourceGroupName, networkFabricName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateCommitConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Atomic update of the given Network Fabric instance. Sync update of NFA resources at Fabric level.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/commitConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkFabrics_CommitConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> CommitConfigurationNetworkFabric(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkFabricsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CommitConfigurationNetworkFabric");
            scope.Start();
            try
            {
                var response = NetworkFabricsRestClient.CommitConfiguration(subscriptionId, resourceGroupName, networkFabricName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkFabricsClientDiagnostics, Pipeline, NetworkFabricsRestClient.CreateCommitConfigurationRequest(subscriptionId, resourceGroupName, networkFabricName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Configuration used to setup CE-PE connectivity PUT Method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkToNetworkInterconnect>> CreateNetworkToNetworkInterconnectAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, NetworkToNetworkInterconnect body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = await NetworkToNetworkInterconnectsRestClient.CreateAsync(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkToNetworkInterconnect>(new NetworkToNetworkInterconnectOperationSource(), NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Configuration used to setup CE-PE connectivity PUT Method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkToNetworkInterconnect> CreateNetworkToNetworkInterconnect(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, NetworkToNetworkInterconnect body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = NetworkToNetworkInterconnectsRestClient.Create(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkToNetworkInterconnect>(new NetworkToNetworkInterconnectOperationSource(), NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements NetworkToNetworkInterconnects GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkToNetworkInterconnect>> GetNetworkToNetworkInterconnectAsync(Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = await NetworkToNetworkInterconnectsRestClient.GetAsync(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements NetworkToNetworkInterconnects GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkToNetworkInterconnect> GetNetworkToNetworkInterconnect(Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = NetworkToNetworkInterconnectsRestClient.Get(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network To NetworkInterconnects resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="patch"> Network to Network Interconnect properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkToNetworkInterconnect>> UpdateNetworkToNetworkInterconnectAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, NetworkToNetworkInterconnectPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = await NetworkToNetworkInterconnectsRestClient.UpdateAsync(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkToNetworkInterconnect>(new NetworkToNetworkInterconnectOperationSource(), NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network To NetworkInterconnects resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="patch"> Network to Network Interconnect properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkToNetworkInterconnect> UpdateNetworkToNetworkInterconnect(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, NetworkToNetworkInterconnectPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = NetworkToNetworkInterconnectsRestClient.Update(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkToNetworkInterconnect>(new NetworkToNetworkInterconnectOperationSource(), NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements NetworkToNetworkInterconnects DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNetworkToNetworkInterconnectAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = await NetworkToNetworkInterconnectsRestClient.DeleteAsync(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements NetworkToNetworkInterconnects DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNetworkToNetworkInterconnect(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = NetworkToNetworkInterconnectsRestClient.Delete(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Network To Network Interconnects list by Network Fabric GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_ListByNetworkFabric</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkToNetworkInterconnect" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkToNetworkInterconnect> GetNetworkToNetworkInterconnectsByNetworkFabricAsync(Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkToNetworkInterconnectsRestClient.CreateListByNetworkFabricRequest(subscriptionId, resourceGroupName, networkFabricName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkToNetworkInterconnectsRestClient.CreateListByNetworkFabricNextPageRequest(nextLink, subscriptionId, resourceGroupName, networkFabricName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkToNetworkInterconnect.DeserializeNetworkToNetworkInterconnect, NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkToNetworkInterconnectsByNetworkFabric", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements Network To Network Interconnects list by Network Fabric GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_ListByNetworkFabric</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkToNetworkInterconnect" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkToNetworkInterconnect> GetNetworkToNetworkInterconnectsByNetworkFabric(Guid subscriptionId, string resourceGroupName, string networkFabricName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkToNetworkInterconnectsRestClient.CreateListByNetworkFabricRequest(subscriptionId, resourceGroupName, networkFabricName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkToNetworkInterconnectsRestClient.CreateListByNetworkFabricNextPageRequest(nextLink, subscriptionId, resourceGroupName, networkFabricName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkToNetworkInterconnect.DeserializeNetworkToNetworkInterconnect, NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkToNetworkInterconnectsByNetworkFabric", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Updates the NPB Static Route BFD Administrative State.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}/updateNpbStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_updateNpbStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateNpbStaticRouteBfdAdministrativeStateNetworkToNetworkInterconnectAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNpbStaticRouteBfdAdministrativeStateNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = await NetworkToNetworkInterconnectsRestClient.UpdateNpbStaticRouteBfdAdministrativeStateAsync(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateUpdateNpbStaticRouteBfdAdministrativeStateRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the NPB Static Route BFD Administrative State.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}/updateNpbStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_updateNpbStaticRouteBfdAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateNpbStaticRouteBfdAdministrativeStateNetworkToNetworkInterconnect(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNpbStaticRouteBfdAdministrativeStateNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = NetworkToNetworkInterconnectsRestClient.UpdateNpbStaticRouteBfdAdministrativeState(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateUpdateNpbStaticRouteBfdAdministrativeStateRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Admin State.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_updateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateAdministrativeStateNetworkToNetworkInterconnectAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = await NetworkToNetworkInterconnectsRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updates the Admin State.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkFabrics/{networkFabricName}/networkToNetworkInterconnects/{networkToNetworkInterconnectName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkToNetworkInterconnects_updateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkFabricName"> Name of the Network Fabric. </param>
        /// <param name="networkToNetworkInterconnectName"> Name of the Network to Network Interconnect. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateAdministrativeStateNetworkToNetworkInterconnect(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkFabricName, string networkToNetworkInterconnectName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkToNetworkInterconnectsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkToNetworkInterconnect");
            scope.Start();
            try
            {
                var response = NetworkToNetworkInterconnectsRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkToNetworkInterconnectsClientDiagnostics, Pipeline, NetworkToNetworkInterconnectsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkFabricName, networkToNetworkInterconnectName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a Network Packet Broker.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkPacketBrokerName"> Name of the Network Packet Broker. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkPacketBroker>> CreateNetworkPacketBrokerAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkPacketBrokerName, NetworkPacketBroker body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkPacketBrokersClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkPacketBroker");
            scope.Start();
            try
            {
                var response = await NetworkPacketBrokersRestClient.CreateAsync(subscriptionId, resourceGroupName, networkPacketBrokerName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkPacketBroker>(new NetworkPacketBrokerOperationSource(), NetworkPacketBrokersClientDiagnostics, Pipeline, NetworkPacketBrokersRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkPacketBrokerName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a Network Packet Broker.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkPacketBrokerName"> Name of the Network Packet Broker. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkPacketBroker> CreateNetworkPacketBroker(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkPacketBrokerName, NetworkPacketBroker body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkPacketBrokersClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkPacketBroker");
            scope.Start();
            try
            {
                var response = NetworkPacketBrokersRestClient.Create(subscriptionId, resourceGroupName, networkPacketBrokerName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkPacketBroker>(new NetworkPacketBrokerOperationSource(), NetworkPacketBrokersClientDiagnostics, Pipeline, NetworkPacketBrokersRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkPacketBrokerName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieves details of this Network Packet Broker.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkPacketBrokerName"> Name of the Network Packet Broker. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkPacketBroker>> GetNetworkPacketBrokerAsync(Guid subscriptionId, string resourceGroupName, string networkPacketBrokerName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkPacketBrokersClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkPacketBroker");
            scope.Start();
            try
            {
                var response = await NetworkPacketBrokersRestClient.GetAsync(subscriptionId, resourceGroupName, networkPacketBrokerName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieves details of this Network Packet Broker.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkPacketBrokerName"> Name of the Network Packet Broker. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkPacketBroker> GetNetworkPacketBroker(Guid subscriptionId, string resourceGroupName, string networkPacketBrokerName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkPacketBrokersClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkPacketBroker");
            scope.Start();
            try
            {
                var response = NetworkPacketBrokersRestClient.Get(subscriptionId, resourceGroupName, networkPacketBrokerName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Network Packet Broker resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkPacketBrokerName"> Name of the Network Packet Broker. </param>
        /// <param name="patch"> Network Packet Broker properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkPacketBroker>> UpdateNetworkPacketBrokerAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkPacketBrokerName, NetworkPacketBrokerPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkPacketBrokersClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkPacketBroker");
            scope.Start();
            try
            {
                var response = await NetworkPacketBrokersRestClient.UpdateAsync(subscriptionId, resourceGroupName, networkPacketBrokerName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkPacketBroker>(new NetworkPacketBrokerOperationSource(), NetworkPacketBrokersClientDiagnostics, Pipeline, NetworkPacketBrokersRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkPacketBrokerName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Network Packet Broker resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkPacketBrokerName"> Name of the Network Packet Broker. </param>
        /// <param name="patch"> Network Packet Broker properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkPacketBroker> UpdateNetworkPacketBroker(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkPacketBrokerName, NetworkPacketBrokerPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkPacketBrokersClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkPacketBroker");
            scope.Start();
            try
            {
                var response = NetworkPacketBrokersRestClient.Update(subscriptionId, resourceGroupName, networkPacketBrokerName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkPacketBroker>(new NetworkPacketBrokerOperationSource(), NetworkPacketBrokersClientDiagnostics, Pipeline, NetworkPacketBrokersRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkPacketBrokerName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes Network Packet Broker.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkPacketBrokerName"> Name of the Network Packet Broker. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNetworkPacketBrokerAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkPacketBrokerName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkPacketBrokersClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkPacketBroker");
            scope.Start();
            try
            {
                var response = await NetworkPacketBrokersRestClient.DeleteAsync(subscriptionId, resourceGroupName, networkPacketBrokerName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NetworkPacketBrokersClientDiagnostics, Pipeline, NetworkPacketBrokersRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkPacketBrokerName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes Network Packet Broker.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers/{networkPacketBrokerName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkPacketBrokerName"> Name of the Network Packet Broker. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNetworkPacketBroker(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkPacketBrokerName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkPacketBrokersClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkPacketBroker");
            scope.Start();
            try
            {
                var response = NetworkPacketBrokersRestClient.Delete(subscriptionId, resourceGroupName, networkPacketBrokerName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NetworkPacketBrokersClientDiagnostics, Pipeline, NetworkPacketBrokersRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkPacketBrokerName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Displays NetworkPacketBrokers list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkPacketBroker" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkPacketBroker> GetNetworkPacketBrokersByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkPacketBrokersRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkPacketBrokersRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkPacketBroker.DeserializeNetworkPacketBroker, NetworkPacketBrokersClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkPacketBrokersByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays NetworkPacketBrokers list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkPacketBroker" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkPacketBroker> GetNetworkPacketBrokersByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkPacketBrokersRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkPacketBrokersRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkPacketBroker.DeserializeNetworkPacketBroker, NetworkPacketBrokersClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkPacketBrokersByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays Network Packet Brokers list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkPacketBroker" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkPacketBroker> GetNetworkPacketBrokersBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkPacketBrokersRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkPacketBrokersRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkPacketBroker.DeserializeNetworkPacketBroker, NetworkPacketBrokersClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkPacketBrokersBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays Network Packet Brokers list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkPacketBrokers</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkPacketBrokers_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkPacketBroker" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkPacketBroker> GetNetworkPacketBrokersBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkPacketBrokersRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkPacketBrokersRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkPacketBroker.DeserializeNetworkPacketBroker, NetworkPacketBrokersClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkPacketBrokersBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Create Network Rack resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkRackName"> Name of the Network Rack. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkRack>> CreateNetworkRackAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkRackName, NetworkRack body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkRacksClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkRack");
            scope.Start();
            try
            {
                var response = await NetworkRacksRestClient.CreateAsync(subscriptionId, resourceGroupName, networkRackName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkRack>(new NetworkRackOperationSource(), NetworkRacksClientDiagnostics, Pipeline, NetworkRacksRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkRackName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create Network Rack resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkRackName"> Name of the Network Rack. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkRack> CreateNetworkRack(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkRackName, NetworkRack body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkRacksClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkRack");
            scope.Start();
            try
            {
                var response = NetworkRacksRestClient.Create(subscriptionId, resourceGroupName, networkRackName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkRack>(new NetworkRackOperationSource(), NetworkRacksClientDiagnostics, Pipeline, NetworkRacksRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkRackName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Network Rack resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkRackName"> Name of the Network Rack. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkRack>> GetNetworkRackAsync(Guid subscriptionId, string resourceGroupName, string networkRackName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkRacksClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkRack");
            scope.Start();
            try
            {
                var response = await NetworkRacksRestClient.GetAsync(subscriptionId, resourceGroupName, networkRackName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Network Rack resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkRackName"> Name of the Network Rack. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkRack> GetNetworkRack(Guid subscriptionId, string resourceGroupName, string networkRackName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkRacksClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkRack");
            scope.Start();
            try
            {
                var response = NetworkRacksRestClient.Get(subscriptionId, resourceGroupName, networkRackName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Rack resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkRackName"> Name of the Network Rack. </param>
        /// <param name="body"> Network Rack properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkRack>> UpdateNetworkRackAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkRackName, TagsUpdate body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkRacksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkRack");
            scope.Start();
            try
            {
                var response = await NetworkRacksRestClient.UpdateAsync(subscriptionId, resourceGroupName, networkRackName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkRack>(new NetworkRackOperationSource(), NetworkRacksClientDiagnostics, Pipeline, NetworkRacksRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkRackName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Rack resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkRackName"> Name of the Network Rack. </param>
        /// <param name="body"> Network Rack properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkRack> UpdateNetworkRack(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkRackName, TagsUpdate body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkRacksClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkRack");
            scope.Start();
            try
            {
                var response = NetworkRacksRestClient.Update(subscriptionId, resourceGroupName, networkRackName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkRack>(new NetworkRackOperationSource(), NetworkRacksClientDiagnostics, Pipeline, NetworkRacksRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkRackName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Network Rack resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkRackName"> Name of the Network Rack. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNetworkRackAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkRackName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkRacksClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkRack");
            scope.Start();
            try
            {
                var response = await NetworkRacksRestClient.DeleteAsync(subscriptionId, resourceGroupName, networkRackName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NetworkRacksClientDiagnostics, Pipeline, NetworkRacksRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkRackName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Network Rack resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks/{networkRackName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkRackName"> Name of the Network Rack. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNetworkRack(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkRackName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkRacksClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkRack");
            scope.Start();
            try
            {
                var response = NetworkRacksRestClient.Delete(subscriptionId, resourceGroupName, networkRackName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NetworkRacksClientDiagnostics, Pipeline, NetworkRacksRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkRackName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List all Network Rack resources in the given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkRack" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkRack> GetNetworkRacksByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkRacksRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkRacksRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkRack.DeserializeNetworkRack, NetworkRacksClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkRacksByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all Network Rack resources in the given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkRacks</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkRack" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkRack> GetNetworkRacksByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkRacksRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkRacksRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkRack.DeserializeNetworkRack, NetworkRacksClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkRacksByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all Network Rack resources in the given subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkRacks</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkRack" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkRack> GetNetworkRacksBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkRacksRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkRacksRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkRack.DeserializeNetworkRack, NetworkRacksClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkRacksBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all Network Rack resources in the given subscription
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkRacks</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkRacks_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkRack" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkRack> GetNetworkRacksBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkRacksRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkRacksRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkRack.DeserializeNetworkRack, NetworkRacksClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkRacksBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Create Network Tap Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkTapRule>> CreateNetworkTapRuleAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, NetworkTapRule body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkTapRule");
            scope.Start();
            try
            {
                var response = await NetworkTapRulesRestClient.CreateAsync(subscriptionId, resourceGroupName, networkTapRuleName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkTapRule>(new NetworkTapRuleOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkTapRuleName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Create Network Tap Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkTapRule> CreateNetworkTapRule(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, NetworkTapRule body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkTapRule");
            scope.Start();
            try
            {
                var response = NetworkTapRulesRestClient.Create(subscriptionId, resourceGroupName, networkTapRuleName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkTapRule>(new NetworkTapRuleOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkTapRuleName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Network Tap Rule resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkTapRule>> GetNetworkTapRuleAsync(Guid subscriptionId, string resourceGroupName, string networkTapRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkTapRule");
            scope.Start();
            try
            {
                var response = await NetworkTapRulesRestClient.GetAsync(subscriptionId, resourceGroupName, networkTapRuleName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Get Network Tap Rule resource details.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkTapRule> GetNetworkTapRule(Guid subscriptionId, string resourceGroupName, string networkTapRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkTapRule");
            scope.Start();
            try
            {
                var response = NetworkTapRulesRestClient.Get(subscriptionId, resourceGroupName, networkTapRuleName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Tap Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="patch"> Network Tap Rule properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkTapRule>> UpdateNetworkTapRuleAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, NetworkTapRulePatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkTapRule");
            scope.Start();
            try
            {
                var response = await NetworkTapRulesRestClient.UpdateAsync(subscriptionId, resourceGroupName, networkTapRuleName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkTapRule>(new NetworkTapRuleOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkTapRuleName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Update certain properties of the Network Tap Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="patch"> Network Tap Rule properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkTapRule> UpdateNetworkTapRule(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, NetworkTapRulePatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkTapRule");
            scope.Start();
            try
            {
                var response = NetworkTapRulesRestClient.Update(subscriptionId, resourceGroupName, networkTapRuleName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkTapRule>(new NetworkTapRuleOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkTapRuleName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Network Tap Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNetworkTapRuleAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkTapRule");
            scope.Start();
            try
            {
                var response = await NetworkTapRulesRestClient.DeleteAsync(subscriptionId, resourceGroupName, networkTapRuleName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkTapRuleName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Delete Network Tap Rule resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNetworkTapRule(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkTapRule");
            scope.Start();
            try
            {
                var response = NetworkTapRulesRestClient.Delete(subscriptionId, resourceGroupName, networkTapRuleName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkTapRuleName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// List all the Network Tap Rule resources in the given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkTapRule" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkTapRule> GetNetworkTapRulesByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkTapRulesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkTapRulesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkTapRule.DeserializeNetworkTapRule, NetworkTapRulesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkTapRulesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Tap Rule resources in the given resource group.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkTapRule" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkTapRule> GetNetworkTapRulesByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkTapRulesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkTapRulesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkTapRule.DeserializeNetworkTapRule, NetworkTapRulesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkTapRulesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Tap Rule resources in the given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkTapRules</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkTapRule" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkTapRule> GetNetworkTapRulesBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkTapRulesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkTapRulesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkTapRule.DeserializeNetworkTapRule, NetworkTapRulesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkTapRulesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// List all the Network Tap Rule resources in the given subscription.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkTapRules</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkTapRule" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkTapRule> GetNetworkTapRulesBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkTapRulesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkTapRulesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkTapRule.DeserializeNetworkTapRule, NetworkTapRulesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkTapRulesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> UpdateAdministrativeStateNetworkTapRuleAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkTapRule");
            scope.Start();
            try
            {
                var response = await NetworkTapRulesRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, networkTapRuleName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkTapRuleName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> UpdateAdministrativeStateNetworkTapRule(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkTapRule");
            scope.Start();
            try
            {
                var response = NetworkTapRulesRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, networkTapRuleName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkTapRuleName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/resync</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Resync</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> ResyncNetworkTapRuleAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.ResyncNetworkTapRule");
            scope.Start();
            try
            {
                var response = await NetworkTapRulesRestClient.ResyncAsync(subscriptionId, resourceGroupName, networkTapRuleName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateResyncRequest(subscriptionId, resourceGroupName, networkTapRuleName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/resync</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_Resync</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> ResyncNetworkTapRule(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.ResyncNetworkTapRule");
            scope.Start();
            try
            {
                var response = NetworkTapRulesRestClient.Resync(subscriptionId, resourceGroupName, networkTapRuleName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateResyncRequest(subscriptionId, resourceGroupName, networkTapRuleName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ValidateConfigurationResponse>> ValidateConfigurationNetworkTapRuleAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationNetworkTapRule");
            scope.Start();
            try
            {
                var response = await NetworkTapRulesRestClient.ValidateConfigurationAsync(subscriptionId, resourceGroupName, networkTapRuleName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, networkTapRuleName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTapRules/{networkTapRuleName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTapRules_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapRuleName"> Name of the Network Tap Rule. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ValidateConfigurationResponse> ValidateConfigurationNetworkTapRule(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapRuleName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapRulesClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationNetworkTapRule");
            scope.Start();
            try
            {
                var response = NetworkTapRulesRestClient.ValidateConfiguration(subscriptionId, resourceGroupName, networkTapRuleName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), NetworkTapRulesClientDiagnostics, Pipeline, NetworkTapRulesRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, networkTapRuleName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a Network Tap.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkTap>> CreateNetworkTapAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, NetworkTap body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkTap");
            scope.Start();
            try
            {
                var response = await NetworkTapsRestClient.CreateAsync(subscriptionId, resourceGroupName, networkTapName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkTap>(new NetworkTapOperationSource(), NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkTapName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Creates a Network Tap.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkTap> CreateNetworkTap(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, NetworkTap body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateNetworkTap");
            scope.Start();
            try
            {
                var response = NetworkTapsRestClient.Create(subscriptionId, resourceGroupName, networkTapName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkTap>(new NetworkTapOperationSource(), NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, networkTapName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieves details of this Network Tap.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<NetworkTap>> GetNetworkTapAsync(Guid subscriptionId, string resourceGroupName, string networkTapName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkTap");
            scope.Start();
            try
            {
                var response = await NetworkTapsRestClient.GetAsync(subscriptionId, resourceGroupName, networkTapName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Retrieves details of this Network Tap.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<NetworkTap> GetNetworkTap(Guid subscriptionId, string resourceGroupName, string networkTapName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetNetworkTap");
            scope.Start();
            try
            {
                var response = NetworkTapsRestClient.Get(subscriptionId, resourceGroupName, networkTapName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Network Tap resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="patch"> Network Tap properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<NetworkTap>> UpdateNetworkTapAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, NetworkTapPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkTap");
            scope.Start();
            try
            {
                var response = await NetworkTapsRestClient.UpdateAsync(subscriptionId, resourceGroupName, networkTapName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<NetworkTap>(new NetworkTapOperationSource(), NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkTapName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Network Tap resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="patch"> Network Tap properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<NetworkTap> UpdateNetworkTap(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, NetworkTapPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateNetworkTap");
            scope.Start();
            try
            {
                var response = NetworkTapsRestClient.Update(subscriptionId, resourceGroupName, networkTapName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<NetworkTap>(new NetworkTapOperationSource(), NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, networkTapName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes Network Tap.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteNetworkTapAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkTap");
            scope.Start();
            try
            {
                var response = await NetworkTapsRestClient.DeleteAsync(subscriptionId, resourceGroupName, networkTapName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkTapName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Deletes Network Tap.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteNetworkTap(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteNetworkTap");
            scope.Start();
            try
            {
                var response = NetworkTapsRestClient.Delete(subscriptionId, resourceGroupName, networkTapName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, networkTapName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Displays Network Taps list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkTap" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkTap> GetNetworkTapsByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkTapsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkTapsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkTap.DeserializeNetworkTap, NetworkTapsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkTapsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays Network Taps list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkTap" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkTap> GetNetworkTapsByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkTapsRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkTapsRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkTap.DeserializeNetworkTap, NetworkTapsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkTapsByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays Network Taps list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkTaps</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="NetworkTap" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<NetworkTap> GetNetworkTapsBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkTapsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkTapsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, NetworkTap.DeserializeNetworkTap, NetworkTapsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkTapsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Displays Network Taps list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/networkTaps</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="NetworkTap" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<NetworkTap> GetNetworkTapsBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => NetworkTapsRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => NetworkTapsRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, NetworkTap.DeserializeNetworkTap, NetworkTapsClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetNetworkTapsBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForDeviceUpdate>> UpdateAdministrativeStateNetworkTapAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkTap");
            scope.Start();
            try
            {
                var response = await NetworkTapsRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, networkTapName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkTapName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForDeviceUpdate> UpdateAdministrativeStateNetworkTap(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateNetworkTap");
            scope.Start();
            try
            {
                var response = NetworkTapsRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, networkTapName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, networkTapName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}/resync</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Resync</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> ResyncNetworkTapAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ResyncNetworkTap");
            scope.Start();
            try
            {
                var response = await NetworkTapsRestClient.ResyncAsync(subscriptionId, resourceGroupName, networkTapName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateResyncRequest(subscriptionId, resourceGroupName, networkTapName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements the operation to the underlying resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/networkTaps/{networkTapName}/resync</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>NetworkTaps_Resync</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="networkTapName"> Name of the Network Tap. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> ResyncNetworkTap(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string networkTapName, CancellationToken cancellationToken = default)
        {
            using var scope = NetworkTapsClientDiagnostics.CreateScope("TenantResourceExtensionClient.ResyncNetworkTap");
            scope.Start();
            try
            {
                var response = NetworkTapsRestClient.Resync(subscriptionId, resourceGroupName, networkTapName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), NetworkTapsClientDiagnostics, Pipeline, NetworkTapsRestClient.CreateResyncRequest(subscriptionId, resourceGroupName, networkTapName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Route Policy PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<RoutePolicy>> CreateRoutePolicyAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, RoutePolicy body, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateRoutePolicy");
            scope.Start();
            try
            {
                var response = await RoutePoliciesRestClient.CreateAsync(subscriptionId, resourceGroupName, routePolicyName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<RoutePolicy>(new RoutePolicyOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, routePolicyName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Route Policy PUT method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_Create</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<RoutePolicy> CreateRoutePolicy(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, RoutePolicy body, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CreateRoutePolicy");
            scope.Start();
            try
            {
                var response = RoutePoliciesRestClient.Create(subscriptionId, resourceGroupName, routePolicyName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<RoutePolicy>(new RoutePolicyOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateCreateRequest(subscriptionId, resourceGroupName, routePolicyName, body).Request, response, OperationFinalStateVia.AzureAsyncOperation);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Route Policy GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<Response<RoutePolicy>> GetRoutePolicyAsync(Guid subscriptionId, string resourceGroupName, string routePolicyName, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetRoutePolicy");
            scope.Start();
            try
            {
                var response = await RoutePoliciesRestClient.GetAsync(subscriptionId, resourceGroupName, routePolicyName, cancellationToken).ConfigureAwait(false);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Route Policy GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_Get</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual Response<RoutePolicy> GetRoutePolicy(Guid subscriptionId, string resourceGroupName, string routePolicyName, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.GetRoutePolicy");
            scope.Start();
            try
            {
                var response = RoutePoliciesRestClient.Get(subscriptionId, resourceGroupName, routePolicyName, cancellationToken);
                return response;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Route Policy resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="patch"> Route Policy properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<RoutePolicy>> UpdateRoutePolicyAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, RoutePolicyPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateRoutePolicy");
            scope.Start();
            try
            {
                var response = await RoutePoliciesRestClient.UpdateAsync(subscriptionId, resourceGroupName, routePolicyName, patch, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<RoutePolicy>(new RoutePolicyOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, routePolicyName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// API to update certain properties of the Route Policy resource.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_Update</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="patch"> Route Policy properties to update. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<RoutePolicy> UpdateRoutePolicy(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, RoutePolicyPatch patch, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateRoutePolicy");
            scope.Start();
            try
            {
                var response = RoutePoliciesRestClient.Update(subscriptionId, resourceGroupName, routePolicyName, patch, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<RoutePolicy>(new RoutePolicyOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateUpdateRequest(subscriptionId, resourceGroupName, routePolicyName, patch).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Route Policy DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation> DeleteRoutePolicyAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteRoutePolicy");
            scope.Start();
            try
            {
                var response = await RoutePoliciesRestClient.DeleteAsync(subscriptionId, resourceGroupName, routePolicyName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation(RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, routePolicyName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionResponseAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements Route Policy DELETE method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_Delete</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation DeleteRoutePolicy(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.DeleteRoutePolicy");
            scope.Start();
            try
            {
                var response = RoutePoliciesRestClient.Delete(subscriptionId, resourceGroupName, routePolicyName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation(RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateDeleteRequest(subscriptionId, resourceGroupName, routePolicyName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletionResponse(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Implements RoutePolicies list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="RoutePolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<RoutePolicy> GetRoutePoliciesByResourceGroupAsync(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => RoutePoliciesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => RoutePoliciesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, RoutePolicy.DeserializeRoutePolicy, RoutePoliciesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetRoutePoliciesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements RoutePolicies list by resource group GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_ListByResourceGroup</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="RoutePolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<RoutePolicy> GetRoutePoliciesByResourceGroup(Guid subscriptionId, string resourceGroupName, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => RoutePoliciesRestClient.CreateListByResourceGroupRequest(subscriptionId, resourceGroupName);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => RoutePoliciesRestClient.CreateListByResourceGroupNextPageRequest(nextLink, subscriptionId, resourceGroupName);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, RoutePolicy.DeserializeRoutePolicy, RoutePoliciesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetRoutePoliciesByResourceGroup", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements RoutePolicies list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/routePolicies</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> An async collection of <see cref="RoutePolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual AsyncPageable<RoutePolicy> GetRoutePoliciesBySubscriptionAsync(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => RoutePoliciesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => RoutePoliciesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreateAsyncPageable(FirstPageRequest, NextPageRequest, RoutePolicy.DeserializeRoutePolicy, RoutePoliciesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetRoutePoliciesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Implements RoutePolicies list by subscription GET method.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/providers/Microsoft.ManagedNetworkFabric/routePolicies</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_ListBySubscription</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <returns> A collection of <see cref="RoutePolicy" /> that may take multiple service requests to iterate over. </returns>
        public virtual Pageable<RoutePolicy> GetRoutePoliciesBySubscription(Guid subscriptionId, CancellationToken cancellationToken = default)
        {
            HttpMessage FirstPageRequest(int? pageSizeHint) => RoutePoliciesRestClient.CreateListBySubscriptionRequest(subscriptionId);
            HttpMessage NextPageRequest(int? pageSizeHint, string nextLink) => RoutePoliciesRestClient.CreateListBySubscriptionNextPageRequest(nextLink, subscriptionId);
            return PageableHelpers.CreatePageable(FirstPageRequest, NextPageRequest, RoutePolicy.DeserializeRoutePolicy, RoutePoliciesClientDiagnostics, Pipeline, "TenantResourceExtensionClient.GetRoutePoliciesBySubscription", "value", "nextLink", cancellationToken);
        }

        /// <summary>
        /// Updated the admin state for this Route Policy.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForDeviceUpdate>> UpdateAdministrativeStateRoutePolicyAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateRoutePolicy");
            scope.Start();
            try
            {
                var response = await RoutePoliciesRestClient.UpdateAdministrativeStateAsync(subscriptionId, resourceGroupName, routePolicyName, body, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, routePolicyName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Updated the admin state for this Route Policy.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/updateAdministrativeState</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_UpdateAdministrativeState</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="body"> Request payload. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForDeviceUpdate> UpdateAdministrativeStateRoutePolicy(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, UpdateAdministrativeState body, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.UpdateAdministrativeStateRoutePolicy");
            scope.Start();
            try
            {
                var response = RoutePoliciesRestClient.UpdateAdministrativeState(subscriptionId, resourceGroupName, routePolicyName, body, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForDeviceUpdate>(new CommonPostActionResponseForDeviceUpdateOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateUpdateAdministrativeStateRequest(subscriptionId, resourceGroupName, routePolicyName, body).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Validates the configuration of the resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<ValidateConfigurationResponse>> ValidateConfigurationRoutePolicyAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationRoutePolicy");
            scope.Start();
            try
            {
                var response = await RoutePoliciesRestClient.ValidateConfigurationAsync(subscriptionId, resourceGroupName, routePolicyName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, routePolicyName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Validates the configuration of the resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/validateConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_ValidateConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<ValidateConfigurationResponse> ValidateConfigurationRoutePolicy(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.ValidateConfigurationRoutePolicy");
            scope.Start();
            try
            {
                var response = RoutePoliciesRestClient.ValidateConfiguration(subscriptionId, resourceGroupName, routePolicyName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<ValidateConfigurationResponse>(new ValidateConfigurationResponseOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateValidateConfigurationRequest(subscriptionId, resourceGroupName, routePolicyName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Commits the configuration of the given resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/commitConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_CommitConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual async Task<ArmOperation<CommonPostActionResponseForStateUpdate>> CommitConfigurationRoutePolicyAsync(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CommitConfigurationRoutePolicy");
            scope.Start();
            try
            {
                var response = await RoutePoliciesRestClient.CommitConfigurationAsync(subscriptionId, resourceGroupName, routePolicyName, cancellationToken).ConfigureAwait(false);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateCommitConfigurationRequest(subscriptionId, resourceGroupName, routePolicyName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    await operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(false);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Commits the configuration of the given resources.
        /// <list type="bullet">
        /// <item>
        /// <term>Request Path</term>
        /// <description>/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedNetworkFabric/routePolicies/{routePolicyName}/commitConfiguration</description>
        /// </item>
        /// <item>
        /// <term>Operation Id</term>
        /// <description>RoutePolicies_CommitConfiguration</description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="subscriptionId"> The ID of the target subscription. The value must be an UUID. </param>
        /// <param name="resourceGroupName"> The name of the resource group. The name is case insensitive. </param>
        /// <param name="routePolicyName"> Name of the Route Policy. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        public virtual ArmOperation<CommonPostActionResponseForStateUpdate> CommitConfigurationRoutePolicy(WaitUntil waitUntil, Guid subscriptionId, string resourceGroupName, string routePolicyName, CancellationToken cancellationToken = default)
        {
            using var scope = RoutePoliciesClientDiagnostics.CreateScope("TenantResourceExtensionClient.CommitConfigurationRoutePolicy");
            scope.Start();
            try
            {
                var response = RoutePoliciesRestClient.CommitConfiguration(subscriptionId, resourceGroupName, routePolicyName, cancellationToken);
                var operation = new ManagedNetworkFabricArmOperation<CommonPostActionResponseForStateUpdate>(new CommonPostActionResponseForStateUpdateOperationSource(), RoutePoliciesClientDiagnostics, Pipeline, RoutePoliciesRestClient.CreateCommitConfigurationRequest(subscriptionId, resourceGroupName, routePolicyName).Request, response, OperationFinalStateVia.Location);
                if (waitUntil == WaitUntil.Completed)
                    operation.WaitForCompletion(cancellationToken);
                return operation;
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }
    }
}
