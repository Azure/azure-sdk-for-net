// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.ComponentModel;

namespace Azure.ResourceManager.StackHCI.Models
{
    /// <summary> State of Arc Extension in this node. Reflects the current lifecycle status of the extension on the individual node, such as whether it's being created, updated, deleted, or has encountered an error. </summary>
    public readonly partial struct NodeExtensionState : IEquatable<NodeExtensionState>
    {
        private readonly string _value;

        /// <summary> Initializes a new instance of <see cref="NodeExtensionState"/>. </summary>
        /// <exception cref="ArgumentNullException"> <paramref name="value"/> is null. </exception>
        public NodeExtensionState(string value)
        {
            _value = value ?? throw new ArgumentNullException(nameof(value));
        }

        private const string NotSpecifiedValue = "NotSpecified";
        private const string ErrorValue = "Error";
        private const string SucceededValue = "Succeeded";
        private const string CanceledValue = "Canceled";
        private const string FailedValue = "Failed";
        private const string ConnectedValue = "Connected";
        private const string DisconnectedValue = "Disconnected";
        private const string DeletedValue = "Deleted";
        private const string CreatingValue = "Creating";
        private const string UpdatingValue = "Updating";
        private const string DeletingValue = "Deleting";
        private const string MovingValue = "Moving";
        private const string PartiallySucceededValue = "PartiallySucceeded";
        private const string PartiallyConnectedValue = "PartiallyConnected";
        private const string InProgressValue = "InProgress";
        private const string AcceptedValue = "Accepted";
        private const string ProvisioningValue = "Provisioning";

        /// <summary> The state is not specified. </summary>
        public static NodeExtensionState NotSpecified { get; } = new NodeExtensionState(NotSpecifiedValue);
        /// <summary> An error occurred during the extension lifecycle. </summary>
        public static NodeExtensionState Error { get; } = new NodeExtensionState(ErrorValue);
        /// <summary> The extension operation completed successfully. </summary>
        public static NodeExtensionState Succeeded { get; } = new NodeExtensionState(SucceededValue);
        /// <summary> The extension operation was canceled. </summary>
        public static NodeExtensionState Canceled { get; } = new NodeExtensionState(CanceledValue);
        /// <summary> The extension operation failed. </summary>
        public static NodeExtensionState Failed { get; } = new NodeExtensionState(FailedValue);
        /// <summary> The extension is connected on the node. </summary>
        public static NodeExtensionState Connected { get; } = new NodeExtensionState(ConnectedValue);
        /// <summary> The extension is disconnected on the node. </summary>
        public static NodeExtensionState Disconnected { get; } = new NodeExtensionState(DisconnectedValue);
        /// <summary> The extension has been deleted from the node. </summary>
        public static NodeExtensionState Deleted { get; } = new NodeExtensionState(DeletedValue);
        /// <summary> The extension is being created on the node. </summary>
        public static NodeExtensionState Creating { get; } = new NodeExtensionState(CreatingValue);
        /// <summary> The extension is being updated on the node. </summary>
        public static NodeExtensionState Updating { get; } = new NodeExtensionState(UpdatingValue);
        /// <summary> The extension is being deleted from the node. </summary>
        public static NodeExtensionState Deleting { get; } = new NodeExtensionState(DeletingValue);
        /// <summary> The extension is being moved on the node. </summary>
        public static NodeExtensionState Moving { get; } = new NodeExtensionState(MovingValue);
        /// <summary> The extension operation partially succeeded. </summary>
        public static NodeExtensionState PartiallySucceeded { get; } = new NodeExtensionState(PartiallySucceededValue);
        /// <summary> The extension is partially connected on the node. </summary>
        public static NodeExtensionState PartiallyConnected { get; } = new NodeExtensionState(PartiallyConnectedValue);
        /// <summary> The extension operation is currently in progress. </summary>
        public static NodeExtensionState InProgress { get; } = new NodeExtensionState(InProgressValue);
        /// <summary> The extension operation has been accepted and is pending execution. </summary>
        public static NodeExtensionState Accepted { get; } = new NodeExtensionState(AcceptedValue);
        /// <summary> The extension is currently being provisioned on the node. </summary>
        public static NodeExtensionState Provisioning { get; } = new NodeExtensionState(ProvisioningValue);
        /// <summary> Determines if two <see cref="NodeExtensionState"/> values are the same. </summary>
        public static bool operator ==(NodeExtensionState left, NodeExtensionState right) => left.Equals(right);
        /// <summary> Determines if two <see cref="NodeExtensionState"/> values are not the same. </summary>
        public static bool operator !=(NodeExtensionState left, NodeExtensionState right) => !left.Equals(right);
        /// <summary> Converts a <see cref="string"/> to a <see cref="NodeExtensionState"/>. </summary>
        public static implicit operator NodeExtensionState(string value) => new NodeExtensionState(value);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override bool Equals(object obj) => obj is NodeExtensionState other && Equals(other);
        /// <inheritdoc />
        public bool Equals(NodeExtensionState other) => string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);

        /// <inheritdoc />
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override int GetHashCode() => _value != null ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;
        /// <inheritdoc />
        public override string ToString() => _value;
    }
}
