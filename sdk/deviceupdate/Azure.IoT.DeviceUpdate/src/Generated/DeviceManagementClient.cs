// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.IoT.DeviceUpdate
{
    /// <summary> The DeviceManagement service client. </summary>
    public partial class DeviceManagementClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://api.adu.microsoft.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _instanceId;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of DeviceManagementClient for mocking. </summary>
        protected DeviceManagementClient()
        {
        }

        /// <summary> Initializes a new instance of DeviceManagementClient. </summary>
        /// <param name="endpoint"> Account endpoint. </param>
        /// <param name="instanceId"> Account instance identifier. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/>, <paramref name="instanceId"/> or <paramref name="credential"/> is null. </exception>
        public DeviceManagementClient(Uri endpoint, string instanceId, TokenCredential credential) : this(endpoint, instanceId, credential, new DeviceUpdateClientOptions())
        {
        }

        /// <summary> Initializes a new instance of DeviceManagementClient. </summary>
        /// <param name="endpoint"> Account endpoint. </param>
        /// <param name="instanceId"> Account instance identifier. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/>, <paramref name="instanceId"/> or <paramref name="credential"/> is null. </exception>
        public DeviceManagementClient(Uri endpoint, string instanceId, TokenCredential credential, DeviceUpdateClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(instanceId, nameof(instanceId));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new DeviceUpdateClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _instanceId = instanceId;
            _apiVersion = options.Version;
        }

        /// <summary> Gets the properties of a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClass</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is best compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassRequest(deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the properties of a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClass</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is best compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClass(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassRequest(deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update device class details. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>PatchBody</c>:
        /// <code>{
        ///   friendlyName: string, # Required. The device class friendly name.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClass</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is best compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateDeviceClassAsync(string deviceClassId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.UpdateDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDeviceClassRequest(deviceClassId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update device class details. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>PatchBody</c>:
        /// <code>{
        ///   friendlyName: string, # Required. The device class friendly name.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClass</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is best compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UpdateDeviceClass(string deviceClassId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.UpdateDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDeviceClassRequest(deviceClassId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class. Device classes are created automatically when Device Update-enabled devices are connected to the hub but are not automatically cleaned up since they are referenced by DeviceClassSubgroups. If the user has deleted all DeviceClassSubgroups for a device class they can also delete the device class to remove the records from the system and to stop checking the compatibility of this device class with new updates. If a device is ever reconnected for this device class it will be re-created. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteDeviceClassAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassRequest(deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class. Device classes are created automatically when Device Update-enabled devices are connected to the hub but are not automatically cleaned up since they are referenced by DeviceClassSubgroups. If the user has deleted all DeviceClassSubgroups for a device class they can also delete the device class to remove the records from the system and to stop checking the compatibility of this device class with new updates. If a device is ever reconnected for this device class it will be re-created. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteDeviceClass(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassRequest(deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device properties and latest deployment status for a device connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Device</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceAsync(string deviceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDevice");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceRequest(deviceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device properties and latest deployment status for a device connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Device</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDevice(string deviceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDevice");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceRequest(deviceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device module properties and latest deployment status for a device module connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Device</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceModuleAsync(string deviceId, string moduleId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceModule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceModuleRequest(deviceId, moduleId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device module properties and latest deployment status for a device module connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Device</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceModule(string deviceId, string moduleId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceModule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceModuleRequest(deviceId, moduleId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the breakdown of how many devices are on their latest update, have new updates available, or are in progress receiving new updates. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetUpdateComplianceAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the breakdown of how many devices are on their latest update, have new updates available, or are in progress receiving new updates. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetUpdateCompliance(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device group properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Group</c>:
        /// <code>{
        ///   groupId: string, # Required. Group identity.
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;, # Required. Group type.
        ///   createdDateTime: string, # Required. Date and time when the update was created.
        ///   deviceCount: number, # Optional. The number of devices in the group.
        ///   subgroupsWithNewUpdatesAvailableCount: number, # Optional. The count of subgroups with new updates available.
        ///   subgroupsWithUpdatesInProgressCount: number, # Optional. The count of subgroups with updates in progress.
        ///   subgroupsWithOnLatestUpdateCount: number, # Optional. The count of subgroups with devices on the latest update.
        ///   deployments: [string], # Optional. The active deployment Ids for the group
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device group properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Group</c>:
        /// <code>{
        ///   groupId: string, # Required. Group identity.
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;, # Required. Group type.
        ///   createdDateTime: string, # Required. Date and time when the update was created.
        ///   deviceCount: number, # Optional. The number of devices in the group.
        ///   subgroupsWithNewUpdatesAvailableCount: number, # Optional. The count of subgroups with new updates available.
        ///   subgroupsWithUpdatesInProgressCount: number, # Optional. The count of subgroups with updates in progress.
        ///   subgroupsWithOnLatestUpdateCount: number, # Optional. The count of subgroups with devices on the latest update.
        ///   deployments: [string], # Optional. The active deployment Ids for the group
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device group. This group is automatically created when a Device Update-enabled device is connected to the hub and reports its properties. Groups, subgroups, and deployments are not automatically cleaned up but are retained for history purposes. Users can call this method to delete a group if they do not need to retain any of the history of the group and no longer need it. If a device is ever connected again for this group after the group was deleted it will be automatically re-created but there will be no history. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device group. This group is automatically created when a Device Update-enabled device is connected to the hub and reports its properties. Groups, subgroups, and deployments are not automatically cleaned up but are retained for history purposes. Users can call this method to delete a group if they do not need to retain any of the history of the group and no longer need it. If a device is ever connected again for this group after the group was deleted it will be automatically re-created but there will be no history. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device group update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetUpdateComplianceForGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateComplianceForGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceForGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device group update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetUpdateComplianceForGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateComplianceForGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceForGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeployment(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates or updates a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateOrUpdateDeploymentAsync(string groupId, string deploymentId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.CreateOrUpdateDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateDeploymentRequest(groupId, deploymentId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates or updates a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateOrUpdateDeployment(string groupId, string deploymentId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.CreateOrUpdateDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateDeploymentRequest(groupId, deploymentId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteDeploymentAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteDeployment(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentStatus</c>:
        /// <code>{
        ///   groupId: string, # Required. The group identity
        ///   deploymentState: &quot;Active&quot; | &quot;ActiveWithSubgroupFailures&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the deployment.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///   subgroupStatus: [
        ///     {
        ///       groupId: string, # Required. The group identity
        ///       deviceClassId: string, # Required. The device class subgroup identity
        ///       deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the subgroup deployment.
        ///       error: Error, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///       totalDevices: number, # Optional. The total number of devices in the deployment.
        ///       devicesInProgressCount: number, # Optional. The number of devices that are currently in deployment.
        ///       devicesCompletedFailedCount: number, # Optional. The number of devices that have completed deployment with a failure.
        ///       devicesCompletedSucceededCount: number, # Optional. The number of devices which have successfully completed deployment.
        ///       devicesCanceledCount: number, # Optional. The number of devices which have had their deployment canceled.
        ///     }
        ///   ], # Required. The collection of device class subgroup status objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentStatusAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentStatusRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentStatus</c>:
        /// <code>{
        ///   groupId: string, # Required. The group identity
        ///   deploymentState: &quot;Active&quot; | &quot;ActiveWithSubgroupFailures&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the deployment.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///   subgroupStatus: [
        ///     {
        ///       groupId: string, # Required. The group identity
        ///       deviceClassId: string, # Required. The device class subgroup identity
        ///       deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the subgroup deployment.
        ///       error: Error, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///       totalDevices: number, # Optional. The total number of devices in the deployment.
        ///       devicesInProgressCount: number, # Optional. The number of devices that are currently in deployment.
        ///       devicesCompletedFailedCount: number, # Optional. The number of devices that have completed deployment with a failure.
        ///       devicesCompletedSucceededCount: number, # Optional. The number of devices which have successfully completed deployment.
        ///       devicesCanceledCount: number, # Optional. The number of devices which have had their deployment canceled.
        ///     }
        ///   ], # Required. The collection of device class subgroup status objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeploymentStatus(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentStatusRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets device class subgroup details. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroup</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. Device class subgroup identity.
        ///   groupId: string, # Required. Group identity.
        ///   createdDateTime: string, # Required. Date and time when the device class subgroup was created.
        ///   deviceCount: number, # Optional. The number of devices in the device class subgroup.
        ///   deploymentId: string, # Optional. The active deployment Id for the device class subgroup.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets device class subgroup details. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroup</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. Device class subgroup identity.
        ///   groupId: string, # Required. Group identity.
        ///   createdDateTime: string, # Required. Date and time when the device class subgroup was created.
        ///   deviceCount: number, # Optional. The number of devices in the device class subgroup.
        ///   deploymentId: string, # Optional. The active deployment Id for the device class subgroup.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device class subgroup update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassSubgroupUpdateComplianceAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupUpdateComplianceRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device class subgroup update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClassSubgroupUpdateCompliance(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupUpdateComplianceRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the best available update for a device class subgroup and a count of how many devices need this update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupUpdatableDevices</c>:
        /// <code>{
        ///   groupId: string, # Required. The group Id
        ///   deviceClassId: string, # Required. The device class subgroup&apos;s device class Id
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information.
        ///   deviceCount: number, # Required. Total number of devices for which the update is applicable.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetBestUpdatesForDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetBestUpdatesForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBestUpdatesForDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the best available update for a device class subgroup and a count of how many devices need this update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupUpdatableDevices</c>:
        /// <code>{
        ///   groupId: string, # Required. The group Id
        ///   deviceClassId: string, # Required. The device class subgroup&apos;s device class Id
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information.
        ///   deviceCount: number, # Required. Total number of devices for which the update is applicable.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetBestUpdatesForDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetBestUpdatesForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBestUpdatesForDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentForDeviceClassSubgroupAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeploymentForDeviceClassSubgroup(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<Response> DeleteDeploymentForDeviceClassSubgroupAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual Response DeleteDeploymentForDeviceClassSubgroup(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stops a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> StopDeploymentAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StopDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stops a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response StopDeployment(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StopDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retries a deployment with failed devices. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> RetryDeploymentAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.RetryDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRetryDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retries a deployment with failed devices. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response RetryDeployment(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.RetryDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRetryDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupDeploymentStatus</c>:
        /// <code>{
        ///   groupId: string, # Required. The group identity
        ///   deviceClassId: string, # Required. The device class subgroup identity
        ///   deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the subgroup deployment.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///   totalDevices: number, # Optional. The total number of devices in the deployment.
        ///   devicesInProgressCount: number, # Optional. The number of devices that are currently in deployment.
        ///   devicesCompletedFailedCount: number, # Optional. The number of devices that have completed deployment with a failure.
        ///   devicesCompletedSucceededCount: number, # Optional. The number of devices which have successfully completed deployment.
        ///   devicesCanceledCount: number, # Optional. The number of devices which have had their deployment canceled.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassSubgroupDeploymentStatusAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupDeploymentStatusRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupDeploymentStatus</c>:
        /// <code>{
        ///   groupId: string, # Required. The group identity
        ///   deviceClassId: string, # Required. The device class subgroup identity
        ///   deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the subgroup deployment.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///   totalDevices: number, # Optional. The total number of devices in the deployment.
        ///   devicesInProgressCount: number, # Optional. The number of devices that are currently in deployment.
        ///   devicesCompletedFailedCount: number, # Optional. The number of devices that have completed deployment with a failure.
        ///   devicesCompletedSucceededCount: number, # Optional. The number of devices which have successfully completed deployment.
        ///   devicesCanceledCount: number, # Optional. The number of devices which have had their deployment canceled.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClassSubgroupDeploymentStatus(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupDeploymentStatusRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve operation status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="ifNoneMatch"> Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceOperation</c>:
        /// <code>{
        ///   operationId: string, # Required. Operation Id.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Operation status.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. Operation error encountered, if any.
        ///   traceId: string, # Optional. Operation correlation identity that can used by Microsoft Support for troubleshooting.
        ///   lastActionDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation status was last updated.
        ///   createdDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation was created.
        ///   etag: string, # Optional. Operation ETag.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetOperationAsync(string operationId, ETag? ifNoneMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetOperation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetOperationRequest(operationId, ifNoneMatch, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve operation status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="ifNoneMatch"> Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceOperation</c>:
        /// <code>{
        ///   operationId: string, # Required. Operation Id.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Operation status.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. Operation error encountered, if any.
        ///   traceId: string, # Optional. Operation correlation identity that can used by Microsoft Support for troubleshooting.
        ///   lastActionDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation status was last updated.
        ///   createdDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation was created.
        ///   etag: string, # Optional. Operation ETag.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetOperation(string operationId, ETag? ifNoneMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetOperation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetOperationRequest(operationId, ifNoneMatch, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Start the device diagnostics log collection on specified devices. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> StartLogCollectionAsync(string logCollectionId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StartLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartLogCollectionRequest(logCollectionId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Start the device diagnostics log collection on specified devices. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response StartLogCollection(string logCollectionId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StartLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartLogCollectionRequest(logCollectionId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the device diagnostics log collection. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLogCollectionAsync(string logCollectionId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionRequest(logCollectionId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the device diagnostics log collection. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLogCollection(string logCollectionId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionRequest(logCollectionId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get log collection with detailed status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollectionOperationDetailedStatus</c>:
        /// <code>{
        ///   operationId: string, # Optional. The device diagnostics operation id.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        ///   deviceStatus: [
        ///     {
        ///       deviceId: string, # Required. Device id
        ///       moduleId: string, # Optional. Module id.
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Log upload status
        ///       resultCode: string, # Optional. Log upload result code
        ///       extendedResultCode: string, # Optional. Log upload extended result code
        ///       logLocation: string, # Optional. Log upload location
        ///     }
        ///   ], # Optional. Status of the devices in the operation
        ///   description: string, # Optional. Device diagnostics operation description.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLogCollectionDetailedStatusAsync(string operationId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollectionDetailedStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionDetailedStatusRequest(operationId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get log collection with detailed status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollectionOperationDetailedStatus</c>:
        /// <code>{
        ///   operationId: string, # Optional. The device diagnostics operation id.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        ///   deviceStatus: [
        ///     {
        ///       deviceId: string, # Required. Device id
        ///       moduleId: string, # Optional. Module id.
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Log upload status
        ///       resultCode: string, # Optional. Log upload result code
        ///       extendedResultCode: string, # Optional. Log upload extended result code
        ///       logLocation: string, # Optional. Log upload location
        ///     }
        ///   ], # Optional. Status of the devices in the operation
        ///   description: string, # Optional. Device diagnostics operation description.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLogCollectionDetailedStatus(string operationId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollectionDetailedStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionDetailedStatusRequest(operationId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of all device classes (unique combinations of device manufacturer and model) for all devices connected to Device Update for IoT Hub. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassesListValue</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is best compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceClassesAsync(RequestContext context = null)
        {
            return GetDeviceClassesImplementationAsync("DeviceManagementClient.GetDeviceClasses", context);
        }

        private AsyncPageable<BinaryData> GetDeviceClassesImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassesRequest(context)
                        : CreateGetDeviceClassesNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of all device classes (unique combinations of device manufacturer and model) for all devices connected to Device Update for IoT Hub. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassesListValue</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is best compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceClasses(RequestContext context = null)
        {
            return GetDeviceClassesImplementation("DeviceManagementClient.GetDeviceClasses", context);
        }

        private Pageable<BinaryData> GetDeviceClassesImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassesRequest(context)
                        : CreateGetDeviceClassesNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of installable updates for a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateInfoListValue</c>:
        /// <code>{
        ///   updateId: {
        ///     provider: string, # Required. Update provider.
        ///     name: string, # Required. Update name.
        ///     version: string, # Required. Update version.
        ///   }, # Required. Update identifier.
        ///   description: string, # Optional. Update description.
        ///   friendlyName: string, # Optional. Friendly update name.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetInstallableUpdatesForDeviceClassesAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetInstallableUpdatesForDeviceClassesImplementationAsync("DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", deviceClassId, context);
        }

        private AsyncPageable<BinaryData> GetInstallableUpdatesForDeviceClassesImplementationAsync(string diagnosticsScopeName, string deviceClassId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context)
                        : CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of installable updates for a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateInfoListValue</c>:
        /// <code>{
        ///   updateId: {
        ///     provider: string, # Required. Update provider.
        ///     name: string, # Required. Update name.
        ///     version: string, # Required. Update version.
        ///   }, # Required. Update identifier.
        ///   description: string, # Optional. Update description.
        ///   friendlyName: string, # Optional. Friendly update name.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetInstallableUpdatesForDeviceClasses(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetInstallableUpdatesForDeviceClassesImplementation("DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", deviceClassId, context);
        }

        private Pageable<BinaryData> GetInstallableUpdatesForDeviceClassesImplementation(string diagnosticsScopeName, string deviceClassId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context)
                        : CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter"> Restricts the set of devices returned. You can filter on GroupId, DeviceClassId, or GroupId and DeploymentStatus. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DevicesListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDevicesAsync(string filter = null, RequestContext context = null)
        {
            return GetDevicesImplementationAsync("DeviceManagementClient.GetDevices", filter, context);
        }

        private AsyncPageable<BinaryData> GetDevicesImplementationAsync(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDevicesRequest(filter, context)
                        : CreateGetDevicesNextPageRequest(nextLink, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter"> Restricts the set of devices returned. You can filter on GroupId, DeviceClassId, or GroupId and DeploymentStatus. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DevicesListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDevices(string filter = null, RequestContext context = null)
        {
            return GetDevicesImplementation("DeviceManagementClient.GetDevices", filter, context);
        }

        private Pageable<BinaryData> GetDevicesImplementation(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDevicesRequest(filter, context)
                        : CreateGetDevicesNextPageRequest(nextLink, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of all device groups.  The $default group will always be returned first. </summary>
        /// <param name="orderBy"> Orders the set of groups returned. You can order by any combination of groupId, device count, created date, subgroupsWithNewUpdatesAvailableCount, subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>GroupsListValue</c>:
        /// <code>{
        ///   groupId: string, # Required. Group identity.
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;, # Required. Group type.
        ///   createdDateTime: string, # Required. Date and time when the update was created.
        ///   deviceCount: number, # Optional. The number of devices in the group.
        ///   subgroupsWithNewUpdatesAvailableCount: number, # Optional. The count of subgroups with new updates available.
        ///   subgroupsWithUpdatesInProgressCount: number, # Optional. The count of subgroups with updates in progress.
        ///   subgroupsWithOnLatestUpdateCount: number, # Optional. The count of subgroups with devices on the latest update.
        ///   deployments: [string], # Optional. The active deployment Ids for the group
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetGroupsAsync(string orderBy = null, RequestContext context = null)
        {
            return GetGroupsImplementationAsync("DeviceManagementClient.GetGroups", orderBy, context);
        }

        private AsyncPageable<BinaryData> GetGroupsImplementationAsync(string diagnosticsScopeName, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetGroupsRequest(orderBy, context)
                        : CreateGetGroupsNextPageRequest(nextLink, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of all device groups.  The $default group will always be returned first. </summary>
        /// <param name="orderBy"> Orders the set of groups returned. You can order by any combination of groupId, device count, created date, subgroupsWithNewUpdatesAvailableCount, subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>GroupsListValue</c>:
        /// <code>{
        ///   groupId: string, # Required. Group identity.
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;, # Required. Group type.
        ///   createdDateTime: string, # Required. Date and time when the update was created.
        ///   deviceCount: number, # Optional. The number of devices in the group.
        ///   subgroupsWithNewUpdatesAvailableCount: number, # Optional. The count of subgroups with new updates available.
        ///   subgroupsWithUpdatesInProgressCount: number, # Optional. The count of subgroups with updates in progress.
        ///   subgroupsWithOnLatestUpdateCount: number, # Optional. The count of subgroups with devices on the latest update.
        ///   deployments: [string], # Optional. The active deployment Ids for the group
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetGroups(string orderBy = null, RequestContext context = null)
        {
            return GetGroupsImplementation("DeviceManagementClient.GetGroups", orderBy, context);
        }

        private Pageable<BinaryData> GetGroupsImplementation(string diagnosticsScopeName, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetGroupsRequest(orderBy, context)
                        : CreateGetGroupsNextPageRequest(nextLink, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the best available updates for a device group and a count of how many devices need each update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="filter"> Restricts the set of bestUpdates returned. You can filter on update Provider, Name and Version property. This filter is deprecated and should not be used. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupUpdatableDevicesListValue</c>:
        /// <code>{
        ///   groupId: string, # Required. The group Id
        ///   deviceClassId: string, # Required. The device class subgroup&apos;s device class Id
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information.
        ///   deviceCount: number, # Required. Total number of devices for which the update is applicable.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetBestUpdatesForGroupsAsync(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetBestUpdatesForGroupsImplementationAsync("DeviceManagementClient.GetBestUpdatesForGroups", groupId, filter, context);
        }

        private AsyncPageable<BinaryData> GetBestUpdatesForGroupsImplementationAsync(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetBestUpdatesForGroupsRequest(groupId, filter, context)
                        : CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the best available updates for a device group and a count of how many devices need each update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="filter"> Restricts the set of bestUpdates returned. You can filter on update Provider, Name and Version property. This filter is deprecated and should not be used. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupUpdatableDevicesListValue</c>:
        /// <code>{
        ///   groupId: string, # Required. The group Id
        ///   deviceClassId: string, # Required. The device class subgroup&apos;s device class Id
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information.
        ///   deviceCount: number, # Required. Total number of devices for which the update is applicable.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetBestUpdatesForGroups(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetBestUpdatesForGroupsImplementation("DeviceManagementClient.GetBestUpdatesForGroups", groupId, filter, context);
        }

        private Pageable<BinaryData> GetBestUpdatesForGroupsImplementation(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetBestUpdatesForGroupsRequest(groupId, filter, context)
                        : CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device group. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentsListValue</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsForGroupsAsync(string groupId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeploymentsForGroupsImplementationAsync("DeviceManagementClient.GetDeploymentsForGroups", groupId, orderBy, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsForGroupsImplementationAsync(string diagnosticsScopeName, string groupId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForGroupsRequest(groupId, orderBy, context)
                        : CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device group. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentsListValue</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeploymentsForGroups(string groupId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeploymentsForGroupsImplementation("DeviceManagementClient.GetDeploymentsForGroups", groupId, orderBy, context);
        }

        private Pageable<BinaryData> GetDeploymentsForGroupsImplementation(string diagnosticsScopeName, string groupId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForGroupsRequest(groupId, orderBy, context)
                        : CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the device class subgroups for the group. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="filter"> Restricts the set of device class subgroups returned. You can filter on compat properties by name and value. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupsListValue</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. Device class subgroup identity.
        ///   groupId: string, # Required. Group identity.
        ///   createdDateTime: string, # Required. Date and time when the device class subgroup was created.
        ///   deviceCount: number, # Optional. The number of devices in the device class subgroup.
        ///   deploymentId: string, # Optional. The active deployment Id for the device class subgroup.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceClassSubgroupsForGroupsAsync(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeviceClassSubgroupsForGroupsImplementationAsync("DeviceManagementClient.GetDeviceClassSubgroupsForGroups", groupId, filter, context);
        }

        private AsyncPageable<BinaryData> GetDeviceClassSubgroupsForGroupsImplementationAsync(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context)
                        : CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the device class subgroups for the group. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="filter"> Restricts the set of device class subgroups returned. You can filter on compat properties by name and value. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupsListValue</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. Device class subgroup identity.
        ///   groupId: string, # Required. Group identity.
        ///   createdDateTime: string, # Required. Date and time when the device class subgroup was created.
        ///   deviceCount: number, # Optional. The number of devices in the device class subgroup.
        ///   deploymentId: string, # Optional. The active deployment Id for the device class subgroup.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceClassSubgroupsForGroups(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeviceClassSubgroupsForGroupsImplementation("DeviceManagementClient.GetDeviceClassSubgroupsForGroups", groupId, filter, context);
        }

        private Pageable<BinaryData> GetDeviceClassSubgroupsForGroupsImplementation(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context)
                        : CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device class subgroup. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentsListValue</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsAsync(string groupId, string deviceClassId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetDeploymentsForDeviceClassSubgroupsImplementationAsync("DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", groupId, deviceClassId, orderBy, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsImplementationAsync(string diagnosticsScopeName, string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderBy, context)
                        : CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device class subgroup. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentsListValue</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeploymentsForDeviceClassSubgroups(string groupId, string deviceClassId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetDeploymentsForDeviceClassSubgroupsImplementation("DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", groupId, deviceClassId, orderBy, context);
        }

        private Pageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsImplementation(string diagnosticsScopeName, string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderBy, context)
                        : CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices in a deployment along with their state. Useful for getting a list of failed devices. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="filter"> Restricts the set of deployment device states returned. You can filter on deviceId and moduleId and/or deviceState. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentDeviceStatesListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   retryCount: number, # Required. The number of times this deployment has been retried on this device.
        ///   movedOnToNewDeployment: boolean, # Required. Boolean flag indicating whether this device is in a newer deployment and can no longer retry this deployment.
        ///   deviceState: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Required. Deployment device state.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync(string groupId, string deviceClassId, string deploymentId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            return GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementationAsync("DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", groupId, deviceClassId, deploymentId, filter, context);
        }

        private AsyncPageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementationAsync(string diagnosticsScopeName, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context)
                        : CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices in a deployment along with their state. Useful for getting a list of failed devices. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="filter"> Restricts the set of deployment device states returned. You can filter on deviceId and moduleId and/or deviceState. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentDeviceStatesListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   retryCount: number, # Required. The number of times this deployment has been retried on this device.
        ///   movedOnToNewDeployment: boolean, # Required. Boolean flag indicating whether this device is in a newer deployment and can no longer retry this deployment.
        ///   deviceState: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Required. Deployment device state.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeployments(string groupId, string deviceClassId, string deploymentId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            return GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementation("DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", groupId, deviceClassId, deploymentId, filter, context);
        }

        private Pageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementation(string diagnosticsScopeName, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context)
                        : CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted. </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: &quot;status eq &apos;NotStarted&apos; or status eq &apos;Running&apos;&quot;. </param>
        /// <param name="top"> Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to but not greater than the specified value n. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceOperationsListValue</c>:
        /// <code>{
        ///   operationId: string, # Required. Operation Id.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Operation status.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. Operation error encountered, if any.
        ///   traceId: string, # Optional. Operation correlation identity that can used by Microsoft Support for troubleshooting.
        ///   lastActionDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation status was last updated.
        ///   createdDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation was created.
        ///   etag: string, # Optional. Operation ETag.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetOperationsAsync(string filter = null, int? top = null, RequestContext context = null)
        {
            return GetOperationsImplementationAsync("DeviceManagementClient.GetOperations", filter, top, context);
        }

        private AsyncPageable<BinaryData> GetOperationsImplementationAsync(string diagnosticsScopeName, string filter, int? top, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetOperationsRequest(filter, top, context)
                        : CreateGetOperationsNextPageRequest(nextLink, filter, top, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted. </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: &quot;status eq &apos;NotStarted&apos; or status eq &apos;Running&apos;&quot;. </param>
        /// <param name="top"> Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to but not greater than the specified value n. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceOperationsListValue</c>:
        /// <code>{
        ///   operationId: string, # Required. Operation Id.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Operation status.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. Operation error encountered, if any.
        ///   traceId: string, # Optional. Operation correlation identity that can used by Microsoft Support for troubleshooting.
        ///   lastActionDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation status was last updated.
        ///   createdDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation was created.
        ///   etag: string, # Optional. Operation ETag.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetOperations(string filter = null, int? top = null, RequestContext context = null)
        {
            return GetOperationsImplementation("DeviceManagementClient.GetOperations", filter, top, context);
        }

        private Pageable<BinaryData> GetOperationsImplementation(string diagnosticsScopeName, string filter, int? top, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetOperationsRequest(filter, top, context)
                        : CreateGetOperationsNextPageRequest(nextLink, filter, top, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all device diagnostics log collections. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollectionListValue</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetLogCollectionsAsync(RequestContext context = null)
        {
            return GetLogCollectionsImplementationAsync("DeviceManagementClient.GetLogCollections", context);
        }

        private AsyncPageable<BinaryData> GetLogCollectionsImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetLogCollectionsRequest(context)
                        : CreateGetLogCollectionsNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all device diagnostics log collections. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollectionListValue</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetLogCollections(RequestContext context = null)
        {
            return GetLogCollectionsImplementation("DeviceManagementClient.GetLogCollections", context);
        }

        private Pageable<BinaryData> GetLogCollectionsImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetLogCollectionsRequest(context)
                        : CreateGetLogCollectionsNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get list of device health. </summary>
        /// <param name="filter"> Filter list by specified properties. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filter"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceHealthListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device id
        ///   moduleId: string, # Optional. Module id
        ///   state: &quot;healthy&quot; | &quot;unhealthy&quot;, # Required. Aggregate device health state
        ///   digitalTwinModelId: string, # Optional. Digital twin model Id
        ///   healthChecks: [
        ///     {
        ///       name: string, # Optional. Health check name
        ///       result: &quot;success&quot; | &quot;userError&quot;, # Optional. Health check result
        ///     }
        ///   ], # Required. Array of health checks and their results
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceHealthsAsync(string filter, RequestContext context = null)
        {
            Argument.AssertNotNull(filter, nameof(filter));

            return GetDeviceHealthsImplementationAsync("DeviceManagementClient.GetDeviceHealths", filter, context);
        }

        private AsyncPageable<BinaryData> GetDeviceHealthsImplementationAsync(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceHealthsRequest(filter, context)
                        : CreateGetDeviceHealthsNextPageRequest(nextLink, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get list of device health. </summary>
        /// <param name="filter"> Filter list by specified properties. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filter"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceHealthListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device id
        ///   moduleId: string, # Optional. Module id
        ///   state: &quot;healthy&quot; | &quot;unhealthy&quot;, # Required. Aggregate device health state
        ///   digitalTwinModelId: string, # Optional. Digital twin model Id
        ///   healthChecks: [
        ///     {
        ///       name: string, # Optional. Health check name
        ///       result: &quot;success&quot; | &quot;userError&quot;, # Optional. Health check result
        ///     }
        ///   ], # Required. Array of health checks and their results
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceHealths(string filter, RequestContext context = null)
        {
            Argument.AssertNotNull(filter, nameof(filter));

            return GetDeviceHealthsImplementation("DeviceManagementClient.GetDeviceHealths", filter, context);
        }

        private Pageable<BinaryData> GetDeviceHealthsImplementation(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceHealthsRequest(filter, context)
                        : CreateGetDeviceHealthsNextPageRequest(nextLink, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Import existing devices from IoT Hub. This is a long-running-operation; use Operation-Location response header value to check for operation status. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        public virtual async Task<Operation> ImportDevicesAsync(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.ImportDevices");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportDevicesRequest(content, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "DeviceManagementClient.ImportDevices", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Import existing devices from IoT Hub. This is a long-running-operation; use Operation-Location response header value to check for operation status. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        public virtual Operation ImportDevices(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.ImportDevices");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportDevicesRequest(content, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "DeviceManagementClient.ImportDevices", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetDeviceClassesRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateDeviceClassRequest(string deviceClassId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeviceClassRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInstallableUpdatesForDeviceClassesRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/installableUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDevicesRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateImportDevicesRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices:import", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeviceRequest(string deviceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices/", false);
            uri.AppendPath(deviceId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceModuleRequest(string deviceId, string moduleId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices/", false);
            uri.AppendPath(deviceId, true);
            uri.AppendPath("/modules/", false);
            uri.AppendPath(moduleId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUpdateComplianceRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupsRequest(string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups", false);
            if (orderBy != null)
            {
                uri.AppendQuery("orderby", orderBy, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUpdateComplianceForGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForGroupsRequest(string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/bestUpdates", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForGroupsRequest(string groupId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (orderBy != null)
            {
                uri.AppendQuery("orderby", orderBy, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrUpdateDeploymentRequest(string groupId, string deploymentId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentStatusRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/status", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupsForGroupsRequest(string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupUpdateComplianceRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/bestUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForDeviceClassSubgroupsRequest(string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (orderBy != null)
            {
                uri.AppendQuery("orderby", orderBy, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentForDeviceClassSubgroupRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentForDeviceClassSubgroupRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStopDeploymentRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath(":cancel", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateRetryDeploymentRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath(":retry", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupDeploymentStatusRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/status", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/devicestates", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOperationRequest(string operationId, ETag? ifNoneMatch, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200304);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/operations/", false);
            uri.AppendPath(operationId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ifNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", ifNoneMatch.Value);
            }
            return message;
        }

        internal HttpMessage CreateGetOperationsRequest(string filter, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/operations", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStartLogCollectionRequest(string logCollectionId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(logCollectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLogCollectionRequest(string logCollectionId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(logCollectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionDetailedStatusRequest(string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(operationId, true);
            uri.AppendPath("/detailedStatus", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceHealthsRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/deviceHealth", false);
            uri.AppendQuery("filter", filter, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassesNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(string nextLink, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDevicesNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupsNextPageRequest(string nextLink, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForGroupsNextPageRequest(string nextLink, string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForGroupsNextPageRequest(string nextLink, string groupId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(string nextLink, string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(string nextLink, string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(string nextLink, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOperationsNextPageRequest(string nextLink, string filter, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionsNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceHealthsNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200304;
        private static ResponseClassifier ResponseClassifier200304 => _responseClassifier200304 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 304 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
    }
}
